Binary files labcodes_answer/lab3_result/bin/bootblock and labcodes/lab3/bin/bootblock differ
Binary files labcodes_answer/lab3_result/bin/kernel and labcodes/lab3/bin/kernel differ
Binary files labcodes_answer/lab3_result/bin/sign and labcodes/lab3/bin/sign differ
Binary files labcodes_answer/lab3_result/bin/swap.img and labcodes/lab3/bin/swap.img differ
Binary files labcodes_answer/lab3_result/bin/ucore.img and labcodes/lab3/bin/ucore.img differ
diff -r -uN labcodes_answer/lab3_result/boot/bootasm.S labcodes/lab3/boot/bootasm.S
--- labcodes_answer/lab3_result/boot/bootasm.S	2020-05-30 07:45:13.671200547 +0800
+++ labcodes/lab3/boot/bootasm.S	2020-05-30 07:45:13.627200504 +0800
@@ -28,20 +28,20 @@
     #  address line 20 is tied low, so that addresses higher than
     #  1MB wrap around to zero by default. This code undoes this.
 seta20.1:
-    inb $0x64, %al                                  # Wait for not busy
+    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).
     testb $0x2, %al
     jnz seta20.1
 
     movb $0xd1, %al                                 # 0xd1 -> port 0x64
-    outb %al, $0x64
+    outb %al, $0x64                                 # 0xd1 means: write data to 8042's P2 port
 
 seta20.2:
-    inb $0x64, %al                                  # Wait for not busy
+    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).
     testb $0x2, %al
     jnz seta20.2
 
     movb $0xdf, %al                                 # 0xdf -> port 0x60
-    outb %al, $0x60
+    outb %al, $0x60                                 # 0xdf = 11011111, means set P2's A20 bit(the 1 bit) to 1
 
 probe_memory:
     movl $0, 0x8000
diff -r -uN labcodes_answer/lab3_result/.check_swap.log labcodes/lab3/.check_swap.log
--- labcodes_answer/lab3_result/.check_swap.log	1970-01-01 08:00:00.000000000 +0800
+++ labcodes/lab3/.check_swap.log	2020-05-30 16:42:23.230845582 +0800
@@ -0,0 +1,27 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc0100036 (phys)
+  etext  0xc0108ab2 (phys)
+  edata  0xc0123000 (phys)
+  end    0xc0124118 (phys)
+Kernel executable memory footprint: 145KB
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+check_vma_struct() succeeded!
diff -r -uN labcodes_answer/lab3_result/.check_swap.log.orig labcodes/lab3/.check_swap.log.orig
--- labcodes_answer/lab3_result/.check_swap.log.orig	1970-01-01 08:00:00.000000000 +0800
+++ labcodes/lab3/.check_swap.log.orig	2020-05-30 16:38:13.382363744 +0800
@@ -0,0 +1,27 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc0100036 (phys)
+  etext  0xc0108ab2 (phys)
+  edata  0xc0123000 (phys)
+  end    0xc0124118 (phys)
+Kernel executable memory footprint: 145KB
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+check_vma_struct() succeeded!
diff -r -uN labcodes_answer/lab3_result/.check_swap.log.rej labcodes/lab3/.check_swap.log.rej
--- labcodes_answer/lab3_result/.check_swap.log.rej	1970-01-01 08:00:00.000000000 +0800
+++ labcodes/lab3/.check_swap.log.rej	2020-05-30 16:38:13.382363744 +0800
@@ -0,0 +1,30 @@
+--- labcodes_answer/lab3_result/.check_swap.log	1970-01-01 08:00:00.000000000 +0800
++++ labcodes/lab3/.check_swap.log	2020-05-30 16:34:18.378206180 +0800
+@@ -0,0 +1,27 @@
++(THU.CST) os is loading ...
++
++Special kernel symbols:
++  entry  0xc0100036 (phys)
++  etext  0xc0108ab2 (phys)
++  edata  0xc0123000 (phys)
++  end    0xc0124118 (phys)
++Kernel executable memory footprint: 145KB
++memory management: default_pmm_manager
++e820map:
++  memory: 0009fc00, [00000000, 0009fbff], type = 1.
++  memory: 00000400, [0009fc00, 0009ffff], type = 2.
++  memory: 00010000, [000f0000, 000fffff], type = 2.
++  memory: 07ee0000, [00100000, 07fdffff], type = 1.
++  memory: 00020000, [07fe0000, 07ffffff], type = 2.
++  memory: 00040000, [fffc0000, ffffffff], type = 2.
++check_alloc_page() succeeded!
++check_pgdir() succeeded!
++check_boot_pgdir() succeeded!
++-------------------- BEGIN --------------------
++PDE(0e0) c0000000-f8000000 38000000 urw
++  |-- PTE(38000) c0000000-f8000000 38000000 -rw
++PDE(001) fac00000-fb000000 00400000 -rw
++  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
++  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
++--------------------- END ---------------------
++check_vma_struct() succeeded!
diff -r -uN labcodes_answer/lab3_result/.gdb.in labcodes/lab3/.gdb.in
--- labcodes_answer/lab3_result/.gdb.in	2020-05-30 10:42:07.641374761 +0800
+++ labcodes/lab3/.gdb.in	2020-05-30 16:42:22.782844223 +0800
@@ -1,3 +1,4 @@
 target remote localhost:1234
-break *0xc0100326
+break *0xc0100343
+break *0x00100343
 continue
diff -r -uN labcodes_answer/lab3_result/.gdb.in.orig labcodes/lab3/.gdb.in.orig
--- labcodes_answer/lab3_result/.gdb.in.orig	1970-01-01 08:00:00.000000000 +0800
+++ labcodes/lab3/.gdb.in.orig	2020-05-30 16:38:41.734382754 +0800
@@ -0,0 +1,4 @@
+target remote localhost:1234
+break *0xc0100343
+break *0x00100343
+continue
diff -r -uN labcodes_answer/lab3_result/.gdb.in.rej labcodes/lab3/.gdb.in.rej
--- labcodes_answer/lab3_result/.gdb.in.rej	1970-01-01 08:00:00.000000000 +0800
+++ labcodes/lab3/.gdb.in.rej	2020-05-30 16:38:21.894369453 +0800
@@ -0,0 +1,8 @@
+--- labcodes_answer/lab3_result/.gdb.in	2020-05-30 10:42:07.641374761 +0800
++++ labcodes/lab3/.gdb.in	2020-05-30 16:34:17.926205877 +0800
+@@ -1,3 +1,4 @@
+ target remote localhost:1234
+-break *0xc0100326
++break *0xc0100343
++break *0x00100343
+ continue
diff -r -uN labcodes_answer/lab3_result/kern/debug/kdebug.c labcodes/lab3/kern/debug/kdebug.c
--- labcodes_answer/lab3_result/kern/debug/kdebug.c	2020-05-30 07:45:13.671200547 +0800
+++ labcodes/lab3/kern/debug/kdebug.c	2020-05-30 07:45:13.627200504 +0800
@@ -305,19 +305,5 @@
       *           NOTICE: the calling funciton's return addr eip  = ss:[ebp+4]
       *                   the calling funciton's ebp = ss:[ebp]
       */
-    uint32_t ebp = read_ebp(), eip = read_eip();
-
-    int i, j;
-    for (i = 0; ebp != 0 && i < STACKFRAME_DEPTH; i ++) {
-        cprintf("ebp:0x%08x eip:0x%08x args:", ebp, eip);
-        uint32_t *args = (uint32_t *)ebp + 2;
-        for (j = 0; j < 4; j ++) {
-            cprintf("0x%08x ", args[j]);
-        }
-        cprintf("\n");
-        print_debuginfo(eip - 1);
-        eip = ((uint32_t *)ebp)[1];
-        ebp = ((uint32_t *)ebp)[0];
-    }
 }
 
diff -r -uN labcodes_answer/lab3_result/kern/init/init.c labcodes/lab3/kern/init/init.c
--- labcodes_answer/lab3_result/kern/init/init.c	2020-05-30 07:45:13.671200547 +0800
+++ labcodes/lab3/kern/init/init.c	2020-05-30 07:45:13.631200508 +0800
@@ -11,9 +11,10 @@
 #include <vmm.h>
 #include <ide.h>
 #include <swap.h>
+#include <kmonitor.h>
 
 int kern_init(void) __attribute__((noreturn));
-
+void grade_backtrace(void);
 static void lab1_switch_test(void);
 
 int
diff -r -uN labcodes_answer/lab3_result/kern/mm/default_pmm.c labcodes/lab3/kern/mm/default_pmm.c
--- labcodes_answer/lab3_result/kern/mm/default_pmm.c	2020-05-30 07:45:13.671200547 +0800
+++ labcodes/lab3/kern/mm/default_pmm.c	2020-05-30 09:54:17.146711209 +0800
@@ -111,6 +111,7 @@
     for (; p != base + n; p ++) {
         assert(PageReserved(p));
         p->flags = p->property = 0;
+        //SetPageProperty(p);
         set_page_ref(p, 0);
     }
     base->property = n;
@@ -127,7 +128,6 @@
     }
     struct Page *page = NULL;
     list_entry_t *le = &free_list;
-    // TODO: optimize (next-fit)
     while ((le = list_next(le)) != &free_list) {
         struct Page *p = le2page(le, page_link);
         if (p->property >= n) {
@@ -136,14 +136,15 @@
         }
     }
     if (page != NULL) {
+        //list_del(&(page->page_link));
         if (page->property > n) {
             struct Page *p = page + n;
             p->property = page->property - n;
             SetPageProperty(p);
-            list_add_after(&(page->page_link), &(p->page_link));
-        }
-        list_del(&(page->page_link));
+            list_add_before(&(page->page_link), &(p->page_link));
+    }
         nr_free -= n;
+        list_del(&(page->page_link));
         ClearPageProperty(page);
     }
     return page;
@@ -164,7 +165,6 @@
     while (le != &free_list) {
         p = le2page(le, page_link);
         le = list_next(le);
-        // TODO: optimize
         if (base + base->property == p) {
             base->property += p->property;
             ClearPageProperty(p);
@@ -178,14 +178,13 @@
         }
     }
     nr_free += n;
-    le = list_next(&free_list);
-    while (le != &free_list) {
+    for (le = list_next(&free_list);le != &free_list;le = list_next(le))
+    {
         p = le2page(le, page_link);
         if (base + base->property <= p) {
             assert(base + base->property != p);
             break;
         }
-        le = list_next(le);
     }
     list_add_before(le, &(base->page_link));
 }
@@ -320,3 +319,4 @@
     .nr_free_pages = default_nr_free_pages,
     .check = default_check,
 };
+
diff -r -uN labcodes_answer/lab3_result/kern/mm/memlayout.h labcodes/lab3/kern/mm/memlayout.h
--- labcodes_answer/lab3_result/kern/mm/memlayout.h	2020-05-30 07:45:13.671200547 +0800
+++ labcodes/lab3/kern/mm/memlayout.h	2020-05-30 07:45:13.631200508 +0800
@@ -107,8 +107,8 @@
 };
 
 /* Flags describing the status of a page frame */
-#define PG_reserved                 0       // the page descriptor is reserved for kernel or unusable
-#define PG_property                 1       // the member 'property' is valid
+#define PG_reserved                 0       // if this bit=1: the Page is reserved for kernel, cannot be used in alloc/free_pages; otherwise, this bit=0 
+#define PG_property                 1       // if this bit=1: the Page is the head page of a free memory block(contains some continuous_addrress pages), and can be used in alloc_pages; if this bit=0: if the Page is the the head page of a free memory block, then this Page and the memory block is alloced. Or this Page isn't the head page.
 
 #define SetPageReserved(page)       set_bit(PG_reserved, &((page)->flags))
 #define ClearPageReserved(page)     clear_bit(PG_reserved, &((page)->flags))
diff -r -uN labcodes_answer/lab3_result/kern/mm/pmm.c labcodes/lab3/kern/mm/pmm.c
--- labcodes_answer/lab3_result/kern/mm/pmm.c	2020-05-30 07:45:13.671200547 +0800
+++ labcodes/lab3/kern/mm/pmm.c	2020-05-30 09:59:37.862947290 +0800
@@ -372,16 +372,16 @@
     }
     return NULL;          // (8) return page table entry
 #endif
-    pde_t *pdep = &pgdir[PDX(la)];
-    if (!(*pdep & PTE_P)) {
+    pde_t *pdep = &pgdir[PDX(la)];    //尝试获得页表
+    if (!(*pdep & PTE_P)) {             //如果获取不成功
         struct Page *page;
         if (!create || (page = alloc_page()) == NULL) {
             return NULL;
         }
-        set_page_ref(page, 1);
+        set_page_ref(page, 1);          //引用次数+1
         uintptr_t pa = page2pa(page);
-        memset(KADDR(pa), 0, PGSIZE);
-        *pdep = pa | PTE_U | PTE_W | PTE_P;
+        memset(KADDR(pa), 0, PGSIZE);   //初始化
+        *pdep = pa | PTE_U | PTE_W | PTE_P;//设置控制位
     }
     return &((pte_t *)KADDR(PDE_ADDR(*pdep)))[PTX(la)];
 }
@@ -421,7 +421,7 @@
      *   PTE_P           0x001                   // page table/directory entry flags bit : Present
      */
 #if 0
-    if (0) {                      //(1) check if page directory is present
+    if (0) {                      //(1) check if this page table entry is present
         struct Page *page = NULL; //(2) find corresponding page to pte
                                   //(3) decrease page reference
                                   //(4) and free this page when page reference reachs 0
@@ -429,14 +429,13 @@
                                   //(6) flush tlb
     }
 #endif
-    if (*ptep & PTE_P) {
-        struct Page *page = pte2page(*ptep);
+    assert(*ptep & PTE_P);        //确保传入的二级页表项是存在的
+        struct Page *page = pte2page(*ptep);   //获取该页表项对应的物理页
         if (page_ref_dec(page) == 0) {
             free_page(page);
         }
-        *ptep = 0;
-        tlb_invalidate(pgdir, la);
-    }
+        *ptep = 0;     //取消映射关系
+        tlb_invalidate(pgdir, la);  //更新TLB
 }
 
 //page_remove - free an Page which is related linear address la and has an validated pte
diff -r -uN labcodes_answer/lab3_result/kern/mm/swap_fifo.c.orig labcodes/lab3/kern/mm/swap_fifo.c.orig
--- labcodes_answer/lab3_result/kern/mm/swap_fifo.c.orig	1970-01-01 08:00:00.000000000 +0800
+++ labcodes/lab3/kern/mm/swap_fifo.c.orig	2020-05-30 16:40:06.234439425 +0800
@@ -0,0 +1,143 @@
+#include <defs.h>
+#include <x86.h>
+#include <stdio.h>
+#include <string.h>
+#include <swap.h>
+#include <swap_fifo.h>
+#include <list.h>
+
+/* [wikipedia]The simplest Page Replacement Algorithm(PRA) is a FIFO algorithm. The first-in, first-out
+ * page replacement algorithm is a low-overhead algorithm that requires little book-keeping on
+ * the part of the operating system. The idea is obvious from the name - the operating system
+ * keeps track of all the pages in memory in a queue, with the most recent arrival at the back,
+ * and the earliest arrival in front. When a page needs to be replaced, the page at the front
+ * of the queue (the oldest page) is selected. While FIFO is cheap and intuitive, it performs
+ * poorly in practical application. Thus, it is rarely used in its unmodified form. This
+ * algorithm experiences Belady's anomaly.
+ *
+ * Details of FIFO PRA
+ * (1) Prepare: In order to implement FIFO PRA, we should manage all swappable pages, so we can
+ *              link these pages into pra_list_head according the time order. At first you should
+ *              be familiar to the struct list in list.h. struct list is a simple doubly linked list
+ *              implementation. You should know howto USE: list_init, list_add(list_add_after),
+ *              list_add_before, list_del, list_next, list_prev. Another tricky method is to transform
+ *              a general list struct to a special struct (such as struct page). You can find some MACRO:
+ *              le2page (in memlayout.h), (in future labs: le2vma (in vmm.h), le2proc (in proc.h),etc.
+ */
+
+list_entry_t pra_list_head;
+/*
+ * (2) _fifo_init_mm: init pra_list_head and let  mm->sm_priv point to the addr of pra_list_head.
+ *              Now, From the memory control struct mm_struct, we can access FIFO PRA
+ */
+static int
+_fifo_init_mm(struct mm_struct *mm)
+{     
+     list_init(&pra_list_head);
+     mm->sm_priv = &pra_list_head;
+     //cprintf(" mm->sm_priv %x in fifo_init_mm\n",mm->sm_priv);
+     return 0;
+}
+/*
+ * (3)_fifo_map_swappable: According FIFO PRA, we should link the most recent arrival page at the back of pra_list_head qeueue
+ */
+static int
+_fifo_map_swappable(struct mm_struct *mm, uintptr_t addr, struct Page *page, int swap_in)
+{
+    list_entry_t *head=(list_entry_t*) mm->sm_priv;
+    list_entry_t *entry=&(page->pra_page_link);
+ 
+    assert(entry != NULL && head != NULL);
+    //record the page access situlation
+    /*LAB3 EXERCISE 2: YOUR CODE*/ 
+    //(1)link the most recent arrival page at the back of the pra_list_head qeueue.
+    return 0;
+}
+/*
+ *  (4)_fifo_swap_out_victim: According FIFO PRA, we should unlink the  earliest arrival page in front of pra_list_head qeueue,
+ *                            then assign the value of *ptr_page to the addr of this page.
+ */
+static int
+_fifo_swap_out_victim(struct mm_struct *mm, struct Page ** ptr_page, int in_tick)
+{
+     list_entry_t *head=(list_entry_t*) mm->sm_priv;
+         assert(head != NULL);
+     assert(in_tick==0);
+     /* Select the victim */
+     /*LAB3 EXERCISE 2: YOUR CODE*/ 
+     //(1)  unlink the  earliest arrival page in front of pra_list_head qeueue
+     //(2)  assign the value of *ptr_page to the addr of this page
+     return 0;
+}
+
+static int
+_fifo_check_swap(void) {
+    cprintf("write Virt Page c in fifo_check_swap\n");
+    *(unsigned char *)0x3000 = 0x0c;
+    assert(pgfault_num==4);
+    cprintf("write Virt Page a in fifo_check_swap\n");
+    *(unsigned char *)0x1000 = 0x0a;
+    assert(pgfault_num==4);
+    cprintf("write Virt Page d in fifo_check_swap\n");
+    *(unsigned char *)0x4000 = 0x0d;
+    assert(pgfault_num==4);
+    cprintf("write Virt Page b in fifo_check_swap\n");
+    *(unsigned char *)0x2000 = 0x0b;
+    assert(pgfault_num==4);
+    cprintf("write Virt Page e in fifo_check_swap\n");
+    *(unsigned char *)0x5000 = 0x0e;
+    assert(pgfault_num==5);
+    cprintf("write Virt Page b in fifo_check_swap\n");
+    *(unsigned char *)0x2000 = 0x0b;
+    assert(pgfault_num==5);
+    cprintf("write Virt Page a in fifo_check_swap\n");
+    *(unsigned char *)0x1000 = 0x0a;
+    assert(pgfault_num==6);
+    cprintf("write Virt Page b in fifo_check_swap\n");
+    *(unsigned char *)0x2000 = 0x0b;
+    assert(pgfault_num==7);
+    cprintf("write Virt Page c in fifo_check_swap\n");
+    *(unsigned char *)0x3000 = 0x0c;
+    assert(pgfault_num==8);
+    cprintf("write Virt Page d in fifo_check_swap\n");
+    *(unsigned char *)0x4000 = 0x0d;
+    assert(pgfault_num==9);
+    cprintf("write Virt Page e in fifo_check_swap\n");
+    *(unsigned char *)0x5000 = 0x0e;
+    assert(pgfault_num==10);
+    cprintf("write Virt Page a in fifo_check_swap\n");
+    assert(*(unsigned char *)0x1000 == 0x0a);
+    *(unsigned char *)0x1000 = 0x0a;
+    assert(pgfault_num==11);
+    return 0;
+}
+
+
+static int
+_fifo_init(void)
+{
+    return 0;
+}
+
+static int
+_fifo_set_unswappable(struct mm_struct *mm, uintptr_t addr)
+{
+    return 0;
+}
+
+static int
+_fifo_tick_event(struct mm_struct *mm)
+{ return 0; }
+
+
+struct swap_manager swap_manager_fifo =
+{
+     .name            = "fifo swap manager",
+     .init            = &_fifo_init,
+     .init_mm         = &_fifo_init_mm,
+     .tick_event      = &_fifo_tick_event,
+     .map_swappable   = &_fifo_map_swappable,
+     .set_unswappable = &_fifo_set_unswappable,
+     .swap_out_victim = &_fifo_swap_out_victim,
+     .check_swap      = &_fifo_check_swap,
+};
diff -r -uN labcodes_answer/lab3_result/kern/mm/vmm.c.orig labcodes/lab3/kern/mm/vmm.c.orig
--- labcodes_answer/lab3_result/kern/mm/vmm.c.orig	1970-01-01 08:00:00.000000000 +0800
+++ labcodes/lab3/kern/mm/vmm.c.orig	2020-05-30 16:40:06.234439425 +0800
@@ -0,0 +1,403 @@
+#include <vmm.h>
+#include <sync.h>
+#include <string.h>
+#include <assert.h>
+#include <stdio.h>
+#include <error.h>
+#include <pmm.h>
+#include <x86.h>
+#include <swap.h>
+
+/* 
+  vmm design include two parts: mm_struct (mm) & vma_struct (vma)
+  mm is the memory manager for the set of continuous virtual memory  
+  area which have the same PDT. vma is a continuous virtual memory area.
+  There a linear link list for vma & a redblack link list for vma in mm.
+---------------
+  mm related functions:
+   golbal functions
+     struct mm_struct * mm_create(void)
+     void mm_destroy(struct mm_struct *mm)
+     int do_pgfault(struct mm_struct *mm, uint32_t error_code, uintptr_t addr)
+--------------
+  vma related functions:
+   global functions
+     struct vma_struct * vma_create (uintptr_t vm_start, uintptr_t vm_end,...)
+     void insert_vma_struct(struct mm_struct *mm, struct vma_struct *vma)
+     struct vma_struct * find_vma(struct mm_struct *mm, uintptr_t addr)
+   local functions
+     inline void check_vma_overlap(struct vma_struct *prev, struct vma_struct *next)
+---------------
+   check correctness functions
+     void check_vmm(void);
+     void check_vma_struct(void);
+     void check_pgfault(void);
+*/
+
+static void check_vmm(void);
+static void check_vma_struct(void);
+static void check_pgfault(void);
+
+// mm_create -  alloc a mm_struct & initialize it.
+struct mm_struct *
+mm_create(void) {
+    struct mm_struct *mm = kmalloc(sizeof(struct mm_struct));
+
+    if (mm != NULL) {
+        list_init(&(mm->mmap_list));
+        mm->mmap_cache = NULL;
+        mm->pgdir = NULL;
+        mm->map_count = 0;
+
+        if (swap_init_ok) swap_init_mm(mm);
+        else mm->sm_priv = NULL;
+    }
+    return mm;
+}
+
+// vma_create - alloc a vma_struct & initialize it. (addr range: vm_start~vm_end)
+struct vma_struct *
+vma_create(uintptr_t vm_start, uintptr_t vm_end, uint32_t vm_flags) {
+    struct vma_struct *vma = kmalloc(sizeof(struct vma_struct));
+
+    if (vma != NULL) {
+        vma->vm_start = vm_start;
+        vma->vm_end = vm_end;
+        vma->vm_flags = vm_flags;
+    }
+    return vma;
+}
+
+
+// find_vma - find a vma  (vma->vm_start <= addr <= vma_vm_end)
+struct vma_struct *
+find_vma(struct mm_struct *mm, uintptr_t addr) {
+    struct vma_struct *vma = NULL;
+    if (mm != NULL) {
+        vma = mm->mmap_cache;
+        if (!(vma != NULL && vma->vm_start <= addr && vma->vm_end > addr)) {
+                bool found = 0;
+                list_entry_t *list = &(mm->mmap_list), *le = list;
+                while ((le = list_next(le)) != list) {
+                    vma = le2vma(le, list_link);
+                    if (vma->vm_start<=addr && addr < vma->vm_end) {
+                        found = 1;
+                        break;
+                    }
+                }
+                if (!found) {
+                    vma = NULL;
+                }
+        }
+        if (vma != NULL) {
+            mm->mmap_cache = vma;
+        }
+    }
+    return vma;
+}
+
+
+// check_vma_overlap - check if vma1 overlaps vma2 ?
+static inline void
+check_vma_overlap(struct vma_struct *prev, struct vma_struct *next) {
+    assert(prev->vm_start < prev->vm_end);
+    assert(prev->vm_end <= next->vm_start);
+    assert(next->vm_start < next->vm_end);
+}
+
+
+// insert_vma_struct -insert vma in mm's list link
+void
+insert_vma_struct(struct mm_struct *mm, struct vma_struct *vma) {
+    assert(vma->vm_start < vma->vm_end);
+    list_entry_t *list = &(mm->mmap_list);
+    list_entry_t *le_prev = list, *le_next;
+
+        list_entry_t *le = list;
+        while ((le = list_next(le)) != list) {
+            struct vma_struct *mmap_prev = le2vma(le, list_link);
+            if (mmap_prev->vm_start > vma->vm_start) {
+                break;
+            }
+            le_prev = le;
+        }
+
+    le_next = list_next(le_prev);
+
+    /* check overlap */
+    if (le_prev != list) {
+        check_vma_overlap(le2vma(le_prev, list_link), vma);
+    }
+    if (le_next != list) {
+        check_vma_overlap(vma, le2vma(le_next, list_link));
+    }
+
+    vma->vm_mm = mm;
+    list_add_after(le_prev, &(vma->list_link));
+
+    mm->map_count ++;
+}
+
+// mm_destroy - free mm and mm internal fields
+void
+mm_destroy(struct mm_struct *mm) {
+
+    list_entry_t *list = &(mm->mmap_list), *le;
+    while ((le = list_next(list)) != list) {
+        list_del(le);
+        kfree(le2vma(le, list_link),sizeof(struct vma_struct));  //kfree vma        
+    }
+    kfree(mm, sizeof(struct mm_struct)); //kfree mm
+    mm=NULL;
+}
+
+// vmm_init - initialize virtual memory management
+//          - now just call check_vmm to check correctness of vmm
+void
+vmm_init(void) {
+    check_vmm();
+}
+
+// check_vmm - check correctness of vmm
+static void
+check_vmm(void) {
+    size_t nr_free_pages_store = nr_free_pages();
+    
+    check_vma_struct();
+    check_pgfault();
+
+    assert(nr_free_pages_store == nr_free_pages());
+
+    cprintf("check_vmm() succeeded.\n");
+}
+
+static void
+check_vma_struct(void) {
+    size_t nr_free_pages_store = nr_free_pages();
+
+    struct mm_struct *mm = mm_create();
+    assert(mm != NULL);
+
+    int step1 = 10, step2 = step1 * 10;
+
+    int i;
+    for (i = step1; i >= 1; i --) {
+        struct vma_struct *vma = vma_create(i * 5, i * 5 + 2, 0);
+        assert(vma != NULL);
+        insert_vma_struct(mm, vma);
+    }
+
+    for (i = step1 + 1; i <= step2; i ++) {
+        struct vma_struct *vma = vma_create(i * 5, i * 5 + 2, 0);
+        assert(vma != NULL);
+        insert_vma_struct(mm, vma);
+    }
+
+    list_entry_t *le = list_next(&(mm->mmap_list));
+
+    for (i = 1; i <= step2; i ++) {
+        assert(le != &(mm->mmap_list));
+        struct vma_struct *mmap = le2vma(le, list_link);
+        assert(mmap->vm_start == i * 5 && mmap->vm_end == i * 5 + 2);
+        le = list_next(le);
+    }
+
+    for (i = 5; i <= 5 * step2; i +=5) {
+        struct vma_struct *vma1 = find_vma(mm, i);
+        assert(vma1 != NULL);
+        struct vma_struct *vma2 = find_vma(mm, i+1);
+        assert(vma2 != NULL);
+        struct vma_struct *vma3 = find_vma(mm, i+2);
+        assert(vma3 == NULL);
+        struct vma_struct *vma4 = find_vma(mm, i+3);
+        assert(vma4 == NULL);
+        struct vma_struct *vma5 = find_vma(mm, i+4);
+        assert(vma5 == NULL);
+
+        assert(vma1->vm_start == i  && vma1->vm_end == i  + 2);
+        assert(vma2->vm_start == i  && vma2->vm_end == i  + 2);
+    }
+
+    for (i =4; i>=0; i--) {
+        struct vma_struct *vma_below_5= find_vma(mm,i);
+        if (vma_below_5 != NULL ) {
+           cprintf("vma_below_5: i %x, start %x, end %x\n",i, vma_below_5->vm_start, vma_below_5->vm_end); 
+        }
+        assert(vma_below_5 == NULL);
+    }
+
+    mm_destroy(mm);
+
+    assert(nr_free_pages_store == nr_free_pages());
+
+    cprintf("check_vma_struct() succeeded!\n");
+}
+
+struct mm_struct *check_mm_struct;
+
+// check_pgfault - check correctness of pgfault handler
+static void
+check_pgfault(void) {
+    size_t nr_free_pages_store = nr_free_pages();
+
+    check_mm_struct = mm_create();
+    assert(check_mm_struct != NULL);
+
+    struct mm_struct *mm = check_mm_struct;
+    pde_t *pgdir = mm->pgdir = boot_pgdir;
+    assert(pgdir[0] == 0);
+
+    struct vma_struct *vma = vma_create(0, PTSIZE, VM_WRITE);
+    assert(vma != NULL);
+
+    insert_vma_struct(mm, vma);
+
+    uintptr_t addr = 0x100;
+    assert(find_vma(mm, addr) == vma);
+
+    int i, sum = 0;
+    for (i = 0; i < 100; i ++) {
+        *(char *)(addr + i) = i;
+        sum += i;
+    }
+    for (i = 0; i < 100; i ++) {
+        sum -= *(char *)(addr + i);
+    }
+    assert(sum == 0);
+
+    page_remove(pgdir, ROUNDDOWN(addr, PGSIZE));
+    free_page(pde2page(pgdir[0]));
+    pgdir[0] = 0;
+
+    mm->pgdir = NULL;
+    mm_destroy(mm);
+    check_mm_struct = NULL;
+
+    assert(nr_free_pages_store == nr_free_pages());
+
+    cprintf("check_pgfault() succeeded!\n");
+}
+//page fault number
+volatile unsigned int pgfault_num=0;
+
+/* do_pgfault - interrupt handler to process the page fault execption
+ * @mm         : the control struct for a set of vma using the same PDT
+ * @error_code : the error code recorded in trapframe->tf_err which is setted by x86 hardware
+ * @addr       : the addr which causes a memory access exception, (the contents of the CR2 register)
+ *
+ * CALL GRAPH: trap--> trap_dispatch-->pgfault_handler-->do_pgfault
+ * The processor provides ucore's do_pgfault function with two items of information to aid in diagnosing
+ * the exception and recovering from it.
+ *   (1) The contents of the CR2 register. The processor loads the CR2 register with the
+ *       32-bit linear address that generated the exception. The do_pgfault fun can
+ *       use this address to locate the corresponding page directory and page-table
+ *       entries.
+ *   (2) An error code on the kernel stack. The error code for a page fault has a format different from
+ *       that for other exceptions. The error code tells the exception handler three things:
+ *         -- The P flag   (bit 0) indicates whether the exception was due to a not-present page (0)
+ *            or to either an access rights violation or the use of a reserved bit (1).
+ *         -- The W/R flag (bit 1) indicates whether the memory access that caused the exception
+ *            was a read (0) or write (1).
+ *         -- The U/S flag (bit 2) indicates whether the processor was executing at user mode (1)
+ *            or supervisor mode (0) at the time of the exception.
+ */
+int
+do_pgfault(struct mm_struct *mm, uint32_t error_code, uintptr_t addr) {
+    int ret = -E_INVAL;
+    //try to find a vma which include addr
+    struct vma_struct *vma = find_vma(mm, addr);
+
+    pgfault_num++;
+    //If the addr is in the range of a mm's vma?
+    if (vma == NULL || vma->vm_start > addr) {
+        cprintf("not valid addr %x, and  can not find it in vma\n", addr);
+        goto failed;
+    }
+    //check the error_code
+    switch (error_code & 3) {
+    default:
+            /* error code flag : default is 3 ( W/R=1, P=1): write, present */
+    case 2: /* error code flag : (W/R=1, P=0): write, not present */
+        if (!(vma->vm_flags & VM_WRITE)) {
+            cprintf("do_pgfault failed: error code flag = write AND not present, but the addr's vma cannot write\n");
+            goto failed;
+        }
+        break;
+    case 1: /* error code flag : (W/R=0, P=1): read, present */
+        cprintf("do_pgfault failed: error code flag = read AND present\n");
+        goto failed;
+    case 0: /* error code flag : (W/R=0, P=0): read, not present */
+        if (!(vma->vm_flags & (VM_READ | VM_EXEC))) {
+            cprintf("do_pgfault failed: error code flag = read AND not present, but the addr's vma cannot read or exec\n");
+            goto failed;
+        }
+    }
+    /* IF (write an existed addr ) OR
+     *    (write an non_existed addr && addr is writable) OR
+     *    (read  an non_existed addr && addr is readable)
+     * THEN
+     *    continue process
+     */
+    uint32_t perm = PTE_U;
+    if (vma->vm_flags & VM_WRITE) {
+        perm |= PTE_W;
+    }
+    addr = ROUNDDOWN(addr, PGSIZE);
+
+    ret = -E_NO_MEM;
+
+    pte_t *ptep=NULL;
+    /*LAB3 EXERCISE 1: YOUR CODE
+    * Maybe you want help comment, BELOW comments can help you finish the code
+    *
+    * Some Useful MACROs and DEFINEs, you can use them in below implementation.
+    * MACROs or Functions:
+    *   get_pte : get an pte and return the kernel virtual address of this pte for la
+    *             if the PT contians this pte didn't exist, alloc a page for PT (notice the 3th parameter '1')
+    *   pgdir_alloc_page : call alloc_page & page_insert functions to allocate a page size memory & setup
+    *             an addr map pa<--->la with linear address la and the PDT pgdir
+    * DEFINES:
+    *   VM_WRITE  : If vma->vm_flags & VM_WRITE == 1/0, then the vma is writable/non writable
+    *   PTE_W           0x002                   // page table/directory entry flags bit : Writeable
+    *   PTE_U           0x004                   // page table/directory entry flags bit : User can access
+    * VARIABLES:
+    *   mm->pgdir : the PDT of these vma
+    *
+    */
+#if 0
+    /*LAB3 EXERCISE 1: YOUR CODE*/
+    ptep = ???              //(1) try to find a pte, if pte's PT(Page Table) isn't existed, then create a PT.
+    if (*ptep == 0) {
+                            //(2) if the phy addr isn't exist, then alloc a page & map the phy addr with logical addr
+
+    }
+    else {
+    /*LAB3 EXERCISE 2: YOUR CODE
+    * Now we think this pte is a  swap entry, we should load data from disk to a page with phy addr,
+    * and map the phy addr with logical addr, trigger swap manager to record the access situation of this page.
+    *
+    *  Some Useful MACROs and DEFINEs, you can use them in below implementation.
+    *  MACROs or Functions:
+    *    swap_in(mm, addr, &page) : alloc a memory page, then according to the swap entry in PTE for addr,
+    *                               find the addr of disk page, read the content of disk page into this memroy page
+    *    page_insert ： build the map of phy addr of an Page with the linear addr la
+    *    swap_map_swappable ： set the page swappable
+    */
+        if(swap_init_ok) {
+            struct Page *page=NULL;
+                                    //(1）According to the mm AND addr, try to load the content of right disk page
+                                    //    into the memory which page managed.
+                                    //(2) According to the mm, addr AND page, setup the map of phy addr <---> logical addr
+                                    //(3) make the page swappable.
+        }
+        else {
+            cprintf("no swap_init_ok but ptep is %x, failed\n",*ptep);
+            goto failed;
+        }
+   }
+#endif
+   ret = 0;
+failed:
+    return ret;
+}
+
diff -r -uN labcodes_answer/lab3_result/kern/mm/vmm.c.rej labcodes/lab3/kern/mm/vmm.c.rej
--- labcodes_answer/lab3_result/kern/mm/vmm.c.rej	1970-01-01 08:00:00.000000000 +0800
+++ labcodes/lab3/kern/mm/vmm.c.rej	2020-05-30 10:50:25.925857970 +0800
@@ -0,0 +1,20 @@
+--- labcodes_answer/lab3_result/kern/mm/vmm.c	2020-05-30 07:45:13.671200547 +0800
++++ labcodes/lab3/kern/mm/vmm.c	2020-05-30 10:48:18.933735931 +0800
+@@ -396,8 +396,6 @@
+         }
+    }
+ #endif
+-    // try to find a pte, if pte's PT(Page Table) isn't existed, then create a PT.
+-    // (notice the 3th parameter '1')
+     if ((ptep = get_pte(mm->pgdir, addr, 1)) == NULL) {
+         cprintf("get_pte in do_pgfault failed\n");
+         goto failed;
+@@ -426,7 +424,7 @@
+             goto failed;
+         }
+    }
+-   ret = 0;
++    ret = 0;
+ failed:
+     return ret;
+ }
diff -r -uN labcodes_answer/lab3_result/kern/mm/vmm.h labcodes/lab3/kern/mm/vmm.h
--- labcodes_answer/lab3_result/kern/mm/vmm.h	2020-05-30 07:45:13.671200547 +0800
+++ labcodes/lab3/kern/mm/vmm.h	2020-05-30 07:45:13.631200508 +0800
@@ -9,11 +9,12 @@
 //pre define
 struct mm_struct;
 
-// the virtual continuous memory area(vma)
+// the virtual continuous memory area(vma), [vm_start, vm_end), 
+// addr belong to a vma means  vma.vm_start<= addr <vma.vm_end 
 struct vma_struct {
     struct mm_struct *vm_mm; // the set of vma using the same PDT 
-    uintptr_t vm_start;      //    start addr of vma    
-    uintptr_t vm_end;        // end addr of vma
+    uintptr_t vm_start;      // start addr of vma      
+    uintptr_t vm_end;        // end addr of vma, not include the vm_end itself
     uint32_t vm_flags;       // flags of vma
     list_entry_t list_link;  // linear list link which sorted by start addr of vma
 };
diff -r -uN labcodes_answer/lab3_result/kern/trap/trap.c labcodes/lab3/kern/trap/trap.c
--- labcodes_answer/lab3_result/kern/trap/trap.c	2020-05-30 11:01:52.830489481 +0800
+++ labcodes/lab3/kern/trap/trap.c	2020-05-30 16:42:21.430840120 +0800
@@ -48,12 +48,6 @@
       *     You don't know the meaning of this instruction? just google it! and check the libs/x86.h to know more.
       *     Notice: the argument of lidt is idt_pd. try to find it!
       */
-    extern uintptr_t __vectors[];
-    int i;
-    for (i = 0; i < sizeof(idt) / sizeof(struct gatedesc); i ++) {
-        SETGATE(idt[i], 0, GD_KTEXT, __vectors[i], DPL_KERNEL);
-    }
-    lidt(&idt_pd);
 }
 
 static const char *
@@ -183,7 +177,7 @@
         break;
     case IRQ_OFFSET + IRQ_TIMER:
 #if 0
-    LAB3  CHALLENGE 1 : If some page replacement algorithm(such as CLOCK PRA) need tick to change the priority of pages, 
+    LAB3 : If some page replacement algorithm(such as CLOCK PRA) need tick to change the priority of pages, 
     then you can add code here. 
 #endif
         /* LAB1 YOUR CODE : STEP 3 */
@@ -192,10 +186,6 @@
          * (2) Every TICK_NUM cycle, you can print some info using a funciton, such as print_ticks().
          * (3) Too Simple? Yes, I think so!
          */
-        ticks ++;
-        if (ticks % TICK_NUM == 0) {
-            print_ticks();
-        }
         break;
     case IRQ_OFFSET + IRQ_COM1:
         c = cons_getc();
diff -r -uN labcodes_answer/lab3_result/kern/trap/vectors.S labcodes/lab3/kern/trap/vectors.S
--- labcodes_answer/lab3_result/kern/trap/vectors.S	2020-05-30 07:45:13.671200547 +0800
+++ labcodes/lab3/kern/trap/vectors.S	2020-05-30 07:45:13.631200508 +0800
@@ -47,6 +47,7 @@
   jmp __alltraps
 .globl vector9
 vector9:
+  pushl $0
   pushl $9
   jmp __alltraps
 .globl vector10
diff -r -uN labcodes_answer/lab3_result/Makefile labcodes/lab3/Makefile
--- labcodes_answer/lab3_result/Makefile	2020-05-30 07:45:13.671200547 +0800
+++ labcodes/lab3/Makefile	2020-05-30 16:40:06.234439425 +0800
@@ -4,7 +4,8 @@
 SLASH	:= /
 
 V       := @
-
+#need llvm/cang-3.5+
+#USELLVM := 1
 # try to infer the correct GCCPREFX
 ifndef GCCPREFIX
 GCCPREFIX := $(shell if i386-elf-objdump -i 2>&1 | grep '^elf32-i386$$' >/dev/null 2>&1; \
@@ -27,6 +28,8 @@
 	then echo 'qemu-system-i386'; exit; \
 	elif which i386-elf-qemu > /dev/null; \
 	then echo 'i386-elf-qemu'; exit; \
+	elif which qemu > /dev/null; \
+	then echo 'qemu'; exit; \
 	else \
 	echo "***" 1>&2; \
 	echo "*** Error: Couldn't find a working QEMU executable." 1>&2; \
@@ -41,15 +44,21 @@
 .DELETE_ON_ERROR:
 
 # define compiler and flags
-
+ifndef  USELLVM
 HOSTCC		:= gcc
 HOSTCFLAGS	:= -g -Wall -O2
-
-GDB		:= $(GCCPREFIX)gdb
-
 CC		:= $(GCCPREFIX)gcc
-CFLAGS	:= -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc $(DEFS)
+CFLAGS	:= -march=i686 -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc $(DEFS)
 CFLAGS	+= $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+else
+HOSTCC		:= clang
+HOSTCFLAGS	:= -g -Wall -O2
+CC		:= clang
+CFLAGS	:= -march=i686 -fno-builtin -fno-PIC -Wall -g -m32 -nostdinc $(DEFS)
+CFLAGS	+= $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+endif
+
+GDB		:= $(GCCPREFIX)gdb
 CTYPE	:= c S
 
 LD      := $(GCCPREFIX)ld
@@ -217,12 +226,12 @@
 
 .PHONY: qemu qemu-nox debug debug-nox
 qemu-mon: $(UCOREIMG) $(SWAPIMG)
-	$(V)$(QEMU) -monitor stdio $(QEMUOPTS) -serial null
+	$(V)$(QEMU)  -no-reboot -monitor stdio $(QEMUOPTS) -serial null
 qemu: $(UCOREIMG) $(SWAPIMG)
-	$(V)$(QEMU) -parallel stdio $(QEMUOPTS) -serial null
+	$(V)$(QEMU)  -no-reboot -parallel stdio $(QEMUOPTS) -serial null
 
 qemu-nox: $(UCOREIMG) $(SWAPIMG)
-	$(V)$(QEMU) -serial mon:stdio $(QEMUOPTS) -nographic
+	$(V)$(QEMU)  -no-reboot -serial mon:stdio $(QEMUOPTS) -nographic
 
 TERMINAL := gnome-terminal
 
@@ -256,9 +265,9 @@
 print-%:
 	@echo $($(shell echo $(patsubst print-%,%,$@) | $(TR) [a-z] [A-Z]))
 
-.PHONY: clean dist-clean handin packall
+.PHONY: clean dist-clean handin packall tags
 clean:
-	$(V)$(RM) $(GRADE_GDB_IN) $(GRADE_QEMU_OUT)
+	$(V)$(RM) $(GRADE_GDB_IN) $(GRADE_QEMU_OUT) cscope* tags
 	-$(RM) -r $(OBJDIR) $(BINDIR)
 
 dist-clean: clean
@@ -271,3 +280,9 @@
 	@$(RM) -f $(HANDIN)
 	@tar -czf $(HANDIN) `find . -type f -o -type d | grep -v '^\.*$$' | grep -vF '$(HANDIN)'`
 
+tags:
+	@echo TAGS ALL
+	$(V)rm -f cscope.files cscope.in.out cscope.out cscope.po.out tags
+	$(V)find . -type f -name "*.[chS]" >cscope.files
+	$(V)cscope -bq 
+	$(V)ctags -L cscope.files
diff -r -uN labcodes_answer/lab3_result/Makefile.orig labcodes/lab3/Makefile.orig
--- labcodes_answer/lab3_result/Makefile.orig	1970-01-01 08:00:00.000000000 +0800
+++ labcodes/lab3/Makefile.orig	2020-05-30 07:45:13.627200504 +0800
@@ -0,0 +1,288 @@
+PROJ	:= 8
+EMPTY	:=
+SPACE	:= $(EMPTY) $(EMPTY)
+SLASH	:= /
+
+V       := @
+#need llvm/cang-3.5+
+#USELLVM := 1
+# try to infer the correct GCCPREFX
+ifndef GCCPREFIX
+GCCPREFIX := $(shell if i386-elf-objdump -i 2>&1 | grep '^elf32-i386$$' >/dev/null 2>&1; \
+	then echo 'i386-elf-'; \
+	elif objdump -i 2>&1 | grep 'elf32-i386' >/dev/null 2>&1; \
+	then echo ''; \
+	else echo "***" 1>&2; \
+	echo "*** Error: Couldn't find an i386-elf version of GCC/binutils." 1>&2; \
+	echo "*** Is the directory with i386-elf-gcc in your PATH?" 1>&2; \
+	echo "*** If your i386-elf toolchain is installed with a command" 1>&2; \
+	echo "*** prefix other than 'i386-elf-', set your GCCPREFIX" 1>&2; \
+	echo "*** environment variable to that prefix and run 'make' again." 1>&2; \
+	echo "*** To turn off this error, run 'gmake GCCPREFIX= ...'." 1>&2; \
+	echo "***" 1>&2; exit 1; fi)
+endif
+
+# try to infer the correct QEMU
+ifndef QEMU
+QEMU := $(shell if which qemu-system-i386 > /dev/null; \
+	then echo 'qemu-system-i386'; exit; \
+	elif which i386-elf-qemu > /dev/null; \
+	then echo 'i386-elf-qemu'; exit; \
+	elif which qemu > /dev/null; \
+	then echo 'qemu'; exit; \
+	else \
+	echo "***" 1>&2; \
+	echo "*** Error: Couldn't find a working QEMU executable." 1>&2; \
+	echo "*** Is the directory containing the qemu binary in your PATH" 1>&2; \
+	echo "***" 1>&2; exit 1; fi)
+endif
+
+# eliminate default suffix rules
+.SUFFIXES: .c .S .h
+
+# delete target files if there is an error (or make is interrupted)
+.DELETE_ON_ERROR:
+
+# define compiler and flags
+ifndef  USELLVM
+HOSTCC		:= gcc
+HOSTCFLAGS	:= -g -Wall -O2
+CC		:= $(GCCPREFIX)gcc
+CFLAGS	:= -march=i686 -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc $(DEFS)
+CFLAGS	+= $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+else
+HOSTCC		:= clang
+HOSTCFLAGS	:= -g -Wall -O2
+CC		:= clang
+CFLAGS	:= -march=i686 -fno-builtin -fno-PIC -Wall -g -m32 -nostdinc $(DEFS)
+CFLAGS	+= $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+endif
+
+GDB		:= $(GCCPREFIX)gdb
+CTYPE	:= c S
+
+LD      := $(GCCPREFIX)ld
+LDFLAGS	:= -m $(shell $(LD) -V | grep elf_i386 2>/dev/null | head -n 1)
+LDFLAGS	+= -nostdlib
+
+OBJCOPY := $(GCCPREFIX)objcopy
+OBJDUMP := $(GCCPREFIX)objdump
+
+COPY	:= cp
+MKDIR   := mkdir -p
+MV		:= mv
+RM		:= rm -f
+AWK		:= awk
+SED		:= sed
+SH		:= sh
+TR		:= tr
+TOUCH	:= touch -c
+
+OBJDIR	:= obj
+BINDIR	:= bin
+
+ALLOBJS	:=
+ALLDEPS	:=
+TARGETS	:=
+
+include tools/function.mk
+
+listf_cc = $(call listf,$(1),$(CTYPE))
+
+# for cc
+add_files_cc = $(call add_files,$(1),$(CC),$(CFLAGS) $(3),$(2),$(4))
+create_target_cc = $(call create_target,$(1),$(2),$(3),$(CC),$(CFLAGS))
+
+# for hostcc
+add_files_host = $(call add_files,$(1),$(HOSTCC),$(HOSTCFLAGS),$(2),$(3))
+create_target_host = $(call create_target,$(1),$(2),$(3),$(HOSTCC),$(HOSTCFLAGS))
+
+cgtype = $(patsubst %.$(2),%.$(3),$(1))
+objfile = $(call toobj,$(1))
+asmfile = $(call cgtype,$(call toobj,$(1)),o,asm)
+outfile = $(call cgtype,$(call toobj,$(1)),o,out)
+symfile = $(call cgtype,$(call toobj,$(1)),o,sym)
+
+# for match pattern
+match = $(shell echo $(2) | $(AWK) '{for(i=1;i<=NF;i++){if(match("$(1)","^"$$(i)"$$")){exit 1;}}}'; echo $$?)
+
+# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
+# include kernel/user
+
+INCLUDE	+= libs/
+
+CFLAGS	+= $(addprefix -I,$(INCLUDE))
+
+LIBDIR	+= libs
+
+$(call add_files_cc,$(call listf_cc,$(LIBDIR)),libs,)
+
+# -------------------------------------------------------------------
+# kernel
+
+KINCLUDE	+= kern/debug/ \
+			   kern/driver/ \
+			   kern/trap/ \
+			   kern/mm/ \
+			   kern/libs/ \
+			   kern/sync/ \
+			   kern/fs/
+
+KSRCDIR		+= kern/init \
+			   kern/libs \
+			   kern/debug \
+			   kern/driver \
+			   kern/trap \
+			   kern/mm \
+			   kern/sync \
+			   kern/fs
+
+KCFLAGS		+= $(addprefix -I,$(KINCLUDE))
+
+$(call add_files_cc,$(call listf_cc,$(KSRCDIR)),kernel,$(KCFLAGS))
+
+KOBJS	= $(call read_packet,kernel libs)
+
+# create kernel target
+kernel = $(call totarget,kernel)
+
+$(kernel): tools/kernel.ld
+
+$(kernel): $(KOBJS)
+	@echo + ld $@
+	$(V)$(LD) $(LDFLAGS) -T tools/kernel.ld -o $@ $(KOBJS)
+	@$(OBJDUMP) -S $@ > $(call asmfile,kernel)
+	@$(OBJDUMP) -t $@ | $(SED) '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $(call symfile,kernel)
+
+$(call create_target,kernel)
+
+# -------------------------------------------------------------------
+
+# create bootblock
+bootfiles = $(call listf_cc,boot)
+$(foreach f,$(bootfiles),$(call cc_compile,$(f),$(CC),$(CFLAGS) -Os -nostdinc))
+
+bootblock = $(call totarget,bootblock)
+
+$(bootblock): $(call toobj,boot/bootasm.S) $(call toobj,$(bootfiles)) | $(call totarget,sign)
+	@echo + ld $@
+	$(V)$(LD) $(LDFLAGS) -N -T tools/boot.ld $^ -o $(call toobj,bootblock)
+	@$(OBJDUMP) -S $(call objfile,bootblock) > $(call asmfile,bootblock)
+	@$(OBJCOPY) -S -O binary $(call objfile,bootblock) $(call outfile,bootblock)
+	@$(call totarget,sign) $(call outfile,bootblock) $(bootblock)
+
+$(call create_target,bootblock)
+
+# -------------------------------------------------------------------
+
+# create 'sign' tools
+$(call add_files_host,tools/sign.c,sign,sign)
+$(call create_target_host,sign,sign)
+
+# -------------------------------------------------------------------
+
+# create ucore.img
+UCOREIMG	:= $(call totarget,ucore.img)
+
+$(UCOREIMG): $(kernel) $(bootblock)
+	$(V)dd if=/dev/zero of=$@ count=10000
+	$(V)dd if=$(bootblock) of=$@ conv=notrunc
+	$(V)dd if=$(kernel) of=$@ seek=1 conv=notrunc
+
+$(call create_target,ucore.img)
+
+# -------------------------------------------------------------------
+
+# create swap.img
+SWAPIMG		:= $(call totarget,swap.img)
+
+$(SWAPIMG):
+	$(V)dd if=/dev/zero of=$@ bs=1024k count=128
+
+$(call create_target,swap.img)
+
+# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
+
+$(call finish_all)
+
+IGNORE_ALLDEPS	= clean \
+				  dist-clean \
+				  grade \
+				  touch \
+				  print-.+ \
+				  handin
+
+ifeq ($(call match,$(MAKECMDGOALS),$(IGNORE_ALLDEPS)),0)
+-include $(ALLDEPS)
+endif
+
+# files for grade script
+
+TARGETS: $(TARGETS)
+
+.DEFAULT_GOAL := TARGETS
+
+QEMUOPTS = -hda $(UCOREIMG) -drive file=$(SWAPIMG),media=disk,cache=writeback
+
+.PHONY: qemu qemu-nox debug debug-nox
+qemu-mon: $(UCOREIMG) $(SWAPIMG)
+	$(V)$(QEMU)  -no-reboot -monitor stdio $(QEMUOPTS) -serial null
+qemu: $(UCOREIMG) $(SWAPIMG)
+	$(V)$(QEMU)  -no-reboot -parallel stdio $(QEMUOPTS) -serial null
+
+qemu-nox: $(UCOREIMG) $(SWAPIMG)
+	$(V)$(QEMU)  -no-reboot -serial mon:stdio $(QEMUOPTS) -nographic
+
+TERMINAL := gnome-terminal
+
+debug: $(UCOREIMG) $(SWAPIMG)
+	$(V)$(QEMU) -S -s -parallel stdio $(QEMUOPTS) -serial null &
+	$(V)sleep 2
+	$(V)$(TERMINAL) -e "$(GDB) -q -x tools/gdbinit"
+
+debug-nox: $(UCOREIMG) $(SWAPIMG)
+	$(V)$(QEMU) -S -s -serial mon:stdio $(QEMUOPTS) -nographic &
+	$(V)sleep 2
+	$(V)$(TERMINAL) -e "$(GDB) -q -x tools/gdbinit"
+
+.PHONY: grade touch
+
+GRADE_GDB_IN	:= .gdb.in
+GRADE_QEMU_OUT	:= .qemu.out
+HANDIN			:= proj$(PROJ)-handin.tar.gz
+
+TOUCH_FILES		:= kern/trap/trap.c
+
+MAKEOPTS		:= --quiet --no-print-directory
+
+grade:
+	$(V)$(MAKE) $(MAKEOPTS) clean
+	$(V)$(SH) tools/grade.sh
+
+touch:
+	$(V)$(foreach f,$(TOUCH_FILES),$(TOUCH) $(f))
+
+print-%:
+	@echo $($(shell echo $(patsubst print-%,%,$@) | $(TR) [a-z] [A-Z]))
+
+.PHONY: clean dist-clean handin packall tags
+clean:
+	$(V)$(RM) $(GRADE_GDB_IN) $(GRADE_QEMU_OUT) cscope* tags
+	-$(RM) -r $(OBJDIR) $(BINDIR)
+
+dist-clean: clean
+	-$(RM) $(HANDIN)
+
+handin: packall
+	@echo Please visit http://learn.tsinghua.edu.cn and upload $(HANDIN). Thanks!
+
+packall: clean
+	@$(RM) -f $(HANDIN)
+	@tar -czf $(HANDIN) `find . -type f -o -type d | grep -v '^\.*$$' | grep -vF '$(HANDIN)'`
+
+tags:
+	@echo TAGS ALL
+	$(V)rm -f cscope.files cscope.in.out cscope.out cscope.po.out tags
+	$(V)find . -type f -name "*.[chS]" >cscope.files
+	$(V)cscope -bq 
+	$(V)ctags -L cscope.files
diff -r -uN labcodes_answer/lab3_result/Makefile.rej labcodes/lab3/Makefile.rej
--- labcodes_answer/lab3_result/Makefile.rej	1970-01-01 08:00:00.000000000 +0800
+++ labcodes/lab3/Makefile.rej	2020-05-30 16:38:26.966372851 +0800
@@ -0,0 +1,86 @@
+--- labcodes_answer/lab3_result/Makefile	2020-05-30 07:45:13.671200547 +0800
++++ labcodes/lab3/Makefile	2020-05-30 07:45:13.627200504 +0800
+@@ -4,7 +4,8 @@
+ SLASH	:= /
+ 
+ V       := @
+-
++#need llvm/cang-3.5+
++#USELLVM := 1
+ # try to infer the correct GCCPREFX
+ ifndef GCCPREFIX
+ GCCPREFIX := $(shell if i386-elf-objdump -i 2>&1 | grep '^elf32-i386$$' >/dev/null 2>&1; \
+@@ -27,6 +28,8 @@
+ 	then echo 'qemu-system-i386'; exit; \
+ 	elif which i386-elf-qemu > /dev/null; \
+ 	then echo 'i386-elf-qemu'; exit; \
++	elif which qemu > /dev/null; \
++	then echo 'qemu'; exit; \
+ 	else \
+ 	echo "***" 1>&2; \
+ 	echo "*** Error: Couldn't find a working QEMU executable." 1>&2; \
+@@ -41,15 +44,21 @@
+ .DELETE_ON_ERROR:
+ 
+ # define compiler and flags
+-
++ifndef  USELLVM
+ HOSTCC		:= gcc
+ HOSTCFLAGS	:= -g -Wall -O2
+-
+-GDB		:= $(GCCPREFIX)gdb
+-
+ CC		:= $(GCCPREFIX)gcc
+-CFLAGS	:= -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc $(DEFS)
++CFLAGS	:= -march=i686 -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc $(DEFS)
+ CFLAGS	+= $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
++else
++HOSTCC		:= clang
++HOSTCFLAGS	:= -g -Wall -O2
++CC		:= clang
++CFLAGS	:= -march=i686 -fno-builtin -fno-PIC -Wall -g -m32 -nostdinc $(DEFS)
++CFLAGS	+= $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
++endif
++
++GDB		:= $(GCCPREFIX)gdb
+ CTYPE	:= c S
+ 
+ LD      := $(GCCPREFIX)ld
+@@ -217,12 +226,12 @@
+ 
+ .PHONY: qemu qemu-nox debug debug-nox
+ qemu-mon: $(UCOREIMG) $(SWAPIMG)
+-	$(V)$(QEMU) -monitor stdio $(QEMUOPTS) -serial null
++	$(V)$(QEMU)  -no-reboot -monitor stdio $(QEMUOPTS) -serial null
+ qemu: $(UCOREIMG) $(SWAPIMG)
+-	$(V)$(QEMU) -parallel stdio $(QEMUOPTS) -serial null
++	$(V)$(QEMU)  -no-reboot -parallel stdio $(QEMUOPTS) -serial null
+ 
+ qemu-nox: $(UCOREIMG) $(SWAPIMG)
+-	$(V)$(QEMU) -serial mon:stdio $(QEMUOPTS) -nographic
++	$(V)$(QEMU)  -no-reboot -serial mon:stdio $(QEMUOPTS) -nographic
+ 
+ TERMINAL := gnome-terminal
+ 
+@@ -256,9 +265,9 @@
+ print-%:
+ 	@echo $($(shell echo $(patsubst print-%,%,$@) | $(TR) [a-z] [A-Z]))
+ 
+-.PHONY: clean dist-clean handin packall
++.PHONY: clean dist-clean handin packall tags
+ clean:
+-	$(V)$(RM) $(GRADE_GDB_IN) $(GRADE_QEMU_OUT)
++	$(V)$(RM) $(GRADE_GDB_IN) $(GRADE_QEMU_OUT) cscope* tags
+ 	-$(RM) -r $(OBJDIR) $(BINDIR)
+ 
+ dist-clean: clean
+@@ -271,3 +280,9 @@
+ 	@$(RM) -f $(HANDIN)
+ 	@tar -czf $(HANDIN) `find . -type f -o -type d | grep -v '^\.*$$' | grep -vF '$(HANDIN)'`
+ 
++tags:
++	@echo TAGS ALL
++	$(V)rm -f cscope.files cscope.in.out cscope.out cscope.po.out tags
++	$(V)find . -type f -name "*.[chS]" >cscope.files
++	$(V)cscope -bq 
++	$(V)ctags -L cscope.files
Binary files labcodes_answer/lab3_result/obj/boot/bootasm.o and labcodes/lab3/obj/boot/bootasm.o differ
Binary files labcodes_answer/lab3_result/obj/boot/bootmain.o and labcodes/lab3/obj/boot/bootmain.o differ
diff -r -uN labcodes_answer/lab3_result/obj/bootblock.asm labcodes/lab3/obj/bootblock.asm
--- labcodes_answer/lab3_result/obj/bootblock.asm	2020-05-30 10:42:06.581373717 +0800
+++ labcodes/lab3/obj/bootblock.asm	2020-05-30 16:42:21.662840825 +0800
@@ -31,7 +31,7 @@
     #  address line 20 is tied low, so that addresses higher than
     #  1MB wrap around to zero by default. This code undoes this.
 seta20.1:
-    inb $0x64, %al                                  # Wait for not busy
+    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).
     7c0a:	e4 64                	in     $0x64,%al
     testb $0x2, %al
     7c0c:	a8 02                	test   $0x2,%al
@@ -40,13 +40,13 @@
 
     movb $0xd1, %al                                 # 0xd1 -> port 0x64
     7c10:	b0 d1                	mov    $0xd1,%al
-    outb %al, $0x64
+    outb %al, $0x64                                 # 0xd1 means: write data to 8042's P2 port
     7c12:	e6 64                	out    %al,$0x64
 
 00007c14 <seta20.2>:
 
 seta20.2:
-    inb $0x64, %al                                  # Wait for not busy
+    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).
     7c14:	e4 64                	in     $0x64,%al
     testb $0x2, %al
     7c16:	a8 02                	test   $0x2,%al
@@ -55,7 +55,7 @@
 
     movb $0xdf, %al                                 # 0xdf -> port 0x60
     7c1a:	b0 df                	mov    $0xdf,%al
-    outb %al, $0x60
+    outb %al, $0x60                                 # 0xdf = 11011111, means set P2's A20 bit(the 1 bit) to 1
     7c1c:	e6 60                	out    %al,$0x60
 
 00007c1e <probe_memory>:
@@ -111,7 +111,7 @@
     # effective memory map does not change during the switch.
     lgdt gdtdesc
     7c59:	0f 01 16             	lgdtl  (%esi)
-    7c5c:	b4 7d                	mov    $0x7d,%ah
+    7c5c:	b0 7d                	mov    $0x7d,%al
     movl %cr0, %eax
     7c5e:	0f 20 c0             	mov    %cr0,%eax
     orl $CR0_PE_ON, %eax
@@ -151,7 +151,7 @@
     movl $start, %esp
     7c80:	bc 00 7c 00 00       	mov    $0x7c00,%esp
     call bootmain
-    7c85:	e8 9d 00 00 00       	call   7d27 <bootmain>
+    7c85:	e8 99 00 00 00       	call   7d23 <bootmain>
 
 00007c8a <spin>:
 
@@ -178,59 +178,70 @@
     // round down to sector boundary
     va -= offset % SECTSIZE;
     7c93:	89 ca                	mov    %ecx,%edx
-
-    // translate from bytes to sectors; kernel starts at sector 1
-    uint32_t secno = (offset / SECTSIZE) + 1;
-    7c95:	c1 e9 09             	shr    $0x9,%ecx
 /* *
  * readseg - read @count bytes at @offset from kernel into virtual address @va,
  * might copy more than asked.
  * */
 static void
 readseg(uintptr_t va, uint32_t count, uint32_t offset) {
-    7c98:	56                   	push   %esi
+    7c95:	56                   	push   %esi
     uintptr_t end_va = va + count;
 
     // round down to sector boundary
     va -= offset % SECTSIZE;
-    7c99:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
-
-    // translate from bytes to sectors; kernel starts at sector 1
-    uint32_t secno = (offset / SECTSIZE) + 1;
-    7c9f:	8d 71 01             	lea    0x1(%ecx),%esi
+    7c96:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
 /* *
  * readseg - read @count bytes at @offset from kernel into virtual address @va,
  * might copy more than asked.
  * */
 static void
 readseg(uintptr_t va, uint32_t count, uint32_t offset) {
-    7ca2:	53                   	push   %ebx
+    7c9c:	53                   	push   %ebx
     uintptr_t end_va = va + count;
 
     // round down to sector boundary
     va -= offset % SECTSIZE;
-    7ca3:	29 d0                	sub    %edx,%eax
+    7c9d:	29 d0                	sub    %edx,%eax
+
+    // translate from bytes to sectors; kernel starts at sector 1
+    uint32_t secno = (offset / SECTSIZE) + 1;
+    7c9f:	c1 e9 09             	shr    $0x9,%ecx
+static void
+readseg(uintptr_t va, uint32_t count, uint32_t offset) {
+    uintptr_t end_va = va + count;
+
+    // round down to sector boundary
+    va -= offset % SECTSIZE;
+    7ca2:	89 c6                	mov    %eax,%esi
 /* *
  * readseg - read @count bytes at @offset from kernel into virtual address @va,
  * might copy more than asked.
  * */
 static void
 readseg(uintptr_t va, uint32_t count, uint32_t offset) {
-    7ca5:	53                   	push   %ebx
-    uintptr_t end_va = va + count;
-    7ca6:	89 7d f0             	mov    %edi,-0x10(%ebp)
+    7ca4:	53                   	push   %ebx
 
     // round down to sector boundary
     va -= offset % SECTSIZE;
-    7ca9:	89 c3                	mov    %eax,%ebx
+
+    // translate from bytes to sectors; kernel starts at sector 1
+    uint32_t secno = (offset / SECTSIZE) + 1;
+    7ca5:	8d 59 01             	lea    0x1(%ecx),%ebx
+ * readseg - read @count bytes at @offset from kernel into virtual address @va,
+ * might copy more than asked.
+ * */
+static void
+readseg(uintptr_t va, uint32_t count, uint32_t offset) {
+    uintptr_t end_va = va + count;
+    7ca8:	89 7d f0             	mov    %edi,-0x10(%ebp)
     uint32_t secno = (offset / SECTSIZE) + 1;
 
     // If this is too slow, we could read lots of sectors at a time.
     // We'd write more to memory than asked, but it doesn't matter --
     // we load in increasing order.
     for (; va < end_va; va += SECTSIZE, secno ++) {
-    7cab:	3b 5d f0             	cmp    -0x10(%ebp),%ebx
-    7cae:	73 71                	jae    7d21 <readseg+0x95>
+    7cab:	3b 75 f0             	cmp    -0x10(%ebp),%esi
+    7cae:	73 6d                	jae    7d1d <readseg+0x91>
 static inline void invlpg(void *addr) __attribute__((always_inline));
 
 static inline uint8_t
@@ -245,162 +256,178 @@
 static void
 waitdisk(void) {
     while ((inb(0x1F7) & 0xC0) != 0x40)
-    7cb6:	83 e0 c0             	and    $0xffffffc0,%eax
-    7cb9:	3c 40                	cmp    $0x40,%al
-    7cbb:	75 f3                	jne    7cb0 <readseg+0x24>
+    7cb6:	24 c0                	and    $0xc0,%al
+    7cb8:	3c 40                	cmp    $0x40,%al
+    7cba:	75 f4                	jne    7cb0 <readseg+0x24>
         : "memory", "cc");
 }
 
 static inline void
 outb(uint16_t port, uint8_t data) {
     asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
-    7cbd:	ba f2 01 00 00       	mov    $0x1f2,%edx
-    7cc2:	b0 01                	mov    $0x1,%al
-    7cc4:	ee                   	out    %al,(%dx)
-    7cc5:	ba f3 01 00 00       	mov    $0x1f3,%edx
-    7cca:	89 f0                	mov    %esi,%eax
-    7ccc:	ee                   	out    %al,(%dx)
-    7ccd:	89 f0                	mov    %esi,%eax
-    7ccf:	ba f4 01 00 00       	mov    $0x1f4,%edx
-    7cd4:	c1 e8 08             	shr    $0x8,%eax
-    7cd7:	ee                   	out    %al,(%dx)
-    7cd8:	89 f0                	mov    %esi,%eax
-    7cda:	ba f5 01 00 00       	mov    $0x1f5,%edx
-    7cdf:	c1 e8 10             	shr    $0x10,%eax
-    7ce2:	ee                   	out    %al,(%dx)
-    7ce3:	89 f0                	mov    %esi,%eax
-    7ce5:	ba f6 01 00 00       	mov    $0x1f6,%edx
-    7cea:	c1 e8 18             	shr    $0x18,%eax
-    7ced:	83 e0 0f             	and    $0xf,%eax
-    7cf0:	83 c8 e0             	or     $0xffffffe0,%eax
-    7cf3:	ee                   	out    %al,(%dx)
-    7cf4:	b0 20                	mov    $0x20,%al
-    7cf6:	ba f7 01 00 00       	mov    $0x1f7,%edx
-    7cfb:	ee                   	out    %al,(%dx)
+    7cbc:	ba f2 01 00 00       	mov    $0x1f2,%edx
+    7cc1:	b0 01                	mov    $0x1,%al
+    7cc3:	ee                   	out    %al,(%dx)
+    7cc4:	ba f3 01 00 00       	mov    $0x1f3,%edx
+    7cc9:	88 d8                	mov    %bl,%al
+    7ccb:	ee                   	out    %al,(%dx)
+    7ccc:	89 d8                	mov    %ebx,%eax
+    7cce:	ba f4 01 00 00       	mov    $0x1f4,%edx
+    7cd3:	c1 e8 08             	shr    $0x8,%eax
+    7cd6:	ee                   	out    %al,(%dx)
+    7cd7:	89 d8                	mov    %ebx,%eax
+    7cd9:	ba f5 01 00 00       	mov    $0x1f5,%edx
+    7cde:	c1 e8 10             	shr    $0x10,%eax
+    7ce1:	ee                   	out    %al,(%dx)
+    7ce2:	89 d8                	mov    %ebx,%eax
+    7ce4:	ba f6 01 00 00       	mov    $0x1f6,%edx
+    7ce9:	c1 e8 18             	shr    $0x18,%eax
+    7cec:	24 0f                	and    $0xf,%al
+    7cee:	0c e0                	or     $0xe0,%al
+    7cf0:	ee                   	out    %al,(%dx)
+    7cf1:	b0 20                	mov    $0x20,%al
+    7cf3:	ba f7 01 00 00       	mov    $0x1f7,%edx
+    7cf8:	ee                   	out    %al,(%dx)
 static inline void invlpg(void *addr) __attribute__((always_inline));
 
 static inline uint8_t
 inb(uint16_t port) {
     uint8_t data;
     asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
-    7cfc:	ba f7 01 00 00       	mov    $0x1f7,%edx
-    7d01:	ec                   	in     (%dx),%al
-    7d02:	83 e0 c0             	and    $0xffffffc0,%eax
-    7d05:	3c 40                	cmp    $0x40,%al
-    7d07:	75 f3                	jne    7cfc <readseg+0x70>
+    7cf9:	ba f7 01 00 00       	mov    $0x1f7,%edx
+    7cfe:	ec                   	in     (%dx),%al
+    7cff:	24 c0                	and    $0xc0,%al
+    7d01:	3c 40                	cmp    $0x40,%al
+    7d03:	75 f4                	jne    7cf9 <readseg+0x6d>
     return data;
 }
 
 static inline void
 insl(uint32_t port, void *addr, int cnt) {
     asm volatile (
-    7d09:	89 df                	mov    %ebx,%edi
-    7d0b:	b9 80 00 00 00       	mov    $0x80,%ecx
-    7d10:	ba f0 01 00 00       	mov    $0x1f0,%edx
-    7d15:	fc                   	cld    
-    7d16:	f2 6d                	repnz insl (%dx),%es:(%edi)
+    7d05:	89 f7                	mov    %esi,%edi
+    7d07:	b9 80 00 00 00       	mov    $0x80,%ecx
+    7d0c:	ba f0 01 00 00       	mov    $0x1f0,%edx
+    7d11:	fc                   	cld    
+    7d12:	f2 6d                	repnz insl (%dx),%es:(%edi)
     uint32_t secno = (offset / SECTSIZE) + 1;
 
     // If this is too slow, we could read lots of sectors at a time.
     // We'd write more to memory than asked, but it doesn't matter --
     // we load in increasing order.
     for (; va < end_va; va += SECTSIZE, secno ++) {
-    7d18:	81 c3 00 02 00 00    	add    $0x200,%ebx
-    7d1e:	46                   	inc    %esi
-    7d1f:	eb 8a                	jmp    7cab <readseg+0x1f>
+    7d14:	81 c6 00 02 00 00    	add    $0x200,%esi
+    7d1a:	43                   	inc    %ebx
+    7d1b:	eb 8e                	jmp    7cab <readseg+0x1f>
         readsect((void *)va, secno);
     }
 }
-    7d21:	58                   	pop    %eax
-    7d22:	5b                   	pop    %ebx
-    7d23:	5e                   	pop    %esi
-    7d24:	5f                   	pop    %edi
-    7d25:	5d                   	pop    %ebp
-    7d26:	c3                   	ret    
+    7d1d:	58                   	pop    %eax
+    7d1e:	5b                   	pop    %ebx
+    7d1f:	5e                   	pop    %esi
+    7d20:	5f                   	pop    %edi
+    7d21:	5d                   	pop    %ebp
+    7d22:	c3                   	ret    
+
+00007d23 <bootmain>:
+
+/* bootmain - the entry of bootloader */
+void
+bootmain(void) {
+    7d23:	55                   	push   %ebp
+    // read the 1st page off disk
+    readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0);
+    7d24:	31 c9                	xor    %ecx,%ecx
+    }
+}
 
-00007d27 <bootmain>:
+/* bootmain - the entry of bootloader */
+void
+bootmain(void) {
+    7d26:	89 e5                	mov    %esp,%ebp
+    // read the 1st page off disk
+    readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0);
+    7d28:	ba 00 10 00 00       	mov    $0x1000,%edx
+    }
+}
 
 /* bootmain - the entry of bootloader */
 void
 bootmain(void) {
-    7d27:	55                   	push   %ebp
+    7d2d:	56                   	push   %esi
     // read the 1st page off disk
     readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0);
-    7d28:	31 c9                	xor    %ecx,%ecx
-    7d2a:	ba 00 10 00 00       	mov    $0x1000,%edx
-    7d2f:	b8 00 00 01 00       	mov    $0x10000,%eax
+    7d2e:	b8 00 00 01 00       	mov    $0x10000,%eax
     }
 }
 
 /* bootmain - the entry of bootloader */
 void
 bootmain(void) {
-    7d34:	89 e5                	mov    %esp,%ebp
-    7d36:	56                   	push   %esi
-    7d37:	53                   	push   %ebx
+    7d33:	53                   	push   %ebx
     // read the 1st page off disk
     readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0);
-    7d38:	e8 4f ff ff ff       	call   7c8c <readseg>
+    7d34:	e8 53 ff ff ff       	call   7c8c <readseg>
 
     // is this a valid ELF?
     if (ELFHDR->e_magic != ELF_MAGIC) {
-    7d3d:	81 3d 00 00 01 00 7f 	cmpl   $0x464c457f,0x10000
-    7d44:	45 4c 46 
-    7d47:	75 3f                	jne    7d88 <bootmain+0x61>
+    7d39:	81 3d 00 00 01 00 7f 	cmpl   $0x464c457f,0x10000
+    7d40:	45 4c 46 
+    7d43:	75 3f                	jne    7d84 <bootmain+0x61>
     }
 
     struct proghdr *ph, *eph;
 
     // load each program segment (ignores ph flags)
     ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR->e_phoff);
-    7d49:	a1 1c 00 01 00       	mov    0x1001c,%eax
+    7d45:	a1 1c 00 01 00       	mov    0x1001c,%eax
     eph = ph + ELFHDR->e_phnum;
-    7d4e:	0f b7 35 2c 00 01 00 	movzwl 0x1002c,%esi
+    7d4a:	0f b7 35 2c 00 01 00 	movzwl 0x1002c,%esi
     }
 
     struct proghdr *ph, *eph;
 
     // load each program segment (ignores ph flags)
     ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR->e_phoff);
-    7d55:	8d 98 00 00 01 00    	lea    0x10000(%eax),%ebx
+    7d51:	8d 98 00 00 01 00    	lea    0x10000(%eax),%ebx
     eph = ph + ELFHDR->e_phnum;
-    7d5b:	c1 e6 05             	shl    $0x5,%esi
-    7d5e:	01 de                	add    %ebx,%esi
+    7d57:	c1 e6 05             	shl    $0x5,%esi
+    7d5a:	01 de                	add    %ebx,%esi
     for (; ph < eph; ph ++) {
-    7d60:	39 f3                	cmp    %esi,%ebx
-    7d62:	73 18                	jae    7d7c <bootmain+0x55>
+    7d5c:	39 f3                	cmp    %esi,%ebx
+    7d5e:	73 18                	jae    7d78 <bootmain+0x55>
         readseg(ph->p_va & 0xFFFFFF, ph->p_memsz, ph->p_offset);
-    7d64:	8b 43 08             	mov    0x8(%ebx),%eax
-    7d67:	8b 4b 04             	mov    0x4(%ebx),%ecx
+    7d60:	8b 43 08             	mov    0x8(%ebx),%eax
     struct proghdr *ph, *eph;
 
     // load each program segment (ignores ph flags)
     ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR->e_phoff);
     eph = ph + ELFHDR->e_phnum;
     for (; ph < eph; ph ++) {
-    7d6a:	83 c3 20             	add    $0x20,%ebx
+    7d63:	83 c3 20             	add    $0x20,%ebx
         readseg(ph->p_va & 0xFFFFFF, ph->p_memsz, ph->p_offset);
-    7d6d:	8b 53 f4             	mov    -0xc(%ebx),%edx
-    7d70:	25 ff ff ff 00       	and    $0xffffff,%eax
-    7d75:	e8 12 ff ff ff       	call   7c8c <readseg>
-    7d7a:	eb e4                	jmp    7d60 <bootmain+0x39>
+    7d66:	8b 4b e4             	mov    -0x1c(%ebx),%ecx
+    7d69:	8b 53 f4             	mov    -0xc(%ebx),%edx
+    7d6c:	25 ff ff ff 00       	and    $0xffffff,%eax
+    7d71:	e8 16 ff ff ff       	call   7c8c <readseg>
+    7d76:	eb e4                	jmp    7d5c <bootmain+0x39>
     }
 
     // call the entry point from the ELF header
     // note: does not return
     ((void (*)(void))(ELFHDR->e_entry & 0xFFFFFF))();
-    7d7c:	a1 18 00 01 00       	mov    0x10018,%eax
-    7d81:	25 ff ff ff 00       	and    $0xffffff,%eax
-    7d86:	ff d0                	call   *%eax
+    7d78:	a1 18 00 01 00       	mov    0x10018,%eax
+    7d7d:	25 ff ff ff 00       	and    $0xffffff,%eax
+    7d82:	ff d0                	call   *%eax
     asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
 }
 
 static inline void
 outw(uint16_t port, uint16_t data) {
     asm volatile ("outw %0, %1" :: "a" (data), "d" (port) : "memory");
-    7d88:	ba 00 8a ff ff       	mov    $0xffff8a00,%edx
-    7d8d:	89 d0                	mov    %edx,%eax
-    7d8f:	66 ef                	out    %ax,(%dx)
-    7d91:	b8 00 8e ff ff       	mov    $0xffff8e00,%eax
-    7d96:	66 ef                	out    %ax,(%dx)
-    7d98:	eb fe                	jmp    7d98 <bootmain+0x71>
+    7d84:	ba 00 8a ff ff       	mov    $0xffff8a00,%edx
+    7d89:	89 d0                	mov    %edx,%eax
+    7d8b:	66 ef                	out    %ax,(%dx)
+    7d8d:	b8 00 8e ff ff       	mov    $0xffff8e00,%eax
+    7d92:	66 ef                	out    %ax,(%dx)
+    7d94:	eb fe                	jmp    7d94 <bootmain+0x71>
Binary files labcodes_answer/lab3_result/obj/bootblock.o and labcodes/lab3/obj/bootblock.o differ
Binary files labcodes_answer/lab3_result/obj/bootblock.out and labcodes/lab3/obj/bootblock.out differ
Binary files labcodes_answer/lab3_result/obj/kern/debug/kdebug.o and labcodes/lab3/obj/kern/debug/kdebug.o differ
Binary files labcodes_answer/lab3_result/obj/kern/debug/kmonitor.o and labcodes/lab3/obj/kern/debug/kmonitor.o differ
Binary files labcodes_answer/lab3_result/obj/kern/debug/panic.o and labcodes/lab3/obj/kern/debug/panic.o differ
Binary files labcodes_answer/lab3_result/obj/kern/driver/clock.o and labcodes/lab3/obj/kern/driver/clock.o differ
Binary files labcodes_answer/lab3_result/obj/kern/driver/console.o and labcodes/lab3/obj/kern/driver/console.o differ
Binary files labcodes_answer/lab3_result/obj/kern/driver/ide.o and labcodes/lab3/obj/kern/driver/ide.o differ
Binary files labcodes_answer/lab3_result/obj/kern/driver/picirq.o and labcodes/lab3/obj/kern/driver/picirq.o differ
Binary files labcodes_answer/lab3_result/obj/kern/fs/swapfs.o and labcodes/lab3/obj/kern/fs/swapfs.o differ
Binary files labcodes_answer/lab3_result/obj/kern/init/entry.o and labcodes/lab3/obj/kern/init/entry.o differ
diff -r -uN labcodes_answer/lab3_result/obj/kern/init/init.d labcodes/lab3/obj/kern/init/init.d
--- labcodes_answer/lab3_result/obj/kern/init/init.d	2020-05-30 10:42:06.393373532 +0800
+++ labcodes/lab3/obj/kern/init/init.d	2020-05-30 16:42:21.498840327 +0800
@@ -4,4 +4,4 @@
  kern/driver/clock.h kern/driver/intr.h kern/mm/pmm.h kern/mm/mmu.h \
  kern/mm/memlayout.h libs/atomic.h libs/list.h kern/debug/assert.h \
  kern/mm/vmm.h kern/sync/sync.h libs/x86.h kern/driver/ide.h \
- kern/mm/swap.h
+ kern/mm/swap.h kern/debug/kmonitor.h
Binary files labcodes_answer/lab3_result/obj/kern/init/init.o and labcodes/lab3/obj/kern/init/init.o differ
Binary files labcodes_answer/lab3_result/obj/kern/libs/readline.o and labcodes/lab3/obj/kern/libs/readline.o differ
Binary files labcodes_answer/lab3_result/obj/kern/libs/stdio.o and labcodes/lab3/obj/kern/libs/stdio.o differ
Binary files labcodes_answer/lab3_result/obj/kern/mm/default_pmm.o and labcodes/lab3/obj/kern/mm/default_pmm.o differ
Binary files labcodes_answer/lab3_result/obj/kern/mm/pmm.o and labcodes/lab3/obj/kern/mm/pmm.o differ
Binary files labcodes_answer/lab3_result/obj/kern/mm/swap_fifo.o and labcodes/lab3/obj/kern/mm/swap_fifo.o differ
Binary files labcodes_answer/lab3_result/obj/kern/mm/swap.o and labcodes/lab3/obj/kern/mm/swap.o differ
Binary files labcodes_answer/lab3_result/obj/kern/mm/vmm.o and labcodes/lab3/obj/kern/mm/vmm.o differ
Binary files labcodes_answer/lab3_result/obj/kern/trap/trapentry.o and labcodes/lab3/obj/kern/trap/trapentry.o differ
Binary files labcodes_answer/lab3_result/obj/kern/trap/trap.o and labcodes/lab3/obj/kern/trap/trap.o differ
Binary files labcodes_answer/lab3_result/obj/kern/trap/vectors.o and labcodes/lab3/obj/kern/trap/vectors.o differ
diff -r -uN labcodes_answer/lab3_result/obj/kernel.asm labcodes/lab3/obj/kernel.asm
--- labcodes_answer/lab3_result/obj/kernel.asm	2020-05-30 10:42:06.581373717 +0800
+++ labcodes/lab3/obj/kernel.asm	2020-05-30 16:42:21.718840995 +0800
@@ -11,7 +11,7 @@
 kern_entry:
     # load pa of boot pgdir
     movl $REALLOC(__boot_pgdir), %eax
-c0100000:	b8 00 00 12 00       	mov    $0x120000,%eax
+c0100000:	b8 00 10 12 00       	mov    $0x121000,%eax
     movl %eax, %cr3
 c0100005:	0f 22 d8             	mov    %eax,%cr3
 
@@ -40,7 +40,7 @@
     xorl %eax, %eax
 c010001e:	31 c0                	xor    %eax,%eax
     movl %eax, __boot_pgdir
-c0100020:	a3 00 00 12 c0       	mov    %eax,0xc0120000
+c0100020:	a3 00 10 12 c0       	mov    %eax,0xc0121000
 
     # set ebp, esp
     movl $0x0, %ebp
@@ -48,7 +48,7 @@
     # the kernel stack region is from bootstack -- bootstacktop,
     # the kernel stack size is KSTACKSIZE (8KB)defined in memlayout.h
     movl $bootstacktop, %esp
-c010002a:	bc 00 f0 11 c0       	mov    $0xc011f000,%esp
+c010002a:	bc 00 00 12 c0       	mov    $0xc0120000,%esp
     # now kernel stack is ready , call the first C function
     call kern_init
 c010002f:	e8 02 00 00 00       	call   c0100036 <kern_init>
@@ -62,934 +62,896 @@
 
 c0100036 <kern_init>:
 int kern_init(void) __attribute__((noreturn));
-
+void grade_backtrace(void);
 static void lab1_switch_test(void);
 
 int
 kern_init(void) {
 c0100036:	55                   	push   %ebp
 c0100037:	89 e5                	mov    %esp,%ebp
-c0100039:	83 ec 18             	sub    $0x18,%esp
+c0100039:	83 ec 28             	sub    $0x28,%esp
     extern char edata[], end[];
     memset(edata, 0, end - edata);
-c010003c:	ba 18 31 12 c0       	mov    $0xc0123118,%edx
-c0100041:	b8 00 20 12 c0       	mov    $0xc0122000,%eax
+c010003c:	ba 18 41 12 c0       	mov    $0xc0124118,%edx
+c0100041:	b8 00 30 12 c0       	mov    $0xc0123000,%eax
 c0100046:	29 c2                	sub    %eax,%edx
 c0100048:	89 d0                	mov    %edx,%eax
-c010004a:	83 ec 04             	sub    $0x4,%esp
-c010004d:	50                   	push   %eax
-c010004e:	6a 00                	push   $0x0
-c0100050:	68 00 20 12 c0       	push   $0xc0122000
-c0100055:	e8 ae 7a 00 00       	call   c0107b08 <memset>
-c010005a:	83 c4 10             	add    $0x10,%esp
+c010004a:	89 44 24 08          	mov    %eax,0x8(%esp)
+c010004e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+c0100055:	00 
+c0100056:	c7 04 24 00 30 12 c0 	movl   $0xc0123000,(%esp)
+c010005d:	e8 7e 81 00 00       	call   c01081e0 <memset>
 
     cons_init();                // init the console
-c010005d:	e8 b1 1d 00 00       	call   c0101e13 <cons_init>
+c0100062:	e8 35 1d 00 00       	call   c0101d9c <cons_init>
 
     const char *message = "(THU.CST) os is loading ...";
-c0100062:	c7 45 f4 80 83 10 c0 	movl   $0xc0108380,-0xc(%ebp)
+c0100067:	c7 45 f4 c0 8a 10 c0 	movl   $0xc0108ac0,-0xc(%ebp)
     cprintf("%s\n\n", message);
-c0100069:	83 ec 08             	sub    $0x8,%esp
-c010006c:	ff 75 f4             	pushl  -0xc(%ebp)
-c010006f:	68 9c 83 10 c0       	push   $0xc010839c
-c0100074:	e8 09 02 00 00       	call   c0100282 <cprintf>
-c0100079:	83 c4 10             	add    $0x10,%esp
+c010006e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100071:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0100075:	c7 04 24 dc 8a 10 c0 	movl   $0xc0108adc,(%esp)
+c010007c:	e8 20 02 00 00       	call   c01002a1 <cprintf>
 
     print_kerninfo();
-c010007c:	e8 a0 08 00 00       	call   c0100921 <print_kerninfo>
+c0100081:	e8 c1 08 00 00       	call   c0100947 <print_kerninfo>
 
     grade_backtrace();
-c0100081:	e8 83 00 00 00       	call   c0100109 <grade_backtrace>
+c0100086:	e8 98 00 00 00       	call   c0100123 <grade_backtrace>
 
     pmm_init();                 // init physical memory management
-c0100086:	e8 30 3a 00 00       	call   c0103abb <pmm_init>
+c010008b:	e8 c4 38 00 00       	call   c0103954 <pmm_init>
 
     pic_init();                 // init interrupt controller
-c010008b:	e8 f5 1e 00 00       	call   c0101f85 <pic_init>
+c0100090:	e8 6b 1e 00 00       	call   c0101f00 <pic_init>
     idt_init();                 // init interrupt descriptor table
-c0100090:	e8 77 20 00 00       	call   c010210c <idt_init>
+c0100095:	e8 e9 1f 00 00       	call   c0102083 <idt_init>
 
     vmm_init();                 // init virtual memory management
-c0100095:	e8 70 4e 00 00       	call   c0104f0a <vmm_init>
+c010009a:	e8 d3 4f 00 00       	call   c0105072 <vmm_init>
 
     ide_init();                 // init ide devices
-c010009a:	e8 43 0d 00 00       	call   c0100de2 <ide_init>
+c010009f:	e8 9c 0c 00 00       	call   c0100d40 <ide_init>
     swap_init();                // init swap
-c010009f:	e8 61 57 00 00       	call   c0105805 <swap_init>
+c01000a4:	e8 c8 59 00 00       	call   c0105a71 <swap_init>
 
     clock_init();               // init clock interrupt
-c01000a4:	e8 11 15 00 00       	call   c01015ba <clock_init>
+c01000a9:	e8 a1 14 00 00       	call   c010154f <clock_init>
     intr_enable();              // enable irq interrupt
-c01000a9:	e8 14 20 00 00       	call   c01020c2 <intr_enable>
+c01000ae:	e8 80 1f 00 00       	call   c0102033 <intr_enable>
     //LAB1: CAHLLENGE 1 If you try to do it, uncomment lab1_switch_test()
     // user/kernel mode switch test
     //lab1_switch_test();
 
     /* do nothing */
     while (1);
-c01000ae:	eb fe                	jmp    c01000ae <kern_init+0x78>
+c01000b3:	eb fe                	jmp    c01000b3 <kern_init+0x7d>
 
-c01000b0 <grade_backtrace2>:
+c01000b5 <grade_backtrace2>:
 }
 
 void __attribute__((noinline))
 grade_backtrace2(int arg0, int arg1, int arg2, int arg3) {
-c01000b0:	55                   	push   %ebp
-c01000b1:	89 e5                	mov    %esp,%ebp
-c01000b3:	83 ec 08             	sub    $0x8,%esp
+c01000b5:	55                   	push   %ebp
+c01000b6:	89 e5                	mov    %esp,%ebp
+c01000b8:	83 ec 18             	sub    $0x18,%esp
     mon_backtrace(0, NULL, NULL);
-c01000b6:	83 ec 04             	sub    $0x4,%esp
-c01000b9:	6a 00                	push   $0x0
-c01000bb:	6a 00                	push   $0x0
-c01000bd:	6a 00                	push   $0x0
-c01000bf:	e8 b2 0c 00 00       	call   c0100d76 <mon_backtrace>
-c01000c4:	83 c4 10             	add    $0x10,%esp
-}
-c01000c7:	90                   	nop
-c01000c8:	c9                   	leave  
-c01000c9:	c3                   	ret    
+c01000bb:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+c01000c2:	00 
+c01000c3:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+c01000ca:	00 
+c01000cb:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+c01000d2:	e8 fe 0b 00 00       	call   c0100cd5 <mon_backtrace>
+}
+c01000d7:	90                   	nop
+c01000d8:	c9                   	leave  
+c01000d9:	c3                   	ret    
 
-c01000ca <grade_backtrace1>:
+c01000da <grade_backtrace1>:
 
 void __attribute__((noinline))
 grade_backtrace1(int arg0, int arg1) {
-c01000ca:	55                   	push   %ebp
-c01000cb:	89 e5                	mov    %esp,%ebp
-c01000cd:	53                   	push   %ebx
-c01000ce:	83 ec 04             	sub    $0x4,%esp
+c01000da:	55                   	push   %ebp
+c01000db:	89 e5                	mov    %esp,%ebp
+c01000dd:	53                   	push   %ebx
+c01000de:	83 ec 14             	sub    $0x14,%esp
     grade_backtrace2(arg0, (int)&arg0, arg1, (int)&arg1);
-c01000d1:	8d 4d 0c             	lea    0xc(%ebp),%ecx
-c01000d4:	8b 55 0c             	mov    0xc(%ebp),%edx
-c01000d7:	8d 5d 08             	lea    0x8(%ebp),%ebx
-c01000da:	8b 45 08             	mov    0x8(%ebp),%eax
-c01000dd:	51                   	push   %ecx
-c01000de:	52                   	push   %edx
-c01000df:	53                   	push   %ebx
-c01000e0:	50                   	push   %eax
-c01000e1:	e8 ca ff ff ff       	call   c01000b0 <grade_backtrace2>
-c01000e6:	83 c4 10             	add    $0x10,%esp
-}
-c01000e9:	90                   	nop
-c01000ea:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-c01000ed:	c9                   	leave  
-c01000ee:	c3                   	ret    
+c01000e1:	8d 4d 0c             	lea    0xc(%ebp),%ecx
+c01000e4:	8b 55 0c             	mov    0xc(%ebp),%edx
+c01000e7:	8d 5d 08             	lea    0x8(%ebp),%ebx
+c01000ea:	8b 45 08             	mov    0x8(%ebp),%eax
+c01000ed:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
+c01000f1:	89 54 24 08          	mov    %edx,0x8(%esp)
+c01000f5:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+c01000f9:	89 04 24             	mov    %eax,(%esp)
+c01000fc:	e8 b4 ff ff ff       	call   c01000b5 <grade_backtrace2>
+}
+c0100101:	90                   	nop
+c0100102:	83 c4 14             	add    $0x14,%esp
+c0100105:	5b                   	pop    %ebx
+c0100106:	5d                   	pop    %ebp
+c0100107:	c3                   	ret    
 
-c01000ef <grade_backtrace0>:
+c0100108 <grade_backtrace0>:
 
 void __attribute__((noinline))
 grade_backtrace0(int arg0, int arg1, int arg2) {
-c01000ef:	55                   	push   %ebp
-c01000f0:	89 e5                	mov    %esp,%ebp
-c01000f2:	83 ec 08             	sub    $0x8,%esp
+c0100108:	55                   	push   %ebp
+c0100109:	89 e5                	mov    %esp,%ebp
+c010010b:	83 ec 18             	sub    $0x18,%esp
     grade_backtrace1(arg0, arg2);
-c01000f5:	83 ec 08             	sub    $0x8,%esp
-c01000f8:	ff 75 10             	pushl  0x10(%ebp)
-c01000fb:	ff 75 08             	pushl  0x8(%ebp)
-c01000fe:	e8 c7 ff ff ff       	call   c01000ca <grade_backtrace1>
-c0100103:	83 c4 10             	add    $0x10,%esp
-}
-c0100106:	90                   	nop
-c0100107:	c9                   	leave  
-c0100108:	c3                   	ret    
+c010010e:	8b 45 10             	mov    0x10(%ebp),%eax
+c0100111:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0100115:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100118:	89 04 24             	mov    %eax,(%esp)
+c010011b:	e8 ba ff ff ff       	call   c01000da <grade_backtrace1>
+}
+c0100120:	90                   	nop
+c0100121:	c9                   	leave  
+c0100122:	c3                   	ret    
 
-c0100109 <grade_backtrace>:
+c0100123 <grade_backtrace>:
 
 void
 grade_backtrace(void) {
-c0100109:	55                   	push   %ebp
-c010010a:	89 e5                	mov    %esp,%ebp
-c010010c:	83 ec 08             	sub    $0x8,%esp
+c0100123:	55                   	push   %ebp
+c0100124:	89 e5                	mov    %esp,%ebp
+c0100126:	83 ec 18             	sub    $0x18,%esp
     grade_backtrace0(0, (int)kern_init, 0xffff0000);
-c010010f:	b8 36 00 10 c0       	mov    $0xc0100036,%eax
-c0100114:	83 ec 04             	sub    $0x4,%esp
-c0100117:	68 00 00 ff ff       	push   $0xffff0000
-c010011c:	50                   	push   %eax
-c010011d:	6a 00                	push   $0x0
-c010011f:	e8 cb ff ff ff       	call   c01000ef <grade_backtrace0>
-c0100124:	83 c4 10             	add    $0x10,%esp
-}
-c0100127:	90                   	nop
-c0100128:	c9                   	leave  
-c0100129:	c3                   	ret    
+c0100129:	b8 36 00 10 c0       	mov    $0xc0100036,%eax
+c010012e:	c7 44 24 08 00 00 ff 	movl   $0xffff0000,0x8(%esp)
+c0100135:	ff 
+c0100136:	89 44 24 04          	mov    %eax,0x4(%esp)
+c010013a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+c0100141:	e8 c2 ff ff ff       	call   c0100108 <grade_backtrace0>
+}
+c0100146:	90                   	nop
+c0100147:	c9                   	leave  
+c0100148:	c3                   	ret    
 
-c010012a <lab1_print_cur_status>:
+c0100149 <lab1_print_cur_status>:
 
 static void
 lab1_print_cur_status(void) {
-c010012a:	55                   	push   %ebp
-c010012b:	89 e5                	mov    %esp,%ebp
-c010012d:	83 ec 18             	sub    $0x18,%esp
+c0100149:	55                   	push   %ebp
+c010014a:	89 e5                	mov    %esp,%ebp
+c010014c:	83 ec 28             	sub    $0x28,%esp
     static int round = 0;
     uint16_t reg1, reg2, reg3, reg4;
     asm volatile (
-c0100130:	8c 4d f6             	mov    %cs,-0xa(%ebp)
-c0100133:	8c 5d f4             	mov    %ds,-0xc(%ebp)
-c0100136:	8c 45 f2             	mov    %es,-0xe(%ebp)
-c0100139:	8c 55 f0             	mov    %ss,-0x10(%ebp)
+c010014f:	8c 4d f6             	mov    %cs,-0xa(%ebp)
+c0100152:	8c 5d f4             	mov    %ds,-0xc(%ebp)
+c0100155:	8c 45 f2             	mov    %es,-0xe(%ebp)
+c0100158:	8c 55 f0             	mov    %ss,-0x10(%ebp)
             "mov %%cs, %0;"
             "mov %%ds, %1;"
             "mov %%es, %2;"
             "mov %%ss, %3;"
             : "=m"(reg1), "=m"(reg2), "=m"(reg3), "=m"(reg4));
     cprintf("%d: @ring %d\n", round, reg1 & 3);
-c010013c:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
-c0100140:	0f b7 c0             	movzwl %ax,%eax
-c0100143:	83 e0 03             	and    $0x3,%eax
-c0100146:	89 c2                	mov    %eax,%edx
-c0100148:	a1 00 20 12 c0       	mov    0xc0122000,%eax
-c010014d:	83 ec 04             	sub    $0x4,%esp
-c0100150:	52                   	push   %edx
-c0100151:	50                   	push   %eax
-c0100152:	68 a1 83 10 c0       	push   $0xc01083a1
-c0100157:	e8 26 01 00 00       	call   c0100282 <cprintf>
-c010015c:	83 c4 10             	add    $0x10,%esp
+c010015b:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
+c010015f:	83 e0 03             	and    $0x3,%eax
+c0100162:	89 c2                	mov    %eax,%edx
+c0100164:	a1 00 30 12 c0       	mov    0xc0123000,%eax
+c0100169:	89 54 24 08          	mov    %edx,0x8(%esp)
+c010016d:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0100171:	c7 04 24 e1 8a 10 c0 	movl   $0xc0108ae1,(%esp)
+c0100178:	e8 24 01 00 00       	call   c01002a1 <cprintf>
     cprintf("%d:  cs = %x\n", round, reg1);
-c010015f:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
-c0100163:	0f b7 d0             	movzwl %ax,%edx
-c0100166:	a1 00 20 12 c0       	mov    0xc0122000,%eax
-c010016b:	83 ec 04             	sub    $0x4,%esp
-c010016e:	52                   	push   %edx
-c010016f:	50                   	push   %eax
-c0100170:	68 af 83 10 c0       	push   $0xc01083af
-c0100175:	e8 08 01 00 00       	call   c0100282 <cprintf>
-c010017a:	83 c4 10             	add    $0x10,%esp
+c010017d:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
+c0100181:	89 c2                	mov    %eax,%edx
+c0100183:	a1 00 30 12 c0       	mov    0xc0123000,%eax
+c0100188:	89 54 24 08          	mov    %edx,0x8(%esp)
+c010018c:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0100190:	c7 04 24 ef 8a 10 c0 	movl   $0xc0108aef,(%esp)
+c0100197:	e8 05 01 00 00       	call   c01002a1 <cprintf>
     cprintf("%d:  ds = %x\n", round, reg2);
-c010017d:	0f b7 45 f4          	movzwl -0xc(%ebp),%eax
-c0100181:	0f b7 d0             	movzwl %ax,%edx
-c0100184:	a1 00 20 12 c0       	mov    0xc0122000,%eax
-c0100189:	83 ec 04             	sub    $0x4,%esp
-c010018c:	52                   	push   %edx
-c010018d:	50                   	push   %eax
-c010018e:	68 bd 83 10 c0       	push   $0xc01083bd
-c0100193:	e8 ea 00 00 00       	call   c0100282 <cprintf>
-c0100198:	83 c4 10             	add    $0x10,%esp
+c010019c:	0f b7 45 f4          	movzwl -0xc(%ebp),%eax
+c01001a0:	89 c2                	mov    %eax,%edx
+c01001a2:	a1 00 30 12 c0       	mov    0xc0123000,%eax
+c01001a7:	89 54 24 08          	mov    %edx,0x8(%esp)
+c01001ab:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01001af:	c7 04 24 fd 8a 10 c0 	movl   $0xc0108afd,(%esp)
+c01001b6:	e8 e6 00 00 00       	call   c01002a1 <cprintf>
     cprintf("%d:  es = %x\n", round, reg3);
-c010019b:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
-c010019f:	0f b7 d0             	movzwl %ax,%edx
-c01001a2:	a1 00 20 12 c0       	mov    0xc0122000,%eax
-c01001a7:	83 ec 04             	sub    $0x4,%esp
-c01001aa:	52                   	push   %edx
-c01001ab:	50                   	push   %eax
-c01001ac:	68 cb 83 10 c0       	push   $0xc01083cb
-c01001b1:	e8 cc 00 00 00       	call   c0100282 <cprintf>
-c01001b6:	83 c4 10             	add    $0x10,%esp
+c01001bb:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
+c01001bf:	89 c2                	mov    %eax,%edx
+c01001c1:	a1 00 30 12 c0       	mov    0xc0123000,%eax
+c01001c6:	89 54 24 08          	mov    %edx,0x8(%esp)
+c01001ca:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01001ce:	c7 04 24 0b 8b 10 c0 	movl   $0xc0108b0b,(%esp)
+c01001d5:	e8 c7 00 00 00       	call   c01002a1 <cprintf>
     cprintf("%d:  ss = %x\n", round, reg4);
-c01001b9:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
-c01001bd:	0f b7 d0             	movzwl %ax,%edx
-c01001c0:	a1 00 20 12 c0       	mov    0xc0122000,%eax
-c01001c5:	83 ec 04             	sub    $0x4,%esp
-c01001c8:	52                   	push   %edx
-c01001c9:	50                   	push   %eax
-c01001ca:	68 d9 83 10 c0       	push   $0xc01083d9
-c01001cf:	e8 ae 00 00 00       	call   c0100282 <cprintf>
-c01001d4:	83 c4 10             	add    $0x10,%esp
+c01001da:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
+c01001de:	89 c2                	mov    %eax,%edx
+c01001e0:	a1 00 30 12 c0       	mov    0xc0123000,%eax
+c01001e5:	89 54 24 08          	mov    %edx,0x8(%esp)
+c01001e9:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01001ed:	c7 04 24 19 8b 10 c0 	movl   $0xc0108b19,(%esp)
+c01001f4:	e8 a8 00 00 00       	call   c01002a1 <cprintf>
     round ++;
-c01001d7:	a1 00 20 12 c0       	mov    0xc0122000,%eax
-c01001dc:	83 c0 01             	add    $0x1,%eax
-c01001df:	a3 00 20 12 c0       	mov    %eax,0xc0122000
-}
-c01001e4:	90                   	nop
-c01001e5:	c9                   	leave  
-c01001e6:	c3                   	ret    
+c01001f9:	a1 00 30 12 c0       	mov    0xc0123000,%eax
+c01001fe:	40                   	inc    %eax
+c01001ff:	a3 00 30 12 c0       	mov    %eax,0xc0123000
+}
+c0100204:	90                   	nop
+c0100205:	c9                   	leave  
+c0100206:	c3                   	ret    
 
-c01001e7 <lab1_switch_to_user>:
+c0100207 <lab1_switch_to_user>:
 
 static void
 lab1_switch_to_user(void) {
-c01001e7:	55                   	push   %ebp
-c01001e8:	89 e5                	mov    %esp,%ebp
+c0100207:	55                   	push   %ebp
+c0100208:	89 e5                	mov    %esp,%ebp
     //LAB1 CHALLENGE 1 : TODO
 }
-c01001ea:	90                   	nop
-c01001eb:	5d                   	pop    %ebp
-c01001ec:	c3                   	ret    
+c010020a:	90                   	nop
+c010020b:	5d                   	pop    %ebp
+c010020c:	c3                   	ret    
 
-c01001ed <lab1_switch_to_kernel>:
+c010020d <lab1_switch_to_kernel>:
 
 static void
 lab1_switch_to_kernel(void) {
-c01001ed:	55                   	push   %ebp
-c01001ee:	89 e5                	mov    %esp,%ebp
+c010020d:	55                   	push   %ebp
+c010020e:	89 e5                	mov    %esp,%ebp
     //LAB1 CHALLENGE 1 :  TODO
 }
-c01001f0:	90                   	nop
-c01001f1:	5d                   	pop    %ebp
-c01001f2:	c3                   	ret    
+c0100210:	90                   	nop
+c0100211:	5d                   	pop    %ebp
+c0100212:	c3                   	ret    
 
-c01001f3 <lab1_switch_test>:
+c0100213 <lab1_switch_test>:
 
 static void
 lab1_switch_test(void) {
-c01001f3:	55                   	push   %ebp
-c01001f4:	89 e5                	mov    %esp,%ebp
-c01001f6:	83 ec 08             	sub    $0x8,%esp
+c0100213:	55                   	push   %ebp
+c0100214:	89 e5                	mov    %esp,%ebp
+c0100216:	83 ec 18             	sub    $0x18,%esp
     lab1_print_cur_status();
-c01001f9:	e8 2c ff ff ff       	call   c010012a <lab1_print_cur_status>
+c0100219:	e8 2b ff ff ff       	call   c0100149 <lab1_print_cur_status>
     cprintf("+++ switch to  user  mode +++\n");
-c01001fe:	83 ec 0c             	sub    $0xc,%esp
-c0100201:	68 e8 83 10 c0       	push   $0xc01083e8
-c0100206:	e8 77 00 00 00       	call   c0100282 <cprintf>
-c010020b:	83 c4 10             	add    $0x10,%esp
+c010021e:	c7 04 24 28 8b 10 c0 	movl   $0xc0108b28,(%esp)
+c0100225:	e8 77 00 00 00       	call   c01002a1 <cprintf>
     lab1_switch_to_user();
-c010020e:	e8 d4 ff ff ff       	call   c01001e7 <lab1_switch_to_user>
+c010022a:	e8 d8 ff ff ff       	call   c0100207 <lab1_switch_to_user>
     lab1_print_cur_status();
-c0100213:	e8 12 ff ff ff       	call   c010012a <lab1_print_cur_status>
+c010022f:	e8 15 ff ff ff       	call   c0100149 <lab1_print_cur_status>
     cprintf("+++ switch to kernel mode +++\n");
-c0100218:	83 ec 0c             	sub    $0xc,%esp
-c010021b:	68 08 84 10 c0       	push   $0xc0108408
-c0100220:	e8 5d 00 00 00       	call   c0100282 <cprintf>
-c0100225:	83 c4 10             	add    $0x10,%esp
+c0100234:	c7 04 24 48 8b 10 c0 	movl   $0xc0108b48,(%esp)
+c010023b:	e8 61 00 00 00       	call   c01002a1 <cprintf>
     lab1_switch_to_kernel();
-c0100228:	e8 c0 ff ff ff       	call   c01001ed <lab1_switch_to_kernel>
+c0100240:	e8 c8 ff ff ff       	call   c010020d <lab1_switch_to_kernel>
     lab1_print_cur_status();
-c010022d:	e8 f8 fe ff ff       	call   c010012a <lab1_print_cur_status>
+c0100245:	e8 ff fe ff ff       	call   c0100149 <lab1_print_cur_status>
 }
-c0100232:	90                   	nop
-c0100233:	c9                   	leave  
-c0100234:	c3                   	ret    
+c010024a:	90                   	nop
+c010024b:	c9                   	leave  
+c010024c:	c3                   	ret    
 
-c0100235 <cputch>:
+c010024d <cputch>:
 /* *
  * cputch - writes a single character @c to stdout, and it will
  * increace the value of counter pointed by @cnt.
  * */
 static void
 cputch(int c, int *cnt) {
-c0100235:	55                   	push   %ebp
-c0100236:	89 e5                	mov    %esp,%ebp
-c0100238:	83 ec 08             	sub    $0x8,%esp
+c010024d:	55                   	push   %ebp
+c010024e:	89 e5                	mov    %esp,%ebp
+c0100250:	83 ec 18             	sub    $0x18,%esp
     cons_putc(c);
-c010023b:	83 ec 0c             	sub    $0xc,%esp
-c010023e:	ff 75 08             	pushl  0x8(%ebp)
-c0100241:	e8 fe 1b 00 00       	call   c0101e44 <cons_putc>
-c0100246:	83 c4 10             	add    $0x10,%esp
+c0100253:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100256:	89 04 24             	mov    %eax,(%esp)
+c0100259:	e8 6b 1b 00 00       	call   c0101dc9 <cons_putc>
     (*cnt) ++;
-c0100249:	8b 45 0c             	mov    0xc(%ebp),%eax
-c010024c:	8b 00                	mov    (%eax),%eax
-c010024e:	8d 50 01             	lea    0x1(%eax),%edx
-c0100251:	8b 45 0c             	mov    0xc(%ebp),%eax
-c0100254:	89 10                	mov    %edx,(%eax)
-}
-c0100256:	90                   	nop
-c0100257:	c9                   	leave  
-c0100258:	c3                   	ret    
+c010025e:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0100261:	8b 00                	mov    (%eax),%eax
+c0100263:	8d 50 01             	lea    0x1(%eax),%edx
+c0100266:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0100269:	89 10                	mov    %edx,(%eax)
+}
+c010026b:	90                   	nop
+c010026c:	c9                   	leave  
+c010026d:	c3                   	ret    
 
-c0100259 <vcprintf>:
+c010026e <vcprintf>:
  *
  * Call this function if you are already dealing with a va_list.
  * Or you probably want cprintf() instead.
  * */
 int
 vcprintf(const char *fmt, va_list ap) {
-c0100259:	55                   	push   %ebp
-c010025a:	89 e5                	mov    %esp,%ebp
-c010025c:	83 ec 18             	sub    $0x18,%esp
+c010026e:	55                   	push   %ebp
+c010026f:	89 e5                	mov    %esp,%ebp
+c0100271:	83 ec 28             	sub    $0x28,%esp
     int cnt = 0;
-c010025f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+c0100274:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     vprintfmt((void*)cputch, &cnt, fmt, ap);
-c0100266:	ff 75 0c             	pushl  0xc(%ebp)
-c0100269:	ff 75 08             	pushl  0x8(%ebp)
-c010026c:	8d 45 f4             	lea    -0xc(%ebp),%eax
-c010026f:	50                   	push   %eax
-c0100270:	68 35 02 10 c0       	push   $0xc0100235
-c0100275:	e8 c4 7b 00 00       	call   c0107e3e <vprintfmt>
-c010027a:	83 c4 10             	add    $0x10,%esp
+c010027b:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010027e:	89 44 24 0c          	mov    %eax,0xc(%esp)
+c0100282:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100285:	89 44 24 08          	mov    %eax,0x8(%esp)
+c0100289:	8d 45 f4             	lea    -0xc(%ebp),%eax
+c010028c:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0100290:	c7 04 24 4d 02 10 c0 	movl   $0xc010024d,(%esp)
+c0100297:	e8 97 82 00 00       	call   c0108533 <vprintfmt>
     return cnt;
-c010027d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010029c:	8b 45 f4             	mov    -0xc(%ebp),%eax
 }
-c0100280:	c9                   	leave  
-c0100281:	c3                   	ret    
+c010029f:	c9                   	leave  
+c01002a0:	c3                   	ret    
 
-c0100282 <cprintf>:
+c01002a1 <cprintf>:
  *
  * The return value is the number of characters which would be
  * written to stdout.
  * */
 int
 cprintf(const char *fmt, ...) {
-c0100282:	55                   	push   %ebp
-c0100283:	89 e5                	mov    %esp,%ebp
-c0100285:	83 ec 18             	sub    $0x18,%esp
+c01002a1:	55                   	push   %ebp
+c01002a2:	89 e5                	mov    %esp,%ebp
+c01002a4:	83 ec 28             	sub    $0x28,%esp
     va_list ap;
     int cnt;
     va_start(ap, fmt);
-c0100288:	8d 45 0c             	lea    0xc(%ebp),%eax
-c010028b:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c01002a7:	8d 45 0c             	lea    0xc(%ebp),%eax
+c01002aa:	89 45 f0             	mov    %eax,-0x10(%ebp)
     cnt = vcprintf(fmt, ap);
-c010028e:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0100291:	83 ec 08             	sub    $0x8,%esp
-c0100294:	50                   	push   %eax
-c0100295:	ff 75 08             	pushl  0x8(%ebp)
-c0100298:	e8 bc ff ff ff       	call   c0100259 <vcprintf>
-c010029d:	83 c4 10             	add    $0x10,%esp
-c01002a0:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c01002ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01002b0:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01002b4:	8b 45 08             	mov    0x8(%ebp),%eax
+c01002b7:	89 04 24             	mov    %eax,(%esp)
+c01002ba:	e8 af ff ff ff       	call   c010026e <vcprintf>
+c01002bf:	89 45 f4             	mov    %eax,-0xc(%ebp)
     va_end(ap);
     return cnt;
-c01002a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01002c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
 }
-c01002a6:	c9                   	leave  
-c01002a7:	c3                   	ret    
+c01002c5:	c9                   	leave  
+c01002c6:	c3                   	ret    
 
-c01002a8 <cputchar>:
+c01002c7 <cputchar>:
 
 /* cputchar - writes a single character to stdout */
 void
 cputchar(int c) {
-c01002a8:	55                   	push   %ebp
-c01002a9:	89 e5                	mov    %esp,%ebp
-c01002ab:	83 ec 08             	sub    $0x8,%esp
+c01002c7:	55                   	push   %ebp
+c01002c8:	89 e5                	mov    %esp,%ebp
+c01002ca:	83 ec 18             	sub    $0x18,%esp
     cons_putc(c);
-c01002ae:	83 ec 0c             	sub    $0xc,%esp
-c01002b1:	ff 75 08             	pushl  0x8(%ebp)
-c01002b4:	e8 8b 1b 00 00       	call   c0101e44 <cons_putc>
-c01002b9:	83 c4 10             	add    $0x10,%esp
-}
-c01002bc:	90                   	nop
-c01002bd:	c9                   	leave  
-c01002be:	c3                   	ret    
+c01002cd:	8b 45 08             	mov    0x8(%ebp),%eax
+c01002d0:	89 04 24             	mov    %eax,(%esp)
+c01002d3:	e8 f1 1a 00 00       	call   c0101dc9 <cons_putc>
+}
+c01002d8:	90                   	nop
+c01002d9:	c9                   	leave  
+c01002da:	c3                   	ret    
 
-c01002bf <cputs>:
+c01002db <cputs>:
 /* *
  * cputs- writes the string pointed by @str to stdout and
  * appends a newline character.
  * */
 int
 cputs(const char *str) {
-c01002bf:	55                   	push   %ebp
-c01002c0:	89 e5                	mov    %esp,%ebp
-c01002c2:	83 ec 18             	sub    $0x18,%esp
+c01002db:	55                   	push   %ebp
+c01002dc:	89 e5                	mov    %esp,%ebp
+c01002de:	83 ec 28             	sub    $0x28,%esp
     int cnt = 0;
-c01002c5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+c01002e1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
     char c;
     while ((c = *str ++) != '\0') {
-c01002cc:	eb 14                	jmp    c01002e2 <cputs+0x23>
+c01002e8:	eb 13                	jmp    c01002fd <cputs+0x22>
         cputch(c, &cnt);
-c01002ce:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
-c01002d2:	83 ec 08             	sub    $0x8,%esp
-c01002d5:	8d 55 f0             	lea    -0x10(%ebp),%edx
-c01002d8:	52                   	push   %edx
-c01002d9:	50                   	push   %eax
-c01002da:	e8 56 ff ff ff       	call   c0100235 <cputch>
-c01002df:	83 c4 10             	add    $0x10,%esp
+c01002ea:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
+c01002ee:	8d 55 f0             	lea    -0x10(%ebp),%edx
+c01002f1:	89 54 24 04          	mov    %edx,0x4(%esp)
+c01002f5:	89 04 24             	mov    %eax,(%esp)
+c01002f8:	e8 50 ff ff ff       	call   c010024d <cputch>
  * */
 int
 cputs(const char *str) {
     int cnt = 0;
     char c;
     while ((c = *str ++) != '\0') {
-c01002e2:	8b 45 08             	mov    0x8(%ebp),%eax
-c01002e5:	8d 50 01             	lea    0x1(%eax),%edx
-c01002e8:	89 55 08             	mov    %edx,0x8(%ebp)
-c01002eb:	0f b6 00             	movzbl (%eax),%eax
-c01002ee:	88 45 f7             	mov    %al,-0x9(%ebp)
-c01002f1:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
-c01002f5:	75 d7                	jne    c01002ce <cputs+0xf>
+c01002fd:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100300:	8d 50 01             	lea    0x1(%eax),%edx
+c0100303:	89 55 08             	mov    %edx,0x8(%ebp)
+c0100306:	0f b6 00             	movzbl (%eax),%eax
+c0100309:	88 45 f7             	mov    %al,-0x9(%ebp)
+c010030c:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
+c0100310:	75 d8                	jne    c01002ea <cputs+0xf>
         cputch(c, &cnt);
     }
     cputch('\n', &cnt);
-c01002f7:	83 ec 08             	sub    $0x8,%esp
-c01002fa:	8d 45 f0             	lea    -0x10(%ebp),%eax
-c01002fd:	50                   	push   %eax
-c01002fe:	6a 0a                	push   $0xa
-c0100300:	e8 30 ff ff ff       	call   c0100235 <cputch>
-c0100305:	83 c4 10             	add    $0x10,%esp
+c0100312:	8d 45 f0             	lea    -0x10(%ebp),%eax
+c0100315:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0100319:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
+c0100320:	e8 28 ff ff ff       	call   c010024d <cputch>
     return cnt;
-c0100308:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0100325:	8b 45 f0             	mov    -0x10(%ebp),%eax
 }
-c010030b:	c9                   	leave  
-c010030c:	c3                   	ret    
+c0100328:	c9                   	leave  
+c0100329:	c3                   	ret    
 
-c010030d <getchar>:
+c010032a <getchar>:
 
 /* getchar - reads a single non-zero character from stdin */
 int
 getchar(void) {
-c010030d:	55                   	push   %ebp
-c010030e:	89 e5                	mov    %esp,%ebp
-c0100310:	83 ec 18             	sub    $0x18,%esp
+c010032a:	55                   	push   %ebp
+c010032b:	89 e5                	mov    %esp,%ebp
+c010032d:	83 ec 18             	sub    $0x18,%esp
     int c;
     while ((c = cons_getc()) == 0)
-c0100313:	e8 75 1b 00 00       	call   c0101e8d <cons_getc>
-c0100318:	89 45 f4             	mov    %eax,-0xc(%ebp)
-c010031b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
-c010031f:	74 f2                	je     c0100313 <getchar+0x6>
+c0100330:	e8 d1 1a 00 00       	call   c0101e06 <cons_getc>
+c0100335:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0100338:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c010033c:	74 f2                	je     c0100330 <getchar+0x6>
         /* do nothing */;
     return c;
-c0100321:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010033e:	8b 45 f4             	mov    -0xc(%ebp),%eax
 }
-c0100324:	c9                   	leave  
-c0100325:	c3                   	ret    
+c0100341:	c9                   	leave  
+c0100342:	c3                   	ret    
 
-c0100326 <readline>:
+c0100343 <readline>:
  * The readline() function returns the text of the line read. If some errors
  * are happened, NULL is returned. The return value is a global variable,
  * thus it should be copied before it is used.
  * */
 char *
 readline(const char *prompt) {
-c0100326:	55                   	push   %ebp
-c0100327:	89 e5                	mov    %esp,%ebp
-c0100329:	83 ec 18             	sub    $0x18,%esp
+c0100343:	55                   	push   %ebp
+c0100344:	89 e5                	mov    %esp,%ebp
+c0100346:	83 ec 28             	sub    $0x28,%esp
     if (prompt != NULL) {
-c010032c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
-c0100330:	74 13                	je     c0100345 <readline+0x1f>
+c0100349:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+c010034d:	74 13                	je     c0100362 <readline+0x1f>
         cprintf("%s", prompt);
-c0100332:	83 ec 08             	sub    $0x8,%esp
-c0100335:	ff 75 08             	pushl  0x8(%ebp)
-c0100338:	68 27 84 10 c0       	push   $0xc0108427
-c010033d:	e8 40 ff ff ff       	call   c0100282 <cprintf>
-c0100342:	83 c4 10             	add    $0x10,%esp
+c010034f:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100352:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0100356:	c7 04 24 67 8b 10 c0 	movl   $0xc0108b67,(%esp)
+c010035d:	e8 3f ff ff ff       	call   c01002a1 <cprintf>
     }
     int i = 0, c;
-c0100345:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+c0100362:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     while (1) {
         c = getchar();
-c010034c:	e8 bc ff ff ff       	call   c010030d <getchar>
-c0100351:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0100369:	e8 bc ff ff ff       	call   c010032a <getchar>
+c010036e:	89 45 f0             	mov    %eax,-0x10(%ebp)
         if (c < 0) {
-c0100354:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
-c0100358:	79 0a                	jns    c0100364 <readline+0x3e>
+c0100371:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c0100375:	79 07                	jns    c010037e <readline+0x3b>
             return NULL;
-c010035a:	b8 00 00 00 00       	mov    $0x0,%eax
-c010035f:	e9 82 00 00 00       	jmp    c01003e6 <readline+0xc0>
+c0100377:	b8 00 00 00 00       	mov    $0x0,%eax
+c010037c:	eb 78                	jmp    c01003f6 <readline+0xb3>
         }
         else if (c >= ' ' && i < BUFSIZE - 1) {
-c0100364:	83 7d f0 1f          	cmpl   $0x1f,-0x10(%ebp)
-c0100368:	7e 2b                	jle    c0100395 <readline+0x6f>
-c010036a:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
-c0100371:	7f 22                	jg     c0100395 <readline+0x6f>
+c010037e:	83 7d f0 1f          	cmpl   $0x1f,-0x10(%ebp)
+c0100382:	7e 28                	jle    c01003ac <readline+0x69>
+c0100384:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
+c010038b:	7f 1f                	jg     c01003ac <readline+0x69>
             cputchar(c);
-c0100373:	83 ec 0c             	sub    $0xc,%esp
-c0100376:	ff 75 f0             	pushl  -0x10(%ebp)
-c0100379:	e8 2a ff ff ff       	call   c01002a8 <cputchar>
-c010037e:	83 c4 10             	add    $0x10,%esp
+c010038d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0100390:	89 04 24             	mov    %eax,(%esp)
+c0100393:	e8 2f ff ff ff       	call   c01002c7 <cputchar>
             buf[i ++] = c;
-c0100381:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0100384:	8d 50 01             	lea    0x1(%eax),%edx
-c0100387:	89 55 f4             	mov    %edx,-0xc(%ebp)
-c010038a:	8b 55 f0             	mov    -0x10(%ebp),%edx
-c010038d:	88 90 20 20 12 c0    	mov    %dl,-0x3feddfe0(%eax)
-c0100393:	eb 4c                	jmp    c01003e1 <readline+0xbb>
+c0100398:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010039b:	8d 50 01             	lea    0x1(%eax),%edx
+c010039e:	89 55 f4             	mov    %edx,-0xc(%ebp)
+c01003a1:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c01003a4:	88 90 20 30 12 c0    	mov    %dl,-0x3fedcfe0(%eax)
+c01003aa:	eb 45                	jmp    c01003f1 <readline+0xae>
         }
         else if (c == '\b' && i > 0) {
-c0100395:	83 7d f0 08          	cmpl   $0x8,-0x10(%ebp)
-c0100399:	75 1a                	jne    c01003b5 <readline+0x8f>
-c010039b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
-c010039f:	7e 14                	jle    c01003b5 <readline+0x8f>
+c01003ac:	83 7d f0 08          	cmpl   $0x8,-0x10(%ebp)
+c01003b0:	75 16                	jne    c01003c8 <readline+0x85>
+c01003b2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c01003b6:	7e 10                	jle    c01003c8 <readline+0x85>
             cputchar(c);
-c01003a1:	83 ec 0c             	sub    $0xc,%esp
-c01003a4:	ff 75 f0             	pushl  -0x10(%ebp)
-c01003a7:	e8 fc fe ff ff       	call   c01002a8 <cputchar>
-c01003ac:	83 c4 10             	add    $0x10,%esp
+c01003b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01003bb:	89 04 24             	mov    %eax,(%esp)
+c01003be:	e8 04 ff ff ff       	call   c01002c7 <cputchar>
             i --;
-c01003af:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
-c01003b3:	eb 2c                	jmp    c01003e1 <readline+0xbb>
+c01003c3:	ff 4d f4             	decl   -0xc(%ebp)
+c01003c6:	eb 29                	jmp    c01003f1 <readline+0xae>
         }
         else if (c == '\n' || c == '\r') {
-c01003b5:	83 7d f0 0a          	cmpl   $0xa,-0x10(%ebp)
-c01003b9:	74 06                	je     c01003c1 <readline+0x9b>
-c01003bb:	83 7d f0 0d          	cmpl   $0xd,-0x10(%ebp)
-c01003bf:	75 8b                	jne    c010034c <readline+0x26>
+c01003c8:	83 7d f0 0a          	cmpl   $0xa,-0x10(%ebp)
+c01003cc:	74 06                	je     c01003d4 <readline+0x91>
+c01003ce:	83 7d f0 0d          	cmpl   $0xd,-0x10(%ebp)
+c01003d2:	75 95                	jne    c0100369 <readline+0x26>
             cputchar(c);
-c01003c1:	83 ec 0c             	sub    $0xc,%esp
-c01003c4:	ff 75 f0             	pushl  -0x10(%ebp)
-c01003c7:	e8 dc fe ff ff       	call   c01002a8 <cputchar>
-c01003cc:	83 c4 10             	add    $0x10,%esp
+c01003d4:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01003d7:	89 04 24             	mov    %eax,(%esp)
+c01003da:	e8 e8 fe ff ff       	call   c01002c7 <cputchar>
             buf[i] = '\0';
-c01003cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c01003d2:	05 20 20 12 c0       	add    $0xc0122020,%eax
-c01003d7:	c6 00 00             	movb   $0x0,(%eax)
+c01003df:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01003e2:	05 20 30 12 c0       	add    $0xc0123020,%eax
+c01003e7:	c6 00 00             	movb   $0x0,(%eax)
             return buf;
-c01003da:	b8 20 20 12 c0       	mov    $0xc0122020,%eax
-c01003df:	eb 05                	jmp    c01003e6 <readline+0xc0>
+c01003ea:	b8 20 30 12 c0       	mov    $0xc0123020,%eax
+c01003ef:	eb 05                	jmp    c01003f6 <readline+0xb3>
         }
     }
-c01003e1:	e9 66 ff ff ff       	jmp    c010034c <readline+0x26>
+c01003f1:	e9 73 ff ff ff       	jmp    c0100369 <readline+0x26>
 }
-c01003e6:	c9                   	leave  
-c01003e7:	c3                   	ret    
+c01003f6:	c9                   	leave  
+c01003f7:	c3                   	ret    
 
-c01003e8 <__panic>:
+c01003f8 <__panic>:
 /* *
  * __panic - __panic is called on unresolvable fatal errors. it prints
  * "panic: 'message'", and then enters the kernel monitor.
  * */
 void
 __panic(const char *file, int line, const char *fmt, ...) {
-c01003e8:	55                   	push   %ebp
-c01003e9:	89 e5                	mov    %esp,%ebp
-c01003eb:	83 ec 18             	sub    $0x18,%esp
+c01003f8:	55                   	push   %ebp
+c01003f9:	89 e5                	mov    %esp,%ebp
+c01003fb:	83 ec 28             	sub    $0x28,%esp
     if (is_panic) {
-c01003ee:	a1 20 24 12 c0       	mov    0xc0122420,%eax
-c01003f3:	85 c0                	test   %eax,%eax
-c01003f5:	75 5f                	jne    c0100456 <__panic+0x6e>
+c01003fe:	a1 20 34 12 c0       	mov    0xc0123420,%eax
+c0100403:	85 c0                	test   %eax,%eax
+c0100405:	75 5b                	jne    c0100462 <__panic+0x6a>
         goto panic_dead;
     }
     is_panic = 1;
-c01003f7:	c7 05 20 24 12 c0 01 	movl   $0x1,0xc0122420
-c01003fe:	00 00 00 
+c0100407:	c7 05 20 34 12 c0 01 	movl   $0x1,0xc0123420
+c010040e:	00 00 00 
 
     // print the 'message'
     va_list ap;
     va_start(ap, fmt);
-c0100401:	8d 45 14             	lea    0x14(%ebp),%eax
-c0100404:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0100411:	8d 45 14             	lea    0x14(%ebp),%eax
+c0100414:	89 45 f4             	mov    %eax,-0xc(%ebp)
     cprintf("kernel panic at %s:%d:\n    ", file, line);
-c0100407:	83 ec 04             	sub    $0x4,%esp
-c010040a:	ff 75 0c             	pushl  0xc(%ebp)
-c010040d:	ff 75 08             	pushl  0x8(%ebp)
-c0100410:	68 2a 84 10 c0       	push   $0xc010842a
-c0100415:	e8 68 fe ff ff       	call   c0100282 <cprintf>
-c010041a:	83 c4 10             	add    $0x10,%esp
+c0100417:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010041a:	89 44 24 08          	mov    %eax,0x8(%esp)
+c010041e:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100421:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0100425:	c7 04 24 6a 8b 10 c0 	movl   $0xc0108b6a,(%esp)
+c010042c:	e8 70 fe ff ff       	call   c01002a1 <cprintf>
     vcprintf(fmt, ap);
-c010041d:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0100420:	83 ec 08             	sub    $0x8,%esp
-c0100423:	50                   	push   %eax
-c0100424:	ff 75 10             	pushl  0x10(%ebp)
-c0100427:	e8 2d fe ff ff       	call   c0100259 <vcprintf>
-c010042c:	83 c4 10             	add    $0x10,%esp
+c0100431:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100434:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0100438:	8b 45 10             	mov    0x10(%ebp),%eax
+c010043b:	89 04 24             	mov    %eax,(%esp)
+c010043e:	e8 2b fe ff ff       	call   c010026e <vcprintf>
     cprintf("\n");
-c010042f:	83 ec 0c             	sub    $0xc,%esp
-c0100432:	68 46 84 10 c0       	push   $0xc0108446
-c0100437:	e8 46 fe ff ff       	call   c0100282 <cprintf>
-c010043c:	83 c4 10             	add    $0x10,%esp
+c0100443:	c7 04 24 86 8b 10 c0 	movl   $0xc0108b86,(%esp)
+c010044a:	e8 52 fe ff ff       	call   c01002a1 <cprintf>
     
     cprintf("stack trackback:\n");
-c010043f:	83 ec 0c             	sub    $0xc,%esp
-c0100442:	68 48 84 10 c0       	push   $0xc0108448
-c0100447:	e8 36 fe ff ff       	call   c0100282 <cprintf>
-c010044c:	83 c4 10             	add    $0x10,%esp
+c010044f:	c7 04 24 88 8b 10 c0 	movl   $0xc0108b88,(%esp)
+c0100456:	e8 46 fe ff ff       	call   c01002a1 <cprintf>
     print_stackframe();
-c010044f:	e8 17 06 00 00       	call   c0100a6b <print_stackframe>
-c0100454:	eb 01                	jmp    c0100457 <__panic+0x6f>
+c010045b:	e8 32 06 00 00       	call   c0100a92 <print_stackframe>
+c0100460:	eb 01                	jmp    c0100463 <__panic+0x6b>
  * "panic: 'message'", and then enters the kernel monitor.
  * */
 void
 __panic(const char *file, int line, const char *fmt, ...) {
     if (is_panic) {
         goto panic_dead;
-c0100456:	90                   	nop
+c0100462:	90                   	nop
     print_stackframe();
     
     va_end(ap);
 
 panic_dead:
     intr_disable();
-c0100457:	e8 6d 1c 00 00       	call   c01020c9 <intr_disable>
+c0100463:	e8 d2 1b 00 00       	call   c010203a <intr_disable>
     while (1) {
         kmonitor(NULL);
-c010045c:	83 ec 0c             	sub    $0xc,%esp
-c010045f:	6a 00                	push   $0x0
-c0100461:	e8 36 08 00 00       	call   c0100c9c <kmonitor>
-c0100466:	83 c4 10             	add    $0x10,%esp
+c0100468:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+c010046f:	e8 94 07 00 00       	call   c0100c08 <kmonitor>
     }
-c0100469:	eb f1                	jmp    c010045c <__panic+0x74>
+c0100474:	eb f2                	jmp    c0100468 <__panic+0x70>
 
-c010046b <__warn>:
+c0100476 <__warn>:
 }
 
 /* __warn - like panic, but don't */
 void
 __warn(const char *file, int line, const char *fmt, ...) {
-c010046b:	55                   	push   %ebp
-c010046c:	89 e5                	mov    %esp,%ebp
-c010046e:	83 ec 18             	sub    $0x18,%esp
+c0100476:	55                   	push   %ebp
+c0100477:	89 e5                	mov    %esp,%ebp
+c0100479:	83 ec 28             	sub    $0x28,%esp
     va_list ap;
     va_start(ap, fmt);
-c0100471:	8d 45 14             	lea    0x14(%ebp),%eax
-c0100474:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c010047c:	8d 45 14             	lea    0x14(%ebp),%eax
+c010047f:	89 45 f4             	mov    %eax,-0xc(%ebp)
     cprintf("kernel warning at %s:%d:\n    ", file, line);
-c0100477:	83 ec 04             	sub    $0x4,%esp
-c010047a:	ff 75 0c             	pushl  0xc(%ebp)
-c010047d:	ff 75 08             	pushl  0x8(%ebp)
-c0100480:	68 5a 84 10 c0       	push   $0xc010845a
-c0100485:	e8 f8 fd ff ff       	call   c0100282 <cprintf>
-c010048a:	83 c4 10             	add    $0x10,%esp
+c0100482:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0100485:	89 44 24 08          	mov    %eax,0x8(%esp)
+c0100489:	8b 45 08             	mov    0x8(%ebp),%eax
+c010048c:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0100490:	c7 04 24 9a 8b 10 c0 	movl   $0xc0108b9a,(%esp)
+c0100497:	e8 05 fe ff ff       	call   c01002a1 <cprintf>
     vcprintf(fmt, ap);
-c010048d:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0100490:	83 ec 08             	sub    $0x8,%esp
-c0100493:	50                   	push   %eax
-c0100494:	ff 75 10             	pushl  0x10(%ebp)
-c0100497:	e8 bd fd ff ff       	call   c0100259 <vcprintf>
-c010049c:	83 c4 10             	add    $0x10,%esp
+c010049c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010049f:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01004a3:	8b 45 10             	mov    0x10(%ebp),%eax
+c01004a6:	89 04 24             	mov    %eax,(%esp)
+c01004a9:	e8 c0 fd ff ff       	call   c010026e <vcprintf>
     cprintf("\n");
-c010049f:	83 ec 0c             	sub    $0xc,%esp
-c01004a2:	68 46 84 10 c0       	push   $0xc0108446
-c01004a7:	e8 d6 fd ff ff       	call   c0100282 <cprintf>
-c01004ac:	83 c4 10             	add    $0x10,%esp
+c01004ae:	c7 04 24 86 8b 10 c0 	movl   $0xc0108b86,(%esp)
+c01004b5:	e8 e7 fd ff ff       	call   c01002a1 <cprintf>
     va_end(ap);
 }
-c01004af:	90                   	nop
-c01004b0:	c9                   	leave  
-c01004b1:	c3                   	ret    
+c01004ba:	90                   	nop
+c01004bb:	c9                   	leave  
+c01004bc:	c3                   	ret    
 
-c01004b2 <is_kernel_panic>:
+c01004bd <is_kernel_panic>:
 
 bool
 is_kernel_panic(void) {
-c01004b2:	55                   	push   %ebp
-c01004b3:	89 e5                	mov    %esp,%ebp
+c01004bd:	55                   	push   %ebp
+c01004be:	89 e5                	mov    %esp,%ebp
     return is_panic;
-c01004b5:	a1 20 24 12 c0       	mov    0xc0122420,%eax
+c01004c0:	a1 20 34 12 c0       	mov    0xc0123420,%eax
 }
-c01004ba:	5d                   	pop    %ebp
-c01004bb:	c3                   	ret    
+c01004c5:	5d                   	pop    %ebp
+c01004c6:	c3                   	ret    
 
-c01004bc <stab_binsearch>:
+c01004c7 <stab_binsearch>:
  *      stab_binsearch(stabs, &left, &right, N_SO, 0xf0100184);
  * will exit setting left = 118, right = 554.
  * */
 static void
 stab_binsearch(const struct stab *stabs, int *region_left, int *region_right,
            int type, uintptr_t addr) {
-c01004bc:	55                   	push   %ebp
-c01004bd:	89 e5                	mov    %esp,%ebp
-c01004bf:	83 ec 20             	sub    $0x20,%esp
+c01004c7:	55                   	push   %ebp
+c01004c8:	89 e5                	mov    %esp,%ebp
+c01004ca:	83 ec 20             	sub    $0x20,%esp
     int l = *region_left, r = *region_right, any_matches = 0;
-c01004c2:	8b 45 0c             	mov    0xc(%ebp),%eax
-c01004c5:	8b 00                	mov    (%eax),%eax
-c01004c7:	89 45 fc             	mov    %eax,-0x4(%ebp)
-c01004ca:	8b 45 10             	mov    0x10(%ebp),%eax
-c01004cd:	8b 00                	mov    (%eax),%eax
-c01004cf:	89 45 f8             	mov    %eax,-0x8(%ebp)
-c01004d2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+c01004cd:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01004d0:	8b 00                	mov    (%eax),%eax
+c01004d2:	89 45 fc             	mov    %eax,-0x4(%ebp)
+c01004d5:	8b 45 10             	mov    0x10(%ebp),%eax
+c01004d8:	8b 00                	mov    (%eax),%eax
+c01004da:	89 45 f8             	mov    %eax,-0x8(%ebp)
+c01004dd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 
     while (l <= r) {
-c01004d9:	e9 d2 00 00 00       	jmp    c01005b0 <stab_binsearch+0xf4>
+c01004e4:	e9 ca 00 00 00       	jmp    c01005b3 <stab_binsearch+0xec>
         int true_m = (l + r) / 2, m = true_m;
-c01004de:	8b 55 fc             	mov    -0x4(%ebp),%edx
-c01004e1:	8b 45 f8             	mov    -0x8(%ebp),%eax
-c01004e4:	01 d0                	add    %edx,%eax
-c01004e6:	89 c2                	mov    %eax,%edx
-c01004e8:	c1 ea 1f             	shr    $0x1f,%edx
-c01004eb:	01 d0                	add    %edx,%eax
-c01004ed:	d1 f8                	sar    %eax
-c01004ef:	89 45 ec             	mov    %eax,-0x14(%ebp)
-c01004f2:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c01004f5:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c01004e9:	8b 55 fc             	mov    -0x4(%ebp),%edx
+c01004ec:	8b 45 f8             	mov    -0x8(%ebp),%eax
+c01004ef:	01 d0                	add    %edx,%eax
+c01004f1:	89 c2                	mov    %eax,%edx
+c01004f3:	c1 ea 1f             	shr    $0x1f,%edx
+c01004f6:	01 d0                	add    %edx,%eax
+c01004f8:	d1 f8                	sar    %eax
+c01004fa:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c01004fd:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0100500:	89 45 f0             	mov    %eax,-0x10(%ebp)
 
         // search for earliest stab with right type
         while (m >= l && stabs[m].n_type != type) {
-c01004f8:	eb 04                	jmp    c01004fe <stab_binsearch+0x42>
+c0100503:	eb 03                	jmp    c0100508 <stab_binsearch+0x41>
             m --;
-c01004fa:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
+c0100505:	ff 4d f0             	decl   -0x10(%ebp)
 
     while (l <= r) {
         int true_m = (l + r) / 2, m = true_m;
 
         // search for earliest stab with right type
         while (m >= l && stabs[m].n_type != type) {
-c01004fe:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0100501:	3b 45 fc             	cmp    -0x4(%ebp),%eax
-c0100504:	7c 1f                	jl     c0100525 <stab_binsearch+0x69>
-c0100506:	8b 55 f0             	mov    -0x10(%ebp),%edx
-c0100509:	89 d0                	mov    %edx,%eax
-c010050b:	01 c0                	add    %eax,%eax
-c010050d:	01 d0                	add    %edx,%eax
-c010050f:	c1 e0 02             	shl    $0x2,%eax
-c0100512:	89 c2                	mov    %eax,%edx
-c0100514:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100508:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010050b:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+c010050e:	7c 1f                	jl     c010052f <stab_binsearch+0x68>
+c0100510:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c0100513:	89 d0                	mov    %edx,%eax
+c0100515:	01 c0                	add    %eax,%eax
 c0100517:	01 d0                	add    %edx,%eax
-c0100519:	0f b6 40 04          	movzbl 0x4(%eax),%eax
-c010051d:	0f b6 c0             	movzbl %al,%eax
-c0100520:	3b 45 14             	cmp    0x14(%ebp),%eax
-c0100523:	75 d5                	jne    c01004fa <stab_binsearch+0x3e>
+c0100519:	c1 e0 02             	shl    $0x2,%eax
+c010051c:	89 c2                	mov    %eax,%edx
+c010051e:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100521:	01 d0                	add    %edx,%eax
+c0100523:	0f b6 40 04          	movzbl 0x4(%eax),%eax
+c0100527:	0f b6 c0             	movzbl %al,%eax
+c010052a:	3b 45 14             	cmp    0x14(%ebp),%eax
+c010052d:	75 d6                	jne    c0100505 <stab_binsearch+0x3e>
             m --;
         }
         if (m < l) {    // no match in [l, m]
-c0100525:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0100528:	3b 45 fc             	cmp    -0x4(%ebp),%eax
-c010052b:	7d 0b                	jge    c0100538 <stab_binsearch+0x7c>
+c010052f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0100532:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+c0100535:	7d 09                	jge    c0100540 <stab_binsearch+0x79>
             l = true_m + 1;
-c010052d:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c0100530:	83 c0 01             	add    $0x1,%eax
-c0100533:	89 45 fc             	mov    %eax,-0x4(%ebp)
+c0100537:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c010053a:	40                   	inc    %eax
+c010053b:	89 45 fc             	mov    %eax,-0x4(%ebp)
             continue;
-c0100536:	eb 78                	jmp    c01005b0 <stab_binsearch+0xf4>
+c010053e:	eb 73                	jmp    c01005b3 <stab_binsearch+0xec>
         }
 
         // actual binary search
         any_matches = 1;
-c0100538:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
+c0100540:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
         if (stabs[m].n_value < addr) {
-c010053f:	8b 55 f0             	mov    -0x10(%ebp),%edx
-c0100542:	89 d0                	mov    %edx,%eax
-c0100544:	01 c0                	add    %eax,%eax
-c0100546:	01 d0                	add    %edx,%eax
-c0100548:	c1 e0 02             	shl    $0x2,%eax
-c010054b:	89 c2                	mov    %eax,%edx
-c010054d:	8b 45 08             	mov    0x8(%ebp),%eax
-c0100550:	01 d0                	add    %edx,%eax
-c0100552:	8b 40 08             	mov    0x8(%eax),%eax
-c0100555:	3b 45 18             	cmp    0x18(%ebp),%eax
-c0100558:	73 13                	jae    c010056d <stab_binsearch+0xb1>
+c0100547:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c010054a:	89 d0                	mov    %edx,%eax
+c010054c:	01 c0                	add    %eax,%eax
+c010054e:	01 d0                	add    %edx,%eax
+c0100550:	c1 e0 02             	shl    $0x2,%eax
+c0100553:	89 c2                	mov    %eax,%edx
+c0100555:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100558:	01 d0                	add    %edx,%eax
+c010055a:	8b 40 08             	mov    0x8(%eax),%eax
+c010055d:	3b 45 18             	cmp    0x18(%ebp),%eax
+c0100560:	73 11                	jae    c0100573 <stab_binsearch+0xac>
             *region_left = m;
-c010055a:	8b 45 0c             	mov    0xc(%ebp),%eax
-c010055d:	8b 55 f0             	mov    -0x10(%ebp),%edx
-c0100560:	89 10                	mov    %edx,(%eax)
+c0100562:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0100565:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c0100568:	89 10                	mov    %edx,(%eax)
             l = true_m + 1;
-c0100562:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c0100565:	83 c0 01             	add    $0x1,%eax
-c0100568:	89 45 fc             	mov    %eax,-0x4(%ebp)
-c010056b:	eb 43                	jmp    c01005b0 <stab_binsearch+0xf4>
+c010056a:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c010056d:	40                   	inc    %eax
+c010056e:	89 45 fc             	mov    %eax,-0x4(%ebp)
+c0100571:	eb 40                	jmp    c01005b3 <stab_binsearch+0xec>
         } else if (stabs[m].n_value > addr) {
-c010056d:	8b 55 f0             	mov    -0x10(%ebp),%edx
-c0100570:	89 d0                	mov    %edx,%eax
-c0100572:	01 c0                	add    %eax,%eax
-c0100574:	01 d0                	add    %edx,%eax
-c0100576:	c1 e0 02             	shl    $0x2,%eax
-c0100579:	89 c2                	mov    %eax,%edx
-c010057b:	8b 45 08             	mov    0x8(%ebp),%eax
-c010057e:	01 d0                	add    %edx,%eax
-c0100580:	8b 40 08             	mov    0x8(%eax),%eax
-c0100583:	3b 45 18             	cmp    0x18(%ebp),%eax
-c0100586:	76 16                	jbe    c010059e <stab_binsearch+0xe2>
+c0100573:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c0100576:	89 d0                	mov    %edx,%eax
+c0100578:	01 c0                	add    %eax,%eax
+c010057a:	01 d0                	add    %edx,%eax
+c010057c:	c1 e0 02             	shl    $0x2,%eax
+c010057f:	89 c2                	mov    %eax,%edx
+c0100581:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100584:	01 d0                	add    %edx,%eax
+c0100586:	8b 40 08             	mov    0x8(%eax),%eax
+c0100589:	3b 45 18             	cmp    0x18(%ebp),%eax
+c010058c:	76 14                	jbe    c01005a2 <stab_binsearch+0xdb>
             *region_right = m - 1;
-c0100588:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c010058b:	8d 50 ff             	lea    -0x1(%eax),%edx
-c010058e:	8b 45 10             	mov    0x10(%ebp),%eax
-c0100591:	89 10                	mov    %edx,(%eax)
+c010058e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0100591:	8d 50 ff             	lea    -0x1(%eax),%edx
+c0100594:	8b 45 10             	mov    0x10(%ebp),%eax
+c0100597:	89 10                	mov    %edx,(%eax)
             r = m - 1;
-c0100593:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0100596:	83 e8 01             	sub    $0x1,%eax
-c0100599:	89 45 f8             	mov    %eax,-0x8(%ebp)
-c010059c:	eb 12                	jmp    c01005b0 <stab_binsearch+0xf4>
+c0100599:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010059c:	48                   	dec    %eax
+c010059d:	89 45 f8             	mov    %eax,-0x8(%ebp)
+c01005a0:	eb 11                	jmp    c01005b3 <stab_binsearch+0xec>
         } else {
             // exact match for 'addr', but continue loop to find
             // *region_right
             *region_left = m;
-c010059e:	8b 45 0c             	mov    0xc(%ebp),%eax
-c01005a1:	8b 55 f0             	mov    -0x10(%ebp),%edx
-c01005a4:	89 10                	mov    %edx,(%eax)
+c01005a2:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01005a5:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c01005a8:	89 10                	mov    %edx,(%eax)
             l = m;
-c01005a6:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c01005a9:	89 45 fc             	mov    %eax,-0x4(%ebp)
+c01005aa:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01005ad:	89 45 fc             	mov    %eax,-0x4(%ebp)
             addr ++;
-c01005ac:	83 45 18 01          	addl   $0x1,0x18(%ebp)
+c01005b0:	ff 45 18             	incl   0x18(%ebp)
 static void
 stab_binsearch(const struct stab *stabs, int *region_left, int *region_right,
            int type, uintptr_t addr) {
     int l = *region_left, r = *region_right, any_matches = 0;
 
     while (l <= r) {
-c01005b0:	8b 45 fc             	mov    -0x4(%ebp),%eax
-c01005b3:	3b 45 f8             	cmp    -0x8(%ebp),%eax
-c01005b6:	0f 8e 22 ff ff ff    	jle    c01004de <stab_binsearch+0x22>
+c01005b3:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c01005b6:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+c01005b9:	0f 8e 2a ff ff ff    	jle    c01004e9 <stab_binsearch+0x22>
             l = m;
             addr ++;
         }
     }
 
     if (!any_matches) {
-c01005bc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
-c01005c0:	75 0f                	jne    c01005d1 <stab_binsearch+0x115>
+c01005bf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c01005c3:	75 0f                	jne    c01005d4 <stab_binsearch+0x10d>
         *region_right = *region_left - 1;
-c01005c2:	8b 45 0c             	mov    0xc(%ebp),%eax
-c01005c5:	8b 00                	mov    (%eax),%eax
-c01005c7:	8d 50 ff             	lea    -0x1(%eax),%edx
-c01005ca:	8b 45 10             	mov    0x10(%ebp),%eax
-c01005cd:	89 10                	mov    %edx,(%eax)
+c01005c5:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01005c8:	8b 00                	mov    (%eax),%eax
+c01005ca:	8d 50 ff             	lea    -0x1(%eax),%edx
+c01005cd:	8b 45 10             	mov    0x10(%ebp),%eax
+c01005d0:	89 10                	mov    %edx,(%eax)
         l = *region_right;
         for (; l > *region_left && stabs[l].n_type != type; l --)
             /* do nothing */;
         *region_left = l;
     }
 }
-c01005cf:	eb 3f                	jmp    c0100610 <stab_binsearch+0x154>
+c01005d2:	eb 3e                	jmp    c0100612 <stab_binsearch+0x14b>
     if (!any_matches) {
         *region_right = *region_left - 1;
     }
     else {
         // find rightmost region containing 'addr'
         l = *region_right;
-c01005d1:	8b 45 10             	mov    0x10(%ebp),%eax
-c01005d4:	8b 00                	mov    (%eax),%eax
-c01005d6:	89 45 fc             	mov    %eax,-0x4(%ebp)
+c01005d4:	8b 45 10             	mov    0x10(%ebp),%eax
+c01005d7:	8b 00                	mov    (%eax),%eax
+c01005d9:	89 45 fc             	mov    %eax,-0x4(%ebp)
         for (; l > *region_left && stabs[l].n_type != type; l --)
-c01005d9:	eb 04                	jmp    c01005df <stab_binsearch+0x123>
-c01005db:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
-c01005df:	8b 45 0c             	mov    0xc(%ebp),%eax
-c01005e2:	8b 00                	mov    (%eax),%eax
-c01005e4:	3b 45 fc             	cmp    -0x4(%ebp),%eax
-c01005e7:	7d 1f                	jge    c0100608 <stab_binsearch+0x14c>
-c01005e9:	8b 55 fc             	mov    -0x4(%ebp),%edx
-c01005ec:	89 d0                	mov    %edx,%eax
-c01005ee:	01 c0                	add    %eax,%eax
-c01005f0:	01 d0                	add    %edx,%eax
-c01005f2:	c1 e0 02             	shl    $0x2,%eax
-c01005f5:	89 c2                	mov    %eax,%edx
-c01005f7:	8b 45 08             	mov    0x8(%ebp),%eax
-c01005fa:	01 d0                	add    %edx,%eax
-c01005fc:	0f b6 40 04          	movzbl 0x4(%eax),%eax
-c0100600:	0f b6 c0             	movzbl %al,%eax
-c0100603:	3b 45 14             	cmp    0x14(%ebp),%eax
-c0100606:	75 d3                	jne    c01005db <stab_binsearch+0x11f>
+c01005dc:	eb 03                	jmp    c01005e1 <stab_binsearch+0x11a>
+c01005de:	ff 4d fc             	decl   -0x4(%ebp)
+c01005e1:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01005e4:	8b 00                	mov    (%eax),%eax
+c01005e6:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+c01005e9:	7d 1f                	jge    c010060a <stab_binsearch+0x143>
+c01005eb:	8b 55 fc             	mov    -0x4(%ebp),%edx
+c01005ee:	89 d0                	mov    %edx,%eax
+c01005f0:	01 c0                	add    %eax,%eax
+c01005f2:	01 d0                	add    %edx,%eax
+c01005f4:	c1 e0 02             	shl    $0x2,%eax
+c01005f7:	89 c2                	mov    %eax,%edx
+c01005f9:	8b 45 08             	mov    0x8(%ebp),%eax
+c01005fc:	01 d0                	add    %edx,%eax
+c01005fe:	0f b6 40 04          	movzbl 0x4(%eax),%eax
+c0100602:	0f b6 c0             	movzbl %al,%eax
+c0100605:	3b 45 14             	cmp    0x14(%ebp),%eax
+c0100608:	75 d4                	jne    c01005de <stab_binsearch+0x117>
             /* do nothing */;
         *region_left = l;
-c0100608:	8b 45 0c             	mov    0xc(%ebp),%eax
-c010060b:	8b 55 fc             	mov    -0x4(%ebp),%edx
-c010060e:	89 10                	mov    %edx,(%eax)
+c010060a:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010060d:	8b 55 fc             	mov    -0x4(%ebp),%edx
+c0100610:	89 10                	mov    %edx,(%eax)
     }
 }
-c0100610:	90                   	nop
-c0100611:	c9                   	leave  
-c0100612:	c3                   	ret    
+c0100612:	90                   	nop
+c0100613:	c9                   	leave  
+c0100614:	c3                   	ret    
 
-c0100613 <debuginfo_eip>:
+c0100615 <debuginfo_eip>:
  * the specified instruction address, @addr.  Returns 0 if information
  * was found, and negative if not.  But even if it returns negative it
  * has stored some information into '*info'.
  * */
 int
 debuginfo_eip(uintptr_t addr, struct eipdebuginfo *info) {
-c0100613:	55                   	push   %ebp
-c0100614:	89 e5                	mov    %esp,%ebp
-c0100616:	83 ec 38             	sub    $0x38,%esp
+c0100615:	55                   	push   %ebp
+c0100616:	89 e5                	mov    %esp,%ebp
+c0100618:	83 ec 58             	sub    $0x58,%esp
     const struct stab *stabs, *stab_end;
     const char *stabstr, *stabstr_end;
 
     info->eip_file = "<unknown>";
-c0100619:	8b 45 0c             	mov    0xc(%ebp),%eax
-c010061c:	c7 00 78 84 10 c0    	movl   $0xc0108478,(%eax)
+c010061b:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010061e:	c7 00 b8 8b 10 c0    	movl   $0xc0108bb8,(%eax)
     info->eip_line = 0;
-c0100622:	8b 45 0c             	mov    0xc(%ebp),%eax
-c0100625:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
+c0100624:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0100627:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
     info->eip_fn_name = "<unknown>";
-c010062c:	8b 45 0c             	mov    0xc(%ebp),%eax
-c010062f:	c7 40 08 78 84 10 c0 	movl   $0xc0108478,0x8(%eax)
+c010062e:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0100631:	c7 40 08 b8 8b 10 c0 	movl   $0xc0108bb8,0x8(%eax)
     info->eip_fn_namelen = 9;
-c0100636:	8b 45 0c             	mov    0xc(%ebp),%eax
-c0100639:	c7 40 0c 09 00 00 00 	movl   $0x9,0xc(%eax)
+c0100638:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010063b:	c7 40 0c 09 00 00 00 	movl   $0x9,0xc(%eax)
     info->eip_fn_addr = addr;
-c0100640:	8b 45 0c             	mov    0xc(%ebp),%eax
-c0100643:	8b 55 08             	mov    0x8(%ebp),%edx
-c0100646:	89 50 10             	mov    %edx,0x10(%eax)
+c0100642:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0100645:	8b 55 08             	mov    0x8(%ebp),%edx
+c0100648:	89 50 10             	mov    %edx,0x10(%eax)
     info->eip_fn_narg = 0;
-c0100649:	8b 45 0c             	mov    0xc(%ebp),%eax
-c010064c:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
+c010064b:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010064e:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
 
     stabs = __STAB_BEGIN__;
-c0100653:	c7 45 f4 a0 a3 10 c0 	movl   $0xc010a3a0,-0xc(%ebp)
+c0100655:	c7 45 f4 d0 aa 10 c0 	movl   $0xc010aad0,-0xc(%ebp)
     stab_end = __STAB_END__;
-c010065a:	c7 45 f0 20 95 11 c0 	movl   $0xc0119520,-0x10(%ebp)
+c010065c:	c7 45 f0 64 9a 11 c0 	movl   $0xc0119a64,-0x10(%ebp)
     stabstr = __STABSTR_BEGIN__;
-c0100661:	c7 45 ec 21 95 11 c0 	movl   $0xc0119521,-0x14(%ebp)
+c0100663:	c7 45 ec 65 9a 11 c0 	movl   $0xc0119a65,-0x14(%ebp)
     stabstr_end = __STABSTR_END__;
-c0100668:	c7 45 e8 06 ce 11 c0 	movl   $0xc011ce06,-0x18(%ebp)
+c010066a:	c7 45 e8 2d d3 11 c0 	movl   $0xc011d32d,-0x18(%ebp)
 
     // String table validity checks
     if (stabstr_end <= stabstr || stabstr_end[-1] != 0) {
-c010066f:	8b 45 e8             	mov    -0x18(%ebp),%eax
-c0100672:	3b 45 ec             	cmp    -0x14(%ebp),%eax
-c0100675:	76 0d                	jbe    c0100684 <debuginfo_eip+0x71>
-c0100677:	8b 45 e8             	mov    -0x18(%ebp),%eax
-c010067a:	83 e8 01             	sub    $0x1,%eax
+c0100671:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0100674:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+c0100677:	76 0b                	jbe    c0100684 <debuginfo_eip+0x6f>
+c0100679:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c010067c:	48                   	dec    %eax
 c010067d:	0f b6 00             	movzbl (%eax),%eax
 c0100680:	84 c0                	test   %al,%al
-c0100682:	74 0a                	je     c010068e <debuginfo_eip+0x7b>
+c0100682:	74 0a                	je     c010068e <debuginfo_eip+0x79>
         return -1;
 c0100684:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-c0100689:	e9 91 02 00 00       	jmp    c010091f <debuginfo_eip+0x30c>
+c0100689:	e9 b7 02 00 00       	jmp    c0100945 <debuginfo_eip+0x330>
     // 'eip'.  First, we find the basic source file containing 'eip'.
     // Then, we look in that source file for the function.  Then we look
     // for the line number.
@@ -1003,16437 +965,16448 @@
 c010069d:	89 d0                	mov    %edx,%eax
 c010069f:	c1 f8 02             	sar    $0x2,%eax
 c01006a2:	69 c0 ab aa aa aa    	imul   $0xaaaaaaab,%eax,%eax
-c01006a8:	83 e8 01             	sub    $0x1,%eax
-c01006ab:	89 45 e0             	mov    %eax,-0x20(%ebp)
+c01006a8:	48                   	dec    %eax
+c01006a9:	89 45 e0             	mov    %eax,-0x20(%ebp)
     stab_binsearch(stabs, &lfile, &rfile, N_SO, addr);
-c01006ae:	ff 75 08             	pushl  0x8(%ebp)
-c01006b1:	6a 64                	push   $0x64
-c01006b3:	8d 45 e0             	lea    -0x20(%ebp),%eax
-c01006b6:	50                   	push   %eax
-c01006b7:	8d 45 e4             	lea    -0x1c(%ebp),%eax
-c01006ba:	50                   	push   %eax
-c01006bb:	ff 75 f4             	pushl  -0xc(%ebp)
-c01006be:	e8 f9 fd ff ff       	call   c01004bc <stab_binsearch>
-c01006c3:	83 c4 14             	add    $0x14,%esp
+c01006ac:	8b 45 08             	mov    0x8(%ebp),%eax
+c01006af:	89 44 24 10          	mov    %eax,0x10(%esp)
+c01006b3:	c7 44 24 0c 64 00 00 	movl   $0x64,0xc(%esp)
+c01006ba:	00 
+c01006bb:	8d 45 e0             	lea    -0x20(%ebp),%eax
+c01006be:	89 44 24 08          	mov    %eax,0x8(%esp)
+c01006c2:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+c01006c5:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01006c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01006cc:	89 04 24             	mov    %eax,(%esp)
+c01006cf:	e8 f3 fd ff ff       	call   c01004c7 <stab_binsearch>
     if (lfile == 0)
-c01006c6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-c01006c9:	85 c0                	test   %eax,%eax
-c01006cb:	75 0a                	jne    c01006d7 <debuginfo_eip+0xc4>
+c01006d4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c01006d7:	85 c0                	test   %eax,%eax
+c01006d9:	75 0a                	jne    c01006e5 <debuginfo_eip+0xd0>
         return -1;
-c01006cd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-c01006d2:	e9 48 02 00 00       	jmp    c010091f <debuginfo_eip+0x30c>
+c01006db:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+c01006e0:	e9 60 02 00 00       	jmp    c0100945 <debuginfo_eip+0x330>
 
     // Search within that file's stabs for the function definition
     // (N_FUN).
     int lfun = lfile, rfun = rfile;
-c01006d7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-c01006da:	89 45 dc             	mov    %eax,-0x24(%ebp)
-c01006dd:	8b 45 e0             	mov    -0x20(%ebp),%eax
-c01006e0:	89 45 d8             	mov    %eax,-0x28(%ebp)
+c01006e5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c01006e8:	89 45 dc             	mov    %eax,-0x24(%ebp)
+c01006eb:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c01006ee:	89 45 d8             	mov    %eax,-0x28(%ebp)
     int lline, rline;
     stab_binsearch(stabs, &lfun, &rfun, N_FUN, addr);
-c01006e3:	ff 75 08             	pushl  0x8(%ebp)
-c01006e6:	6a 24                	push   $0x24
-c01006e8:	8d 45 d8             	lea    -0x28(%ebp),%eax
-c01006eb:	50                   	push   %eax
-c01006ec:	8d 45 dc             	lea    -0x24(%ebp),%eax
-c01006ef:	50                   	push   %eax
-c01006f0:	ff 75 f4             	pushl  -0xc(%ebp)
-c01006f3:	e8 c4 fd ff ff       	call   c01004bc <stab_binsearch>
-c01006f8:	83 c4 14             	add    $0x14,%esp
+c01006f1:	8b 45 08             	mov    0x8(%ebp),%eax
+c01006f4:	89 44 24 10          	mov    %eax,0x10(%esp)
+c01006f8:	c7 44 24 0c 24 00 00 	movl   $0x24,0xc(%esp)
+c01006ff:	00 
+c0100700:	8d 45 d8             	lea    -0x28(%ebp),%eax
+c0100703:	89 44 24 08          	mov    %eax,0x8(%esp)
+c0100707:	8d 45 dc             	lea    -0x24(%ebp),%eax
+c010070a:	89 44 24 04          	mov    %eax,0x4(%esp)
+c010070e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100711:	89 04 24             	mov    %eax,(%esp)
+c0100714:	e8 ae fd ff ff       	call   c01004c7 <stab_binsearch>
 
     if (lfun <= rfun) {
-c01006fb:	8b 55 dc             	mov    -0x24(%ebp),%edx
-c01006fe:	8b 45 d8             	mov    -0x28(%ebp),%eax
-c0100701:	39 c2                	cmp    %eax,%edx
-c0100703:	7f 7c                	jg     c0100781 <debuginfo_eip+0x16e>
+c0100719:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c010071c:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c010071f:	39 c2                	cmp    %eax,%edx
+c0100721:	7f 7c                	jg     c010079f <debuginfo_eip+0x18a>
         // stabs[lfun] points to the function name
         // in the string table, but check bounds just in case.
         if (stabs[lfun].n_strx < stabstr_end - stabstr) {
-c0100705:	8b 45 dc             	mov    -0x24(%ebp),%eax
-c0100708:	89 c2                	mov    %eax,%edx
-c010070a:	89 d0                	mov    %edx,%eax
-c010070c:	01 c0                	add    %eax,%eax
-c010070e:	01 d0                	add    %edx,%eax
-c0100710:	c1 e0 02             	shl    $0x2,%eax
-c0100713:	89 c2                	mov    %eax,%edx
-c0100715:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0100718:	01 d0                	add    %edx,%eax
-c010071a:	8b 00                	mov    (%eax),%eax
-c010071c:	8b 4d e8             	mov    -0x18(%ebp),%ecx
-c010071f:	8b 55 ec             	mov    -0x14(%ebp),%edx
-c0100722:	29 d1                	sub    %edx,%ecx
-c0100724:	89 ca                	mov    %ecx,%edx
-c0100726:	39 d0                	cmp    %edx,%eax
-c0100728:	73 22                	jae    c010074c <debuginfo_eip+0x139>
+c0100723:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0100726:	89 c2                	mov    %eax,%edx
+c0100728:	89 d0                	mov    %edx,%eax
+c010072a:	01 c0                	add    %eax,%eax
+c010072c:	01 d0                	add    %edx,%eax
+c010072e:	c1 e0 02             	shl    $0x2,%eax
+c0100731:	89 c2                	mov    %eax,%edx
+c0100733:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100736:	01 d0                	add    %edx,%eax
+c0100738:	8b 00                	mov    (%eax),%eax
+c010073a:	8b 4d e8             	mov    -0x18(%ebp),%ecx
+c010073d:	8b 55 ec             	mov    -0x14(%ebp),%edx
+c0100740:	29 d1                	sub    %edx,%ecx
+c0100742:	89 ca                	mov    %ecx,%edx
+c0100744:	39 d0                	cmp    %edx,%eax
+c0100746:	73 22                	jae    c010076a <debuginfo_eip+0x155>
             info->eip_fn_name = stabstr + stabs[lfun].n_strx;
-c010072a:	8b 45 dc             	mov    -0x24(%ebp),%eax
-c010072d:	89 c2                	mov    %eax,%edx
-c010072f:	89 d0                	mov    %edx,%eax
-c0100731:	01 c0                	add    %eax,%eax
-c0100733:	01 d0                	add    %edx,%eax
-c0100735:	c1 e0 02             	shl    $0x2,%eax
-c0100738:	89 c2                	mov    %eax,%edx
-c010073a:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c010073d:	01 d0                	add    %edx,%eax
-c010073f:	8b 10                	mov    (%eax),%edx
-c0100741:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c0100744:	01 c2                	add    %eax,%edx
-c0100746:	8b 45 0c             	mov    0xc(%ebp),%eax
-c0100749:	89 50 08             	mov    %edx,0x8(%eax)
+c0100748:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c010074b:	89 c2                	mov    %eax,%edx
+c010074d:	89 d0                	mov    %edx,%eax
+c010074f:	01 c0                	add    %eax,%eax
+c0100751:	01 d0                	add    %edx,%eax
+c0100753:	c1 e0 02             	shl    $0x2,%eax
+c0100756:	89 c2                	mov    %eax,%edx
+c0100758:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010075b:	01 d0                	add    %edx,%eax
+c010075d:	8b 10                	mov    (%eax),%edx
+c010075f:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0100762:	01 c2                	add    %eax,%edx
+c0100764:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0100767:	89 50 08             	mov    %edx,0x8(%eax)
         }
         info->eip_fn_addr = stabs[lfun].n_value;
-c010074c:	8b 45 dc             	mov    -0x24(%ebp),%eax
-c010074f:	89 c2                	mov    %eax,%edx
-c0100751:	89 d0                	mov    %edx,%eax
-c0100753:	01 c0                	add    %eax,%eax
-c0100755:	01 d0                	add    %edx,%eax
-c0100757:	c1 e0 02             	shl    $0x2,%eax
-c010075a:	89 c2                	mov    %eax,%edx
-c010075c:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c010075f:	01 d0                	add    %edx,%eax
-c0100761:	8b 50 08             	mov    0x8(%eax),%edx
-c0100764:	8b 45 0c             	mov    0xc(%ebp),%eax
-c0100767:	89 50 10             	mov    %edx,0x10(%eax)
+c010076a:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c010076d:	89 c2                	mov    %eax,%edx
+c010076f:	89 d0                	mov    %edx,%eax
+c0100771:	01 c0                	add    %eax,%eax
+c0100773:	01 d0                	add    %edx,%eax
+c0100775:	c1 e0 02             	shl    $0x2,%eax
+c0100778:	89 c2                	mov    %eax,%edx
+c010077a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010077d:	01 d0                	add    %edx,%eax
+c010077f:	8b 50 08             	mov    0x8(%eax),%edx
+c0100782:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0100785:	89 50 10             	mov    %edx,0x10(%eax)
         addr -= info->eip_fn_addr;
-c010076a:	8b 45 0c             	mov    0xc(%ebp),%eax
-c010076d:	8b 40 10             	mov    0x10(%eax),%eax
-c0100770:	29 45 08             	sub    %eax,0x8(%ebp)
+c0100788:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010078b:	8b 40 10             	mov    0x10(%eax),%eax
+c010078e:	29 45 08             	sub    %eax,0x8(%ebp)
         // Search within the function definition for the line number.
         lline = lfun;
-c0100773:	8b 45 dc             	mov    -0x24(%ebp),%eax
-c0100776:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+c0100791:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0100794:	89 45 d4             	mov    %eax,-0x2c(%ebp)
         rline = rfun;
-c0100779:	8b 45 d8             	mov    -0x28(%ebp),%eax
-c010077c:	89 45 d0             	mov    %eax,-0x30(%ebp)
-c010077f:	eb 15                	jmp    c0100796 <debuginfo_eip+0x183>
+c0100797:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c010079a:	89 45 d0             	mov    %eax,-0x30(%ebp)
+c010079d:	eb 15                	jmp    c01007b4 <debuginfo_eip+0x19f>
     } else {
         // Couldn't find function stab!  Maybe we're in an assembly
         // file.  Search the whole file for the line number.
         info->eip_fn_addr = addr;
-c0100781:	8b 45 0c             	mov    0xc(%ebp),%eax
-c0100784:	8b 55 08             	mov    0x8(%ebp),%edx
-c0100787:	89 50 10             	mov    %edx,0x10(%eax)
+c010079f:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01007a2:	8b 55 08             	mov    0x8(%ebp),%edx
+c01007a5:	89 50 10             	mov    %edx,0x10(%eax)
         lline = lfile;
-c010078a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-c010078d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+c01007a8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c01007ab:	89 45 d4             	mov    %eax,-0x2c(%ebp)
         rline = rfile;
-c0100790:	8b 45 e0             	mov    -0x20(%ebp),%eax
-c0100793:	89 45 d0             	mov    %eax,-0x30(%ebp)
+c01007ae:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c01007b1:	89 45 d0             	mov    %eax,-0x30(%ebp)
     }
     info->eip_fn_namelen = strfind(info->eip_fn_name, ':') - info->eip_fn_name;
-c0100796:	8b 45 0c             	mov    0xc(%ebp),%eax
-c0100799:	8b 40 08             	mov    0x8(%eax),%eax
-c010079c:	83 ec 08             	sub    $0x8,%esp
-c010079f:	6a 3a                	push   $0x3a
-c01007a1:	50                   	push   %eax
-c01007a2:	e8 d5 71 00 00       	call   c010797c <strfind>
-c01007a7:	83 c4 10             	add    $0x10,%esp
-c01007aa:	89 c2                	mov    %eax,%edx
-c01007ac:	8b 45 0c             	mov    0xc(%ebp),%eax
-c01007af:	8b 40 08             	mov    0x8(%eax),%eax
-c01007b2:	29 c2                	sub    %eax,%edx
 c01007b4:	8b 45 0c             	mov    0xc(%ebp),%eax
-c01007b7:	89 50 0c             	mov    %edx,0xc(%eax)
+c01007b7:	8b 40 08             	mov    0x8(%eax),%eax
+c01007ba:	c7 44 24 04 3a 00 00 	movl   $0x3a,0x4(%esp)
+c01007c1:	00 
+c01007c2:	89 04 24             	mov    %eax,(%esp)
+c01007c5:	e8 92 78 00 00       	call   c010805c <strfind>
+c01007ca:	89 c2                	mov    %eax,%edx
+c01007cc:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01007cf:	8b 40 08             	mov    0x8(%eax),%eax
+c01007d2:	29 c2                	sub    %eax,%edx
+c01007d4:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01007d7:	89 50 0c             	mov    %edx,0xc(%eax)
 
     // Search within [lline, rline] for the line number stab.
     // If found, set info->eip_line to the right line number.
     // If not found, return -1.
     stab_binsearch(stabs, &lline, &rline, N_SLINE, addr);
-c01007ba:	83 ec 0c             	sub    $0xc,%esp
-c01007bd:	ff 75 08             	pushl  0x8(%ebp)
-c01007c0:	6a 44                	push   $0x44
-c01007c2:	8d 45 d0             	lea    -0x30(%ebp),%eax
-c01007c5:	50                   	push   %eax
-c01007c6:	8d 45 d4             	lea    -0x2c(%ebp),%eax
-c01007c9:	50                   	push   %eax
-c01007ca:	ff 75 f4             	pushl  -0xc(%ebp)
-c01007cd:	e8 ea fc ff ff       	call   c01004bc <stab_binsearch>
-c01007d2:	83 c4 20             	add    $0x20,%esp
+c01007da:	8b 45 08             	mov    0x8(%ebp),%eax
+c01007dd:	89 44 24 10          	mov    %eax,0x10(%esp)
+c01007e1:	c7 44 24 0c 44 00 00 	movl   $0x44,0xc(%esp)
+c01007e8:	00 
+c01007e9:	8d 45 d0             	lea    -0x30(%ebp),%eax
+c01007ec:	89 44 24 08          	mov    %eax,0x8(%esp)
+c01007f0:	8d 45 d4             	lea    -0x2c(%ebp),%eax
+c01007f3:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01007f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01007fa:	89 04 24             	mov    %eax,(%esp)
+c01007fd:	e8 c5 fc ff ff       	call   c01004c7 <stab_binsearch>
     if (lline <= rline) {
-c01007d5:	8b 55 d4             	mov    -0x2c(%ebp),%edx
-c01007d8:	8b 45 d0             	mov    -0x30(%ebp),%eax
-c01007db:	39 c2                	cmp    %eax,%edx
-c01007dd:	7f 24                	jg     c0100803 <debuginfo_eip+0x1f0>
+c0100802:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c0100805:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c0100808:	39 c2                	cmp    %eax,%edx
+c010080a:	7f 23                	jg     c010082f <debuginfo_eip+0x21a>
         info->eip_line = stabs[rline].n_desc;
-c01007df:	8b 45 d0             	mov    -0x30(%ebp),%eax
-c01007e2:	89 c2                	mov    %eax,%edx
-c01007e4:	89 d0                	mov    %edx,%eax
-c01007e6:	01 c0                	add    %eax,%eax
-c01007e8:	01 d0                	add    %edx,%eax
-c01007ea:	c1 e0 02             	shl    $0x2,%eax
-c01007ed:	89 c2                	mov    %eax,%edx
-c01007ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c01007f2:	01 d0                	add    %edx,%eax
-c01007f4:	0f b7 40 06          	movzwl 0x6(%eax),%eax
-c01007f8:	0f b7 d0             	movzwl %ax,%edx
-c01007fb:	8b 45 0c             	mov    0xc(%ebp),%eax
-c01007fe:	89 50 04             	mov    %edx,0x4(%eax)
+c010080c:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c010080f:	89 c2                	mov    %eax,%edx
+c0100811:	89 d0                	mov    %edx,%eax
+c0100813:	01 c0                	add    %eax,%eax
+c0100815:	01 d0                	add    %edx,%eax
+c0100817:	c1 e0 02             	shl    $0x2,%eax
+c010081a:	89 c2                	mov    %eax,%edx
+c010081c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010081f:	01 d0                	add    %edx,%eax
+c0100821:	0f b7 40 06          	movzwl 0x6(%eax),%eax
+c0100825:	89 c2                	mov    %eax,%edx
+c0100827:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010082a:	89 50 04             	mov    %edx,0x4(%eax)
 
     // Search backwards from the line number for the relevant filename stab.
     // We can't just use the "lfile" stab because inlined functions
     // can interpolate code from a different file!
     // Such included source files use the N_SOL stab type.
     while (lline >= lfile
-c0100801:	eb 13                	jmp    c0100816 <debuginfo_eip+0x203>
+c010082d:	eb 11                	jmp    c0100840 <debuginfo_eip+0x22b>
     // If not found, return -1.
     stab_binsearch(stabs, &lline, &rline, N_SLINE, addr);
     if (lline <= rline) {
         info->eip_line = stabs[rline].n_desc;
     } else {
         return -1;
-c0100803:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-c0100808:	e9 12 01 00 00       	jmp    c010091f <debuginfo_eip+0x30c>
+c010082f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+c0100834:	e9 0c 01 00 00       	jmp    c0100945 <debuginfo_eip+0x330>
     // can interpolate code from a different file!
     // Such included source files use the N_SOL stab type.
     while (lline >= lfile
            && stabs[lline].n_type != N_SOL
            && (stabs[lline].n_type != N_SO || !stabs[lline].n_value)) {
         lline --;
-c010080d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
-c0100810:	83 e8 01             	sub    $0x1,%eax
-c0100813:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+c0100839:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+c010083c:	48                   	dec    %eax
+c010083d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 
     // Search backwards from the line number for the relevant filename stab.
     // We can't just use the "lfile" stab because inlined functions
     // can interpolate code from a different file!
     // Such included source files use the N_SOL stab type.
     while (lline >= lfile
-c0100816:	8b 55 d4             	mov    -0x2c(%ebp),%edx
-c0100819:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-c010081c:	39 c2                	cmp    %eax,%edx
-c010081e:	7c 56                	jl     c0100876 <debuginfo_eip+0x263>
+c0100840:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c0100843:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0100846:	39 c2                	cmp    %eax,%edx
+c0100848:	7c 56                	jl     c01008a0 <debuginfo_eip+0x28b>
            && stabs[lline].n_type != N_SOL
-c0100820:	8b 45 d4             	mov    -0x2c(%ebp),%eax
-c0100823:	89 c2                	mov    %eax,%edx
-c0100825:	89 d0                	mov    %edx,%eax
-c0100827:	01 c0                	add    %eax,%eax
-c0100829:	01 d0                	add    %edx,%eax
-c010082b:	c1 e0 02             	shl    $0x2,%eax
-c010082e:	89 c2                	mov    %eax,%edx
-c0100830:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0100833:	01 d0                	add    %edx,%eax
-c0100835:	0f b6 40 04          	movzbl 0x4(%eax),%eax
-c0100839:	3c 84                	cmp    $0x84,%al
-c010083b:	74 39                	je     c0100876 <debuginfo_eip+0x263>
+c010084a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+c010084d:	89 c2                	mov    %eax,%edx
+c010084f:	89 d0                	mov    %edx,%eax
+c0100851:	01 c0                	add    %eax,%eax
+c0100853:	01 d0                	add    %edx,%eax
+c0100855:	c1 e0 02             	shl    $0x2,%eax
+c0100858:	89 c2                	mov    %eax,%edx
+c010085a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010085d:	01 d0                	add    %edx,%eax
+c010085f:	0f b6 40 04          	movzbl 0x4(%eax),%eax
+c0100863:	3c 84                	cmp    $0x84,%al
+c0100865:	74 39                	je     c01008a0 <debuginfo_eip+0x28b>
            && (stabs[lline].n_type != N_SO || !stabs[lline].n_value)) {
-c010083d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
-c0100840:	89 c2                	mov    %eax,%edx
-c0100842:	89 d0                	mov    %edx,%eax
-c0100844:	01 c0                	add    %eax,%eax
-c0100846:	01 d0                	add    %edx,%eax
-c0100848:	c1 e0 02             	shl    $0x2,%eax
-c010084b:	89 c2                	mov    %eax,%edx
-c010084d:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0100850:	01 d0                	add    %edx,%eax
-c0100852:	0f b6 40 04          	movzbl 0x4(%eax),%eax
-c0100856:	3c 64                	cmp    $0x64,%al
-c0100858:	75 b3                	jne    c010080d <debuginfo_eip+0x1fa>
-c010085a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
-c010085d:	89 c2                	mov    %eax,%edx
-c010085f:	89 d0                	mov    %edx,%eax
-c0100861:	01 c0                	add    %eax,%eax
-c0100863:	01 d0                	add    %edx,%eax
-c0100865:	c1 e0 02             	shl    $0x2,%eax
-c0100868:	89 c2                	mov    %eax,%edx
-c010086a:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c010086d:	01 d0                	add    %edx,%eax
-c010086f:	8b 40 08             	mov    0x8(%eax),%eax
-c0100872:	85 c0                	test   %eax,%eax
-c0100874:	74 97                	je     c010080d <debuginfo_eip+0x1fa>
+c0100867:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+c010086a:	89 c2                	mov    %eax,%edx
+c010086c:	89 d0                	mov    %edx,%eax
+c010086e:	01 c0                	add    %eax,%eax
+c0100870:	01 d0                	add    %edx,%eax
+c0100872:	c1 e0 02             	shl    $0x2,%eax
+c0100875:	89 c2                	mov    %eax,%edx
+c0100877:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010087a:	01 d0                	add    %edx,%eax
+c010087c:	0f b6 40 04          	movzbl 0x4(%eax),%eax
+c0100880:	3c 64                	cmp    $0x64,%al
+c0100882:	75 b5                	jne    c0100839 <debuginfo_eip+0x224>
+c0100884:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+c0100887:	89 c2                	mov    %eax,%edx
+c0100889:	89 d0                	mov    %edx,%eax
+c010088b:	01 c0                	add    %eax,%eax
+c010088d:	01 d0                	add    %edx,%eax
+c010088f:	c1 e0 02             	shl    $0x2,%eax
+c0100892:	89 c2                	mov    %eax,%edx
+c0100894:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100897:	01 d0                	add    %edx,%eax
+c0100899:	8b 40 08             	mov    0x8(%eax),%eax
+c010089c:	85 c0                	test   %eax,%eax
+c010089e:	74 99                	je     c0100839 <debuginfo_eip+0x224>
         lline --;
     }
     if (lline >= lfile && stabs[lline].n_strx < stabstr_end - stabstr) {
-c0100876:	8b 55 d4             	mov    -0x2c(%ebp),%edx
-c0100879:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-c010087c:	39 c2                	cmp    %eax,%edx
-c010087e:	7c 46                	jl     c01008c6 <debuginfo_eip+0x2b3>
-c0100880:	8b 45 d4             	mov    -0x2c(%ebp),%eax
-c0100883:	89 c2                	mov    %eax,%edx
-c0100885:	89 d0                	mov    %edx,%eax
-c0100887:	01 c0                	add    %eax,%eax
-c0100889:	01 d0                	add    %edx,%eax
-c010088b:	c1 e0 02             	shl    $0x2,%eax
-c010088e:	89 c2                	mov    %eax,%edx
-c0100890:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0100893:	01 d0                	add    %edx,%eax
-c0100895:	8b 00                	mov    (%eax),%eax
-c0100897:	8b 4d e8             	mov    -0x18(%ebp),%ecx
-c010089a:	8b 55 ec             	mov    -0x14(%ebp),%edx
-c010089d:	29 d1                	sub    %edx,%ecx
-c010089f:	89 ca                	mov    %ecx,%edx
-c01008a1:	39 d0                	cmp    %edx,%eax
-c01008a3:	73 21                	jae    c01008c6 <debuginfo_eip+0x2b3>
+c01008a0:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c01008a3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c01008a6:	39 c2                	cmp    %eax,%edx
+c01008a8:	7c 46                	jl     c01008f0 <debuginfo_eip+0x2db>
+c01008aa:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+c01008ad:	89 c2                	mov    %eax,%edx
+c01008af:	89 d0                	mov    %edx,%eax
+c01008b1:	01 c0                	add    %eax,%eax
+c01008b3:	01 d0                	add    %edx,%eax
+c01008b5:	c1 e0 02             	shl    $0x2,%eax
+c01008b8:	89 c2                	mov    %eax,%edx
+c01008ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01008bd:	01 d0                	add    %edx,%eax
+c01008bf:	8b 00                	mov    (%eax),%eax
+c01008c1:	8b 4d e8             	mov    -0x18(%ebp),%ecx
+c01008c4:	8b 55 ec             	mov    -0x14(%ebp),%edx
+c01008c7:	29 d1                	sub    %edx,%ecx
+c01008c9:	89 ca                	mov    %ecx,%edx
+c01008cb:	39 d0                	cmp    %edx,%eax
+c01008cd:	73 21                	jae    c01008f0 <debuginfo_eip+0x2db>
         info->eip_file = stabstr + stabs[lline].n_strx;
-c01008a5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
-c01008a8:	89 c2                	mov    %eax,%edx
-c01008aa:	89 d0                	mov    %edx,%eax
-c01008ac:	01 c0                	add    %eax,%eax
-c01008ae:	01 d0                	add    %edx,%eax
-c01008b0:	c1 e0 02             	shl    $0x2,%eax
-c01008b3:	89 c2                	mov    %eax,%edx
-c01008b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c01008b8:	01 d0                	add    %edx,%eax
-c01008ba:	8b 10                	mov    (%eax),%edx
-c01008bc:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c01008bf:	01 c2                	add    %eax,%edx
-c01008c1:	8b 45 0c             	mov    0xc(%ebp),%eax
-c01008c4:	89 10                	mov    %edx,(%eax)
+c01008cf:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+c01008d2:	89 c2                	mov    %eax,%edx
+c01008d4:	89 d0                	mov    %edx,%eax
+c01008d6:	01 c0                	add    %eax,%eax
+c01008d8:	01 d0                	add    %edx,%eax
+c01008da:	c1 e0 02             	shl    $0x2,%eax
+c01008dd:	89 c2                	mov    %eax,%edx
+c01008df:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01008e2:	01 d0                	add    %edx,%eax
+c01008e4:	8b 10                	mov    (%eax),%edx
+c01008e6:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c01008e9:	01 c2                	add    %eax,%edx
+c01008eb:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01008ee:	89 10                	mov    %edx,(%eax)
     }
 
     // Set eip_fn_narg to the number of arguments taken by the function,
     // or 0 if there was no containing function.
     if (lfun < rfun) {
-c01008c6:	8b 55 dc             	mov    -0x24(%ebp),%edx
-c01008c9:	8b 45 d8             	mov    -0x28(%ebp),%eax
-c01008cc:	39 c2                	cmp    %eax,%edx
-c01008ce:	7d 4a                	jge    c010091a <debuginfo_eip+0x307>
+c01008f0:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c01008f3:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c01008f6:	39 c2                	cmp    %eax,%edx
+c01008f8:	7d 46                	jge    c0100940 <debuginfo_eip+0x32b>
         for (lline = lfun + 1;
-c01008d0:	8b 45 dc             	mov    -0x24(%ebp),%eax
-c01008d3:	83 c0 01             	add    $0x1,%eax
-c01008d6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
-c01008d9:	eb 18                	jmp    c01008f3 <debuginfo_eip+0x2e0>
+c01008fa:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c01008fd:	40                   	inc    %eax
+c01008fe:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+c0100901:	eb 16                	jmp    c0100919 <debuginfo_eip+0x304>
              lline < rfun && stabs[lline].n_type == N_PSYM;
              lline ++) {
             info->eip_fn_narg ++;
-c01008db:	8b 45 0c             	mov    0xc(%ebp),%eax
-c01008de:	8b 40 14             	mov    0x14(%eax),%eax
-c01008e1:	8d 50 01             	lea    0x1(%eax),%edx
-c01008e4:	8b 45 0c             	mov    0xc(%ebp),%eax
-c01008e7:	89 50 14             	mov    %edx,0x14(%eax)
+c0100903:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0100906:	8b 40 14             	mov    0x14(%eax),%eax
+c0100909:	8d 50 01             	lea    0x1(%eax),%edx
+c010090c:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010090f:	89 50 14             	mov    %edx,0x14(%eax)
     // Set eip_fn_narg to the number of arguments taken by the function,
     // or 0 if there was no containing function.
     if (lfun < rfun) {
         for (lline = lfun + 1;
              lline < rfun && stabs[lline].n_type == N_PSYM;
              lline ++) {
-c01008ea:	8b 45 d4             	mov    -0x2c(%ebp),%eax
-c01008ed:	83 c0 01             	add    $0x1,%eax
-c01008f0:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+c0100912:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+c0100915:	40                   	inc    %eax
+c0100916:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 
     // Set eip_fn_narg to the number of arguments taken by the function,
     // or 0 if there was no containing function.
     if (lfun < rfun) {
         for (lline = lfun + 1;
              lline < rfun && stabs[lline].n_type == N_PSYM;
-c01008f3:	8b 55 d4             	mov    -0x2c(%ebp),%edx
-c01008f6:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c0100919:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c010091c:	8b 45 d8             	mov    -0x28(%ebp),%eax
     }
 
     // Set eip_fn_narg to the number of arguments taken by the function,
     // or 0 if there was no containing function.
     if (lfun < rfun) {
         for (lline = lfun + 1;
-c01008f9:	39 c2                	cmp    %eax,%edx
-c01008fb:	7d 1d                	jge    c010091a <debuginfo_eip+0x307>
+c010091f:	39 c2                	cmp    %eax,%edx
+c0100921:	7d 1d                	jge    c0100940 <debuginfo_eip+0x32b>
              lline < rfun && stabs[lline].n_type == N_PSYM;
-c01008fd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
-c0100900:	89 c2                	mov    %eax,%edx
-c0100902:	89 d0                	mov    %edx,%eax
-c0100904:	01 c0                	add    %eax,%eax
-c0100906:	01 d0                	add    %edx,%eax
-c0100908:	c1 e0 02             	shl    $0x2,%eax
-c010090b:	89 c2                	mov    %eax,%edx
-c010090d:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0100910:	01 d0                	add    %edx,%eax
-c0100912:	0f b6 40 04          	movzbl 0x4(%eax),%eax
-c0100916:	3c a0                	cmp    $0xa0,%al
-c0100918:	74 c1                	je     c01008db <debuginfo_eip+0x2c8>
+c0100923:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+c0100926:	89 c2                	mov    %eax,%edx
+c0100928:	89 d0                	mov    %edx,%eax
+c010092a:	01 c0                	add    %eax,%eax
+c010092c:	01 d0                	add    %edx,%eax
+c010092e:	c1 e0 02             	shl    $0x2,%eax
+c0100931:	89 c2                	mov    %eax,%edx
+c0100933:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100936:	01 d0                	add    %edx,%eax
+c0100938:	0f b6 40 04          	movzbl 0x4(%eax),%eax
+c010093c:	3c a0                	cmp    $0xa0,%al
+c010093e:	74 c3                	je     c0100903 <debuginfo_eip+0x2ee>
              lline ++) {
             info->eip_fn_narg ++;
         }
     }
     return 0;
-c010091a:	b8 00 00 00 00       	mov    $0x0,%eax
+c0100940:	b8 00 00 00 00       	mov    $0x0,%eax
 }
-c010091f:	c9                   	leave  
-c0100920:	c3                   	ret    
+c0100945:	c9                   	leave  
+c0100946:	c3                   	ret    
 
-c0100921 <print_kerninfo>:
+c0100947 <print_kerninfo>:
  * print_kerninfo - print the information about kernel, including the location
  * of kernel entry, the start addresses of data and text segements, the start
  * address of free memory and how many memory that kernel has used.
  * */
 void
 print_kerninfo(void) {
-c0100921:	55                   	push   %ebp
-c0100922:	89 e5                	mov    %esp,%ebp
-c0100924:	83 ec 08             	sub    $0x8,%esp
+c0100947:	55                   	push   %ebp
+c0100948:	89 e5                	mov    %esp,%ebp
+c010094a:	83 ec 18             	sub    $0x18,%esp
     extern char etext[], edata[], end[], kern_init[];
     cprintf("Special kernel symbols:\n");
-c0100927:	83 ec 0c             	sub    $0xc,%esp
-c010092a:	68 82 84 10 c0       	push   $0xc0108482
-c010092f:	e8 4e f9 ff ff       	call   c0100282 <cprintf>
-c0100934:	83 c4 10             	add    $0x10,%esp
+c010094d:	c7 04 24 c2 8b 10 c0 	movl   $0xc0108bc2,(%esp)
+c0100954:	e8 48 f9 ff ff       	call   c01002a1 <cprintf>
     cprintf("  entry  0x%08x (phys)\n", kern_init);
-c0100937:	83 ec 08             	sub    $0x8,%esp
-c010093a:	68 36 00 10 c0       	push   $0xc0100036
-c010093f:	68 9b 84 10 c0       	push   $0xc010849b
-c0100944:	e8 39 f9 ff ff       	call   c0100282 <cprintf>
-c0100949:	83 c4 10             	add    $0x10,%esp
+c0100959:	c7 44 24 04 36 00 10 	movl   $0xc0100036,0x4(%esp)
+c0100960:	c0 
+c0100961:	c7 04 24 db 8b 10 c0 	movl   $0xc0108bdb,(%esp)
+c0100968:	e8 34 f9 ff ff       	call   c01002a1 <cprintf>
     cprintf("  etext  0x%08x (phys)\n", etext);
-c010094c:	83 ec 08             	sub    $0x8,%esp
-c010094f:	68 77 83 10 c0       	push   $0xc0108377
-c0100954:	68 b3 84 10 c0       	push   $0xc01084b3
-c0100959:	e8 24 f9 ff ff       	call   c0100282 <cprintf>
-c010095e:	83 c4 10             	add    $0x10,%esp
+c010096d:	c7 44 24 04 b2 8a 10 	movl   $0xc0108ab2,0x4(%esp)
+c0100974:	c0 
+c0100975:	c7 04 24 f3 8b 10 c0 	movl   $0xc0108bf3,(%esp)
+c010097c:	e8 20 f9 ff ff       	call   c01002a1 <cprintf>
     cprintf("  edata  0x%08x (phys)\n", edata);
-c0100961:	83 ec 08             	sub    $0x8,%esp
-c0100964:	68 00 20 12 c0       	push   $0xc0122000
-c0100969:	68 cb 84 10 c0       	push   $0xc01084cb
-c010096e:	e8 0f f9 ff ff       	call   c0100282 <cprintf>
-c0100973:	83 c4 10             	add    $0x10,%esp
+c0100981:	c7 44 24 04 00 30 12 	movl   $0xc0123000,0x4(%esp)
+c0100988:	c0 
+c0100989:	c7 04 24 0b 8c 10 c0 	movl   $0xc0108c0b,(%esp)
+c0100990:	e8 0c f9 ff ff       	call   c01002a1 <cprintf>
     cprintf("  end    0x%08x (phys)\n", end);
-c0100976:	83 ec 08             	sub    $0x8,%esp
-c0100979:	68 18 31 12 c0       	push   $0xc0123118
-c010097e:	68 e3 84 10 c0       	push   $0xc01084e3
-c0100983:	e8 fa f8 ff ff       	call   c0100282 <cprintf>
-c0100988:	83 c4 10             	add    $0x10,%esp
+c0100995:	c7 44 24 04 18 41 12 	movl   $0xc0124118,0x4(%esp)
+c010099c:	c0 
+c010099d:	c7 04 24 23 8c 10 c0 	movl   $0xc0108c23,(%esp)
+c01009a4:	e8 f8 f8 ff ff       	call   c01002a1 <cprintf>
     cprintf("Kernel executable memory footprint: %dKB\n", (end - kern_init + 1023)/1024);
-c010098b:	b8 18 31 12 c0       	mov    $0xc0123118,%eax
-c0100990:	05 ff 03 00 00       	add    $0x3ff,%eax
-c0100995:	ba 36 00 10 c0       	mov    $0xc0100036,%edx
-c010099a:	29 d0                	sub    %edx,%eax
-c010099c:	8d 90 ff 03 00 00    	lea    0x3ff(%eax),%edx
-c01009a2:	85 c0                	test   %eax,%eax
-c01009a4:	0f 48 c2             	cmovs  %edx,%eax
-c01009a7:	c1 f8 0a             	sar    $0xa,%eax
-c01009aa:	83 ec 08             	sub    $0x8,%esp
-c01009ad:	50                   	push   %eax
-c01009ae:	68 fc 84 10 c0       	push   $0xc01084fc
-c01009b3:	e8 ca f8 ff ff       	call   c0100282 <cprintf>
-c01009b8:	83 c4 10             	add    $0x10,%esp
-}
-c01009bb:	90                   	nop
-c01009bc:	c9                   	leave  
-c01009bd:	c3                   	ret    
+c01009a9:	b8 18 41 12 c0       	mov    $0xc0124118,%eax
+c01009ae:	8d 90 ff 03 00 00    	lea    0x3ff(%eax),%edx
+c01009b4:	b8 36 00 10 c0       	mov    $0xc0100036,%eax
+c01009b9:	29 c2                	sub    %eax,%edx
+c01009bb:	89 d0                	mov    %edx,%eax
+c01009bd:	8d 90 ff 03 00 00    	lea    0x3ff(%eax),%edx
+c01009c3:	85 c0                	test   %eax,%eax
+c01009c5:	0f 48 c2             	cmovs  %edx,%eax
+c01009c8:	c1 f8 0a             	sar    $0xa,%eax
+c01009cb:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01009cf:	c7 04 24 3c 8c 10 c0 	movl   $0xc0108c3c,(%esp)
+c01009d6:	e8 c6 f8 ff ff       	call   c01002a1 <cprintf>
+}
+c01009db:	90                   	nop
+c01009dc:	c9                   	leave  
+c01009dd:	c3                   	ret    
 
-c01009be <print_debuginfo>:
+c01009de <print_debuginfo>:
 /* *
  * print_debuginfo - read and print the stat information for the address @eip,
  * and info.eip_fn_addr should be the first address of the related function.
  * */
 void
 print_debuginfo(uintptr_t eip) {
-c01009be:	55                   	push   %ebp
-c01009bf:	89 e5                	mov    %esp,%ebp
-c01009c1:	81 ec 28 01 00 00    	sub    $0x128,%esp
+c01009de:	55                   	push   %ebp
+c01009df:	89 e5                	mov    %esp,%ebp
+c01009e1:	81 ec 48 01 00 00    	sub    $0x148,%esp
     struct eipdebuginfo info;
     if (debuginfo_eip(eip, &info) != 0) {
-c01009c7:	83 ec 08             	sub    $0x8,%esp
-c01009ca:	8d 45 dc             	lea    -0x24(%ebp),%eax
-c01009cd:	50                   	push   %eax
-c01009ce:	ff 75 08             	pushl  0x8(%ebp)
-c01009d1:	e8 3d fc ff ff       	call   c0100613 <debuginfo_eip>
-c01009d6:	83 c4 10             	add    $0x10,%esp
-c01009d9:	85 c0                	test   %eax,%eax
-c01009db:	74 15                	je     c01009f2 <print_debuginfo+0x34>
+c01009e7:	8d 45 dc             	lea    -0x24(%ebp),%eax
+c01009ea:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01009ee:	8b 45 08             	mov    0x8(%ebp),%eax
+c01009f1:	89 04 24             	mov    %eax,(%esp)
+c01009f4:	e8 1c fc ff ff       	call   c0100615 <debuginfo_eip>
+c01009f9:	85 c0                	test   %eax,%eax
+c01009fb:	74 15                	je     c0100a12 <print_debuginfo+0x34>
         cprintf("    <unknow>: -- 0x%08x --\n", eip);
-c01009dd:	83 ec 08             	sub    $0x8,%esp
-c01009e0:	ff 75 08             	pushl  0x8(%ebp)
-c01009e3:	68 26 85 10 c0       	push   $0xc0108526
-c01009e8:	e8 95 f8 ff ff       	call   c0100282 <cprintf>
-c01009ed:	83 c4 10             	add    $0x10,%esp
+c01009fd:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100a00:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0100a04:	c7 04 24 66 8c 10 c0 	movl   $0xc0108c66,(%esp)
+c0100a0b:	e8 91 f8 ff ff       	call   c01002a1 <cprintf>
         }
         fnname[j] = '\0';
         cprintf("    %s:%d: %s+%d\n", info.eip_file, info.eip_line,
                 fnname, eip - info.eip_fn_addr);
     }
 }
-c01009f0:	eb 65                	jmp    c0100a57 <print_debuginfo+0x99>
+c0100a10:	eb 6c                	jmp    c0100a7e <print_debuginfo+0xa0>
         cprintf("    <unknow>: -- 0x%08x --\n", eip);
     }
     else {
         char fnname[256];
         int j;
         for (j = 0; j < info.eip_fn_namelen; j ++) {
-c01009f2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
-c01009f9:	eb 1c                	jmp    c0100a17 <print_debuginfo+0x59>
+c0100a12:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+c0100a19:	eb 1b                	jmp    c0100a36 <print_debuginfo+0x58>
             fnname[j] = info.eip_fn_name[j];
-c01009fb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
-c01009fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0100a01:	01 d0                	add    %edx,%eax
-c0100a03:	0f b6 00             	movzbl (%eax),%eax
-c0100a06:	8d 8d dc fe ff ff    	lea    -0x124(%ebp),%ecx
-c0100a0c:	8b 55 f4             	mov    -0xc(%ebp),%edx
-c0100a0f:	01 ca                	add    %ecx,%edx
-c0100a11:	88 02                	mov    %al,(%edx)
+c0100a1b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c0100a1e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100a21:	01 d0                	add    %edx,%eax
+c0100a23:	0f b6 00             	movzbl (%eax),%eax
+c0100a26:	8d 8d dc fe ff ff    	lea    -0x124(%ebp),%ecx
+c0100a2c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0100a2f:	01 ca                	add    %ecx,%edx
+c0100a31:	88 02                	mov    %al,(%edx)
         cprintf("    <unknow>: -- 0x%08x --\n", eip);
     }
     else {
         char fnname[256];
         int j;
         for (j = 0; j < info.eip_fn_namelen; j ++) {
-c0100a13:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
-c0100a17:	8b 45 e8             	mov    -0x18(%ebp),%eax
-c0100a1a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
-c0100a1d:	7f dc                	jg     c01009fb <print_debuginfo+0x3d>
+c0100a33:	ff 45 f4             	incl   -0xc(%ebp)
+c0100a36:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0100a39:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+c0100a3c:	7f dd                	jg     c0100a1b <print_debuginfo+0x3d>
             fnname[j] = info.eip_fn_name[j];
         }
         fnname[j] = '\0';
-c0100a1f:	8d 95 dc fe ff ff    	lea    -0x124(%ebp),%edx
-c0100a25:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0100a28:	01 d0                	add    %edx,%eax
-c0100a2a:	c6 00 00             	movb   $0x0,(%eax)
+c0100a3e:	8d 95 dc fe ff ff    	lea    -0x124(%ebp),%edx
+c0100a44:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100a47:	01 d0                	add    %edx,%eax
+c0100a49:	c6 00 00             	movb   $0x0,(%eax)
         cprintf("    %s:%d: %s+%d\n", info.eip_file, info.eip_line,
                 fnname, eip - info.eip_fn_addr);
-c0100a2d:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0100a4c:	8b 45 ec             	mov    -0x14(%ebp),%eax
         int j;
         for (j = 0; j < info.eip_fn_namelen; j ++) {
             fnname[j] = info.eip_fn_name[j];
         }
         fnname[j] = '\0';
         cprintf("    %s:%d: %s+%d\n", info.eip_file, info.eip_line,
-c0100a30:	8b 55 08             	mov    0x8(%ebp),%edx
-c0100a33:	89 d1                	mov    %edx,%ecx
-c0100a35:	29 c1                	sub    %eax,%ecx
-c0100a37:	8b 55 e0             	mov    -0x20(%ebp),%edx
-c0100a3a:	8b 45 dc             	mov    -0x24(%ebp),%eax
-c0100a3d:	83 ec 0c             	sub    $0xc,%esp
-c0100a40:	51                   	push   %ecx
-c0100a41:	8d 8d dc fe ff ff    	lea    -0x124(%ebp),%ecx
-c0100a47:	51                   	push   %ecx
-c0100a48:	52                   	push   %edx
-c0100a49:	50                   	push   %eax
-c0100a4a:	68 42 85 10 c0       	push   $0xc0108542
-c0100a4f:	e8 2e f8 ff ff       	call   c0100282 <cprintf>
-c0100a54:	83 c4 20             	add    $0x20,%esp
+c0100a4f:	8b 55 08             	mov    0x8(%ebp),%edx
+c0100a52:	89 d1                	mov    %edx,%ecx
+c0100a54:	29 c1                	sub    %eax,%ecx
+c0100a56:	8b 55 e0             	mov    -0x20(%ebp),%edx
+c0100a59:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0100a5c:	89 4c 24 10          	mov    %ecx,0x10(%esp)
+c0100a60:	8d 8d dc fe ff ff    	lea    -0x124(%ebp),%ecx
+c0100a66:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
+c0100a6a:	89 54 24 08          	mov    %edx,0x8(%esp)
+c0100a6e:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0100a72:	c7 04 24 82 8c 10 c0 	movl   $0xc0108c82,(%esp)
+c0100a79:	e8 23 f8 ff ff       	call   c01002a1 <cprintf>
                 fnname, eip - info.eip_fn_addr);
     }
 }
-c0100a57:	90                   	nop
-c0100a58:	c9                   	leave  
-c0100a59:	c3                   	ret    
+c0100a7e:	90                   	nop
+c0100a7f:	c9                   	leave  
+c0100a80:	c3                   	ret    
 
-c0100a5a <read_eip>:
+c0100a81 <read_eip>:
 
 static __noinline uint32_t
 read_eip(void) {
-c0100a5a:	55                   	push   %ebp
-c0100a5b:	89 e5                	mov    %esp,%ebp
-c0100a5d:	83 ec 10             	sub    $0x10,%esp
+c0100a81:	55                   	push   %ebp
+c0100a82:	89 e5                	mov    %esp,%ebp
+c0100a84:	83 ec 10             	sub    $0x10,%esp
     uint32_t eip;
     asm volatile("movl 4(%%ebp), %0" : "=r" (eip));
-c0100a60:	8b 45 04             	mov    0x4(%ebp),%eax
-c0100a63:	89 45 fc             	mov    %eax,-0x4(%ebp)
+c0100a87:	8b 45 04             	mov    0x4(%ebp),%eax
+c0100a8a:	89 45 fc             	mov    %eax,-0x4(%ebp)
     return eip;
-c0100a66:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0100a8d:	8b 45 fc             	mov    -0x4(%ebp),%eax
 }
-c0100a69:	c9                   	leave  
-c0100a6a:	c3                   	ret    
+c0100a90:	c9                   	leave  
+c0100a91:	c3                   	ret    
 
-c0100a6b <print_stackframe>:
+c0100a92 <print_stackframe>:
  *
  * Note that, the length of ebp-chain is limited. In boot/bootasm.S, before jumping
  * to the kernel entry, the value of ebp has been set to zero, that's the boundary.
  * */
 void
 print_stackframe(void) {
-c0100a6b:	55                   	push   %ebp
-c0100a6c:	89 e5                	mov    %esp,%ebp
-c0100a6e:	83 ec 28             	sub    $0x28,%esp
-}
-
-static inline uint32_t
-read_ebp(void) {
-    uint32_t ebp;
-    asm volatile ("movl %%ebp, %0" : "=r" (ebp));
-c0100a71:	89 e8                	mov    %ebp,%eax
-c0100a73:	89 45 e0             	mov    %eax,-0x20(%ebp)
-    return ebp;
-c0100a76:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0100a92:	55                   	push   %ebp
+c0100a93:	89 e5                	mov    %esp,%ebp
       *    (3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc.
       *    (3.5) popup a calling stackframe
       *           NOTICE: the calling funciton's return addr eip  = ss:[ebp+4]
       *                   the calling funciton's ebp = ss:[ebp]
       */
-    uint32_t ebp = read_ebp(), eip = read_eip();
-c0100a79:	89 45 f4             	mov    %eax,-0xc(%ebp)
-c0100a7c:	e8 d9 ff ff ff       	call   c0100a5a <read_eip>
-c0100a81:	89 45 f0             	mov    %eax,-0x10(%ebp)
-
-    int i, j;
-    for (i = 0; ebp != 0 && i < STACKFRAME_DEPTH; i ++) {
-c0100a84:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
-c0100a8b:	e9 8d 00 00 00       	jmp    c0100b1d <print_stackframe+0xb2>
-        cprintf("ebp:0x%08x eip:0x%08x args:", ebp, eip);
-c0100a90:	83 ec 04             	sub    $0x4,%esp
-c0100a93:	ff 75 f0             	pushl  -0x10(%ebp)
-c0100a96:	ff 75 f4             	pushl  -0xc(%ebp)
-c0100a99:	68 54 85 10 c0       	push   $0xc0108554
-c0100a9e:	e8 df f7 ff ff       	call   c0100282 <cprintf>
-c0100aa3:	83 c4 10             	add    $0x10,%esp
-        uint32_t *args = (uint32_t *)ebp + 2;
-c0100aa6:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0100aa9:	83 c0 08             	add    $0x8,%eax
-c0100aac:	89 45 e4             	mov    %eax,-0x1c(%ebp)
-        for (j = 0; j < 4; j ++) {
-c0100aaf:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
-c0100ab6:	eb 26                	jmp    c0100ade <print_stackframe+0x73>
-            cprintf("0x%08x ", args[j]);
-c0100ab8:	8b 45 e8             	mov    -0x18(%ebp),%eax
-c0100abb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
-c0100ac2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-c0100ac5:	01 d0                	add    %edx,%eax
-c0100ac7:	8b 00                	mov    (%eax),%eax
-c0100ac9:	83 ec 08             	sub    $0x8,%esp
-c0100acc:	50                   	push   %eax
-c0100acd:	68 70 85 10 c0       	push   $0xc0108570
-c0100ad2:	e8 ab f7 ff ff       	call   c0100282 <cprintf>
-c0100ad7:	83 c4 10             	add    $0x10,%esp
-
-    int i, j;
-    for (i = 0; ebp != 0 && i < STACKFRAME_DEPTH; i ++) {
-        cprintf("ebp:0x%08x eip:0x%08x args:", ebp, eip);
-        uint32_t *args = (uint32_t *)ebp + 2;
-        for (j = 0; j < 4; j ++) {
-c0100ada:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
-c0100ade:	83 7d e8 03          	cmpl   $0x3,-0x18(%ebp)
-c0100ae2:	7e d4                	jle    c0100ab8 <print_stackframe+0x4d>
-            cprintf("0x%08x ", args[j]);
-        }
-        cprintf("\n");
-c0100ae4:	83 ec 0c             	sub    $0xc,%esp
-c0100ae7:	68 78 85 10 c0       	push   $0xc0108578
-c0100aec:	e8 91 f7 ff ff       	call   c0100282 <cprintf>
-c0100af1:	83 c4 10             	add    $0x10,%esp
-        print_debuginfo(eip - 1);
-c0100af4:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0100af7:	83 e8 01             	sub    $0x1,%eax
-c0100afa:	83 ec 0c             	sub    $0xc,%esp
-c0100afd:	50                   	push   %eax
-c0100afe:	e8 bb fe ff ff       	call   c01009be <print_debuginfo>
-c0100b03:	83 c4 10             	add    $0x10,%esp
-        eip = ((uint32_t *)ebp)[1];
-c0100b06:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0100b09:	83 c0 04             	add    $0x4,%eax
-c0100b0c:	8b 00                	mov    (%eax),%eax
-c0100b0e:	89 45 f0             	mov    %eax,-0x10(%ebp)
-        ebp = ((uint32_t *)ebp)[0];
-c0100b11:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0100b14:	8b 00                	mov    (%eax),%eax
-c0100b16:	89 45 f4             	mov    %eax,-0xc(%ebp)
-      *                   the calling funciton's ebp = ss:[ebp]
-      */
-    uint32_t ebp = read_ebp(), eip = read_eip();
-
-    int i, j;
-    for (i = 0; ebp != 0 && i < STACKFRAME_DEPTH; i ++) {
-c0100b19:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
-c0100b1d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
-c0100b21:	74 0a                	je     c0100b2d <print_stackframe+0xc2>
-c0100b23:	83 7d ec 13          	cmpl   $0x13,-0x14(%ebp)
-c0100b27:	0f 8e 63 ff ff ff    	jle    c0100a90 <print_stackframe+0x25>
-        cprintf("\n");
-        print_debuginfo(eip - 1);
-        eip = ((uint32_t *)ebp)[1];
-        ebp = ((uint32_t *)ebp)[0];
-    }
-}
-c0100b2d:	90                   	nop
-c0100b2e:	c9                   	leave  
-c0100b2f:	c3                   	ret    
+}
+c0100a95:	90                   	nop
+c0100a96:	5d                   	pop    %ebp
+c0100a97:	c3                   	ret    
 
-c0100b30 <parse>:
+c0100a98 <parse>:
 #define MAXARGS         16
 #define WHITESPACE      " \t\n\r"
 
 /* parse - parse the command buffer into whitespace-separated arguments */
 static int
 parse(char *buf, char **argv) {
-c0100b30:	55                   	push   %ebp
-c0100b31:	89 e5                	mov    %esp,%ebp
-c0100b33:	83 ec 18             	sub    $0x18,%esp
+c0100a98:	55                   	push   %ebp
+c0100a99:	89 e5                	mov    %esp,%ebp
+c0100a9b:	83 ec 28             	sub    $0x28,%esp
     int argc = 0;
-c0100b36:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+c0100a9e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     while (1) {
         // find global whitespace
         while (*buf != '\0' && strchr(WHITESPACE, *buf) != NULL) {
-c0100b3d:	eb 0c                	jmp    c0100b4b <parse+0x1b>
+c0100aa5:	eb 0c                	jmp    c0100ab3 <parse+0x1b>
             *buf ++ = '\0';
-c0100b3f:	8b 45 08             	mov    0x8(%ebp),%eax
-c0100b42:	8d 50 01             	lea    0x1(%eax),%edx
-c0100b45:	89 55 08             	mov    %edx,0x8(%ebp)
-c0100b48:	c6 00 00             	movb   $0x0,(%eax)
+c0100aa7:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100aaa:	8d 50 01             	lea    0x1(%eax),%edx
+c0100aad:	89 55 08             	mov    %edx,0x8(%ebp)
+c0100ab0:	c6 00 00             	movb   $0x0,(%eax)
 static int
 parse(char *buf, char **argv) {
     int argc = 0;
     while (1) {
         // find global whitespace
         while (*buf != '\0' && strchr(WHITESPACE, *buf) != NULL) {
-c0100b4b:	8b 45 08             	mov    0x8(%ebp),%eax
-c0100b4e:	0f b6 00             	movzbl (%eax),%eax
-c0100b51:	84 c0                	test   %al,%al
-c0100b53:	74 1e                	je     c0100b73 <parse+0x43>
-c0100b55:	8b 45 08             	mov    0x8(%ebp),%eax
-c0100b58:	0f b6 00             	movzbl (%eax),%eax
-c0100b5b:	0f be c0             	movsbl %al,%eax
-c0100b5e:	83 ec 08             	sub    $0x8,%esp
-c0100b61:	50                   	push   %eax
-c0100b62:	68 fc 85 10 c0       	push   $0xc01085fc
-c0100b67:	e8 dd 6d 00 00       	call   c0107949 <strchr>
-c0100b6c:	83 c4 10             	add    $0x10,%esp
-c0100b6f:	85 c0                	test   %eax,%eax
-c0100b71:	75 cc                	jne    c0100b3f <parse+0xf>
+c0100ab3:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100ab6:	0f b6 00             	movzbl (%eax),%eax
+c0100ab9:	84 c0                	test   %al,%al
+c0100abb:	74 1d                	je     c0100ada <parse+0x42>
+c0100abd:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100ac0:	0f b6 00             	movzbl (%eax),%eax
+c0100ac3:	0f be c0             	movsbl %al,%eax
+c0100ac6:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0100aca:	c7 04 24 14 8d 10 c0 	movl   $0xc0108d14,(%esp)
+c0100ad1:	e8 54 75 00 00       	call   c010802a <strchr>
+c0100ad6:	85 c0                	test   %eax,%eax
+c0100ad8:	75 cd                	jne    c0100aa7 <parse+0xf>
             *buf ++ = '\0';
         }
         if (*buf == '\0') {
-c0100b73:	8b 45 08             	mov    0x8(%ebp),%eax
-c0100b76:	0f b6 00             	movzbl (%eax),%eax
-c0100b79:	84 c0                	test   %al,%al
-c0100b7b:	74 69                	je     c0100be6 <parse+0xb6>
+c0100ada:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100add:	0f b6 00             	movzbl (%eax),%eax
+c0100ae0:	84 c0                	test   %al,%al
+c0100ae2:	74 69                	je     c0100b4d <parse+0xb5>
             break;
         }
 
         // save and scan past next arg
         if (argc == MAXARGS - 1) {
-c0100b7d:	83 7d f4 0f          	cmpl   $0xf,-0xc(%ebp)
-c0100b81:	75 12                	jne    c0100b95 <parse+0x65>
+c0100ae4:	83 7d f4 0f          	cmpl   $0xf,-0xc(%ebp)
+c0100ae8:	75 14                	jne    c0100afe <parse+0x66>
             cprintf("Too many arguments (max %d).\n", MAXARGS);
-c0100b83:	83 ec 08             	sub    $0x8,%esp
-c0100b86:	6a 10                	push   $0x10
-c0100b88:	68 01 86 10 c0       	push   $0xc0108601
-c0100b8d:	e8 f0 f6 ff ff       	call   c0100282 <cprintf>
-c0100b92:	83 c4 10             	add    $0x10,%esp
+c0100aea:	c7 44 24 04 10 00 00 	movl   $0x10,0x4(%esp)
+c0100af1:	00 
+c0100af2:	c7 04 24 19 8d 10 c0 	movl   $0xc0108d19,(%esp)
+c0100af9:	e8 a3 f7 ff ff       	call   c01002a1 <cprintf>
         }
         argv[argc ++] = buf;
-c0100b95:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0100b98:	8d 50 01             	lea    0x1(%eax),%edx
-c0100b9b:	89 55 f4             	mov    %edx,-0xc(%ebp)
-c0100b9e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
-c0100ba5:	8b 45 0c             	mov    0xc(%ebp),%eax
-c0100ba8:	01 c2                	add    %eax,%edx
-c0100baa:	8b 45 08             	mov    0x8(%ebp),%eax
-c0100bad:	89 02                	mov    %eax,(%edx)
+c0100afe:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100b01:	8d 50 01             	lea    0x1(%eax),%edx
+c0100b04:	89 55 f4             	mov    %edx,-0xc(%ebp)
+c0100b07:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+c0100b0e:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0100b11:	01 c2                	add    %eax,%edx
+c0100b13:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100b16:	89 02                	mov    %eax,(%edx)
         while (*buf != '\0' && strchr(WHITESPACE, *buf) == NULL) {
-c0100baf:	eb 04                	jmp    c0100bb5 <parse+0x85>
+c0100b18:	eb 03                	jmp    c0100b1d <parse+0x85>
             buf ++;
-c0100bb1:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+c0100b1a:	ff 45 08             	incl   0x8(%ebp)
         // save and scan past next arg
         if (argc == MAXARGS - 1) {
             cprintf("Too many arguments (max %d).\n", MAXARGS);
         }
         argv[argc ++] = buf;
         while (*buf != '\0' && strchr(WHITESPACE, *buf) == NULL) {
-c0100bb5:	8b 45 08             	mov    0x8(%ebp),%eax
-c0100bb8:	0f b6 00             	movzbl (%eax),%eax
-c0100bbb:	84 c0                	test   %al,%al
-c0100bbd:	0f 84 7a ff ff ff    	je     c0100b3d <parse+0xd>
-c0100bc3:	8b 45 08             	mov    0x8(%ebp),%eax
-c0100bc6:	0f b6 00             	movzbl (%eax),%eax
-c0100bc9:	0f be c0             	movsbl %al,%eax
-c0100bcc:	83 ec 08             	sub    $0x8,%esp
-c0100bcf:	50                   	push   %eax
-c0100bd0:	68 fc 85 10 c0       	push   $0xc01085fc
-c0100bd5:	e8 6f 6d 00 00       	call   c0107949 <strchr>
-c0100bda:	83 c4 10             	add    $0x10,%esp
-c0100bdd:	85 c0                	test   %eax,%eax
-c0100bdf:	74 d0                	je     c0100bb1 <parse+0x81>
+c0100b1d:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100b20:	0f b6 00             	movzbl (%eax),%eax
+c0100b23:	84 c0                	test   %al,%al
+c0100b25:	0f 84 7a ff ff ff    	je     c0100aa5 <parse+0xd>
+c0100b2b:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100b2e:	0f b6 00             	movzbl (%eax),%eax
+c0100b31:	0f be c0             	movsbl %al,%eax
+c0100b34:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0100b38:	c7 04 24 14 8d 10 c0 	movl   $0xc0108d14,(%esp)
+c0100b3f:	e8 e6 74 00 00       	call   c010802a <strchr>
+c0100b44:	85 c0                	test   %eax,%eax
+c0100b46:	74 d2                	je     c0100b1a <parse+0x82>
             buf ++;
         }
     }
-c0100be1:	e9 57 ff ff ff       	jmp    c0100b3d <parse+0xd>
+c0100b48:	e9 58 ff ff ff       	jmp    c0100aa5 <parse+0xd>
         // find global whitespace
         while (*buf != '\0' && strchr(WHITESPACE, *buf) != NULL) {
             *buf ++ = '\0';
         }
         if (*buf == '\0') {
             break;
-c0100be6:	90                   	nop
+c0100b4d:	90                   	nop
         argv[argc ++] = buf;
         while (*buf != '\0' && strchr(WHITESPACE, *buf) == NULL) {
             buf ++;
         }
     }
     return argc;
-c0100be7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100b4e:	8b 45 f4             	mov    -0xc(%ebp),%eax
 }
-c0100bea:	c9                   	leave  
-c0100beb:	c3                   	ret    
+c0100b51:	c9                   	leave  
+c0100b52:	c3                   	ret    
 
-c0100bec <runcmd>:
+c0100b53 <runcmd>:
 /* *
  * runcmd - parse the input string, split it into separated arguments
  * and then lookup and invoke some related commands/
  * */
 static int
 runcmd(char *buf, struct trapframe *tf) {
-c0100bec:	55                   	push   %ebp
-c0100bed:	89 e5                	mov    %esp,%ebp
-c0100bef:	83 ec 58             	sub    $0x58,%esp
+c0100b53:	55                   	push   %ebp
+c0100b54:	89 e5                	mov    %esp,%ebp
+c0100b56:	53                   	push   %ebx
+c0100b57:	83 ec 64             	sub    $0x64,%esp
     char *argv[MAXARGS];
     int argc = parse(buf, argv);
-c0100bf2:	83 ec 08             	sub    $0x8,%esp
-c0100bf5:	8d 45 b0             	lea    -0x50(%ebp),%eax
-c0100bf8:	50                   	push   %eax
-c0100bf9:	ff 75 08             	pushl  0x8(%ebp)
-c0100bfc:	e8 2f ff ff ff       	call   c0100b30 <parse>
-c0100c01:	83 c4 10             	add    $0x10,%esp
-c0100c04:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0100b5a:	8d 45 b0             	lea    -0x50(%ebp),%eax
+c0100b5d:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0100b61:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100b64:	89 04 24             	mov    %eax,(%esp)
+c0100b67:	e8 2c ff ff ff       	call   c0100a98 <parse>
+c0100b6c:	89 45 f0             	mov    %eax,-0x10(%ebp)
     if (argc == 0) {
-c0100c07:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
-c0100c0b:	75 0a                	jne    c0100c17 <runcmd+0x2b>
+c0100b6f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c0100b73:	75 0a                	jne    c0100b7f <runcmd+0x2c>
         return 0;
-c0100c0d:	b8 00 00 00 00       	mov    $0x0,%eax
-c0100c12:	e9 83 00 00 00       	jmp    c0100c9a <runcmd+0xae>
+c0100b75:	b8 00 00 00 00       	mov    $0x0,%eax
+c0100b7a:	e9 83 00 00 00       	jmp    c0100c02 <runcmd+0xaf>
     }
     int i;
     for (i = 0; i < NCOMMANDS; i ++) {
-c0100c17:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
-c0100c1e:	eb 59                	jmp    c0100c79 <runcmd+0x8d>
+c0100b7f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+c0100b86:	eb 5a                	jmp    c0100be2 <runcmd+0x8f>
         if (strcmp(commands[i].name, argv[0]) == 0) {
-c0100c20:	8b 4d b0             	mov    -0x50(%ebp),%ecx
-c0100c23:	8b 55 f4             	mov    -0xc(%ebp),%edx
-c0100c26:	89 d0                	mov    %edx,%eax
-c0100c28:	01 c0                	add    %eax,%eax
-c0100c2a:	01 d0                	add    %edx,%eax
-c0100c2c:	c1 e0 02             	shl    $0x2,%eax
-c0100c2f:	05 00 f0 11 c0       	add    $0xc011f000,%eax
-c0100c34:	8b 00                	mov    (%eax),%eax
-c0100c36:	83 ec 08             	sub    $0x8,%esp
-c0100c39:	51                   	push   %ecx
-c0100c3a:	50                   	push   %eax
-c0100c3b:	e8 69 6c 00 00       	call   c01078a9 <strcmp>
-c0100c40:	83 c4 10             	add    $0x10,%esp
-c0100c43:	85 c0                	test   %eax,%eax
-c0100c45:	75 2e                	jne    c0100c75 <runcmd+0x89>
+c0100b88:	8b 4d b0             	mov    -0x50(%ebp),%ecx
+c0100b8b:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0100b8e:	89 d0                	mov    %edx,%eax
+c0100b90:	01 c0                	add    %eax,%eax
+c0100b92:	01 d0                	add    %edx,%eax
+c0100b94:	c1 e0 02             	shl    $0x2,%eax
+c0100b97:	05 00 00 12 c0       	add    $0xc0120000,%eax
+c0100b9c:	8b 00                	mov    (%eax),%eax
+c0100b9e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
+c0100ba2:	89 04 24             	mov    %eax,(%esp)
+c0100ba5:	e8 e3 73 00 00       	call   c0107f8d <strcmp>
+c0100baa:	85 c0                	test   %eax,%eax
+c0100bac:	75 31                	jne    c0100bdf <runcmd+0x8c>
             return commands[i].func(argc - 1, argv + 1, tf);
-c0100c47:	8b 55 f4             	mov    -0xc(%ebp),%edx
-c0100c4a:	89 d0                	mov    %edx,%eax
-c0100c4c:	01 c0                	add    %eax,%eax
-c0100c4e:	01 d0                	add    %edx,%eax
-c0100c50:	c1 e0 02             	shl    $0x2,%eax
-c0100c53:	05 08 f0 11 c0       	add    $0xc011f008,%eax
-c0100c58:	8b 10                	mov    (%eax),%edx
-c0100c5a:	8d 45 b0             	lea    -0x50(%ebp),%eax
-c0100c5d:	83 c0 04             	add    $0x4,%eax
-c0100c60:	8b 4d f0             	mov    -0x10(%ebp),%ecx
-c0100c63:	83 e9 01             	sub    $0x1,%ecx
-c0100c66:	83 ec 04             	sub    $0x4,%esp
-c0100c69:	ff 75 0c             	pushl  0xc(%ebp)
-c0100c6c:	50                   	push   %eax
-c0100c6d:	51                   	push   %ecx
-c0100c6e:	ff d2                	call   *%edx
-c0100c70:	83 c4 10             	add    $0x10,%esp
-c0100c73:	eb 25                	jmp    c0100c9a <runcmd+0xae>
+c0100bae:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0100bb1:	89 d0                	mov    %edx,%eax
+c0100bb3:	01 c0                	add    %eax,%eax
+c0100bb5:	01 d0                	add    %edx,%eax
+c0100bb7:	c1 e0 02             	shl    $0x2,%eax
+c0100bba:	05 08 00 12 c0       	add    $0xc0120008,%eax
+c0100bbf:	8b 10                	mov    (%eax),%edx
+c0100bc1:	8d 45 b0             	lea    -0x50(%ebp),%eax
+c0100bc4:	83 c0 04             	add    $0x4,%eax
+c0100bc7:	8b 4d f0             	mov    -0x10(%ebp),%ecx
+c0100bca:	8d 59 ff             	lea    -0x1(%ecx),%ebx
+c0100bcd:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+c0100bd0:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+c0100bd4:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0100bd8:	89 1c 24             	mov    %ebx,(%esp)
+c0100bdb:	ff d2                	call   *%edx
+c0100bdd:	eb 23                	jmp    c0100c02 <runcmd+0xaf>
     int argc = parse(buf, argv);
     if (argc == 0) {
         return 0;
     }
     int i;
     for (i = 0; i < NCOMMANDS; i ++) {
-c0100c75:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
-c0100c79:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0100c7c:	83 f8 02             	cmp    $0x2,%eax
-c0100c7f:	76 9f                	jbe    c0100c20 <runcmd+0x34>
+c0100bdf:	ff 45 f4             	incl   -0xc(%ebp)
+c0100be2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100be5:	83 f8 02             	cmp    $0x2,%eax
+c0100be8:	76 9e                	jbe    c0100b88 <runcmd+0x35>
         if (strcmp(commands[i].name, argv[0]) == 0) {
             return commands[i].func(argc - 1, argv + 1, tf);
         }
     }
     cprintf("Unknown command '%s'\n", argv[0]);
-c0100c81:	8b 45 b0             	mov    -0x50(%ebp),%eax
-c0100c84:	83 ec 08             	sub    $0x8,%esp
-c0100c87:	50                   	push   %eax
-c0100c88:	68 1f 86 10 c0       	push   $0xc010861f
-c0100c8d:	e8 f0 f5 ff ff       	call   c0100282 <cprintf>
-c0100c92:	83 c4 10             	add    $0x10,%esp
+c0100bea:	8b 45 b0             	mov    -0x50(%ebp),%eax
+c0100bed:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0100bf1:	c7 04 24 37 8d 10 c0 	movl   $0xc0108d37,(%esp)
+c0100bf8:	e8 a4 f6 ff ff       	call   c01002a1 <cprintf>
     return 0;
-c0100c95:	b8 00 00 00 00       	mov    $0x0,%eax
+c0100bfd:	b8 00 00 00 00       	mov    $0x0,%eax
 }
-c0100c9a:	c9                   	leave  
-c0100c9b:	c3                   	ret    
+c0100c02:	83 c4 64             	add    $0x64,%esp
+c0100c05:	5b                   	pop    %ebx
+c0100c06:	5d                   	pop    %ebp
+c0100c07:	c3                   	ret    
 
-c0100c9c <kmonitor>:
+c0100c08 <kmonitor>:
 
 /***** Implementations of basic kernel monitor commands *****/
 
 void
 kmonitor(struct trapframe *tf) {
-c0100c9c:	55                   	push   %ebp
-c0100c9d:	89 e5                	mov    %esp,%ebp
-c0100c9f:	83 ec 18             	sub    $0x18,%esp
+c0100c08:	55                   	push   %ebp
+c0100c09:	89 e5                	mov    %esp,%ebp
+c0100c0b:	83 ec 28             	sub    $0x28,%esp
     cprintf("Welcome to the kernel debug monitor!!\n");
-c0100ca2:	83 ec 0c             	sub    $0xc,%esp
-c0100ca5:	68 38 86 10 c0       	push   $0xc0108638
-c0100caa:	e8 d3 f5 ff ff       	call   c0100282 <cprintf>
-c0100caf:	83 c4 10             	add    $0x10,%esp
+c0100c0e:	c7 04 24 50 8d 10 c0 	movl   $0xc0108d50,(%esp)
+c0100c15:	e8 87 f6 ff ff       	call   c01002a1 <cprintf>
     cprintf("Type 'help' for a list of commands.\n");
-c0100cb2:	83 ec 0c             	sub    $0xc,%esp
-c0100cb5:	68 60 86 10 c0       	push   $0xc0108660
-c0100cba:	e8 c3 f5 ff ff       	call   c0100282 <cprintf>
-c0100cbf:	83 c4 10             	add    $0x10,%esp
+c0100c1a:	c7 04 24 78 8d 10 c0 	movl   $0xc0108d78,(%esp)
+c0100c21:	e8 7b f6 ff ff       	call   c01002a1 <cprintf>
 
     if (tf != NULL) {
-c0100cc2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
-c0100cc6:	74 0e                	je     c0100cd6 <kmonitor+0x3a>
+c0100c26:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+c0100c2a:	74 0b                	je     c0100c37 <kmonitor+0x2f>
         print_trapframe(tf);
-c0100cc8:	83 ec 0c             	sub    $0xc,%esp
-c0100ccb:	ff 75 08             	pushl  0x8(%ebp)
-c0100cce:	e8 73 15 00 00       	call   c0102246 <print_trapframe>
-c0100cd3:	83 c4 10             	add    $0x10,%esp
+c0100c2c:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100c2f:	89 04 24             	mov    %eax,(%esp)
+c0100c32:	e8 98 14 00 00       	call   c01020cf <print_trapframe>
     }
 
     char *buf;
     while (1) {
         if ((buf = readline("K> ")) != NULL) {
-c0100cd6:	83 ec 0c             	sub    $0xc,%esp
-c0100cd9:	68 85 86 10 c0       	push   $0xc0108685
-c0100cde:	e8 43 f6 ff ff       	call   c0100326 <readline>
-c0100ce3:	83 c4 10             	add    $0x10,%esp
-c0100ce6:	89 45 f4             	mov    %eax,-0xc(%ebp)
-c0100ce9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
-c0100ced:	74 e7                	je     c0100cd6 <kmonitor+0x3a>
+c0100c37:	c7 04 24 9d 8d 10 c0 	movl   $0xc0108d9d,(%esp)
+c0100c3e:	e8 00 f7 ff ff       	call   c0100343 <readline>
+c0100c43:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0100c46:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0100c4a:	74 eb                	je     c0100c37 <kmonitor+0x2f>
             if (runcmd(buf, tf) < 0) {
-c0100cef:	83 ec 08             	sub    $0x8,%esp
-c0100cf2:	ff 75 08             	pushl  0x8(%ebp)
-c0100cf5:	ff 75 f4             	pushl  -0xc(%ebp)
-c0100cf8:	e8 ef fe ff ff       	call   c0100bec <runcmd>
-c0100cfd:	83 c4 10             	add    $0x10,%esp
-c0100d00:	85 c0                	test   %eax,%eax
-c0100d02:	78 02                	js     c0100d06 <kmonitor+0x6a>
+c0100c4c:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100c4f:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0100c53:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100c56:	89 04 24             	mov    %eax,(%esp)
+c0100c59:	e8 f5 fe ff ff       	call   c0100b53 <runcmd>
+c0100c5e:	85 c0                	test   %eax,%eax
+c0100c60:	78 02                	js     c0100c64 <kmonitor+0x5c>
                 break;
             }
         }
     }
-c0100d04:	eb d0                	jmp    c0100cd6 <kmonitor+0x3a>
+c0100c62:	eb d3                	jmp    c0100c37 <kmonitor+0x2f>
 
     char *buf;
     while (1) {
         if ((buf = readline("K> ")) != NULL) {
             if (runcmd(buf, tf) < 0) {
                 break;
-c0100d06:	90                   	nop
+c0100c64:	90                   	nop
             }
         }
     }
 }
-c0100d07:	90                   	nop
-c0100d08:	c9                   	leave  
-c0100d09:	c3                   	ret    
+c0100c65:	90                   	nop
+c0100c66:	c9                   	leave  
+c0100c67:	c3                   	ret    
 
-c0100d0a <mon_help>:
+c0100c68 <mon_help>:
 
 /* mon_help - print the information about mon_* functions */
 int
 mon_help(int argc, char **argv, struct trapframe *tf) {
-c0100d0a:	55                   	push   %ebp
-c0100d0b:	89 e5                	mov    %esp,%ebp
-c0100d0d:	83 ec 18             	sub    $0x18,%esp
+c0100c68:	55                   	push   %ebp
+c0100c69:	89 e5                	mov    %esp,%ebp
+c0100c6b:	83 ec 28             	sub    $0x28,%esp
     int i;
     for (i = 0; i < NCOMMANDS; i ++) {
-c0100d10:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
-c0100d17:	eb 3c                	jmp    c0100d55 <mon_help+0x4b>
+c0100c6e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+c0100c75:	eb 3d                	jmp    c0100cb4 <mon_help+0x4c>
         cprintf("%s - %s\n", commands[i].name, commands[i].desc);
-c0100d19:	8b 55 f4             	mov    -0xc(%ebp),%edx
-c0100d1c:	89 d0                	mov    %edx,%eax
-c0100d1e:	01 c0                	add    %eax,%eax
-c0100d20:	01 d0                	add    %edx,%eax
-c0100d22:	c1 e0 02             	shl    $0x2,%eax
-c0100d25:	05 04 f0 11 c0       	add    $0xc011f004,%eax
-c0100d2a:	8b 08                	mov    (%eax),%ecx
-c0100d2c:	8b 55 f4             	mov    -0xc(%ebp),%edx
-c0100d2f:	89 d0                	mov    %edx,%eax
-c0100d31:	01 c0                	add    %eax,%eax
-c0100d33:	01 d0                	add    %edx,%eax
-c0100d35:	c1 e0 02             	shl    $0x2,%eax
-c0100d38:	05 00 f0 11 c0       	add    $0xc011f000,%eax
-c0100d3d:	8b 00                	mov    (%eax),%eax
-c0100d3f:	83 ec 04             	sub    $0x4,%esp
-c0100d42:	51                   	push   %ecx
-c0100d43:	50                   	push   %eax
-c0100d44:	68 89 86 10 c0       	push   $0xc0108689
-c0100d49:	e8 34 f5 ff ff       	call   c0100282 <cprintf>
-c0100d4e:	83 c4 10             	add    $0x10,%esp
+c0100c77:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0100c7a:	89 d0                	mov    %edx,%eax
+c0100c7c:	01 c0                	add    %eax,%eax
+c0100c7e:	01 d0                	add    %edx,%eax
+c0100c80:	c1 e0 02             	shl    $0x2,%eax
+c0100c83:	05 04 00 12 c0       	add    $0xc0120004,%eax
+c0100c88:	8b 08                	mov    (%eax),%ecx
+c0100c8a:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0100c8d:	89 d0                	mov    %edx,%eax
+c0100c8f:	01 c0                	add    %eax,%eax
+c0100c91:	01 d0                	add    %edx,%eax
+c0100c93:	c1 e0 02             	shl    $0x2,%eax
+c0100c96:	05 00 00 12 c0       	add    $0xc0120000,%eax
+c0100c9b:	8b 00                	mov    (%eax),%eax
+c0100c9d:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+c0100ca1:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0100ca5:	c7 04 24 a1 8d 10 c0 	movl   $0xc0108da1,(%esp)
+c0100cac:	e8 f0 f5 ff ff       	call   c01002a1 <cprintf>
 
 /* mon_help - print the information about mon_* functions */
 int
 mon_help(int argc, char **argv, struct trapframe *tf) {
     int i;
     for (i = 0; i < NCOMMANDS; i ++) {
-c0100d51:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
-c0100d55:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0100d58:	83 f8 02             	cmp    $0x2,%eax
-c0100d5b:	76 bc                	jbe    c0100d19 <mon_help+0xf>
+c0100cb1:	ff 45 f4             	incl   -0xc(%ebp)
+c0100cb4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0100cb7:	83 f8 02             	cmp    $0x2,%eax
+c0100cba:	76 bb                	jbe    c0100c77 <mon_help+0xf>
         cprintf("%s - %s\n", commands[i].name, commands[i].desc);
     }
     return 0;
-c0100d5d:	b8 00 00 00 00       	mov    $0x0,%eax
+c0100cbc:	b8 00 00 00 00       	mov    $0x0,%eax
 }
-c0100d62:	c9                   	leave  
-c0100d63:	c3                   	ret    
+c0100cc1:	c9                   	leave  
+c0100cc2:	c3                   	ret    
 
-c0100d64 <mon_kerninfo>:
+c0100cc3 <mon_kerninfo>:
 /* *
  * mon_kerninfo - call print_kerninfo in kern/debug/kdebug.c to
  * print the memory occupancy in kernel.
  * */
 int
 mon_kerninfo(int argc, char **argv, struct trapframe *tf) {
-c0100d64:	55                   	push   %ebp
-c0100d65:	89 e5                	mov    %esp,%ebp
-c0100d67:	83 ec 08             	sub    $0x8,%esp
+c0100cc3:	55                   	push   %ebp
+c0100cc4:	89 e5                	mov    %esp,%ebp
+c0100cc6:	83 ec 08             	sub    $0x8,%esp
     print_kerninfo();
-c0100d6a:	e8 b2 fb ff ff       	call   c0100921 <print_kerninfo>
+c0100cc9:	e8 79 fc ff ff       	call   c0100947 <print_kerninfo>
     return 0;
-c0100d6f:	b8 00 00 00 00       	mov    $0x0,%eax
+c0100cce:	b8 00 00 00 00       	mov    $0x0,%eax
 }
-c0100d74:	c9                   	leave  
-c0100d75:	c3                   	ret    
+c0100cd3:	c9                   	leave  
+c0100cd4:	c3                   	ret    
 
-c0100d76 <mon_backtrace>:
+c0100cd5 <mon_backtrace>:
 /* *
  * mon_backtrace - call print_stackframe in kern/debug/kdebug.c to
  * print a backtrace of the stack.
  * */
 int
 mon_backtrace(int argc, char **argv, struct trapframe *tf) {
-c0100d76:	55                   	push   %ebp
-c0100d77:	89 e5                	mov    %esp,%ebp
-c0100d79:	83 ec 08             	sub    $0x8,%esp
+c0100cd5:	55                   	push   %ebp
+c0100cd6:	89 e5                	mov    %esp,%ebp
+c0100cd8:	83 ec 08             	sub    $0x8,%esp
     print_stackframe();
-c0100d7c:	e8 ea fc ff ff       	call   c0100a6b <print_stackframe>
+c0100cdb:	e8 b2 fd ff ff       	call   c0100a92 <print_stackframe>
     return 0;
-c0100d81:	b8 00 00 00 00       	mov    $0x0,%eax
+c0100ce0:	b8 00 00 00 00       	mov    $0x0,%eax
 }
-c0100d86:	c9                   	leave  
-c0100d87:	c3                   	ret    
+c0100ce5:	c9                   	leave  
+c0100ce6:	c3                   	ret    
 
-c0100d88 <ide_wait_ready>:
+c0100ce7 <ide_wait_ready>:
     unsigned int size;          // Size in Sectors
     unsigned char model[41];    // Model in String
 } ide_devices[MAX_IDE];
 
 static int
 ide_wait_ready(unsigned short iobase, bool check_error) {
-c0100d88:	55                   	push   %ebp
-c0100d89:	89 e5                	mov    %esp,%ebp
-c0100d8b:	83 ec 14             	sub    $0x14,%esp
-c0100d8e:	8b 45 08             	mov    0x8(%ebp),%eax
-c0100d91:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
+c0100ce7:	55                   	push   %ebp
+c0100ce8:	89 e5                	mov    %esp,%ebp
+c0100cea:	83 ec 14             	sub    $0x14,%esp
+c0100ced:	8b 45 08             	mov    0x8(%ebp),%eax
+c0100cf0:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
     int r;
     while ((r = inb(iobase + ISA_STATUS)) & IDE_BSY)
-c0100d95:	90                   	nop
-c0100d96:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
-c0100d9a:	83 c0 07             	add    $0x7,%eax
-c0100d9d:	0f b7 c0             	movzwl %ax,%eax
-c0100da0:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
+c0100cf4:	90                   	nop
+c0100cf5:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0100cf8:	83 c0 07             	add    $0x7,%eax
+c0100cfb:	0f b7 c0             	movzwl %ax,%eax
+c0100cfe:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
 static inline void invlpg(void *addr) __attribute__((always_inline));
 
 static inline uint8_t
 inb(uint16_t port) {
     uint8_t data;
     asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
-c0100da4:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
-c0100da8:	89 c2                	mov    %eax,%edx
-c0100daa:	ec                   	in     (%dx),%al
-c0100dab:	88 45 f9             	mov    %al,-0x7(%ebp)
+c0100d02:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
+c0100d06:	89 c2                	mov    %eax,%edx
+c0100d08:	ec                   	in     (%dx),%al
+c0100d09:	88 45 f9             	mov    %al,-0x7(%ebp)
     return data;
-c0100dae:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
-c0100db2:	0f b6 c0             	movzbl %al,%eax
-c0100db5:	89 45 fc             	mov    %eax,-0x4(%ebp)
-c0100db8:	8b 45 fc             	mov    -0x4(%ebp),%eax
-c0100dbb:	25 80 00 00 00       	and    $0x80,%eax
-c0100dc0:	85 c0                	test   %eax,%eax
-c0100dc2:	75 d2                	jne    c0100d96 <ide_wait_ready+0xe>
+c0100d0c:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
+c0100d10:	0f b6 c0             	movzbl %al,%eax
+c0100d13:	89 45 fc             	mov    %eax,-0x4(%ebp)
+c0100d16:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0100d19:	25 80 00 00 00       	and    $0x80,%eax
+c0100d1e:	85 c0                	test   %eax,%eax
+c0100d20:	75 d3                	jne    c0100cf5 <ide_wait_ready+0xe>
         /* nothing */;
     if (check_error && (r & (IDE_DF | IDE_ERR)) != 0) {
-c0100dc4:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
-c0100dc8:	74 11                	je     c0100ddb <ide_wait_ready+0x53>
-c0100dca:	8b 45 fc             	mov    -0x4(%ebp),%eax
-c0100dcd:	83 e0 21             	and    $0x21,%eax
-c0100dd0:	85 c0                	test   %eax,%eax
-c0100dd2:	74 07                	je     c0100ddb <ide_wait_ready+0x53>
+c0100d22:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+c0100d26:	74 11                	je     c0100d39 <ide_wait_ready+0x52>
+c0100d28:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0100d2b:	83 e0 21             	and    $0x21,%eax
+c0100d2e:	85 c0                	test   %eax,%eax
+c0100d30:	74 07                	je     c0100d39 <ide_wait_ready+0x52>
         return -1;
-c0100dd4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-c0100dd9:	eb 05                	jmp    c0100de0 <ide_wait_ready+0x58>
+c0100d32:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+c0100d37:	eb 05                	jmp    c0100d3e <ide_wait_ready+0x57>
     }
     return 0;
-c0100ddb:	b8 00 00 00 00       	mov    $0x0,%eax
+c0100d39:	b8 00 00 00 00       	mov    $0x0,%eax
 }
-c0100de0:	c9                   	leave  
-c0100de1:	c3                   	ret    
+c0100d3e:	c9                   	leave  
+c0100d3f:	c3                   	ret    
 
-c0100de2 <ide_init>:
+c0100d40 <ide_init>:
 
 void
 ide_init(void) {
-c0100de2:	55                   	push   %ebp
-c0100de3:	89 e5                	mov    %esp,%ebp
-c0100de5:	57                   	push   %edi
-c0100de6:	53                   	push   %ebx
-c0100de7:	81 ec 40 02 00 00    	sub    $0x240,%esp
+c0100d40:	55                   	push   %ebp
+c0100d41:	89 e5                	mov    %esp,%ebp
+c0100d43:	57                   	push   %edi
+c0100d44:	53                   	push   %ebx
+c0100d45:	81 ec 50 02 00 00    	sub    $0x250,%esp
     static_assert((SECTSIZE % 4) == 0);
     unsigned short ideno, iobase;
     for (ideno = 0; ideno < MAX_IDE; ideno ++) {
-c0100ded:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%ebp)
-c0100df3:	e9 c1 02 00 00       	jmp    c01010b9 <ide_init+0x2d7>
+c0100d4b:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%ebp)
+c0100d51:	e9 d4 02 00 00       	jmp    c010102a <ide_init+0x2ea>
         /* assume that no device here */
         ide_devices[ideno].valid = 0;
-c0100df8:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
-c0100dfc:	c1 e0 03             	shl    $0x3,%eax
-c0100dff:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
-c0100e06:	29 c2                	sub    %eax,%edx
-c0100e08:	89 d0                	mov    %edx,%eax
-c0100e0a:	05 40 24 12 c0       	add    $0xc0122440,%eax
-c0100e0f:	c6 00 00             	movb   $0x0,(%eax)
+c0100d56:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
+c0100d5a:	c1 e0 03             	shl    $0x3,%eax
+c0100d5d:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+c0100d64:	29 c2                	sub    %eax,%edx
+c0100d66:	89 d0                	mov    %edx,%eax
+c0100d68:	05 40 34 12 c0       	add    $0xc0123440,%eax
+c0100d6d:	c6 00 00             	movb   $0x0,(%eax)
 
         iobase = IO_BASE(ideno);
-c0100e12:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
-c0100e16:	66 d1 e8             	shr    %ax
-c0100e19:	0f b7 c0             	movzwl %ax,%eax
-c0100e1c:	0f b7 04 85 94 86 10 	movzwl -0x3fef796c(,%eax,4),%eax
-c0100e23:	c0 
-c0100e24:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
+c0100d70:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
+c0100d74:	d1 e8                	shr    %eax
+c0100d76:	0f b7 c0             	movzwl %ax,%eax
+c0100d79:	8b 04 85 ac 8d 10 c0 	mov    -0x3fef7254(,%eax,4),%eax
+c0100d80:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
 
         /* wait device ready */
         ide_wait_ready(iobase, 0);
-c0100e28:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
-c0100e2c:	6a 00                	push   $0x0
-c0100e2e:	50                   	push   %eax
-c0100e2f:	e8 54 ff ff ff       	call   c0100d88 <ide_wait_ready>
-c0100e34:	83 c4 08             	add    $0x8,%esp
+c0100d84:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
+c0100d88:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+c0100d8f:	00 
+c0100d90:	89 04 24             	mov    %eax,(%esp)
+c0100d93:	e8 4f ff ff ff       	call   c0100ce7 <ide_wait_ready>
 
         /* step1: select drive */
         outb(iobase + ISA_SDH, 0xE0 | ((ideno & 1) << 4));
-c0100e37:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
-c0100e3b:	83 e0 01             	and    $0x1,%eax
-c0100e3e:	c1 e0 04             	shl    $0x4,%eax
-c0100e41:	83 c8 e0             	or     $0xffffffe0,%eax
-c0100e44:	0f b6 c0             	movzbl %al,%eax
-c0100e47:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
-c0100e4b:	83 c2 06             	add    $0x6,%edx
-c0100e4e:	0f b7 d2             	movzwl %dx,%edx
-c0100e51:	66 89 55 e2          	mov    %dx,-0x1e(%ebp)
-c0100e55:	88 45 c7             	mov    %al,-0x39(%ebp)
+c0100d98:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
+c0100d9c:	83 e0 01             	and    $0x1,%eax
+c0100d9f:	c1 e0 04             	shl    $0x4,%eax
+c0100da2:	0c e0                	or     $0xe0,%al
+c0100da4:	0f b6 c0             	movzbl %al,%eax
+c0100da7:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
+c0100dab:	83 c2 06             	add    $0x6,%edx
+c0100dae:	0f b7 d2             	movzwl %dx,%edx
+c0100db1:	66 89 55 e2          	mov    %dx,-0x1e(%ebp)
+c0100db5:	88 45 c7             	mov    %al,-0x39(%ebp)
         : "memory", "cc");
 }
 
 static inline void
 outb(uint16_t port, uint8_t data) {
     asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
-c0100e58:	0f b6 45 c7          	movzbl -0x39(%ebp),%eax
-c0100e5c:	0f b7 55 e2          	movzwl -0x1e(%ebp),%edx
-c0100e60:	ee                   	out    %al,(%dx)
+c0100db8:	0f b6 45 c7          	movzbl -0x39(%ebp),%eax
+c0100dbc:	0f b7 55 e2          	movzwl -0x1e(%ebp),%edx
+c0100dc0:	ee                   	out    %al,(%dx)
         ide_wait_ready(iobase, 0);
-c0100e61:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
-c0100e65:	6a 00                	push   $0x0
-c0100e67:	50                   	push   %eax
-c0100e68:	e8 1b ff ff ff       	call   c0100d88 <ide_wait_ready>
-c0100e6d:	83 c4 08             	add    $0x8,%esp
+c0100dc1:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
+c0100dc5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+c0100dcc:	00 
+c0100dcd:	89 04 24             	mov    %eax,(%esp)
+c0100dd0:	e8 12 ff ff ff       	call   c0100ce7 <ide_wait_ready>
 
         /* step2: send ATA identify command */
         outb(iobase + ISA_COMMAND, IDE_CMD_IDENTIFY);
-c0100e70:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
-c0100e74:	83 c0 07             	add    $0x7,%eax
-c0100e77:	0f b7 c0             	movzwl %ax,%eax
-c0100e7a:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
-c0100e7e:	c6 45 c8 ec          	movb   $0xec,-0x38(%ebp)
-c0100e82:	0f b6 45 c8          	movzbl -0x38(%ebp),%eax
-c0100e86:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
-c0100e8a:	ee                   	out    %al,(%dx)
+c0100dd5:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
+c0100dd9:	83 c0 07             	add    $0x7,%eax
+c0100ddc:	0f b7 c0             	movzwl %ax,%eax
+c0100ddf:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
+c0100de3:	c6 45 c8 ec          	movb   $0xec,-0x38(%ebp)
+c0100de7:	0f b6 45 c8          	movzbl -0x38(%ebp),%eax
+c0100deb:	8b 55 e0             	mov    -0x20(%ebp),%edx
+c0100dee:	ee                   	out    %al,(%dx)
         ide_wait_ready(iobase, 0);
-c0100e8b:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
-c0100e8f:	6a 00                	push   $0x0
-c0100e91:	50                   	push   %eax
-c0100e92:	e8 f1 fe ff ff       	call   c0100d88 <ide_wait_ready>
-c0100e97:	83 c4 08             	add    $0x8,%esp
+c0100def:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
+c0100df3:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+c0100dfa:	00 
+c0100dfb:	89 04 24             	mov    %eax,(%esp)
+c0100dfe:	e8 e4 fe ff ff       	call   c0100ce7 <ide_wait_ready>
 
         /* step3: polling */
         if (inb(iobase + ISA_STATUS) == 0 || ide_wait_ready(iobase, 1) != 0) {
-c0100e9a:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
-c0100e9e:	83 c0 07             	add    $0x7,%eax
-c0100ea1:	0f b7 c0             	movzwl %ax,%eax
-c0100ea4:	66 89 45 ca          	mov    %ax,-0x36(%ebp)
+c0100e03:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
+c0100e07:	83 c0 07             	add    $0x7,%eax
+c0100e0a:	0f b7 c0             	movzwl %ax,%eax
+c0100e0d:	66 89 45 ca          	mov    %ax,-0x36(%ebp)
 static inline void invlpg(void *addr) __attribute__((always_inline));
 
 static inline uint8_t
 inb(uint16_t port) {
     uint8_t data;
     asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
-c0100ea8:	0f b7 45 ca          	movzwl -0x36(%ebp),%eax
-c0100eac:	89 c2                	mov    %eax,%edx
-c0100eae:	ec                   	in     (%dx),%al
-c0100eaf:	88 45 c9             	mov    %al,-0x37(%ebp)
+c0100e11:	0f b7 45 ca          	movzwl -0x36(%ebp),%eax
+c0100e15:	89 c2                	mov    %eax,%edx
+c0100e17:	ec                   	in     (%dx),%al
+c0100e18:	88 45 c9             	mov    %al,-0x37(%ebp)
     return data;
-c0100eb2:	0f b6 45 c9          	movzbl -0x37(%ebp),%eax
-c0100eb6:	84 c0                	test   %al,%al
-c0100eb8:	0f 84 ef 01 00 00    	je     c01010ad <ide_init+0x2cb>
-c0100ebe:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
-c0100ec2:	6a 01                	push   $0x1
-c0100ec4:	50                   	push   %eax
-c0100ec5:	e8 be fe ff ff       	call   c0100d88 <ide_wait_ready>
-c0100eca:	83 c4 08             	add    $0x8,%esp
-c0100ecd:	85 c0                	test   %eax,%eax
-c0100ecf:	0f 85 d8 01 00 00    	jne    c01010ad <ide_init+0x2cb>
+c0100e1b:	0f b6 45 c9          	movzbl -0x37(%ebp),%eax
+c0100e1f:	84 c0                	test   %al,%al
+c0100e21:	0f 84 f9 01 00 00    	je     c0101020 <ide_init+0x2e0>
+c0100e27:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
+c0100e2b:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+c0100e32:	00 
+c0100e33:	89 04 24             	mov    %eax,(%esp)
+c0100e36:	e8 ac fe ff ff       	call   c0100ce7 <ide_wait_ready>
+c0100e3b:	85 c0                	test   %eax,%eax
+c0100e3d:	0f 85 dd 01 00 00    	jne    c0101020 <ide_init+0x2e0>
             continue ;
         }
 
         /* device is ok */
         ide_devices[ideno].valid = 1;
-c0100ed5:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
-c0100ed9:	c1 e0 03             	shl    $0x3,%eax
-c0100edc:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
-c0100ee3:	29 c2                	sub    %eax,%edx
-c0100ee5:	89 d0                	mov    %edx,%eax
-c0100ee7:	05 40 24 12 c0       	add    $0xc0122440,%eax
-c0100eec:	c6 00 01             	movb   $0x1,(%eax)
+c0100e43:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
+c0100e47:	c1 e0 03             	shl    $0x3,%eax
+c0100e4a:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+c0100e51:	29 c2                	sub    %eax,%edx
+c0100e53:	89 d0                	mov    %edx,%eax
+c0100e55:	05 40 34 12 c0       	add    $0xc0123440,%eax
+c0100e5a:	c6 00 01             	movb   $0x1,(%eax)
 
         /* read identification space of the device */
         unsigned int buffer[128];
         insl(iobase + ISA_DATA, buffer, sizeof(buffer) / sizeof(unsigned int));
-c0100eef:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
-c0100ef3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
-c0100ef6:	8d 85 bc fd ff ff    	lea    -0x244(%ebp),%eax
-c0100efc:	89 45 c0             	mov    %eax,-0x40(%ebp)
-c0100eff:	c7 45 bc 80 00 00 00 	movl   $0x80,-0x44(%ebp)
+c0100e5d:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
+c0100e61:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+c0100e64:	8d 85 bc fd ff ff    	lea    -0x244(%ebp),%eax
+c0100e6a:	89 45 c0             	mov    %eax,-0x40(%ebp)
+c0100e6d:	c7 45 bc 80 00 00 00 	movl   $0x80,-0x44(%ebp)
 }
 
 static inline void
 insl(uint32_t port, void *addr, int cnt) {
     asm volatile (
-c0100f06:	8b 55 e4             	mov    -0x1c(%ebp),%edx
-c0100f09:	8b 4d c0             	mov    -0x40(%ebp),%ecx
-c0100f0c:	8b 45 bc             	mov    -0x44(%ebp),%eax
-c0100f0f:	89 cb                	mov    %ecx,%ebx
-c0100f11:	89 df                	mov    %ebx,%edi
-c0100f13:	89 c1                	mov    %eax,%ecx
-c0100f15:	fc                   	cld    
-c0100f16:	f2 6d                	repnz insl (%dx),%es:(%edi)
-c0100f18:	89 c8                	mov    %ecx,%eax
-c0100f1a:	89 fb                	mov    %edi,%ebx
-c0100f1c:	89 5d c0             	mov    %ebx,-0x40(%ebp)
-c0100f1f:	89 45 bc             	mov    %eax,-0x44(%ebp)
+c0100e74:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c0100e77:	8b 4d c0             	mov    -0x40(%ebp),%ecx
+c0100e7a:	8b 45 bc             	mov    -0x44(%ebp),%eax
+c0100e7d:	89 cb                	mov    %ecx,%ebx
+c0100e7f:	89 df                	mov    %ebx,%edi
+c0100e81:	89 c1                	mov    %eax,%ecx
+c0100e83:	fc                   	cld    
+c0100e84:	f2 6d                	repnz insl (%dx),%es:(%edi)
+c0100e86:	89 c8                	mov    %ecx,%eax
+c0100e88:	89 fb                	mov    %edi,%ebx
+c0100e8a:	89 5d c0             	mov    %ebx,-0x40(%ebp)
+c0100e8d:	89 45 bc             	mov    %eax,-0x44(%ebp)
 
         unsigned char *ident = (unsigned char *)buffer;
-c0100f22:	8d 85 bc fd ff ff    	lea    -0x244(%ebp),%eax
-c0100f28:	89 45 dc             	mov    %eax,-0x24(%ebp)
+c0100e90:	8d 85 bc fd ff ff    	lea    -0x244(%ebp),%eax
+c0100e96:	89 45 dc             	mov    %eax,-0x24(%ebp)
         unsigned int sectors;
         unsigned int cmdsets = *(unsigned int *)(ident + IDE_IDENT_CMDSETS);
-c0100f2b:	8b 45 dc             	mov    -0x24(%ebp),%eax
-c0100f2e:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
-c0100f34:	89 45 d8             	mov    %eax,-0x28(%ebp)
+c0100e99:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0100e9c:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
+c0100ea2:	89 45 d8             	mov    %eax,-0x28(%ebp)
         /* device use 48-bits or 28-bits addressing */
         if (cmdsets & (1 << 26)) {
-c0100f37:	8b 45 d8             	mov    -0x28(%ebp),%eax
-c0100f3a:	25 00 00 00 04       	and    $0x4000000,%eax
-c0100f3f:	85 c0                	test   %eax,%eax
-c0100f41:	74 0e                	je     c0100f51 <ide_init+0x16f>
+c0100ea5:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c0100ea8:	25 00 00 00 04       	and    $0x4000000,%eax
+c0100ead:	85 c0                	test   %eax,%eax
+c0100eaf:	74 0e                	je     c0100ebf <ide_init+0x17f>
             sectors = *(unsigned int *)(ident + IDE_IDENT_MAX_LBA_EXT);
-c0100f43:	8b 45 dc             	mov    -0x24(%ebp),%eax
-c0100f46:	8b 80 c8 00 00 00    	mov    0xc8(%eax),%eax
-c0100f4c:	89 45 f0             	mov    %eax,-0x10(%ebp)
-c0100f4f:	eb 09                	jmp    c0100f5a <ide_init+0x178>
+c0100eb1:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0100eb4:	8b 80 c8 00 00 00    	mov    0xc8(%eax),%eax
+c0100eba:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0100ebd:	eb 09                	jmp    c0100ec8 <ide_init+0x188>
         }
         else {
             sectors = *(unsigned int *)(ident + IDE_IDENT_MAX_LBA);
-c0100f51:	8b 45 dc             	mov    -0x24(%ebp),%eax
-c0100f54:	8b 40 78             	mov    0x78(%eax),%eax
-c0100f57:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0100ebf:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0100ec2:	8b 40 78             	mov    0x78(%eax),%eax
+c0100ec5:	89 45 f0             	mov    %eax,-0x10(%ebp)
         }
         ide_devices[ideno].sets = cmdsets;
-c0100f5a:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
-c0100f5e:	c1 e0 03             	shl    $0x3,%eax
-c0100f61:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
-c0100f68:	29 c2                	sub    %eax,%edx
-c0100f6a:	89 d0                	mov    %edx,%eax
-c0100f6c:	8d 90 44 24 12 c0    	lea    -0x3feddbbc(%eax),%edx
-c0100f72:	8b 45 d8             	mov    -0x28(%ebp),%eax
-c0100f75:	89 02                	mov    %eax,(%edx)
+c0100ec8:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
+c0100ecc:	c1 e0 03             	shl    $0x3,%eax
+c0100ecf:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+c0100ed6:	29 c2                	sub    %eax,%edx
+c0100ed8:	89 d0                	mov    %edx,%eax
+c0100eda:	8d 90 44 34 12 c0    	lea    -0x3fedcbbc(%eax),%edx
+c0100ee0:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c0100ee3:	89 02                	mov    %eax,(%edx)
         ide_devices[ideno].size = sectors;
-c0100f77:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
-c0100f7b:	c1 e0 03             	shl    $0x3,%eax
-c0100f7e:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
-c0100f85:	29 c2                	sub    %eax,%edx
-c0100f87:	89 d0                	mov    %edx,%eax
-c0100f89:	8d 90 48 24 12 c0    	lea    -0x3feddbb8(%eax),%edx
-c0100f8f:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0100f92:	89 02                	mov    %eax,(%edx)
+c0100ee5:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
+c0100ee9:	c1 e0 03             	shl    $0x3,%eax
+c0100eec:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+c0100ef3:	29 c2                	sub    %eax,%edx
+c0100ef5:	89 d0                	mov    %edx,%eax
+c0100ef7:	8d 90 48 34 12 c0    	lea    -0x3fedcbb8(%eax),%edx
+c0100efd:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0100f00:	89 02                	mov    %eax,(%edx)
 
         /* check if supports LBA */
         assert((*(unsigned short *)(ident + IDE_IDENT_CAPABILITIES) & 0x200) != 0);
-c0100f94:	8b 45 dc             	mov    -0x24(%ebp),%eax
-c0100f97:	83 c0 62             	add    $0x62,%eax
-c0100f9a:	0f b7 00             	movzwl (%eax),%eax
-c0100f9d:	0f b7 c0             	movzwl %ax,%eax
-c0100fa0:	25 00 02 00 00       	and    $0x200,%eax
-c0100fa5:	85 c0                	test   %eax,%eax
-c0100fa7:	75 16                	jne    c0100fbf <ide_init+0x1dd>
-c0100fa9:	68 9c 86 10 c0       	push   $0xc010869c
-c0100fae:	68 df 86 10 c0       	push   $0xc01086df
-c0100fb3:	6a 7d                	push   $0x7d
-c0100fb5:	68 f4 86 10 c0       	push   $0xc01086f4
-c0100fba:	e8 29 f4 ff ff       	call   c01003e8 <__panic>
+c0100f02:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0100f05:	83 c0 62             	add    $0x62,%eax
+c0100f08:	0f b7 00             	movzwl (%eax),%eax
+c0100f0b:	25 00 02 00 00       	and    $0x200,%eax
+c0100f10:	85 c0                	test   %eax,%eax
+c0100f12:	75 24                	jne    c0100f38 <ide_init+0x1f8>
+c0100f14:	c7 44 24 0c b4 8d 10 	movl   $0xc0108db4,0xc(%esp)
+c0100f1b:	c0 
+c0100f1c:	c7 44 24 08 f7 8d 10 	movl   $0xc0108df7,0x8(%esp)
+c0100f23:	c0 
+c0100f24:	c7 44 24 04 7d 00 00 	movl   $0x7d,0x4(%esp)
+c0100f2b:	00 
+c0100f2c:	c7 04 24 0c 8e 10 c0 	movl   $0xc0108e0c,(%esp)
+c0100f33:	e8 c0 f4 ff ff       	call   c01003f8 <__panic>
 
         unsigned char *model = ide_devices[ideno].model, *data = ident + IDE_IDENT_MODEL;
-c0100fbf:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
-c0100fc3:	89 c2                	mov    %eax,%edx
-c0100fc5:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
-c0100fcc:	89 c2                	mov    %eax,%edx
-c0100fce:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
-c0100fd5:	29 d0                	sub    %edx,%eax
-c0100fd7:	05 40 24 12 c0       	add    $0xc0122440,%eax
-c0100fdc:	83 c0 0c             	add    $0xc,%eax
-c0100fdf:	89 45 d4             	mov    %eax,-0x2c(%ebp)
-c0100fe2:	8b 45 dc             	mov    -0x24(%ebp),%eax
-c0100fe5:	83 c0 36             	add    $0x36,%eax
-c0100fe8:	89 45 d0             	mov    %eax,-0x30(%ebp)
+c0100f38:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
+c0100f3c:	c1 e0 03             	shl    $0x3,%eax
+c0100f3f:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+c0100f46:	29 c2                	sub    %eax,%edx
+c0100f48:	8d 82 40 34 12 c0    	lea    -0x3fedcbc0(%edx),%eax
+c0100f4e:	83 c0 0c             	add    $0xc,%eax
+c0100f51:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+c0100f54:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0100f57:	83 c0 36             	add    $0x36,%eax
+c0100f5a:	89 45 d0             	mov    %eax,-0x30(%ebp)
         unsigned int i, length = 40;
-c0100feb:	c7 45 cc 28 00 00 00 	movl   $0x28,-0x34(%ebp)
+c0100f5d:	c7 45 cc 28 00 00 00 	movl   $0x28,-0x34(%ebp)
         for (i = 0; i < length; i += 2) {
-c0100ff2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
-c0100ff9:	eb 34                	jmp    c010102f <ide_init+0x24d>
+c0100f64:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+c0100f6b:	eb 34                	jmp    c0100fa1 <ide_init+0x261>
             model[i] = data[i + 1], model[i + 1] = data[i];
-c0100ffb:	8b 55 d4             	mov    -0x2c(%ebp),%edx
-c0100ffe:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c0101001:	01 c2                	add    %eax,%edx
-c0101003:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c0101006:	8d 48 01             	lea    0x1(%eax),%ecx
-c0101009:	8b 45 d0             	mov    -0x30(%ebp),%eax
-c010100c:	01 c8                	add    %ecx,%eax
-c010100e:	0f b6 00             	movzbl (%eax),%eax
-c0101011:	88 02                	mov    %al,(%edx)
-c0101013:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c0101016:	8d 50 01             	lea    0x1(%eax),%edx
-c0101019:	8b 45 d4             	mov    -0x2c(%ebp),%eax
-c010101c:	01 c2                	add    %eax,%edx
-c010101e:	8b 4d d0             	mov    -0x30(%ebp),%ecx
-c0101021:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c0101024:	01 c8                	add    %ecx,%eax
-c0101026:	0f b6 00             	movzbl (%eax),%eax
-c0101029:	88 02                	mov    %al,(%edx)
+c0100f6d:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c0100f70:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0100f73:	01 c2                	add    %eax,%edx
+c0100f75:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0100f78:	8d 48 01             	lea    0x1(%eax),%ecx
+c0100f7b:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c0100f7e:	01 c8                	add    %ecx,%eax
+c0100f80:	0f b6 00             	movzbl (%eax),%eax
+c0100f83:	88 02                	mov    %al,(%edx)
+c0100f85:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0100f88:	8d 50 01             	lea    0x1(%eax),%edx
+c0100f8b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+c0100f8e:	01 c2                	add    %eax,%edx
+c0100f90:	8b 4d d0             	mov    -0x30(%ebp),%ecx
+c0100f93:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0100f96:	01 c8                	add    %ecx,%eax
+c0100f98:	0f b6 00             	movzbl (%eax),%eax
+c0100f9b:	88 02                	mov    %al,(%edx)
         /* check if supports LBA */
         assert((*(unsigned short *)(ident + IDE_IDENT_CAPABILITIES) & 0x200) != 0);
 
         unsigned char *model = ide_devices[ideno].model, *data = ident + IDE_IDENT_MODEL;
         unsigned int i, length = 40;
         for (i = 0; i < length; i += 2) {
-c010102b:	83 45 ec 02          	addl   $0x2,-0x14(%ebp)
-c010102f:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c0101032:	3b 45 cc             	cmp    -0x34(%ebp),%eax
-c0101035:	72 c4                	jb     c0100ffb <ide_init+0x219>
+c0100f9d:	83 45 ec 02          	addl   $0x2,-0x14(%ebp)
+c0100fa1:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0100fa4:	3b 45 cc             	cmp    -0x34(%ebp),%eax
+c0100fa7:	72 c4                	jb     c0100f6d <ide_init+0x22d>
             model[i] = data[i + 1], model[i + 1] = data[i];
         }
         do {
             model[i] = '\0';
-c0101037:	8b 55 d4             	mov    -0x2c(%ebp),%edx
-c010103a:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c010103d:	01 d0                	add    %edx,%eax
-c010103f:	c6 00 00             	movb   $0x0,(%eax)
+c0100fa9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c0100fac:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0100faf:	01 d0                	add    %edx,%eax
+c0100fb1:	c6 00 00             	movb   $0x0,(%eax)
         } while (i -- > 0 && model[i] == ' ');
-c0101042:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c0101045:	8d 50 ff             	lea    -0x1(%eax),%edx
-c0101048:	89 55 ec             	mov    %edx,-0x14(%ebp)
-c010104b:	85 c0                	test   %eax,%eax
-c010104d:	74 0f                	je     c010105e <ide_init+0x27c>
-c010104f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
-c0101052:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c0101055:	01 d0                	add    %edx,%eax
-c0101057:	0f b6 00             	movzbl (%eax),%eax
-c010105a:	3c 20                	cmp    $0x20,%al
-c010105c:	74 d9                	je     c0101037 <ide_init+0x255>
+c0100fb4:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0100fb7:	8d 50 ff             	lea    -0x1(%eax),%edx
+c0100fba:	89 55 ec             	mov    %edx,-0x14(%ebp)
+c0100fbd:	85 c0                	test   %eax,%eax
+c0100fbf:	74 0f                	je     c0100fd0 <ide_init+0x290>
+c0100fc1:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c0100fc4:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0100fc7:	01 d0                	add    %edx,%eax
+c0100fc9:	0f b6 00             	movzbl (%eax),%eax
+c0100fcc:	3c 20                	cmp    $0x20,%al
+c0100fce:	74 d9                	je     c0100fa9 <ide_init+0x269>
 
         cprintf("ide %d: %10u(sectors), '%s'.\n", ideno, ide_devices[ideno].size, ide_devices[ideno].model);
-c010105e:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
-c0101062:	89 c2                	mov    %eax,%edx
-c0101064:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
-c010106b:	89 c2                	mov    %eax,%edx
-c010106d:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
-c0101074:	29 d0                	sub    %edx,%eax
-c0101076:	05 40 24 12 c0       	add    $0xc0122440,%eax
-c010107b:	8d 48 0c             	lea    0xc(%eax),%ecx
-c010107e:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
-c0101082:	c1 e0 03             	shl    $0x3,%eax
-c0101085:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
-c010108c:	29 c2                	sub    %eax,%edx
-c010108e:	89 d0                	mov    %edx,%eax
-c0101090:	05 48 24 12 c0       	add    $0xc0122448,%eax
-c0101095:	8b 10                	mov    (%eax),%edx
-c0101097:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
-c010109b:	51                   	push   %ecx
-c010109c:	52                   	push   %edx
-c010109d:	50                   	push   %eax
-c010109e:	68 06 87 10 c0       	push   $0xc0108706
-c01010a3:	e8 da f1 ff ff       	call   c0100282 <cprintf>
-c01010a8:	83 c4 10             	add    $0x10,%esp
-c01010ab:	eb 01                	jmp    c01010ae <ide_init+0x2cc>
+c0100fd0:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
+c0100fd4:	c1 e0 03             	shl    $0x3,%eax
+c0100fd7:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+c0100fde:	29 c2                	sub    %eax,%edx
+c0100fe0:	8d 82 40 34 12 c0    	lea    -0x3fedcbc0(%edx),%eax
+c0100fe6:	8d 48 0c             	lea    0xc(%eax),%ecx
+c0100fe9:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
+c0100fed:	c1 e0 03             	shl    $0x3,%eax
+c0100ff0:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+c0100ff7:	29 c2                	sub    %eax,%edx
+c0100ff9:	89 d0                	mov    %edx,%eax
+c0100ffb:	05 48 34 12 c0       	add    $0xc0123448,%eax
+c0101000:	8b 10                	mov    (%eax),%edx
+c0101002:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
+c0101006:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
+c010100a:	89 54 24 08          	mov    %edx,0x8(%esp)
+c010100e:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0101012:	c7 04 24 1e 8e 10 c0 	movl   $0xc0108e1e,(%esp)
+c0101019:	e8 83 f2 ff ff       	call   c01002a1 <cprintf>
+c010101e:	eb 01                	jmp    c0101021 <ide_init+0x2e1>
         outb(iobase + ISA_COMMAND, IDE_CMD_IDENTIFY);
         ide_wait_ready(iobase, 0);
 
         /* step3: polling */
         if (inb(iobase + ISA_STATUS) == 0 || ide_wait_ready(iobase, 1) != 0) {
             continue ;
-c01010ad:	90                   	nop
+c0101020:	90                   	nop
 
 void
 ide_init(void) {
     static_assert((SECTSIZE % 4) == 0);
     unsigned short ideno, iobase;
     for (ideno = 0; ideno < MAX_IDE; ideno ++) {
-c01010ae:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
-c01010b2:	83 c0 01             	add    $0x1,%eax
-c01010b5:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
-c01010b9:	66 83 7d f6 03       	cmpw   $0x3,-0xa(%ebp)
-c01010be:	0f 86 34 fd ff ff    	jbe    c0100df8 <ide_init+0x16>
+c0101021:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
+c0101025:	40                   	inc    %eax
+c0101026:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
+c010102a:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
+c010102e:	83 f8 03             	cmp    $0x3,%eax
+c0101031:	0f 86 1f fd ff ff    	jbe    c0100d56 <ide_init+0x16>
 
         cprintf("ide %d: %10u(sectors), '%s'.\n", ideno, ide_devices[ideno].size, ide_devices[ideno].model);
     }
 
     // enable ide interrupt
     pic_enable(IRQ_IDE1);
-c01010c4:	83 ec 0c             	sub    $0xc,%esp
-c01010c7:	6a 0e                	push   $0xe
-c01010c9:	e8 8a 0e 00 00       	call   c0101f58 <pic_enable>
-c01010ce:	83 c4 10             	add    $0x10,%esp
+c0101037:	c7 04 24 0e 00 00 00 	movl   $0xe,(%esp)
+c010103e:	e8 8a 0e 00 00       	call   c0101ecd <pic_enable>
     pic_enable(IRQ_IDE2);
-c01010d1:	83 ec 0c             	sub    $0xc,%esp
-c01010d4:	6a 0f                	push   $0xf
-c01010d6:	e8 7d 0e 00 00       	call   c0101f58 <pic_enable>
-c01010db:	83 c4 10             	add    $0x10,%esp
-}
-c01010de:	90                   	nop
-c01010df:	8d 65 f8             	lea    -0x8(%ebp),%esp
-c01010e2:	5b                   	pop    %ebx
-c01010e3:	5f                   	pop    %edi
-c01010e4:	5d                   	pop    %ebp
-c01010e5:	c3                   	ret    
+c0101043:	c7 04 24 0f 00 00 00 	movl   $0xf,(%esp)
+c010104a:	e8 7e 0e 00 00       	call   c0101ecd <pic_enable>
+}
+c010104f:	90                   	nop
+c0101050:	81 c4 50 02 00 00    	add    $0x250,%esp
+c0101056:	5b                   	pop    %ebx
+c0101057:	5f                   	pop    %edi
+c0101058:	5d                   	pop    %ebp
+c0101059:	c3                   	ret    
 
-c01010e6 <ide_device_valid>:
+c010105a <ide_device_valid>:
 
 bool
 ide_device_valid(unsigned short ideno) {
-c01010e6:	55                   	push   %ebp
-c01010e7:	89 e5                	mov    %esp,%ebp
-c01010e9:	83 ec 04             	sub    $0x4,%esp
-c01010ec:	8b 45 08             	mov    0x8(%ebp),%eax
-c01010ef:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
+c010105a:	55                   	push   %ebp
+c010105b:	89 e5                	mov    %esp,%ebp
+c010105d:	83 ec 04             	sub    $0x4,%esp
+c0101060:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101063:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
     return VALID_IDE(ideno);
-c01010f3:	66 83 7d fc 03       	cmpw   $0x3,-0x4(%ebp)
-c01010f8:	77 25                	ja     c010111f <ide_device_valid+0x39>
-c01010fa:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
-c01010fe:	c1 e0 03             	shl    $0x3,%eax
-c0101101:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
-c0101108:	29 c2                	sub    %eax,%edx
-c010110a:	89 d0                	mov    %edx,%eax
-c010110c:	05 40 24 12 c0       	add    $0xc0122440,%eax
-c0101111:	0f b6 00             	movzbl (%eax),%eax
-c0101114:	84 c0                	test   %al,%al
-c0101116:	74 07                	je     c010111f <ide_device_valid+0x39>
-c0101118:	b8 01 00 00 00       	mov    $0x1,%eax
-c010111d:	eb 05                	jmp    c0101124 <ide_device_valid+0x3e>
-c010111f:	b8 00 00 00 00       	mov    $0x0,%eax
+c0101067:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
+c010106b:	83 f8 03             	cmp    $0x3,%eax
+c010106e:	77 25                	ja     c0101095 <ide_device_valid+0x3b>
+c0101070:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
+c0101074:	c1 e0 03             	shl    $0x3,%eax
+c0101077:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+c010107e:	29 c2                	sub    %eax,%edx
+c0101080:	89 d0                	mov    %edx,%eax
+c0101082:	05 40 34 12 c0       	add    $0xc0123440,%eax
+c0101087:	0f b6 00             	movzbl (%eax),%eax
+c010108a:	84 c0                	test   %al,%al
+c010108c:	74 07                	je     c0101095 <ide_device_valid+0x3b>
+c010108e:	b8 01 00 00 00       	mov    $0x1,%eax
+c0101093:	eb 05                	jmp    c010109a <ide_device_valid+0x40>
+c0101095:	b8 00 00 00 00       	mov    $0x0,%eax
 }
-c0101124:	c9                   	leave  
-c0101125:	c3                   	ret    
+c010109a:	c9                   	leave  
+c010109b:	c3                   	ret    
 
-c0101126 <ide_device_size>:
+c010109c <ide_device_size>:
 
 size_t
 ide_device_size(unsigned short ideno) {
-c0101126:	55                   	push   %ebp
-c0101127:	89 e5                	mov    %esp,%ebp
-c0101129:	83 ec 04             	sub    $0x4,%esp
-c010112c:	8b 45 08             	mov    0x8(%ebp),%eax
-c010112f:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
+c010109c:	55                   	push   %ebp
+c010109d:	89 e5                	mov    %esp,%ebp
+c010109f:	83 ec 08             	sub    $0x8,%esp
+c01010a2:	8b 45 08             	mov    0x8(%ebp),%eax
+c01010a5:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
     if (ide_device_valid(ideno)) {
-c0101133:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
-c0101137:	50                   	push   %eax
-c0101138:	e8 a9 ff ff ff       	call   c01010e6 <ide_device_valid>
-c010113d:	83 c4 04             	add    $0x4,%esp
-c0101140:	85 c0                	test   %eax,%eax
-c0101142:	74 1b                	je     c010115f <ide_device_size+0x39>
+c01010a9:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
+c01010ad:	89 04 24             	mov    %eax,(%esp)
+c01010b0:	e8 a5 ff ff ff       	call   c010105a <ide_device_valid>
+c01010b5:	85 c0                	test   %eax,%eax
+c01010b7:	74 1b                	je     c01010d4 <ide_device_size+0x38>
         return ide_devices[ideno].size;
-c0101144:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
-c0101148:	c1 e0 03             	shl    $0x3,%eax
-c010114b:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
-c0101152:	29 c2                	sub    %eax,%edx
-c0101154:	89 d0                	mov    %edx,%eax
-c0101156:	05 48 24 12 c0       	add    $0xc0122448,%eax
-c010115b:	8b 00                	mov    (%eax),%eax
-c010115d:	eb 05                	jmp    c0101164 <ide_device_size+0x3e>
+c01010b9:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
+c01010bd:	c1 e0 03             	shl    $0x3,%eax
+c01010c0:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+c01010c7:	29 c2                	sub    %eax,%edx
+c01010c9:	89 d0                	mov    %edx,%eax
+c01010cb:	05 48 34 12 c0       	add    $0xc0123448,%eax
+c01010d0:	8b 00                	mov    (%eax),%eax
+c01010d2:	eb 05                	jmp    c01010d9 <ide_device_size+0x3d>
     }
     return 0;
-c010115f:	b8 00 00 00 00       	mov    $0x0,%eax
+c01010d4:	b8 00 00 00 00       	mov    $0x0,%eax
 }
-c0101164:	c9                   	leave  
-c0101165:	c3                   	ret    
+c01010d9:	c9                   	leave  
+c01010da:	c3                   	ret    
 
-c0101166 <ide_read_secs>:
+c01010db <ide_read_secs>:
 
 int
 ide_read_secs(unsigned short ideno, uint32_t secno, void *dst, size_t nsecs) {
-c0101166:	55                   	push   %ebp
-c0101167:	89 e5                	mov    %esp,%ebp
-c0101169:	57                   	push   %edi
-c010116a:	53                   	push   %ebx
-c010116b:	83 ec 40             	sub    $0x40,%esp
-c010116e:	8b 45 08             	mov    0x8(%ebp),%eax
-c0101171:	66 89 45 c4          	mov    %ax,-0x3c(%ebp)
+c01010db:	55                   	push   %ebp
+c01010dc:	89 e5                	mov    %esp,%ebp
+c01010de:	57                   	push   %edi
+c01010df:	53                   	push   %ebx
+c01010e0:	83 ec 50             	sub    $0x50,%esp
+c01010e3:	8b 45 08             	mov    0x8(%ebp),%eax
+c01010e6:	66 89 45 c4          	mov    %ax,-0x3c(%ebp)
     assert(nsecs <= MAX_NSECS && VALID_IDE(ideno));
-c0101175:	81 7d 14 80 00 00 00 	cmpl   $0x80,0x14(%ebp)
-c010117c:	77 25                	ja     c01011a3 <ide_read_secs+0x3d>
-c010117e:	66 83 7d c4 03       	cmpw   $0x3,-0x3c(%ebp)
-c0101183:	77 1e                	ja     c01011a3 <ide_read_secs+0x3d>
-c0101185:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
-c0101189:	c1 e0 03             	shl    $0x3,%eax
-c010118c:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
-c0101193:	29 c2                	sub    %eax,%edx
-c0101195:	89 d0                	mov    %edx,%eax
-c0101197:	05 40 24 12 c0       	add    $0xc0122440,%eax
-c010119c:	0f b6 00             	movzbl (%eax),%eax
-c010119f:	84 c0                	test   %al,%al
-c01011a1:	75 19                	jne    c01011bc <ide_read_secs+0x56>
-c01011a3:	68 24 87 10 c0       	push   $0xc0108724
-c01011a8:	68 df 86 10 c0       	push   $0xc01086df
-c01011ad:	68 9f 00 00 00       	push   $0x9f
-c01011b2:	68 f4 86 10 c0       	push   $0xc01086f4
-c01011b7:	e8 2c f2 ff ff       	call   c01003e8 <__panic>
+c01010ea:	81 7d 14 80 00 00 00 	cmpl   $0x80,0x14(%ebp)
+c01010f1:	77 27                	ja     c010111a <ide_read_secs+0x3f>
+c01010f3:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
+c01010f7:	83 f8 03             	cmp    $0x3,%eax
+c01010fa:	77 1e                	ja     c010111a <ide_read_secs+0x3f>
+c01010fc:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
+c0101100:	c1 e0 03             	shl    $0x3,%eax
+c0101103:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+c010110a:	29 c2                	sub    %eax,%edx
+c010110c:	89 d0                	mov    %edx,%eax
+c010110e:	05 40 34 12 c0       	add    $0xc0123440,%eax
+c0101113:	0f b6 00             	movzbl (%eax),%eax
+c0101116:	84 c0                	test   %al,%al
+c0101118:	75 24                	jne    c010113e <ide_read_secs+0x63>
+c010111a:	c7 44 24 0c 3c 8e 10 	movl   $0xc0108e3c,0xc(%esp)
+c0101121:	c0 
+c0101122:	c7 44 24 08 f7 8d 10 	movl   $0xc0108df7,0x8(%esp)
+c0101129:	c0 
+c010112a:	c7 44 24 04 9f 00 00 	movl   $0x9f,0x4(%esp)
+c0101131:	00 
+c0101132:	c7 04 24 0c 8e 10 c0 	movl   $0xc0108e0c,(%esp)
+c0101139:	e8 ba f2 ff ff       	call   c01003f8 <__panic>
     assert(secno < MAX_DISK_NSECS && secno + nsecs <= MAX_DISK_NSECS);
-c01011bc:	81 7d 0c ff ff ff 0f 	cmpl   $0xfffffff,0xc(%ebp)
-c01011c3:	77 0f                	ja     c01011d4 <ide_read_secs+0x6e>
-c01011c5:	8b 55 0c             	mov    0xc(%ebp),%edx
-c01011c8:	8b 45 14             	mov    0x14(%ebp),%eax
-c01011cb:	01 d0                	add    %edx,%eax
-c01011cd:	3d 00 00 00 10       	cmp    $0x10000000,%eax
-c01011d2:	76 19                	jbe    c01011ed <ide_read_secs+0x87>
-c01011d4:	68 4c 87 10 c0       	push   $0xc010874c
-c01011d9:	68 df 86 10 c0       	push   $0xc01086df
-c01011de:	68 a0 00 00 00       	push   $0xa0
-c01011e3:	68 f4 86 10 c0       	push   $0xc01086f4
-c01011e8:	e8 fb f1 ff ff       	call   c01003e8 <__panic>
+c010113e:	81 7d 0c ff ff ff 0f 	cmpl   $0xfffffff,0xc(%ebp)
+c0101145:	77 0f                	ja     c0101156 <ide_read_secs+0x7b>
+c0101147:	8b 55 0c             	mov    0xc(%ebp),%edx
+c010114a:	8b 45 14             	mov    0x14(%ebp),%eax
+c010114d:	01 d0                	add    %edx,%eax
+c010114f:	3d 00 00 00 10       	cmp    $0x10000000,%eax
+c0101154:	76 24                	jbe    c010117a <ide_read_secs+0x9f>
+c0101156:	c7 44 24 0c 64 8e 10 	movl   $0xc0108e64,0xc(%esp)
+c010115d:	c0 
+c010115e:	c7 44 24 08 f7 8d 10 	movl   $0xc0108df7,0x8(%esp)
+c0101165:	c0 
+c0101166:	c7 44 24 04 a0 00 00 	movl   $0xa0,0x4(%esp)
+c010116d:	00 
+c010116e:	c7 04 24 0c 8e 10 c0 	movl   $0xc0108e0c,(%esp)
+c0101175:	e8 7e f2 ff ff       	call   c01003f8 <__panic>
     unsigned short iobase = IO_BASE(ideno), ioctrl = IO_CTRL(ideno);
-c01011ed:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
-c01011f1:	66 d1 e8             	shr    %ax
-c01011f4:	0f b7 c0             	movzwl %ax,%eax
-c01011f7:	0f b7 04 85 94 86 10 	movzwl -0x3fef796c(,%eax,4),%eax
-c01011fe:	c0 
-c01011ff:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
-c0101203:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
-c0101207:	66 d1 e8             	shr    %ax
-c010120a:	0f b7 c0             	movzwl %ax,%eax
-c010120d:	0f b7 04 85 96 86 10 	movzwl -0x3fef796a(,%eax,4),%eax
-c0101214:	c0 
-c0101215:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
+c010117a:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
+c010117e:	d1 e8                	shr    %eax
+c0101180:	0f b7 c0             	movzwl %ax,%eax
+c0101183:	8b 04 85 ac 8d 10 c0 	mov    -0x3fef7254(,%eax,4),%eax
+c010118a:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
+c010118e:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
+c0101192:	d1 e8                	shr    %eax
+c0101194:	0f b7 c0             	movzwl %ax,%eax
+c0101197:	0f b7 04 85 ae 8d 10 	movzwl -0x3fef7252(,%eax,4),%eax
+c010119e:	c0 
+c010119f:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
 
     ide_wait_ready(iobase, 0);
-c0101219:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
-c010121d:	83 ec 08             	sub    $0x8,%esp
-c0101220:	6a 00                	push   $0x0
-c0101222:	50                   	push   %eax
-c0101223:	e8 60 fb ff ff       	call   c0100d88 <ide_wait_ready>
-c0101228:	83 c4 10             	add    $0x10,%esp
+c01011a3:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
+c01011a7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+c01011ae:	00 
+c01011af:	89 04 24             	mov    %eax,(%esp)
+c01011b2:	e8 30 fb ff ff       	call   c0100ce7 <ide_wait_ready>
 
     // generate interrupt
     outb(ioctrl + ISA_CTRL, 0);
-c010122b:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
-c010122f:	83 c0 02             	add    $0x2,%eax
-c0101232:	0f b7 c0             	movzwl %ax,%eax
-c0101235:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
-c0101239:	c6 45 d7 00          	movb   $0x0,-0x29(%ebp)
+c01011b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01011ba:	83 c0 02             	add    $0x2,%eax
+c01011bd:	0f b7 c0             	movzwl %ax,%eax
+c01011c0:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
+c01011c4:	c6 45 d7 00          	movb   $0x0,-0x29(%ebp)
         : "memory", "cc");
 }
 
 static inline void
 outb(uint16_t port, uint8_t data) {
     asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
-c010123d:	0f b6 45 d7          	movzbl -0x29(%ebp),%eax
-c0101241:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
-c0101245:	ee                   	out    %al,(%dx)
+c01011c8:	0f b6 45 d7          	movzbl -0x29(%ebp),%eax
+c01011cc:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
+c01011d0:	ee                   	out    %al,(%dx)
     outb(iobase + ISA_SECCNT, nsecs);
-c0101246:	8b 45 14             	mov    0x14(%ebp),%eax
-c0101249:	0f b6 c0             	movzbl %al,%eax
-c010124c:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
-c0101250:	83 c2 02             	add    $0x2,%edx
-c0101253:	0f b7 d2             	movzwl %dx,%edx
-c0101256:	66 89 55 e8          	mov    %dx,-0x18(%ebp)
-c010125a:	88 45 d8             	mov    %al,-0x28(%ebp)
-c010125d:	0f b6 45 d8          	movzbl -0x28(%ebp),%eax
-c0101261:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
-c0101265:	ee                   	out    %al,(%dx)
+c01011d1:	8b 45 14             	mov    0x14(%ebp),%eax
+c01011d4:	0f b6 c0             	movzbl %al,%eax
+c01011d7:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+c01011db:	83 c2 02             	add    $0x2,%edx
+c01011de:	0f b7 d2             	movzwl %dx,%edx
+c01011e1:	66 89 55 e8          	mov    %dx,-0x18(%ebp)
+c01011e5:	88 45 d8             	mov    %al,-0x28(%ebp)
+c01011e8:	0f b6 45 d8          	movzbl -0x28(%ebp),%eax
+c01011ec:	8b 55 e8             	mov    -0x18(%ebp),%edx
+c01011ef:	ee                   	out    %al,(%dx)
     outb(iobase + ISA_SECTOR, secno & 0xFF);
-c0101266:	8b 45 0c             	mov    0xc(%ebp),%eax
-c0101269:	0f b6 c0             	movzbl %al,%eax
-c010126c:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
-c0101270:	83 c2 03             	add    $0x3,%edx
-c0101273:	0f b7 d2             	movzwl %dx,%edx
-c0101276:	66 89 55 e6          	mov    %dx,-0x1a(%ebp)
-c010127a:	88 45 d9             	mov    %al,-0x27(%ebp)
-c010127d:	0f b6 45 d9          	movzbl -0x27(%ebp),%eax
-c0101281:	0f b7 55 e6          	movzwl -0x1a(%ebp),%edx
-c0101285:	ee                   	out    %al,(%dx)
+c01011f0:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01011f3:	0f b6 c0             	movzbl %al,%eax
+c01011f6:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+c01011fa:	83 c2 03             	add    $0x3,%edx
+c01011fd:	0f b7 d2             	movzwl %dx,%edx
+c0101200:	66 89 55 e6          	mov    %dx,-0x1a(%ebp)
+c0101204:	88 45 d9             	mov    %al,-0x27(%ebp)
+c0101207:	0f b6 45 d9          	movzbl -0x27(%ebp),%eax
+c010120b:	0f b7 55 e6          	movzwl -0x1a(%ebp),%edx
+c010120f:	ee                   	out    %al,(%dx)
     outb(iobase + ISA_CYL_LO, (secno >> 8) & 0xFF);
-c0101286:	8b 45 0c             	mov    0xc(%ebp),%eax
-c0101289:	c1 e8 08             	shr    $0x8,%eax
-c010128c:	0f b6 c0             	movzbl %al,%eax
-c010128f:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
-c0101293:	83 c2 04             	add    $0x4,%edx
-c0101296:	0f b7 d2             	movzwl %dx,%edx
-c0101299:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
-c010129d:	88 45 da             	mov    %al,-0x26(%ebp)
-c01012a0:	0f b6 45 da          	movzbl -0x26(%ebp),%eax
-c01012a4:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
-c01012a8:	ee                   	out    %al,(%dx)
+c0101210:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0101213:	c1 e8 08             	shr    $0x8,%eax
+c0101216:	0f b6 c0             	movzbl %al,%eax
+c0101219:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+c010121d:	83 c2 04             	add    $0x4,%edx
+c0101220:	0f b7 d2             	movzwl %dx,%edx
+c0101223:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
+c0101227:	88 45 da             	mov    %al,-0x26(%ebp)
+c010122a:	0f b6 45 da          	movzbl -0x26(%ebp),%eax
+c010122e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c0101231:	ee                   	out    %al,(%dx)
     outb(iobase + ISA_CYL_HI, (secno >> 16) & 0xFF);
-c01012a9:	8b 45 0c             	mov    0xc(%ebp),%eax
-c01012ac:	c1 e8 10             	shr    $0x10,%eax
-c01012af:	0f b6 c0             	movzbl %al,%eax
-c01012b2:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
-c01012b6:	83 c2 05             	add    $0x5,%edx
-c01012b9:	0f b7 d2             	movzwl %dx,%edx
-c01012bc:	66 89 55 e2          	mov    %dx,-0x1e(%ebp)
-c01012c0:	88 45 db             	mov    %al,-0x25(%ebp)
-c01012c3:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
-c01012c7:	0f b7 55 e2          	movzwl -0x1e(%ebp),%edx
-c01012cb:	ee                   	out    %al,(%dx)
+c0101232:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0101235:	c1 e8 10             	shr    $0x10,%eax
+c0101238:	0f b6 c0             	movzbl %al,%eax
+c010123b:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+c010123f:	83 c2 05             	add    $0x5,%edx
+c0101242:	0f b7 d2             	movzwl %dx,%edx
+c0101245:	66 89 55 e2          	mov    %dx,-0x1e(%ebp)
+c0101249:	88 45 db             	mov    %al,-0x25(%ebp)
+c010124c:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
+c0101250:	0f b7 55 e2          	movzwl -0x1e(%ebp),%edx
+c0101254:	ee                   	out    %al,(%dx)
     outb(iobase + ISA_SDH, 0xE0 | ((ideno & 1) << 4) | ((secno >> 24) & 0xF));
-c01012cc:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
-c01012d0:	83 e0 01             	and    $0x1,%eax
-c01012d3:	c1 e0 04             	shl    $0x4,%eax
-c01012d6:	89 c2                	mov    %eax,%edx
-c01012d8:	8b 45 0c             	mov    0xc(%ebp),%eax
-c01012db:	c1 e8 18             	shr    $0x18,%eax
-c01012de:	83 e0 0f             	and    $0xf,%eax
-c01012e1:	09 d0                	or     %edx,%eax
-c01012e3:	83 c8 e0             	or     $0xffffffe0,%eax
-c01012e6:	0f b6 c0             	movzbl %al,%eax
-c01012e9:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
-c01012ed:	83 c2 06             	add    $0x6,%edx
-c01012f0:	0f b7 d2             	movzwl %dx,%edx
-c01012f3:	66 89 55 e0          	mov    %dx,-0x20(%ebp)
-c01012f7:	88 45 dc             	mov    %al,-0x24(%ebp)
-c01012fa:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
-c01012fe:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
-c0101302:	ee                   	out    %al,(%dx)
+c0101255:	8b 45 c4             	mov    -0x3c(%ebp),%eax
+c0101258:	24 01                	and    $0x1,%al
+c010125a:	c0 e0 04             	shl    $0x4,%al
+c010125d:	88 c2                	mov    %al,%dl
+c010125f:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0101262:	c1 e8 18             	shr    $0x18,%eax
+c0101265:	24 0f                	and    $0xf,%al
+c0101267:	08 d0                	or     %dl,%al
+c0101269:	0c e0                	or     $0xe0,%al
+c010126b:	0f b6 c0             	movzbl %al,%eax
+c010126e:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+c0101272:	83 c2 06             	add    $0x6,%edx
+c0101275:	0f b7 d2             	movzwl %dx,%edx
+c0101278:	66 89 55 e0          	mov    %dx,-0x20(%ebp)
+c010127c:	88 45 dc             	mov    %al,-0x24(%ebp)
+c010127f:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
+c0101283:	8b 55 e0             	mov    -0x20(%ebp),%edx
+c0101286:	ee                   	out    %al,(%dx)
     outb(iobase + ISA_COMMAND, IDE_CMD_READ);
-c0101303:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
-c0101307:	83 c0 07             	add    $0x7,%eax
-c010130a:	0f b7 c0             	movzwl %ax,%eax
-c010130d:	66 89 45 de          	mov    %ax,-0x22(%ebp)
-c0101311:	c6 45 dd 20          	movb   $0x20,-0x23(%ebp)
-c0101315:	0f b6 45 dd          	movzbl -0x23(%ebp),%eax
-c0101319:	0f b7 55 de          	movzwl -0x22(%ebp),%edx
-c010131d:	ee                   	out    %al,(%dx)
+c0101287:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
+c010128b:	83 c0 07             	add    $0x7,%eax
+c010128e:	0f b7 c0             	movzwl %ax,%eax
+c0101291:	66 89 45 de          	mov    %ax,-0x22(%ebp)
+c0101295:	c6 45 dd 20          	movb   $0x20,-0x23(%ebp)
+c0101299:	0f b6 45 dd          	movzbl -0x23(%ebp),%eax
+c010129d:	0f b7 55 de          	movzwl -0x22(%ebp),%edx
+c01012a1:	ee                   	out    %al,(%dx)
 
     int ret = 0;
-c010131e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+c01012a2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     for (; nsecs > 0; nsecs --, dst += SECTSIZE) {
-c0101325:	eb 56                	jmp    c010137d <ide_read_secs+0x217>
+c01012a9:	eb 57                	jmp    c0101302 <ide_read_secs+0x227>
         if ((ret = ide_wait_ready(iobase, 1)) != 0) {
-c0101327:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
-c010132b:	83 ec 08             	sub    $0x8,%esp
-c010132e:	6a 01                	push   $0x1
-c0101330:	50                   	push   %eax
-c0101331:	e8 52 fa ff ff       	call   c0100d88 <ide_wait_ready>
-c0101336:	83 c4 10             	add    $0x10,%esp
-c0101339:	89 45 f4             	mov    %eax,-0xc(%ebp)
-c010133c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
-c0101340:	75 43                	jne    c0101385 <ide_read_secs+0x21f>
+c01012ab:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
+c01012af:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+c01012b6:	00 
+c01012b7:	89 04 24             	mov    %eax,(%esp)
+c01012ba:	e8 28 fa ff ff       	call   c0100ce7 <ide_wait_ready>
+c01012bf:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c01012c2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c01012c6:	75 42                	jne    c010130a <ide_read_secs+0x22f>
             goto out;
         }
         insl(iobase, dst, SECTSIZE / sizeof(uint32_t));
-c0101342:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
-c0101346:	89 45 ec             	mov    %eax,-0x14(%ebp)
-c0101349:	8b 45 10             	mov    0x10(%ebp),%eax
-c010134c:	89 45 d0             	mov    %eax,-0x30(%ebp)
-c010134f:	c7 45 cc 80 00 00 00 	movl   $0x80,-0x34(%ebp)
+c01012c8:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
+c01012cc:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c01012cf:	8b 45 10             	mov    0x10(%ebp),%eax
+c01012d2:	89 45 d0             	mov    %eax,-0x30(%ebp)
+c01012d5:	c7 45 cc 80 00 00 00 	movl   $0x80,-0x34(%ebp)
     return data;
 }
 
 static inline void
 insl(uint32_t port, void *addr, int cnt) {
     asm volatile (
-c0101356:	8b 55 ec             	mov    -0x14(%ebp),%edx
-c0101359:	8b 4d d0             	mov    -0x30(%ebp),%ecx
-c010135c:	8b 45 cc             	mov    -0x34(%ebp),%eax
-c010135f:	89 cb                	mov    %ecx,%ebx
-c0101361:	89 df                	mov    %ebx,%edi
-c0101363:	89 c1                	mov    %eax,%ecx
-c0101365:	fc                   	cld    
-c0101366:	f2 6d                	repnz insl (%dx),%es:(%edi)
-c0101368:	89 c8                	mov    %ecx,%eax
-c010136a:	89 fb                	mov    %edi,%ebx
-c010136c:	89 5d d0             	mov    %ebx,-0x30(%ebp)
-c010136f:	89 45 cc             	mov    %eax,-0x34(%ebp)
+c01012dc:	8b 55 ec             	mov    -0x14(%ebp),%edx
+c01012df:	8b 4d d0             	mov    -0x30(%ebp),%ecx
+c01012e2:	8b 45 cc             	mov    -0x34(%ebp),%eax
+c01012e5:	89 cb                	mov    %ecx,%ebx
+c01012e7:	89 df                	mov    %ebx,%edi
+c01012e9:	89 c1                	mov    %eax,%ecx
+c01012eb:	fc                   	cld    
+c01012ec:	f2 6d                	repnz insl (%dx),%es:(%edi)
+c01012ee:	89 c8                	mov    %ecx,%eax
+c01012f0:	89 fb                	mov    %edi,%ebx
+c01012f2:	89 5d d0             	mov    %ebx,-0x30(%ebp)
+c01012f5:	89 45 cc             	mov    %eax,-0x34(%ebp)
     outb(iobase + ISA_CYL_HI, (secno >> 16) & 0xFF);
     outb(iobase + ISA_SDH, 0xE0 | ((ideno & 1) << 4) | ((secno >> 24) & 0xF));
     outb(iobase + ISA_COMMAND, IDE_CMD_READ);
 
     int ret = 0;
     for (; nsecs > 0; nsecs --, dst += SECTSIZE) {
-c0101372:	83 6d 14 01          	subl   $0x1,0x14(%ebp)
-c0101376:	81 45 10 00 02 00 00 	addl   $0x200,0x10(%ebp)
-c010137d:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
-c0101381:	75 a4                	jne    c0101327 <ide_read_secs+0x1c1>
-c0101383:	eb 01                	jmp    c0101386 <ide_read_secs+0x220>
+c01012f8:	ff 4d 14             	decl   0x14(%ebp)
+c01012fb:	81 45 10 00 02 00 00 	addl   $0x200,0x10(%ebp)
+c0101302:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+c0101306:	75 a3                	jne    c01012ab <ide_read_secs+0x1d0>
+c0101308:	eb 01                	jmp    c010130b <ide_read_secs+0x230>
         if ((ret = ide_wait_ready(iobase, 1)) != 0) {
             goto out;
-c0101385:	90                   	nop
+c010130a:	90                   	nop
         }
         insl(iobase, dst, SECTSIZE / sizeof(uint32_t));
     }
 
 out:
     return ret;
-c0101386:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010130b:	8b 45 f4             	mov    -0xc(%ebp),%eax
 }
-c0101389:	8d 65 f8             	lea    -0x8(%ebp),%esp
-c010138c:	5b                   	pop    %ebx
-c010138d:	5f                   	pop    %edi
-c010138e:	5d                   	pop    %ebp
-c010138f:	c3                   	ret    
+c010130e:	83 c4 50             	add    $0x50,%esp
+c0101311:	5b                   	pop    %ebx
+c0101312:	5f                   	pop    %edi
+c0101313:	5d                   	pop    %ebp
+c0101314:	c3                   	ret    
 
-c0101390 <ide_write_secs>:
+c0101315 <ide_write_secs>:
 
 int
 ide_write_secs(unsigned short ideno, uint32_t secno, const void *src, size_t nsecs) {
-c0101390:	55                   	push   %ebp
-c0101391:	89 e5                	mov    %esp,%ebp
-c0101393:	56                   	push   %esi
-c0101394:	53                   	push   %ebx
-c0101395:	83 ec 40             	sub    $0x40,%esp
-c0101398:	8b 45 08             	mov    0x8(%ebp),%eax
-c010139b:	66 89 45 c4          	mov    %ax,-0x3c(%ebp)
+c0101315:	55                   	push   %ebp
+c0101316:	89 e5                	mov    %esp,%ebp
+c0101318:	56                   	push   %esi
+c0101319:	53                   	push   %ebx
+c010131a:	83 ec 50             	sub    $0x50,%esp
+c010131d:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101320:	66 89 45 c4          	mov    %ax,-0x3c(%ebp)
     assert(nsecs <= MAX_NSECS && VALID_IDE(ideno));
-c010139f:	81 7d 14 80 00 00 00 	cmpl   $0x80,0x14(%ebp)
-c01013a6:	77 25                	ja     c01013cd <ide_write_secs+0x3d>
-c01013a8:	66 83 7d c4 03       	cmpw   $0x3,-0x3c(%ebp)
-c01013ad:	77 1e                	ja     c01013cd <ide_write_secs+0x3d>
-c01013af:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
-c01013b3:	c1 e0 03             	shl    $0x3,%eax
-c01013b6:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
-c01013bd:	29 c2                	sub    %eax,%edx
-c01013bf:	89 d0                	mov    %edx,%eax
-c01013c1:	05 40 24 12 c0       	add    $0xc0122440,%eax
-c01013c6:	0f b6 00             	movzbl (%eax),%eax
-c01013c9:	84 c0                	test   %al,%al
-c01013cb:	75 19                	jne    c01013e6 <ide_write_secs+0x56>
-c01013cd:	68 24 87 10 c0       	push   $0xc0108724
-c01013d2:	68 df 86 10 c0       	push   $0xc01086df
-c01013d7:	68 bc 00 00 00       	push   $0xbc
-c01013dc:	68 f4 86 10 c0       	push   $0xc01086f4
-c01013e1:	e8 02 f0 ff ff       	call   c01003e8 <__panic>
+c0101324:	81 7d 14 80 00 00 00 	cmpl   $0x80,0x14(%ebp)
+c010132b:	77 27                	ja     c0101354 <ide_write_secs+0x3f>
+c010132d:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
+c0101331:	83 f8 03             	cmp    $0x3,%eax
+c0101334:	77 1e                	ja     c0101354 <ide_write_secs+0x3f>
+c0101336:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
+c010133a:	c1 e0 03             	shl    $0x3,%eax
+c010133d:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
+c0101344:	29 c2                	sub    %eax,%edx
+c0101346:	89 d0                	mov    %edx,%eax
+c0101348:	05 40 34 12 c0       	add    $0xc0123440,%eax
+c010134d:	0f b6 00             	movzbl (%eax),%eax
+c0101350:	84 c0                	test   %al,%al
+c0101352:	75 24                	jne    c0101378 <ide_write_secs+0x63>
+c0101354:	c7 44 24 0c 3c 8e 10 	movl   $0xc0108e3c,0xc(%esp)
+c010135b:	c0 
+c010135c:	c7 44 24 08 f7 8d 10 	movl   $0xc0108df7,0x8(%esp)
+c0101363:	c0 
+c0101364:	c7 44 24 04 bc 00 00 	movl   $0xbc,0x4(%esp)
+c010136b:	00 
+c010136c:	c7 04 24 0c 8e 10 c0 	movl   $0xc0108e0c,(%esp)
+c0101373:	e8 80 f0 ff ff       	call   c01003f8 <__panic>
     assert(secno < MAX_DISK_NSECS && secno + nsecs <= MAX_DISK_NSECS);
-c01013e6:	81 7d 0c ff ff ff 0f 	cmpl   $0xfffffff,0xc(%ebp)
-c01013ed:	77 0f                	ja     c01013fe <ide_write_secs+0x6e>
-c01013ef:	8b 55 0c             	mov    0xc(%ebp),%edx
-c01013f2:	8b 45 14             	mov    0x14(%ebp),%eax
-c01013f5:	01 d0                	add    %edx,%eax
-c01013f7:	3d 00 00 00 10       	cmp    $0x10000000,%eax
-c01013fc:	76 19                	jbe    c0101417 <ide_write_secs+0x87>
-c01013fe:	68 4c 87 10 c0       	push   $0xc010874c
-c0101403:	68 df 86 10 c0       	push   $0xc01086df
-c0101408:	68 bd 00 00 00       	push   $0xbd
-c010140d:	68 f4 86 10 c0       	push   $0xc01086f4
-c0101412:	e8 d1 ef ff ff       	call   c01003e8 <__panic>
+c0101378:	81 7d 0c ff ff ff 0f 	cmpl   $0xfffffff,0xc(%ebp)
+c010137f:	77 0f                	ja     c0101390 <ide_write_secs+0x7b>
+c0101381:	8b 55 0c             	mov    0xc(%ebp),%edx
+c0101384:	8b 45 14             	mov    0x14(%ebp),%eax
+c0101387:	01 d0                	add    %edx,%eax
+c0101389:	3d 00 00 00 10       	cmp    $0x10000000,%eax
+c010138e:	76 24                	jbe    c01013b4 <ide_write_secs+0x9f>
+c0101390:	c7 44 24 0c 64 8e 10 	movl   $0xc0108e64,0xc(%esp)
+c0101397:	c0 
+c0101398:	c7 44 24 08 f7 8d 10 	movl   $0xc0108df7,0x8(%esp)
+c010139f:	c0 
+c01013a0:	c7 44 24 04 bd 00 00 	movl   $0xbd,0x4(%esp)
+c01013a7:	00 
+c01013a8:	c7 04 24 0c 8e 10 c0 	movl   $0xc0108e0c,(%esp)
+c01013af:	e8 44 f0 ff ff       	call   c01003f8 <__panic>
     unsigned short iobase = IO_BASE(ideno), ioctrl = IO_CTRL(ideno);
-c0101417:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
-c010141b:	66 d1 e8             	shr    %ax
-c010141e:	0f b7 c0             	movzwl %ax,%eax
-c0101421:	0f b7 04 85 94 86 10 	movzwl -0x3fef796c(,%eax,4),%eax
-c0101428:	c0 
-c0101429:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
-c010142d:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
-c0101431:	66 d1 e8             	shr    %ax
-c0101434:	0f b7 c0             	movzwl %ax,%eax
-c0101437:	0f b7 04 85 96 86 10 	movzwl -0x3fef796a(,%eax,4),%eax
-c010143e:	c0 
-c010143f:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
+c01013b4:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
+c01013b8:	d1 e8                	shr    %eax
+c01013ba:	0f b7 c0             	movzwl %ax,%eax
+c01013bd:	8b 04 85 ac 8d 10 c0 	mov    -0x3fef7254(,%eax,4),%eax
+c01013c4:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
+c01013c8:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
+c01013cc:	d1 e8                	shr    %eax
+c01013ce:	0f b7 c0             	movzwl %ax,%eax
+c01013d1:	0f b7 04 85 ae 8d 10 	movzwl -0x3fef7252(,%eax,4),%eax
+c01013d8:	c0 
+c01013d9:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
 
     ide_wait_ready(iobase, 0);
-c0101443:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
-c0101447:	83 ec 08             	sub    $0x8,%esp
-c010144a:	6a 00                	push   $0x0
-c010144c:	50                   	push   %eax
-c010144d:	e8 36 f9 ff ff       	call   c0100d88 <ide_wait_ready>
-c0101452:	83 c4 10             	add    $0x10,%esp
+c01013dd:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
+c01013e1:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+c01013e8:	00 
+c01013e9:	89 04 24             	mov    %eax,(%esp)
+c01013ec:	e8 f6 f8 ff ff       	call   c0100ce7 <ide_wait_ready>
 
     // generate interrupt
     outb(ioctrl + ISA_CTRL, 0);
-c0101455:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
-c0101459:	83 c0 02             	add    $0x2,%eax
-c010145c:	0f b7 c0             	movzwl %ax,%eax
-c010145f:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
-c0101463:	c6 45 d7 00          	movb   $0x0,-0x29(%ebp)
+c01013f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01013f4:	83 c0 02             	add    $0x2,%eax
+c01013f7:	0f b7 c0             	movzwl %ax,%eax
+c01013fa:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
+c01013fe:	c6 45 d7 00          	movb   $0x0,-0x29(%ebp)
         : "memory", "cc");
 }
 
 static inline void
 outb(uint16_t port, uint8_t data) {
     asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
-c0101467:	0f b6 45 d7          	movzbl -0x29(%ebp),%eax
-c010146b:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
-c010146f:	ee                   	out    %al,(%dx)
+c0101402:	0f b6 45 d7          	movzbl -0x29(%ebp),%eax
+c0101406:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
+c010140a:	ee                   	out    %al,(%dx)
     outb(iobase + ISA_SECCNT, nsecs);
-c0101470:	8b 45 14             	mov    0x14(%ebp),%eax
-c0101473:	0f b6 c0             	movzbl %al,%eax
-c0101476:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
-c010147a:	83 c2 02             	add    $0x2,%edx
-c010147d:	0f b7 d2             	movzwl %dx,%edx
-c0101480:	66 89 55 e8          	mov    %dx,-0x18(%ebp)
-c0101484:	88 45 d8             	mov    %al,-0x28(%ebp)
-c0101487:	0f b6 45 d8          	movzbl -0x28(%ebp),%eax
-c010148b:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
-c010148f:	ee                   	out    %al,(%dx)
+c010140b:	8b 45 14             	mov    0x14(%ebp),%eax
+c010140e:	0f b6 c0             	movzbl %al,%eax
+c0101411:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+c0101415:	83 c2 02             	add    $0x2,%edx
+c0101418:	0f b7 d2             	movzwl %dx,%edx
+c010141b:	66 89 55 e8          	mov    %dx,-0x18(%ebp)
+c010141f:	88 45 d8             	mov    %al,-0x28(%ebp)
+c0101422:	0f b6 45 d8          	movzbl -0x28(%ebp),%eax
+c0101426:	8b 55 e8             	mov    -0x18(%ebp),%edx
+c0101429:	ee                   	out    %al,(%dx)
     outb(iobase + ISA_SECTOR, secno & 0xFF);
-c0101490:	8b 45 0c             	mov    0xc(%ebp),%eax
-c0101493:	0f b6 c0             	movzbl %al,%eax
-c0101496:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
-c010149a:	83 c2 03             	add    $0x3,%edx
-c010149d:	0f b7 d2             	movzwl %dx,%edx
-c01014a0:	66 89 55 e6          	mov    %dx,-0x1a(%ebp)
-c01014a4:	88 45 d9             	mov    %al,-0x27(%ebp)
-c01014a7:	0f b6 45 d9          	movzbl -0x27(%ebp),%eax
-c01014ab:	0f b7 55 e6          	movzwl -0x1a(%ebp),%edx
-c01014af:	ee                   	out    %al,(%dx)
+c010142a:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010142d:	0f b6 c0             	movzbl %al,%eax
+c0101430:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+c0101434:	83 c2 03             	add    $0x3,%edx
+c0101437:	0f b7 d2             	movzwl %dx,%edx
+c010143a:	66 89 55 e6          	mov    %dx,-0x1a(%ebp)
+c010143e:	88 45 d9             	mov    %al,-0x27(%ebp)
+c0101441:	0f b6 45 d9          	movzbl -0x27(%ebp),%eax
+c0101445:	0f b7 55 e6          	movzwl -0x1a(%ebp),%edx
+c0101449:	ee                   	out    %al,(%dx)
     outb(iobase + ISA_CYL_LO, (secno >> 8) & 0xFF);
-c01014b0:	8b 45 0c             	mov    0xc(%ebp),%eax
-c01014b3:	c1 e8 08             	shr    $0x8,%eax
-c01014b6:	0f b6 c0             	movzbl %al,%eax
-c01014b9:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
-c01014bd:	83 c2 04             	add    $0x4,%edx
-c01014c0:	0f b7 d2             	movzwl %dx,%edx
-c01014c3:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
-c01014c7:	88 45 da             	mov    %al,-0x26(%ebp)
-c01014ca:	0f b6 45 da          	movzbl -0x26(%ebp),%eax
-c01014ce:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
-c01014d2:	ee                   	out    %al,(%dx)
+c010144a:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010144d:	c1 e8 08             	shr    $0x8,%eax
+c0101450:	0f b6 c0             	movzbl %al,%eax
+c0101453:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+c0101457:	83 c2 04             	add    $0x4,%edx
+c010145a:	0f b7 d2             	movzwl %dx,%edx
+c010145d:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
+c0101461:	88 45 da             	mov    %al,-0x26(%ebp)
+c0101464:	0f b6 45 da          	movzbl -0x26(%ebp),%eax
+c0101468:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c010146b:	ee                   	out    %al,(%dx)
     outb(iobase + ISA_CYL_HI, (secno >> 16) & 0xFF);
-c01014d3:	8b 45 0c             	mov    0xc(%ebp),%eax
-c01014d6:	c1 e8 10             	shr    $0x10,%eax
-c01014d9:	0f b6 c0             	movzbl %al,%eax
-c01014dc:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
-c01014e0:	83 c2 05             	add    $0x5,%edx
-c01014e3:	0f b7 d2             	movzwl %dx,%edx
-c01014e6:	66 89 55 e2          	mov    %dx,-0x1e(%ebp)
-c01014ea:	88 45 db             	mov    %al,-0x25(%ebp)
-c01014ed:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
-c01014f1:	0f b7 55 e2          	movzwl -0x1e(%ebp),%edx
-c01014f5:	ee                   	out    %al,(%dx)
+c010146c:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010146f:	c1 e8 10             	shr    $0x10,%eax
+c0101472:	0f b6 c0             	movzbl %al,%eax
+c0101475:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+c0101479:	83 c2 05             	add    $0x5,%edx
+c010147c:	0f b7 d2             	movzwl %dx,%edx
+c010147f:	66 89 55 e2          	mov    %dx,-0x1e(%ebp)
+c0101483:	88 45 db             	mov    %al,-0x25(%ebp)
+c0101486:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
+c010148a:	0f b7 55 e2          	movzwl -0x1e(%ebp),%edx
+c010148e:	ee                   	out    %al,(%dx)
     outb(iobase + ISA_SDH, 0xE0 | ((ideno & 1) << 4) | ((secno >> 24) & 0xF));
-c01014f6:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
-c01014fa:	83 e0 01             	and    $0x1,%eax
-c01014fd:	c1 e0 04             	shl    $0x4,%eax
-c0101500:	89 c2                	mov    %eax,%edx
-c0101502:	8b 45 0c             	mov    0xc(%ebp),%eax
-c0101505:	c1 e8 18             	shr    $0x18,%eax
-c0101508:	83 e0 0f             	and    $0xf,%eax
-c010150b:	09 d0                	or     %edx,%eax
-c010150d:	83 c8 e0             	or     $0xffffffe0,%eax
-c0101510:	0f b6 c0             	movzbl %al,%eax
-c0101513:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
-c0101517:	83 c2 06             	add    $0x6,%edx
-c010151a:	0f b7 d2             	movzwl %dx,%edx
-c010151d:	66 89 55 e0          	mov    %dx,-0x20(%ebp)
-c0101521:	88 45 dc             	mov    %al,-0x24(%ebp)
-c0101524:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
-c0101528:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
-c010152c:	ee                   	out    %al,(%dx)
+c010148f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
+c0101492:	24 01                	and    $0x1,%al
+c0101494:	c0 e0 04             	shl    $0x4,%al
+c0101497:	88 c2                	mov    %al,%dl
+c0101499:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010149c:	c1 e8 18             	shr    $0x18,%eax
+c010149f:	24 0f                	and    $0xf,%al
+c01014a1:	08 d0                	or     %dl,%al
+c01014a3:	0c e0                	or     $0xe0,%al
+c01014a5:	0f b6 c0             	movzbl %al,%eax
+c01014a8:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+c01014ac:	83 c2 06             	add    $0x6,%edx
+c01014af:	0f b7 d2             	movzwl %dx,%edx
+c01014b2:	66 89 55 e0          	mov    %dx,-0x20(%ebp)
+c01014b6:	88 45 dc             	mov    %al,-0x24(%ebp)
+c01014b9:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
+c01014bd:	8b 55 e0             	mov    -0x20(%ebp),%edx
+c01014c0:	ee                   	out    %al,(%dx)
     outb(iobase + ISA_COMMAND, IDE_CMD_WRITE);
-c010152d:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
-c0101531:	83 c0 07             	add    $0x7,%eax
-c0101534:	0f b7 c0             	movzwl %ax,%eax
-c0101537:	66 89 45 de          	mov    %ax,-0x22(%ebp)
-c010153b:	c6 45 dd 30          	movb   $0x30,-0x23(%ebp)
-c010153f:	0f b6 45 dd          	movzbl -0x23(%ebp),%eax
-c0101543:	0f b7 55 de          	movzwl -0x22(%ebp),%edx
-c0101547:	ee                   	out    %al,(%dx)
+c01014c1:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
+c01014c5:	83 c0 07             	add    $0x7,%eax
+c01014c8:	0f b7 c0             	movzwl %ax,%eax
+c01014cb:	66 89 45 de          	mov    %ax,-0x22(%ebp)
+c01014cf:	c6 45 dd 30          	movb   $0x30,-0x23(%ebp)
+c01014d3:	0f b6 45 dd          	movzbl -0x23(%ebp),%eax
+c01014d7:	0f b7 55 de          	movzwl -0x22(%ebp),%edx
+c01014db:	ee                   	out    %al,(%dx)
 
     int ret = 0;
-c0101548:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+c01014dc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     for (; nsecs > 0; nsecs --, src += SECTSIZE) {
-c010154f:	eb 56                	jmp    c01015a7 <ide_write_secs+0x217>
+c01014e3:	eb 57                	jmp    c010153c <ide_write_secs+0x227>
         if ((ret = ide_wait_ready(iobase, 1)) != 0) {
-c0101551:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
-c0101555:	83 ec 08             	sub    $0x8,%esp
-c0101558:	6a 01                	push   $0x1
-c010155a:	50                   	push   %eax
-c010155b:	e8 28 f8 ff ff       	call   c0100d88 <ide_wait_ready>
-c0101560:	83 c4 10             	add    $0x10,%esp
-c0101563:	89 45 f4             	mov    %eax,-0xc(%ebp)
-c0101566:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
-c010156a:	75 43                	jne    c01015af <ide_write_secs+0x21f>
+c01014e5:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
+c01014e9:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+c01014f0:	00 
+c01014f1:	89 04 24             	mov    %eax,(%esp)
+c01014f4:	e8 ee f7 ff ff       	call   c0100ce7 <ide_wait_ready>
+c01014f9:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c01014fc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0101500:	75 42                	jne    c0101544 <ide_write_secs+0x22f>
             goto out;
         }
         outsl(iobase, src, SECTSIZE / sizeof(uint32_t));
-c010156c:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
-c0101570:	89 45 ec             	mov    %eax,-0x14(%ebp)
-c0101573:	8b 45 10             	mov    0x10(%ebp),%eax
-c0101576:	89 45 d0             	mov    %eax,-0x30(%ebp)
-c0101579:	c7 45 cc 80 00 00 00 	movl   $0x80,-0x34(%ebp)
+c0101502:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
+c0101506:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c0101509:	8b 45 10             	mov    0x10(%ebp),%eax
+c010150c:	89 45 d0             	mov    %eax,-0x30(%ebp)
+c010150f:	c7 45 cc 80 00 00 00 	movl   $0x80,-0x34(%ebp)
     asm volatile ("outw %0, %1" :: "a" (data), "d" (port) : "memory");
 }
 
 static inline void
 outsl(uint32_t port, const void *addr, int cnt) {
     asm volatile (
-c0101580:	8b 55 ec             	mov    -0x14(%ebp),%edx
-c0101583:	8b 4d d0             	mov    -0x30(%ebp),%ecx
-c0101586:	8b 45 cc             	mov    -0x34(%ebp),%eax
-c0101589:	89 cb                	mov    %ecx,%ebx
-c010158b:	89 de                	mov    %ebx,%esi
-c010158d:	89 c1                	mov    %eax,%ecx
-c010158f:	fc                   	cld    
-c0101590:	f2 6f                	repnz outsl %ds:(%esi),(%dx)
-c0101592:	89 c8                	mov    %ecx,%eax
-c0101594:	89 f3                	mov    %esi,%ebx
-c0101596:	89 5d d0             	mov    %ebx,-0x30(%ebp)
-c0101599:	89 45 cc             	mov    %eax,-0x34(%ebp)
+c0101516:	8b 55 ec             	mov    -0x14(%ebp),%edx
+c0101519:	8b 4d d0             	mov    -0x30(%ebp),%ecx
+c010151c:	8b 45 cc             	mov    -0x34(%ebp),%eax
+c010151f:	89 cb                	mov    %ecx,%ebx
+c0101521:	89 de                	mov    %ebx,%esi
+c0101523:	89 c1                	mov    %eax,%ecx
+c0101525:	fc                   	cld    
+c0101526:	f2 6f                	repnz outsl %ds:(%esi),(%dx)
+c0101528:	89 c8                	mov    %ecx,%eax
+c010152a:	89 f3                	mov    %esi,%ebx
+c010152c:	89 5d d0             	mov    %ebx,-0x30(%ebp)
+c010152f:	89 45 cc             	mov    %eax,-0x34(%ebp)
     outb(iobase + ISA_CYL_HI, (secno >> 16) & 0xFF);
     outb(iobase + ISA_SDH, 0xE0 | ((ideno & 1) << 4) | ((secno >> 24) & 0xF));
     outb(iobase + ISA_COMMAND, IDE_CMD_WRITE);
 
     int ret = 0;
     for (; nsecs > 0; nsecs --, src += SECTSIZE) {
-c010159c:	83 6d 14 01          	subl   $0x1,0x14(%ebp)
-c01015a0:	81 45 10 00 02 00 00 	addl   $0x200,0x10(%ebp)
-c01015a7:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
-c01015ab:	75 a4                	jne    c0101551 <ide_write_secs+0x1c1>
-c01015ad:	eb 01                	jmp    c01015b0 <ide_write_secs+0x220>
+c0101532:	ff 4d 14             	decl   0x14(%ebp)
+c0101535:	81 45 10 00 02 00 00 	addl   $0x200,0x10(%ebp)
+c010153c:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
+c0101540:	75 a3                	jne    c01014e5 <ide_write_secs+0x1d0>
+c0101542:	eb 01                	jmp    c0101545 <ide_write_secs+0x230>
         if ((ret = ide_wait_ready(iobase, 1)) != 0) {
             goto out;
-c01015af:	90                   	nop
+c0101544:	90                   	nop
         }
         outsl(iobase, src, SECTSIZE / sizeof(uint32_t));
     }
 
 out:
     return ret;
-c01015b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0101545:	8b 45 f4             	mov    -0xc(%ebp),%eax
 }
-c01015b3:	8d 65 f8             	lea    -0x8(%ebp),%esp
-c01015b6:	5b                   	pop    %ebx
-c01015b7:	5e                   	pop    %esi
-c01015b8:	5d                   	pop    %ebp
-c01015b9:	c3                   	ret    
+c0101548:	83 c4 50             	add    $0x50,%esp
+c010154b:	5b                   	pop    %ebx
+c010154c:	5e                   	pop    %esi
+c010154d:	5d                   	pop    %ebp
+c010154e:	c3                   	ret    
 
-c01015ba <clock_init>:
+c010154f <clock_init>:
 /* *
  * clock_init - initialize 8253 clock to interrupt 100 times per second,
  * and then enable IRQ_TIMER.
  * */
 void
 clock_init(void) {
-c01015ba:	55                   	push   %ebp
-c01015bb:	89 e5                	mov    %esp,%ebp
-c01015bd:	83 ec 18             	sub    $0x18,%esp
-c01015c0:	66 c7 45 f6 43 00    	movw   $0x43,-0xa(%ebp)
-c01015c6:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
+c010154f:	55                   	push   %ebp
+c0101550:	89 e5                	mov    %esp,%ebp
+c0101552:	83 ec 28             	sub    $0x28,%esp
+c0101555:	66 c7 45 f6 43 00    	movw   $0x43,-0xa(%ebp)
+c010155b:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
         : "memory", "cc");
 }
 
 static inline void
 outb(uint16_t port, uint8_t data) {
     asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
-c01015ca:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
-c01015ce:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
-c01015d2:	ee                   	out    %al,(%dx)
-c01015d3:	66 c7 45 f4 40 00    	movw   $0x40,-0xc(%ebp)
-c01015d9:	c6 45 f0 9c          	movb   $0x9c,-0x10(%ebp)
-c01015dd:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
-c01015e1:	0f b7 55 f4          	movzwl -0xc(%ebp),%edx
-c01015e5:	ee                   	out    %al,(%dx)
-c01015e6:	66 c7 45 f2 40 00    	movw   $0x40,-0xe(%ebp)
-c01015ec:	c6 45 f1 2e          	movb   $0x2e,-0xf(%ebp)
-c01015f0:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
-c01015f4:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
-c01015f8:	ee                   	out    %al,(%dx)
+c010155f:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+c0101563:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
+c0101567:	ee                   	out    %al,(%dx)
+c0101568:	66 c7 45 f4 40 00    	movw   $0x40,-0xc(%ebp)
+c010156e:	c6 45 f0 9c          	movb   $0x9c,-0x10(%ebp)
+c0101572:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
+c0101576:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0101579:	ee                   	out    %al,(%dx)
+c010157a:	66 c7 45 f2 40 00    	movw   $0x40,-0xe(%ebp)
+c0101580:	c6 45 f1 2e          	movb   $0x2e,-0xf(%ebp)
+c0101584:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
+c0101588:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+c010158c:	ee                   	out    %al,(%dx)
     outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
     outb(IO_TIMER1, TIMER_DIV(100) % 256);
     outb(IO_TIMER1, TIMER_DIV(100) / 256);
 
     // initialize time counter 'ticks' to zero
     ticks = 0;
-c01015f9:	c7 05 1c 30 12 c0 00 	movl   $0x0,0xc012301c
-c0101600:	00 00 00 
+c010158d:	c7 05 1c 40 12 c0 00 	movl   $0x0,0xc012401c
+c0101594:	00 00 00 
 
     cprintf("++ setup timer interrupts\n");
-c0101603:	83 ec 0c             	sub    $0xc,%esp
-c0101606:	68 86 87 10 c0       	push   $0xc0108786
-c010160b:	e8 72 ec ff ff       	call   c0100282 <cprintf>
-c0101610:	83 c4 10             	add    $0x10,%esp
+c0101597:	c7 04 24 9e 8e 10 c0 	movl   $0xc0108e9e,(%esp)
+c010159e:	e8 fe ec ff ff       	call   c01002a1 <cprintf>
     pic_enable(IRQ_TIMER);
-c0101613:	83 ec 0c             	sub    $0xc,%esp
-c0101616:	6a 00                	push   $0x0
-c0101618:	e8 3b 09 00 00       	call   c0101f58 <pic_enable>
-c010161d:	83 c4 10             	add    $0x10,%esp
-}
-c0101620:	90                   	nop
-c0101621:	c9                   	leave  
-c0101622:	c3                   	ret    
+c01015a3:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+c01015aa:	e8 1e 09 00 00       	call   c0101ecd <pic_enable>
+}
+c01015af:	90                   	nop
+c01015b0:	c9                   	leave  
+c01015b1:	c3                   	ret    
 
-c0101623 <__intr_save>:
+c01015b2 <__intr_save>:
 #include <x86.h>
 #include <intr.h>
 #include <mmu.h>
 
 static inline bool
 __intr_save(void) {
-c0101623:	55                   	push   %ebp
-c0101624:	89 e5                	mov    %esp,%ebp
-c0101626:	83 ec 18             	sub    $0x18,%esp
+c01015b2:	55                   	push   %ebp
+c01015b3:	89 e5                	mov    %esp,%ebp
+c01015b5:	83 ec 18             	sub    $0x18,%esp
 }
 
 static inline uint32_t
 read_eflags(void) {
     uint32_t eflags;
     asm volatile ("pushfl; popl %0" : "=r" (eflags));
-c0101629:	9c                   	pushf  
-c010162a:	58                   	pop    %eax
-c010162b:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c01015b8:	9c                   	pushf  
+c01015b9:	58                   	pop    %eax
+c01015ba:	89 45 f4             	mov    %eax,-0xc(%ebp)
     return eflags;
-c010162e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01015bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
     if (read_eflags() & FL_IF) {
-c0101631:	25 00 02 00 00       	and    $0x200,%eax
-c0101636:	85 c0                	test   %eax,%eax
-c0101638:	74 0c                	je     c0101646 <__intr_save+0x23>
+c01015c0:	25 00 02 00 00       	and    $0x200,%eax
+c01015c5:	85 c0                	test   %eax,%eax
+c01015c7:	74 0c                	je     c01015d5 <__intr_save+0x23>
         intr_disable();
-c010163a:	e8 8a 0a 00 00       	call   c01020c9 <intr_disable>
+c01015c9:	e8 6c 0a 00 00       	call   c010203a <intr_disable>
         return 1;
-c010163f:	b8 01 00 00 00       	mov    $0x1,%eax
-c0101644:	eb 05                	jmp    c010164b <__intr_save+0x28>
+c01015ce:	b8 01 00 00 00       	mov    $0x1,%eax
+c01015d3:	eb 05                	jmp    c01015da <__intr_save+0x28>
     }
     return 0;
-c0101646:	b8 00 00 00 00       	mov    $0x0,%eax
+c01015d5:	b8 00 00 00 00       	mov    $0x0,%eax
 }
-c010164b:	c9                   	leave  
-c010164c:	c3                   	ret    
+c01015da:	c9                   	leave  
+c01015db:	c3                   	ret    
 
-c010164d <__intr_restore>:
+c01015dc <__intr_restore>:
 
 static inline void
 __intr_restore(bool flag) {
-c010164d:	55                   	push   %ebp
-c010164e:	89 e5                	mov    %esp,%ebp
-c0101650:	83 ec 08             	sub    $0x8,%esp
+c01015dc:	55                   	push   %ebp
+c01015dd:	89 e5                	mov    %esp,%ebp
+c01015df:	83 ec 08             	sub    $0x8,%esp
     if (flag) {
-c0101653:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
-c0101657:	74 05                	je     c010165e <__intr_restore+0x11>
+c01015e2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+c01015e6:	74 05                	je     c01015ed <__intr_restore+0x11>
         intr_enable();
-c0101659:	e8 64 0a 00 00       	call   c01020c2 <intr_enable>
+c01015e8:	e8 46 0a 00 00       	call   c0102033 <intr_enable>
     }
 }
-c010165e:	90                   	nop
-c010165f:	c9                   	leave  
-c0101660:	c3                   	ret    
+c01015ed:	90                   	nop
+c01015ee:	c9                   	leave  
+c01015ef:	c3                   	ret    
 
-c0101661 <delay>:
+c01015f0 <delay>:
 #include <memlayout.h>
 #include <sync.h>
 
 /* stupid I/O delay routine necessitated by historical PC design flaws */
 static void
 delay(void) {
-c0101661:	55                   	push   %ebp
-c0101662:	89 e5                	mov    %esp,%ebp
-c0101664:	83 ec 10             	sub    $0x10,%esp
-c0101667:	66 c7 45 fe 84 00    	movw   $0x84,-0x2(%ebp)
+c01015f0:	55                   	push   %ebp
+c01015f1:	89 e5                	mov    %esp,%ebp
+c01015f3:	83 ec 10             	sub    $0x10,%esp
+c01015f6:	66 c7 45 fe 84 00    	movw   $0x84,-0x2(%ebp)
 static inline void invlpg(void *addr) __attribute__((always_inline));
 
 static inline uint8_t
 inb(uint16_t port) {
     uint8_t data;
     asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
-c010166d:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
-c0101671:	89 c2                	mov    %eax,%edx
-c0101673:	ec                   	in     (%dx),%al
-c0101674:	88 45 f4             	mov    %al,-0xc(%ebp)
-c0101677:	66 c7 45 fc 84 00    	movw   $0x84,-0x4(%ebp)
-c010167d:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
-c0101681:	89 c2                	mov    %eax,%edx
-c0101683:	ec                   	in     (%dx),%al
-c0101684:	88 45 f5             	mov    %al,-0xb(%ebp)
-c0101687:	66 c7 45 fa 84 00    	movw   $0x84,-0x6(%ebp)
-c010168d:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
-c0101691:	89 c2                	mov    %eax,%edx
-c0101693:	ec                   	in     (%dx),%al
-c0101694:	88 45 f6             	mov    %al,-0xa(%ebp)
-c0101697:	66 c7 45 f8 84 00    	movw   $0x84,-0x8(%ebp)
-c010169d:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
-c01016a1:	89 c2                	mov    %eax,%edx
-c01016a3:	ec                   	in     (%dx),%al
-c01016a4:	88 45 f7             	mov    %al,-0x9(%ebp)
+c01015fc:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
+c0101600:	89 c2                	mov    %eax,%edx
+c0101602:	ec                   	in     (%dx),%al
+c0101603:	88 45 f4             	mov    %al,-0xc(%ebp)
+c0101606:	66 c7 45 fc 84 00    	movw   $0x84,-0x4(%ebp)
+c010160c:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c010160f:	89 c2                	mov    %eax,%edx
+c0101611:	ec                   	in     (%dx),%al
+c0101612:	88 45 f5             	mov    %al,-0xb(%ebp)
+c0101615:	66 c7 45 fa 84 00    	movw   $0x84,-0x6(%ebp)
+c010161b:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
+c010161f:	89 c2                	mov    %eax,%edx
+c0101621:	ec                   	in     (%dx),%al
+c0101622:	88 45 f6             	mov    %al,-0xa(%ebp)
+c0101625:	66 c7 45 f8 84 00    	movw   $0x84,-0x8(%ebp)
+c010162b:	8b 45 f8             	mov    -0x8(%ebp),%eax
+c010162e:	89 c2                	mov    %eax,%edx
+c0101630:	ec                   	in     (%dx),%al
+c0101631:	88 45 f7             	mov    %al,-0x9(%ebp)
     inb(0x84);
     inb(0x84);
     inb(0x84);
     inb(0x84);
 }
-c01016a7:	90                   	nop
-c01016a8:	c9                   	leave  
-c01016a9:	c3                   	ret    
+c0101634:	90                   	nop
+c0101635:	c9                   	leave  
+c0101636:	c3                   	ret    
 
-c01016aa <cga_init>:
+c0101637 <cga_init>:
 static uint16_t addr_6845;
 
 /* TEXT-mode CGA/VGA display output */
 
 static void
 cga_init(void) {
-c01016aa:	55                   	push   %ebp
-c01016ab:	89 e5                	mov    %esp,%ebp
-c01016ad:	83 ec 20             	sub    $0x20,%esp
+c0101637:	55                   	push   %ebp
+c0101638:	89 e5                	mov    %esp,%ebp
+c010163a:	83 ec 20             	sub    $0x20,%esp
     volatile uint16_t *cp = (uint16_t *)(CGA_BUF + KERNBASE);
-c01016b0:	c7 45 fc 00 80 0b c0 	movl   $0xc00b8000,-0x4(%ebp)
+c010163d:	c7 45 fc 00 80 0b c0 	movl   $0xc00b8000,-0x4(%ebp)
     uint16_t was = *cp;
-c01016b7:	8b 45 fc             	mov    -0x4(%ebp),%eax
-c01016ba:	0f b7 00             	movzwl (%eax),%eax
-c01016bd:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
+c0101644:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0101647:	0f b7 00             	movzwl (%eax),%eax
+c010164a:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
     *cp = (uint16_t) 0xA55A;
-c01016c1:	8b 45 fc             	mov    -0x4(%ebp),%eax
-c01016c4:	66 c7 00 5a a5       	movw   $0xa55a,(%eax)
+c010164e:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0101651:	66 c7 00 5a a5       	movw   $0xa55a,(%eax)
     if (*cp != 0xA55A) {
-c01016c9:	8b 45 fc             	mov    -0x4(%ebp),%eax
-c01016cc:	0f b7 00             	movzwl (%eax),%eax
-c01016cf:	66 3d 5a a5          	cmp    $0xa55a,%ax
-c01016d3:	74 12                	je     c01016e7 <cga_init+0x3d>
+c0101656:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0101659:	0f b7 00             	movzwl (%eax),%eax
+c010165c:	0f b7 c0             	movzwl %ax,%eax
+c010165f:	3d 5a a5 00 00       	cmp    $0xa55a,%eax
+c0101664:	74 12                	je     c0101678 <cga_init+0x41>
         cp = (uint16_t*)(MONO_BUF + KERNBASE);
-c01016d5:	c7 45 fc 00 00 0b c0 	movl   $0xc00b0000,-0x4(%ebp)
+c0101666:	c7 45 fc 00 00 0b c0 	movl   $0xc00b0000,-0x4(%ebp)
         addr_6845 = MONO_BASE;
-c01016dc:	66 c7 05 26 25 12 c0 	movw   $0x3b4,0xc0122526
-c01016e3:	b4 03 
-c01016e5:	eb 13                	jmp    c01016fa <cga_init+0x50>
+c010166d:	66 c7 05 26 35 12 c0 	movw   $0x3b4,0xc0123526
+c0101674:	b4 03 
+c0101676:	eb 13                	jmp    c010168b <cga_init+0x54>
     } else {
         *cp = was;
-c01016e7:	8b 45 fc             	mov    -0x4(%ebp),%eax
-c01016ea:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
-c01016ee:	66 89 10             	mov    %dx,(%eax)
+c0101678:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c010167b:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
+c010167f:	66 89 10             	mov    %dx,(%eax)
         addr_6845 = CGA_BASE;
-c01016f1:	66 c7 05 26 25 12 c0 	movw   $0x3d4,0xc0122526
-c01016f8:	d4 03 
+c0101682:	66 c7 05 26 35 12 c0 	movw   $0x3d4,0xc0123526
+c0101689:	d4 03 
     }
 
     // Extract cursor location
     uint32_t pos;
     outb(addr_6845, 14);
-c01016fa:	0f b7 05 26 25 12 c0 	movzwl 0xc0122526,%eax
-c0101701:	0f b7 c0             	movzwl %ax,%eax
-c0101704:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
-c0101708:	c6 45 ea 0e          	movb   $0xe,-0x16(%ebp)
+c010168b:	0f b7 05 26 35 12 c0 	movzwl 0xc0123526,%eax
+c0101692:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
+c0101696:	c6 45 ea 0e          	movb   $0xe,-0x16(%ebp)
         : "memory", "cc");
 }
 
 static inline void
 outb(uint16_t port, uint8_t data) {
     asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
-c010170c:	0f b6 45 ea          	movzbl -0x16(%ebp),%eax
-c0101710:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
-c0101714:	ee                   	out    %al,(%dx)
+c010169a:	0f b6 45 ea          	movzbl -0x16(%ebp),%eax
+c010169e:	8b 55 f8             	mov    -0x8(%ebp),%edx
+c01016a1:	ee                   	out    %al,(%dx)
     pos = inb(addr_6845 + 1) << 8;
-c0101715:	0f b7 05 26 25 12 c0 	movzwl 0xc0122526,%eax
-c010171c:	83 c0 01             	add    $0x1,%eax
-c010171f:	0f b7 c0             	movzwl %ax,%eax
-c0101722:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
+c01016a2:	0f b7 05 26 35 12 c0 	movzwl 0xc0123526,%eax
+c01016a9:	40                   	inc    %eax
+c01016aa:	0f b7 c0             	movzwl %ax,%eax
+c01016ad:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
 static inline void invlpg(void *addr) __attribute__((always_inline));
 
 static inline uint8_t
 inb(uint16_t port) {
     uint8_t data;
     asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
-c0101726:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
-c010172a:	89 c2                	mov    %eax,%edx
-c010172c:	ec                   	in     (%dx),%al
-c010172d:	88 45 eb             	mov    %al,-0x15(%ebp)
+c01016b1:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
+c01016b5:	89 c2                	mov    %eax,%edx
+c01016b7:	ec                   	in     (%dx),%al
+c01016b8:	88 45 eb             	mov    %al,-0x15(%ebp)
     return data;
-c0101730:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
-c0101734:	0f b6 c0             	movzbl %al,%eax
-c0101737:	c1 e0 08             	shl    $0x8,%eax
-c010173a:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c01016bb:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
+c01016bf:	0f b6 c0             	movzbl %al,%eax
+c01016c2:	c1 e0 08             	shl    $0x8,%eax
+c01016c5:	89 45 f4             	mov    %eax,-0xc(%ebp)
     outb(addr_6845, 15);
-c010173d:	0f b7 05 26 25 12 c0 	movzwl 0xc0122526,%eax
-c0101744:	0f b7 c0             	movzwl %ax,%eax
-c0101747:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
-c010174b:	c6 45 ec 0f          	movb   $0xf,-0x14(%ebp)
+c01016c8:	0f b7 05 26 35 12 c0 	movzwl 0xc0123526,%eax
+c01016cf:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
+c01016d3:	c6 45 ec 0f          	movb   $0xf,-0x14(%ebp)
         : "memory", "cc");
 }
 
 static inline void
 outb(uint16_t port, uint8_t data) {
     asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
-c010174f:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
-c0101753:	0f b7 55 f0          	movzwl -0x10(%ebp),%edx
-c0101757:	ee                   	out    %al,(%dx)
+c01016d7:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
+c01016db:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c01016de:	ee                   	out    %al,(%dx)
     pos |= inb(addr_6845 + 1);
-c0101758:	0f b7 05 26 25 12 c0 	movzwl 0xc0122526,%eax
-c010175f:	83 c0 01             	add    $0x1,%eax
-c0101762:	0f b7 c0             	movzwl %ax,%eax
-c0101765:	66 89 45 ee          	mov    %ax,-0x12(%ebp)
+c01016df:	0f b7 05 26 35 12 c0 	movzwl 0xc0123526,%eax
+c01016e6:	40                   	inc    %eax
+c01016e7:	0f b7 c0             	movzwl %ax,%eax
+c01016ea:	66 89 45 ee          	mov    %ax,-0x12(%ebp)
 static inline void invlpg(void *addr) __attribute__((always_inline));
 
 static inline uint8_t
 inb(uint16_t port) {
     uint8_t data;
     asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
-c0101769:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
-c010176d:	89 c2                	mov    %eax,%edx
-c010176f:	ec                   	in     (%dx),%al
-c0101770:	88 45 ed             	mov    %al,-0x13(%ebp)
+c01016ee:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
+c01016f2:	89 c2                	mov    %eax,%edx
+c01016f4:	ec                   	in     (%dx),%al
+c01016f5:	88 45 ed             	mov    %al,-0x13(%ebp)
     return data;
-c0101773:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
-c0101777:	0f b6 c0             	movzbl %al,%eax
-c010177a:	09 45 f4             	or     %eax,-0xc(%ebp)
+c01016f8:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
+c01016fc:	0f b6 c0             	movzbl %al,%eax
+c01016ff:	09 45 f4             	or     %eax,-0xc(%ebp)
 
     crt_buf = (uint16_t*) cp;
-c010177d:	8b 45 fc             	mov    -0x4(%ebp),%eax
-c0101780:	a3 20 25 12 c0       	mov    %eax,0xc0122520
+c0101702:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0101705:	a3 20 35 12 c0       	mov    %eax,0xc0123520
     crt_pos = pos;
-c0101785:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0101788:	66 a3 24 25 12 c0    	mov    %ax,0xc0122524
-}
-c010178e:	90                   	nop
-c010178f:	c9                   	leave  
-c0101790:	c3                   	ret    
+c010170a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010170d:	0f b7 c0             	movzwl %ax,%eax
+c0101710:	66 a3 24 35 12 c0    	mov    %ax,0xc0123524
+}
+c0101716:	90                   	nop
+c0101717:	c9                   	leave  
+c0101718:	c3                   	ret    
 
-c0101791 <serial_init>:
+c0101719 <serial_init>:
 
 static bool serial_exists = 0;
 
 static void
 serial_init(void) {
-c0101791:	55                   	push   %ebp
-c0101792:	89 e5                	mov    %esp,%ebp
-c0101794:	83 ec 28             	sub    $0x28,%esp
-c0101797:	66 c7 45 f6 fa 03    	movw   $0x3fa,-0xa(%ebp)
-c010179d:	c6 45 da 00          	movb   $0x0,-0x26(%ebp)
+c0101719:	55                   	push   %ebp
+c010171a:	89 e5                	mov    %esp,%ebp
+c010171c:	83 ec 38             	sub    $0x38,%esp
+c010171f:	66 c7 45 f6 fa 03    	movw   $0x3fa,-0xa(%ebp)
+c0101725:	c6 45 da 00          	movb   $0x0,-0x26(%ebp)
         : "memory", "cc");
 }
 
 static inline void
 outb(uint16_t port, uint8_t data) {
     asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
-c01017a1:	0f b6 45 da          	movzbl -0x26(%ebp),%eax
-c01017a5:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
-c01017a9:	ee                   	out    %al,(%dx)
-c01017aa:	66 c7 45 f4 fb 03    	movw   $0x3fb,-0xc(%ebp)
-c01017b0:	c6 45 db 80          	movb   $0x80,-0x25(%ebp)
-c01017b4:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
-c01017b8:	0f b7 55 f4          	movzwl -0xc(%ebp),%edx
-c01017bc:	ee                   	out    %al,(%dx)
-c01017bd:	66 c7 45 f2 f8 03    	movw   $0x3f8,-0xe(%ebp)
-c01017c3:	c6 45 dc 0c          	movb   $0xc,-0x24(%ebp)
-c01017c7:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
-c01017cb:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
-c01017cf:	ee                   	out    %al,(%dx)
-c01017d0:	66 c7 45 f0 f9 03    	movw   $0x3f9,-0x10(%ebp)
-c01017d6:	c6 45 dd 00          	movb   $0x0,-0x23(%ebp)
-c01017da:	0f b6 45 dd          	movzbl -0x23(%ebp),%eax
-c01017de:	0f b7 55 f0          	movzwl -0x10(%ebp),%edx
-c01017e2:	ee                   	out    %al,(%dx)
-c01017e3:	66 c7 45 ee fb 03    	movw   $0x3fb,-0x12(%ebp)
-c01017e9:	c6 45 de 03          	movb   $0x3,-0x22(%ebp)
-c01017ed:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
-c01017f1:	0f b7 55 ee          	movzwl -0x12(%ebp),%edx
-c01017f5:	ee                   	out    %al,(%dx)
-c01017f6:	66 c7 45 ec fc 03    	movw   $0x3fc,-0x14(%ebp)
-c01017fc:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
-c0101800:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
-c0101804:	0f b7 55 ec          	movzwl -0x14(%ebp),%edx
-c0101808:	ee                   	out    %al,(%dx)
-c0101809:	66 c7 45 ea f9 03    	movw   $0x3f9,-0x16(%ebp)
-c010180f:	c6 45 e0 01          	movb   $0x1,-0x20(%ebp)
-c0101813:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
-c0101817:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
-c010181b:	ee                   	out    %al,(%dx)
-c010181c:	66 c7 45 e8 fd 03    	movw   $0x3fd,-0x18(%ebp)
+c0101729:	0f b6 45 da          	movzbl -0x26(%ebp),%eax
+c010172d:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
+c0101731:	ee                   	out    %al,(%dx)
+c0101732:	66 c7 45 f4 fb 03    	movw   $0x3fb,-0xc(%ebp)
+c0101738:	c6 45 db 80          	movb   $0x80,-0x25(%ebp)
+c010173c:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
+c0101740:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0101743:	ee                   	out    %al,(%dx)
+c0101744:	66 c7 45 f2 f8 03    	movw   $0x3f8,-0xe(%ebp)
+c010174a:	c6 45 dc 0c          	movb   $0xc,-0x24(%ebp)
+c010174e:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
+c0101752:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+c0101756:	ee                   	out    %al,(%dx)
+c0101757:	66 c7 45 f0 f9 03    	movw   $0x3f9,-0x10(%ebp)
+c010175d:	c6 45 dd 00          	movb   $0x0,-0x23(%ebp)
+c0101761:	0f b6 45 dd          	movzbl -0x23(%ebp),%eax
+c0101765:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c0101768:	ee                   	out    %al,(%dx)
+c0101769:	66 c7 45 ee fb 03    	movw   $0x3fb,-0x12(%ebp)
+c010176f:	c6 45 de 03          	movb   $0x3,-0x22(%ebp)
+c0101773:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
+c0101777:	0f b7 55 ee          	movzwl -0x12(%ebp),%edx
+c010177b:	ee                   	out    %al,(%dx)
+c010177c:	66 c7 45 ec fc 03    	movw   $0x3fc,-0x14(%ebp)
+c0101782:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
+c0101786:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
+c010178a:	8b 55 ec             	mov    -0x14(%ebp),%edx
+c010178d:	ee                   	out    %al,(%dx)
+c010178e:	66 c7 45 ea f9 03    	movw   $0x3f9,-0x16(%ebp)
+c0101794:	c6 45 e0 01          	movb   $0x1,-0x20(%ebp)
+c0101798:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
+c010179c:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
+c01017a0:	ee                   	out    %al,(%dx)
+c01017a1:	66 c7 45 e8 fd 03    	movw   $0x3fd,-0x18(%ebp)
 static inline void invlpg(void *addr) __attribute__((always_inline));
 
 static inline uint8_t
 inb(uint16_t port) {
     uint8_t data;
     asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
-c0101822:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
-c0101826:	89 c2                	mov    %eax,%edx
-c0101828:	ec                   	in     (%dx),%al
-c0101829:	88 45 e1             	mov    %al,-0x1f(%ebp)
+c01017a7:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c01017aa:	89 c2                	mov    %eax,%edx
+c01017ac:	ec                   	in     (%dx),%al
+c01017ad:	88 45 e1             	mov    %al,-0x1f(%ebp)
     return data;
-c010182c:	0f b6 45 e1          	movzbl -0x1f(%ebp),%eax
+c01017b0:	0f b6 45 e1          	movzbl -0x1f(%ebp),%eax
     // Enable rcv interrupts
     outb(COM1 + COM_IER, COM_IER_RDI);
 
     // Clear any preexisting overrun indications and interrupts
     // Serial port doesn't exist if COM_LSR returns 0xFF
     serial_exists = (inb(COM1 + COM_LSR) != 0xFF);
-c0101830:	3c ff                	cmp    $0xff,%al
-c0101832:	0f 95 c0             	setne  %al
-c0101835:	0f b6 c0             	movzbl %al,%eax
-c0101838:	a3 28 25 12 c0       	mov    %eax,0xc0122528
-c010183d:	66 c7 45 e6 fa 03    	movw   $0x3fa,-0x1a(%ebp)
+c01017b4:	3c ff                	cmp    $0xff,%al
+c01017b6:	0f 95 c0             	setne  %al
+c01017b9:	0f b6 c0             	movzbl %al,%eax
+c01017bc:	a3 28 35 12 c0       	mov    %eax,0xc0123528
+c01017c1:	66 c7 45 e6 fa 03    	movw   $0x3fa,-0x1a(%ebp)
 static inline void invlpg(void *addr) __attribute__((always_inline));
 
 static inline uint8_t
 inb(uint16_t port) {
     uint8_t data;
     asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
-c0101843:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
-c0101847:	89 c2                	mov    %eax,%edx
-c0101849:	ec                   	in     (%dx),%al
-c010184a:	88 45 e2             	mov    %al,-0x1e(%ebp)
-c010184d:	66 c7 45 e4 f8 03    	movw   $0x3f8,-0x1c(%ebp)
-c0101853:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
-c0101857:	89 c2                	mov    %eax,%edx
-c0101859:	ec                   	in     (%dx),%al
-c010185a:	88 45 e3             	mov    %al,-0x1d(%ebp)
+c01017c7:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
+c01017cb:	89 c2                	mov    %eax,%edx
+c01017cd:	ec                   	in     (%dx),%al
+c01017ce:	88 45 e2             	mov    %al,-0x1e(%ebp)
+c01017d1:	66 c7 45 e4 f8 03    	movw   $0x3f8,-0x1c(%ebp)
+c01017d7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c01017da:	89 c2                	mov    %eax,%edx
+c01017dc:	ec                   	in     (%dx),%al
+c01017dd:	88 45 e3             	mov    %al,-0x1d(%ebp)
     (void) inb(COM1+COM_IIR);
     (void) inb(COM1+COM_RX);
 
     if (serial_exists) {
-c010185d:	a1 28 25 12 c0       	mov    0xc0122528,%eax
-c0101862:	85 c0                	test   %eax,%eax
-c0101864:	74 0d                	je     c0101873 <serial_init+0xe2>
+c01017e0:	a1 28 35 12 c0       	mov    0xc0123528,%eax
+c01017e5:	85 c0                	test   %eax,%eax
+c01017e7:	74 0c                	je     c01017f5 <serial_init+0xdc>
         pic_enable(IRQ_COM1);
-c0101866:	83 ec 0c             	sub    $0xc,%esp
-c0101869:	6a 04                	push   $0x4
-c010186b:	e8 e8 06 00 00       	call   c0101f58 <pic_enable>
-c0101870:	83 c4 10             	add    $0x10,%esp
+c01017e9:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
+c01017f0:	e8 d8 06 00 00       	call   c0101ecd <pic_enable>
     }
 }
-c0101873:	90                   	nop
-c0101874:	c9                   	leave  
-c0101875:	c3                   	ret    
+c01017f5:	90                   	nop
+c01017f6:	c9                   	leave  
+c01017f7:	c3                   	ret    
 
-c0101876 <lpt_putc_sub>:
+c01017f8 <lpt_putc_sub>:
 
 static void
 lpt_putc_sub(int c) {
-c0101876:	55                   	push   %ebp
-c0101877:	89 e5                	mov    %esp,%ebp
-c0101879:	83 ec 10             	sub    $0x10,%esp
+c01017f8:	55                   	push   %ebp
+c01017f9:	89 e5                	mov    %esp,%ebp
+c01017fb:	83 ec 10             	sub    $0x10,%esp
     int i;
     for (i = 0; !(inb(LPTPORT + 1) & 0x80) && i < 12800; i ++) {
-c010187c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
-c0101883:	eb 09                	jmp    c010188e <lpt_putc_sub+0x18>
+c01017fe:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+c0101805:	eb 08                	jmp    c010180f <lpt_putc_sub+0x17>
         delay();
-c0101885:	e8 d7 fd ff ff       	call   c0101661 <delay>
+c0101807:	e8 e4 fd ff ff       	call   c01015f0 <delay>
 }
 
 static void
 lpt_putc_sub(int c) {
     int i;
     for (i = 0; !(inb(LPTPORT + 1) & 0x80) && i < 12800; i ++) {
-c010188a:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
-c010188e:	66 c7 45 f4 79 03    	movw   $0x379,-0xc(%ebp)
-c0101894:	0f b7 45 f4          	movzwl -0xc(%ebp),%eax
-c0101898:	89 c2                	mov    %eax,%edx
-c010189a:	ec                   	in     (%dx),%al
-c010189b:	88 45 f3             	mov    %al,-0xd(%ebp)
+c010180c:	ff 45 fc             	incl   -0x4(%ebp)
+c010180f:	66 c7 45 f4 79 03    	movw   $0x379,-0xc(%ebp)
+c0101815:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0101818:	89 c2                	mov    %eax,%edx
+c010181a:	ec                   	in     (%dx),%al
+c010181b:	88 45 f3             	mov    %al,-0xd(%ebp)
     return data;
-c010189e:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
-c01018a2:	84 c0                	test   %al,%al
-c01018a4:	78 09                	js     c01018af <lpt_putc_sub+0x39>
-c01018a6:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%ebp)
-c01018ad:	7e d6                	jle    c0101885 <lpt_putc_sub+0xf>
+c010181e:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+c0101822:	84 c0                	test   %al,%al
+c0101824:	78 09                	js     c010182f <lpt_putc_sub+0x37>
+c0101826:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%ebp)
+c010182d:	7e d8                	jle    c0101807 <lpt_putc_sub+0xf>
         delay();
     }
     outb(LPTPORT + 0, c);
-c01018af:	8b 45 08             	mov    0x8(%ebp),%eax
-c01018b2:	0f b6 c0             	movzbl %al,%eax
-c01018b5:	66 c7 45 f8 78 03    	movw   $0x378,-0x8(%ebp)
-c01018bb:	88 45 f0             	mov    %al,-0x10(%ebp)
+c010182f:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101832:	0f b6 c0             	movzbl %al,%eax
+c0101835:	66 c7 45 f8 78 03    	movw   $0x378,-0x8(%ebp)
+c010183b:	88 45 f0             	mov    %al,-0x10(%ebp)
         : "memory", "cc");
 }
 
 static inline void
 outb(uint16_t port, uint8_t data) {
     asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
-c01018be:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
-c01018c2:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
-c01018c6:	ee                   	out    %al,(%dx)
-c01018c7:	66 c7 45 f6 7a 03    	movw   $0x37a,-0xa(%ebp)
-c01018cd:	c6 45 f1 0d          	movb   $0xd,-0xf(%ebp)
-c01018d1:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
-c01018d5:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
-c01018d9:	ee                   	out    %al,(%dx)
-c01018da:	66 c7 45 fa 7a 03    	movw   $0x37a,-0x6(%ebp)
-c01018e0:	c6 45 f2 08          	movb   $0x8,-0xe(%ebp)
-c01018e4:	0f b6 45 f2          	movzbl -0xe(%ebp),%eax
-c01018e8:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
-c01018ec:	ee                   	out    %al,(%dx)
+c010183e:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
+c0101842:	8b 55 f8             	mov    -0x8(%ebp),%edx
+c0101845:	ee                   	out    %al,(%dx)
+c0101846:	66 c7 45 f6 7a 03    	movw   $0x37a,-0xa(%ebp)
+c010184c:	c6 45 f1 0d          	movb   $0xd,-0xf(%ebp)
+c0101850:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
+c0101854:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
+c0101858:	ee                   	out    %al,(%dx)
+c0101859:	66 c7 45 fa 7a 03    	movw   $0x37a,-0x6(%ebp)
+c010185f:	c6 45 f2 08          	movb   $0x8,-0xe(%ebp)
+c0101863:	0f b6 45 f2          	movzbl -0xe(%ebp),%eax
+c0101867:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
+c010186b:	ee                   	out    %al,(%dx)
     outb(LPTPORT + 2, 0x08 | 0x04 | 0x01);
     outb(LPTPORT + 2, 0x08);
 }
-c01018ed:	90                   	nop
-c01018ee:	c9                   	leave  
-c01018ef:	c3                   	ret    
+c010186c:	90                   	nop
+c010186d:	c9                   	leave  
+c010186e:	c3                   	ret    
 
-c01018f0 <lpt_putc>:
+c010186f <lpt_putc>:
 
 /* lpt_putc - copy console output to parallel port */
 static void
 lpt_putc(int c) {
-c01018f0:	55                   	push   %ebp
-c01018f1:	89 e5                	mov    %esp,%ebp
+c010186f:	55                   	push   %ebp
+c0101870:	89 e5                	mov    %esp,%ebp
+c0101872:	83 ec 04             	sub    $0x4,%esp
     if (c != '\b') {
-c01018f3:	83 7d 08 08          	cmpl   $0x8,0x8(%ebp)
-c01018f7:	74 0d                	je     c0101906 <lpt_putc+0x16>
+c0101875:	83 7d 08 08          	cmpl   $0x8,0x8(%ebp)
+c0101879:	74 0d                	je     c0101888 <lpt_putc+0x19>
         lpt_putc_sub(c);
-c01018f9:	ff 75 08             	pushl  0x8(%ebp)
-c01018fc:	e8 75 ff ff ff       	call   c0101876 <lpt_putc_sub>
-c0101901:	83 c4 04             	add    $0x4,%esp
+c010187b:	8b 45 08             	mov    0x8(%ebp),%eax
+c010187e:	89 04 24             	mov    %eax,(%esp)
+c0101881:	e8 72 ff ff ff       	call   c01017f8 <lpt_putc_sub>
     else {
         lpt_putc_sub('\b');
         lpt_putc_sub(' ');
         lpt_putc_sub('\b');
     }
 }
-c0101904:	eb 1e                	jmp    c0101924 <lpt_putc+0x34>
+c0101886:	eb 24                	jmp    c01018ac <lpt_putc+0x3d>
 lpt_putc(int c) {
     if (c != '\b') {
         lpt_putc_sub(c);
     }
     else {
         lpt_putc_sub('\b');
-c0101906:	6a 08                	push   $0x8
-c0101908:	e8 69 ff ff ff       	call   c0101876 <lpt_putc_sub>
-c010190d:	83 c4 04             	add    $0x4,%esp
+c0101888:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
+c010188f:	e8 64 ff ff ff       	call   c01017f8 <lpt_putc_sub>
         lpt_putc_sub(' ');
-c0101910:	6a 20                	push   $0x20
-c0101912:	e8 5f ff ff ff       	call   c0101876 <lpt_putc_sub>
-c0101917:	83 c4 04             	add    $0x4,%esp
+c0101894:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
+c010189b:	e8 58 ff ff ff       	call   c01017f8 <lpt_putc_sub>
         lpt_putc_sub('\b');
-c010191a:	6a 08                	push   $0x8
-c010191c:	e8 55 ff ff ff       	call   c0101876 <lpt_putc_sub>
-c0101921:	83 c4 04             	add    $0x4,%esp
+c01018a0:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
+c01018a7:	e8 4c ff ff ff       	call   c01017f8 <lpt_putc_sub>
     }
 }
-c0101924:	90                   	nop
-c0101925:	c9                   	leave  
-c0101926:	c3                   	ret    
+c01018ac:	90                   	nop
+c01018ad:	c9                   	leave  
+c01018ae:	c3                   	ret    
 
-c0101927 <cga_putc>:
+c01018af <cga_putc>:
 
 /* cga_putc - print character to console */
 static void
 cga_putc(int c) {
-c0101927:	55                   	push   %ebp
-c0101928:	89 e5                	mov    %esp,%ebp
-c010192a:	53                   	push   %ebx
-c010192b:	83 ec 14             	sub    $0x14,%esp
+c01018af:	55                   	push   %ebp
+c01018b0:	89 e5                	mov    %esp,%ebp
+c01018b2:	53                   	push   %ebx
+c01018b3:	83 ec 24             	sub    $0x24,%esp
     // set black on white
     if (!(c & ~0xFF)) {
-c010192e:	8b 45 08             	mov    0x8(%ebp),%eax
-c0101931:	b0 00                	mov    $0x0,%al
-c0101933:	85 c0                	test   %eax,%eax
-c0101935:	75 07                	jne    c010193e <cga_putc+0x17>
+c01018b6:	8b 45 08             	mov    0x8(%ebp),%eax
+c01018b9:	25 00 ff ff ff       	and    $0xffffff00,%eax
+c01018be:	85 c0                	test   %eax,%eax
+c01018c0:	75 07                	jne    c01018c9 <cga_putc+0x1a>
         c |= 0x0700;
-c0101937:	81 4d 08 00 07 00 00 	orl    $0x700,0x8(%ebp)
+c01018c2:	81 4d 08 00 07 00 00 	orl    $0x700,0x8(%ebp)
     }
 
     switch (c & 0xff) {
-c010193e:	8b 45 08             	mov    0x8(%ebp),%eax
-c0101941:	0f b6 c0             	movzbl %al,%eax
-c0101944:	83 f8 0a             	cmp    $0xa,%eax
-c0101947:	74 4e                	je     c0101997 <cga_putc+0x70>
-c0101949:	83 f8 0d             	cmp    $0xd,%eax
-c010194c:	74 59                	je     c01019a7 <cga_putc+0x80>
-c010194e:	83 f8 08             	cmp    $0x8,%eax
-c0101951:	0f 85 8a 00 00 00    	jne    c01019e1 <cga_putc+0xba>
+c01018c9:	8b 45 08             	mov    0x8(%ebp),%eax
+c01018cc:	0f b6 c0             	movzbl %al,%eax
+c01018cf:	83 f8 0a             	cmp    $0xa,%eax
+c01018d2:	74 54                	je     c0101928 <cga_putc+0x79>
+c01018d4:	83 f8 0d             	cmp    $0xd,%eax
+c01018d7:	74 62                	je     c010193b <cga_putc+0x8c>
+c01018d9:	83 f8 08             	cmp    $0x8,%eax
+c01018dc:	0f 85 93 00 00 00    	jne    c0101975 <cga_putc+0xc6>
     case '\b':
         if (crt_pos > 0) {
-c0101957:	0f b7 05 24 25 12 c0 	movzwl 0xc0122524,%eax
-c010195e:	66 85 c0             	test   %ax,%ax
-c0101961:	0f 84 a0 00 00 00    	je     c0101a07 <cga_putc+0xe0>
+c01018e2:	0f b7 05 24 35 12 c0 	movzwl 0xc0123524,%eax
+c01018e9:	85 c0                	test   %eax,%eax
+c01018eb:	0f 84 ae 00 00 00    	je     c010199f <cga_putc+0xf0>
             crt_pos --;
-c0101967:	0f b7 05 24 25 12 c0 	movzwl 0xc0122524,%eax
-c010196e:	83 e8 01             	sub    $0x1,%eax
-c0101971:	66 a3 24 25 12 c0    	mov    %ax,0xc0122524
+c01018f1:	0f b7 05 24 35 12 c0 	movzwl 0xc0123524,%eax
+c01018f8:	48                   	dec    %eax
+c01018f9:	0f b7 c0             	movzwl %ax,%eax
+c01018fc:	66 a3 24 35 12 c0    	mov    %ax,0xc0123524
             crt_buf[crt_pos] = (c & ~0xff) | ' ';
-c0101977:	a1 20 25 12 c0       	mov    0xc0122520,%eax
-c010197c:	0f b7 15 24 25 12 c0 	movzwl 0xc0122524,%edx
-c0101983:	0f b7 d2             	movzwl %dx,%edx
-c0101986:	01 d2                	add    %edx,%edx
-c0101988:	01 d0                	add    %edx,%eax
-c010198a:	8b 55 08             	mov    0x8(%ebp),%edx
-c010198d:	b2 00                	mov    $0x0,%dl
-c010198f:	83 ca 20             	or     $0x20,%edx
-c0101992:	66 89 10             	mov    %dx,(%eax)
+c0101902:	a1 20 35 12 c0       	mov    0xc0123520,%eax
+c0101907:	0f b7 15 24 35 12 c0 	movzwl 0xc0123524,%edx
+c010190e:	01 d2                	add    %edx,%edx
+c0101910:	01 c2                	add    %eax,%edx
+c0101912:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101915:	98                   	cwtl   
+c0101916:	25 00 ff ff ff       	and    $0xffffff00,%eax
+c010191b:	98                   	cwtl   
+c010191c:	83 c8 20             	or     $0x20,%eax
+c010191f:	98                   	cwtl   
+c0101920:	0f b7 c0             	movzwl %ax,%eax
+c0101923:	66 89 02             	mov    %ax,(%edx)
         }
         break;
-c0101995:	eb 70                	jmp    c0101a07 <cga_putc+0xe0>
+c0101926:	eb 77                	jmp    c010199f <cga_putc+0xf0>
     case '\n':
         crt_pos += CRT_COLS;
-c0101997:	0f b7 05 24 25 12 c0 	movzwl 0xc0122524,%eax
-c010199e:	83 c0 50             	add    $0x50,%eax
-c01019a1:	66 a3 24 25 12 c0    	mov    %ax,0xc0122524
+c0101928:	0f b7 05 24 35 12 c0 	movzwl 0xc0123524,%eax
+c010192f:	83 c0 50             	add    $0x50,%eax
+c0101932:	0f b7 c0             	movzwl %ax,%eax
+c0101935:	66 a3 24 35 12 c0    	mov    %ax,0xc0123524
     case '\r':
         crt_pos -= (crt_pos % CRT_COLS);
-c01019a7:	0f b7 1d 24 25 12 c0 	movzwl 0xc0122524,%ebx
-c01019ae:	0f b7 0d 24 25 12 c0 	movzwl 0xc0122524,%ecx
-c01019b5:	0f b7 c1             	movzwl %cx,%eax
-c01019b8:	69 c0 cd cc 00 00    	imul   $0xcccd,%eax,%eax
-c01019be:	c1 e8 10             	shr    $0x10,%eax
-c01019c1:	89 c2                	mov    %eax,%edx
-c01019c3:	66 c1 ea 06          	shr    $0x6,%dx
-c01019c7:	89 d0                	mov    %edx,%eax
-c01019c9:	c1 e0 02             	shl    $0x2,%eax
-c01019cc:	01 d0                	add    %edx,%eax
-c01019ce:	c1 e0 04             	shl    $0x4,%eax
-c01019d1:	29 c1                	sub    %eax,%ecx
-c01019d3:	89 ca                	mov    %ecx,%edx
-c01019d5:	89 d8                	mov    %ebx,%eax
-c01019d7:	29 d0                	sub    %edx,%eax
-c01019d9:	66 a3 24 25 12 c0    	mov    %ax,0xc0122524
+c010193b:	0f b7 1d 24 35 12 c0 	movzwl 0xc0123524,%ebx
+c0101942:	0f b7 0d 24 35 12 c0 	movzwl 0xc0123524,%ecx
+c0101949:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
+c010194e:	89 c8                	mov    %ecx,%eax
+c0101950:	f7 e2                	mul    %edx
+c0101952:	c1 ea 06             	shr    $0x6,%edx
+c0101955:	89 d0                	mov    %edx,%eax
+c0101957:	c1 e0 02             	shl    $0x2,%eax
+c010195a:	01 d0                	add    %edx,%eax
+c010195c:	c1 e0 04             	shl    $0x4,%eax
+c010195f:	29 c1                	sub    %eax,%ecx
+c0101961:	89 c8                	mov    %ecx,%eax
+c0101963:	0f b7 c0             	movzwl %ax,%eax
+c0101966:	29 c3                	sub    %eax,%ebx
+c0101968:	89 d8                	mov    %ebx,%eax
+c010196a:	0f b7 c0             	movzwl %ax,%eax
+c010196d:	66 a3 24 35 12 c0    	mov    %ax,0xc0123524
         break;
-c01019df:	eb 27                	jmp    c0101a08 <cga_putc+0xe1>
+c0101973:	eb 2b                	jmp    c01019a0 <cga_putc+0xf1>
     default:
         crt_buf[crt_pos ++] = c;     // write the character
-c01019e1:	8b 0d 20 25 12 c0    	mov    0xc0122520,%ecx
-c01019e7:	0f b7 05 24 25 12 c0 	movzwl 0xc0122524,%eax
-c01019ee:	8d 50 01             	lea    0x1(%eax),%edx
-c01019f1:	66 89 15 24 25 12 c0 	mov    %dx,0xc0122524
-c01019f8:	0f b7 c0             	movzwl %ax,%eax
-c01019fb:	01 c0                	add    %eax,%eax
-c01019fd:	01 c8                	add    %ecx,%eax
-c01019ff:	8b 55 08             	mov    0x8(%ebp),%edx
-c0101a02:	66 89 10             	mov    %dx,(%eax)
+c0101975:	8b 0d 20 35 12 c0    	mov    0xc0123520,%ecx
+c010197b:	0f b7 05 24 35 12 c0 	movzwl 0xc0123524,%eax
+c0101982:	8d 50 01             	lea    0x1(%eax),%edx
+c0101985:	0f b7 d2             	movzwl %dx,%edx
+c0101988:	66 89 15 24 35 12 c0 	mov    %dx,0xc0123524
+c010198f:	01 c0                	add    %eax,%eax
+c0101991:	8d 14 01             	lea    (%ecx,%eax,1),%edx
+c0101994:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101997:	0f b7 c0             	movzwl %ax,%eax
+c010199a:	66 89 02             	mov    %ax,(%edx)
         break;
-c0101a05:	eb 01                	jmp    c0101a08 <cga_putc+0xe1>
+c010199d:	eb 01                	jmp    c01019a0 <cga_putc+0xf1>
     case '\b':
         if (crt_pos > 0) {
             crt_pos --;
             crt_buf[crt_pos] = (c & ~0xff) | ' ';
         }
         break;
-c0101a07:	90                   	nop
+c010199f:	90                   	nop
         crt_buf[crt_pos ++] = c;     // write the character
         break;
     }
 
     // What is the purpose of this?
     if (crt_pos >= CRT_SIZE) {
-c0101a08:	0f b7 05 24 25 12 c0 	movzwl 0xc0122524,%eax
-c0101a0f:	66 3d cf 07          	cmp    $0x7cf,%ax
-c0101a13:	76 59                	jbe    c0101a6e <cga_putc+0x147>
+c01019a0:	0f b7 05 24 35 12 c0 	movzwl 0xc0123524,%eax
+c01019a7:	3d cf 07 00 00       	cmp    $0x7cf,%eax
+c01019ac:	76 5d                	jbe    c0101a0b <cga_putc+0x15c>
         int i;
         memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
-c0101a15:	a1 20 25 12 c0       	mov    0xc0122520,%eax
-c0101a1a:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
-c0101a20:	a1 20 25 12 c0       	mov    0xc0122520,%eax
-c0101a25:	83 ec 04             	sub    $0x4,%esp
-c0101a28:	68 00 0f 00 00       	push   $0xf00
-c0101a2d:	52                   	push   %edx
-c0101a2e:	50                   	push   %eax
-c0101a2f:	e8 14 61 00 00       	call   c0107b48 <memmove>
-c0101a34:	83 c4 10             	add    $0x10,%esp
+c01019ae:	a1 20 35 12 c0       	mov    0xc0123520,%eax
+c01019b3:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
+c01019b9:	a1 20 35 12 c0       	mov    0xc0123520,%eax
+c01019be:	c7 44 24 08 00 0f 00 	movl   $0xf00,0x8(%esp)
+c01019c5:	00 
+c01019c6:	89 54 24 04          	mov    %edx,0x4(%esp)
+c01019ca:	89 04 24             	mov    %eax,(%esp)
+c01019cd:	e8 4e 68 00 00       	call   c0108220 <memmove>
         for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i ++) {
-c0101a37:	c7 45 f4 80 07 00 00 	movl   $0x780,-0xc(%ebp)
-c0101a3e:	eb 15                	jmp    c0101a55 <cga_putc+0x12e>
+c01019d2:	c7 45 f4 80 07 00 00 	movl   $0x780,-0xc(%ebp)
+c01019d9:	eb 14                	jmp    c01019ef <cga_putc+0x140>
             crt_buf[i] = 0x0700 | ' ';
-c0101a40:	a1 20 25 12 c0       	mov    0xc0122520,%eax
-c0101a45:	8b 55 f4             	mov    -0xc(%ebp),%edx
-c0101a48:	01 d2                	add    %edx,%edx
-c0101a4a:	01 d0                	add    %edx,%eax
-c0101a4c:	66 c7 00 20 07       	movw   $0x720,(%eax)
+c01019db:	a1 20 35 12 c0       	mov    0xc0123520,%eax
+c01019e0:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c01019e3:	01 d2                	add    %edx,%edx
+c01019e5:	01 d0                	add    %edx,%eax
+c01019e7:	66 c7 00 20 07       	movw   $0x720,(%eax)
 
     // What is the purpose of this?
     if (crt_pos >= CRT_SIZE) {
         int i;
         memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
         for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i ++) {
-c0101a51:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
-c0101a55:	81 7d f4 cf 07 00 00 	cmpl   $0x7cf,-0xc(%ebp)
-c0101a5c:	7e e2                	jle    c0101a40 <cga_putc+0x119>
+c01019ec:	ff 45 f4             	incl   -0xc(%ebp)
+c01019ef:	81 7d f4 cf 07 00 00 	cmpl   $0x7cf,-0xc(%ebp)
+c01019f6:	7e e3                	jle    c01019db <cga_putc+0x12c>
             crt_buf[i] = 0x0700 | ' ';
         }
         crt_pos -= CRT_COLS;
-c0101a5e:	0f b7 05 24 25 12 c0 	movzwl 0xc0122524,%eax
-c0101a65:	83 e8 50             	sub    $0x50,%eax
-c0101a68:	66 a3 24 25 12 c0    	mov    %ax,0xc0122524
+c01019f8:	0f b7 05 24 35 12 c0 	movzwl 0xc0123524,%eax
+c01019ff:	83 e8 50             	sub    $0x50,%eax
+c0101a02:	0f b7 c0             	movzwl %ax,%eax
+c0101a05:	66 a3 24 35 12 c0    	mov    %ax,0xc0123524
     }
 
     // move that little blinky thing
     outb(addr_6845, 14);
-c0101a6e:	0f b7 05 26 25 12 c0 	movzwl 0xc0122526,%eax
-c0101a75:	0f b7 c0             	movzwl %ax,%eax
-c0101a78:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
-c0101a7c:	c6 45 e8 0e          	movb   $0xe,-0x18(%ebp)
-c0101a80:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
-c0101a84:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
-c0101a88:	ee                   	out    %al,(%dx)
+c0101a0b:	0f b7 05 26 35 12 c0 	movzwl 0xc0123526,%eax
+c0101a12:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
+c0101a16:	c6 45 e8 0e          	movb   $0xe,-0x18(%ebp)
+c0101a1a:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
+c0101a1e:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+c0101a22:	ee                   	out    %al,(%dx)
     outb(addr_6845 + 1, crt_pos >> 8);
-c0101a89:	0f b7 05 24 25 12 c0 	movzwl 0xc0122524,%eax
-c0101a90:	66 c1 e8 08          	shr    $0x8,%ax
-c0101a94:	0f b6 c0             	movzbl %al,%eax
-c0101a97:	0f b7 15 26 25 12 c0 	movzwl 0xc0122526,%edx
-c0101a9e:	83 c2 01             	add    $0x1,%edx
-c0101aa1:	0f b7 d2             	movzwl %dx,%edx
-c0101aa4:	66 89 55 f0          	mov    %dx,-0x10(%ebp)
-c0101aa8:	88 45 e9             	mov    %al,-0x17(%ebp)
-c0101aab:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
-c0101aaf:	0f b7 55 f0          	movzwl -0x10(%ebp),%edx
-c0101ab3:	ee                   	out    %al,(%dx)
+c0101a23:	0f b7 05 24 35 12 c0 	movzwl 0xc0123524,%eax
+c0101a2a:	c1 e8 08             	shr    $0x8,%eax
+c0101a2d:	0f b7 c0             	movzwl %ax,%eax
+c0101a30:	0f b6 c0             	movzbl %al,%eax
+c0101a33:	0f b7 15 26 35 12 c0 	movzwl 0xc0123526,%edx
+c0101a3a:	42                   	inc    %edx
+c0101a3b:	0f b7 d2             	movzwl %dx,%edx
+c0101a3e:	66 89 55 f0          	mov    %dx,-0x10(%ebp)
+c0101a42:	88 45 e9             	mov    %al,-0x17(%ebp)
+c0101a45:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
+c0101a49:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c0101a4c:	ee                   	out    %al,(%dx)
     outb(addr_6845, 15);
-c0101ab4:	0f b7 05 26 25 12 c0 	movzwl 0xc0122526,%eax
-c0101abb:	0f b7 c0             	movzwl %ax,%eax
-c0101abe:	66 89 45 ee          	mov    %ax,-0x12(%ebp)
-c0101ac2:	c6 45 ea 0f          	movb   $0xf,-0x16(%ebp)
-c0101ac6:	0f b6 45 ea          	movzbl -0x16(%ebp),%eax
-c0101aca:	0f b7 55 ee          	movzwl -0x12(%ebp),%edx
-c0101ace:	ee                   	out    %al,(%dx)
+c0101a4d:	0f b7 05 26 35 12 c0 	movzwl 0xc0123526,%eax
+c0101a54:	66 89 45 ee          	mov    %ax,-0x12(%ebp)
+c0101a58:	c6 45 ea 0f          	movb   $0xf,-0x16(%ebp)
+c0101a5c:	0f b6 45 ea          	movzbl -0x16(%ebp),%eax
+c0101a60:	0f b7 55 ee          	movzwl -0x12(%ebp),%edx
+c0101a64:	ee                   	out    %al,(%dx)
     outb(addr_6845 + 1, crt_pos);
-c0101acf:	0f b7 05 24 25 12 c0 	movzwl 0xc0122524,%eax
-c0101ad6:	0f b6 c0             	movzbl %al,%eax
-c0101ad9:	0f b7 15 26 25 12 c0 	movzwl 0xc0122526,%edx
-c0101ae0:	83 c2 01             	add    $0x1,%edx
-c0101ae3:	0f b7 d2             	movzwl %dx,%edx
-c0101ae6:	66 89 55 ec          	mov    %dx,-0x14(%ebp)
-c0101aea:	88 45 eb             	mov    %al,-0x15(%ebp)
-c0101aed:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
-c0101af1:	0f b7 55 ec          	movzwl -0x14(%ebp),%edx
-c0101af5:	ee                   	out    %al,(%dx)
-}
-c0101af6:	90                   	nop
-c0101af7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-c0101afa:	c9                   	leave  
-c0101afb:	c3                   	ret    
+c0101a65:	0f b7 05 24 35 12 c0 	movzwl 0xc0123524,%eax
+c0101a6c:	0f b6 c0             	movzbl %al,%eax
+c0101a6f:	0f b7 15 26 35 12 c0 	movzwl 0xc0123526,%edx
+c0101a76:	42                   	inc    %edx
+c0101a77:	0f b7 d2             	movzwl %dx,%edx
+c0101a7a:	66 89 55 ec          	mov    %dx,-0x14(%ebp)
+c0101a7e:	88 45 eb             	mov    %al,-0x15(%ebp)
+c0101a81:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
+c0101a85:	8b 55 ec             	mov    -0x14(%ebp),%edx
+c0101a88:	ee                   	out    %al,(%dx)
+}
+c0101a89:	90                   	nop
+c0101a8a:	83 c4 24             	add    $0x24,%esp
+c0101a8d:	5b                   	pop    %ebx
+c0101a8e:	5d                   	pop    %ebp
+c0101a8f:	c3                   	ret    
 
-c0101afc <serial_putc_sub>:
+c0101a90 <serial_putc_sub>:
 
 static void
 serial_putc_sub(int c) {
-c0101afc:	55                   	push   %ebp
-c0101afd:	89 e5                	mov    %esp,%ebp
-c0101aff:	83 ec 10             	sub    $0x10,%esp
+c0101a90:	55                   	push   %ebp
+c0101a91:	89 e5                	mov    %esp,%ebp
+c0101a93:	83 ec 10             	sub    $0x10,%esp
     int i;
     for (i = 0; !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800; i ++) {
-c0101b02:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
-c0101b09:	eb 09                	jmp    c0101b14 <serial_putc_sub+0x18>
+c0101a96:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+c0101a9d:	eb 08                	jmp    c0101aa7 <serial_putc_sub+0x17>
         delay();
-c0101b0b:	e8 51 fb ff ff       	call   c0101661 <delay>
+c0101a9f:	e8 4c fb ff ff       	call   c01015f0 <delay>
 }
 
 static void
 serial_putc_sub(int c) {
     int i;
     for (i = 0; !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800; i ++) {
-c0101b10:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
-c0101b14:	66 c7 45 f8 fd 03    	movw   $0x3fd,-0x8(%ebp)
+c0101aa4:	ff 45 fc             	incl   -0x4(%ebp)
+c0101aa7:	66 c7 45 f8 fd 03    	movw   $0x3fd,-0x8(%ebp)
 static inline void invlpg(void *addr) __attribute__((always_inline));
 
 static inline uint8_t
 inb(uint16_t port) {
     uint8_t data;
     asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
-c0101b1a:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
-c0101b1e:	89 c2                	mov    %eax,%edx
-c0101b20:	ec                   	in     (%dx),%al
-c0101b21:	88 45 f7             	mov    %al,-0x9(%ebp)
+c0101aad:	8b 45 f8             	mov    -0x8(%ebp),%eax
+c0101ab0:	89 c2                	mov    %eax,%edx
+c0101ab2:	ec                   	in     (%dx),%al
+c0101ab3:	88 45 f7             	mov    %al,-0x9(%ebp)
     return data;
-c0101b24:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
-c0101b28:	0f b6 c0             	movzbl %al,%eax
-c0101b2b:	83 e0 20             	and    $0x20,%eax
-c0101b2e:	85 c0                	test   %eax,%eax
-c0101b30:	75 09                	jne    c0101b3b <serial_putc_sub+0x3f>
-c0101b32:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%ebp)
-c0101b39:	7e d0                	jle    c0101b0b <serial_putc_sub+0xf>
+c0101ab6:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
+c0101aba:	0f b6 c0             	movzbl %al,%eax
+c0101abd:	83 e0 20             	and    $0x20,%eax
+c0101ac0:	85 c0                	test   %eax,%eax
+c0101ac2:	75 09                	jne    c0101acd <serial_putc_sub+0x3d>
+c0101ac4:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%ebp)
+c0101acb:	7e d2                	jle    c0101a9f <serial_putc_sub+0xf>
         delay();
     }
     outb(COM1 + COM_TX, c);
-c0101b3b:	8b 45 08             	mov    0x8(%ebp),%eax
-c0101b3e:	0f b6 c0             	movzbl %al,%eax
-c0101b41:	66 c7 45 fa f8 03    	movw   $0x3f8,-0x6(%ebp)
-c0101b47:	88 45 f6             	mov    %al,-0xa(%ebp)
+c0101acd:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101ad0:	0f b6 c0             	movzbl %al,%eax
+c0101ad3:	66 c7 45 fa f8 03    	movw   $0x3f8,-0x6(%ebp)
+c0101ad9:	88 45 f6             	mov    %al,-0xa(%ebp)
         : "memory", "cc");
 }
 
 static inline void
 outb(uint16_t port, uint8_t data) {
     asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
-c0101b4a:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
-c0101b4e:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
-c0101b52:	ee                   	out    %al,(%dx)
-}
-c0101b53:	90                   	nop
-c0101b54:	c9                   	leave  
-c0101b55:	c3                   	ret    
+c0101adc:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
+c0101ae0:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
+c0101ae4:	ee                   	out    %al,(%dx)
+}
+c0101ae5:	90                   	nop
+c0101ae6:	c9                   	leave  
+c0101ae7:	c3                   	ret    
 
-c0101b56 <serial_putc>:
+c0101ae8 <serial_putc>:
 
 /* serial_putc - print character to serial port */
 static void
 serial_putc(int c) {
-c0101b56:	55                   	push   %ebp
-c0101b57:	89 e5                	mov    %esp,%ebp
+c0101ae8:	55                   	push   %ebp
+c0101ae9:	89 e5                	mov    %esp,%ebp
+c0101aeb:	83 ec 04             	sub    $0x4,%esp
     if (c != '\b') {
-c0101b59:	83 7d 08 08          	cmpl   $0x8,0x8(%ebp)
-c0101b5d:	74 0d                	je     c0101b6c <serial_putc+0x16>
+c0101aee:	83 7d 08 08          	cmpl   $0x8,0x8(%ebp)
+c0101af2:	74 0d                	je     c0101b01 <serial_putc+0x19>
         serial_putc_sub(c);
-c0101b5f:	ff 75 08             	pushl  0x8(%ebp)
-c0101b62:	e8 95 ff ff ff       	call   c0101afc <serial_putc_sub>
-c0101b67:	83 c4 04             	add    $0x4,%esp
+c0101af4:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101af7:	89 04 24             	mov    %eax,(%esp)
+c0101afa:	e8 91 ff ff ff       	call   c0101a90 <serial_putc_sub>
     else {
         serial_putc_sub('\b');
         serial_putc_sub(' ');
         serial_putc_sub('\b');
     }
 }
-c0101b6a:	eb 1e                	jmp    c0101b8a <serial_putc+0x34>
+c0101aff:	eb 24                	jmp    c0101b25 <serial_putc+0x3d>
 serial_putc(int c) {
     if (c != '\b') {
         serial_putc_sub(c);
     }
     else {
         serial_putc_sub('\b');
-c0101b6c:	6a 08                	push   $0x8
-c0101b6e:	e8 89 ff ff ff       	call   c0101afc <serial_putc_sub>
-c0101b73:	83 c4 04             	add    $0x4,%esp
+c0101b01:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
+c0101b08:	e8 83 ff ff ff       	call   c0101a90 <serial_putc_sub>
         serial_putc_sub(' ');
-c0101b76:	6a 20                	push   $0x20
-c0101b78:	e8 7f ff ff ff       	call   c0101afc <serial_putc_sub>
-c0101b7d:	83 c4 04             	add    $0x4,%esp
+c0101b0d:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
+c0101b14:	e8 77 ff ff ff       	call   c0101a90 <serial_putc_sub>
         serial_putc_sub('\b');
-c0101b80:	6a 08                	push   $0x8
-c0101b82:	e8 75 ff ff ff       	call   c0101afc <serial_putc_sub>
-c0101b87:	83 c4 04             	add    $0x4,%esp
+c0101b19:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
+c0101b20:	e8 6b ff ff ff       	call   c0101a90 <serial_putc_sub>
     }
 }
-c0101b8a:	90                   	nop
-c0101b8b:	c9                   	leave  
-c0101b8c:	c3                   	ret    
+c0101b25:	90                   	nop
+c0101b26:	c9                   	leave  
+c0101b27:	c3                   	ret    
 
-c0101b8d <cons_intr>:
+c0101b28 <cons_intr>:
 /* *
  * cons_intr - called by device interrupt routines to feed input
  * characters into the circular console input buffer.
  * */
 static void
 cons_intr(int (*proc)(void)) {
-c0101b8d:	55                   	push   %ebp
-c0101b8e:	89 e5                	mov    %esp,%ebp
-c0101b90:	83 ec 18             	sub    $0x18,%esp
+c0101b28:	55                   	push   %ebp
+c0101b29:	89 e5                	mov    %esp,%ebp
+c0101b2b:	83 ec 18             	sub    $0x18,%esp
     int c;
     while ((c = (*proc)()) != -1) {
-c0101b93:	eb 33                	jmp    c0101bc8 <cons_intr+0x3b>
+c0101b2e:	eb 33                	jmp    c0101b63 <cons_intr+0x3b>
         if (c != 0) {
-c0101b95:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
-c0101b99:	74 2d                	je     c0101bc8 <cons_intr+0x3b>
+c0101b30:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0101b34:	74 2d                	je     c0101b63 <cons_intr+0x3b>
             cons.buf[cons.wpos ++] = c;
-c0101b9b:	a1 44 27 12 c0       	mov    0xc0122744,%eax
-c0101ba0:	8d 50 01             	lea    0x1(%eax),%edx
-c0101ba3:	89 15 44 27 12 c0    	mov    %edx,0xc0122744
-c0101ba9:	8b 55 f4             	mov    -0xc(%ebp),%edx
-c0101bac:	88 90 40 25 12 c0    	mov    %dl,-0x3feddac0(%eax)
+c0101b36:	a1 44 37 12 c0       	mov    0xc0123744,%eax
+c0101b3b:	8d 50 01             	lea    0x1(%eax),%edx
+c0101b3e:	89 15 44 37 12 c0    	mov    %edx,0xc0123744
+c0101b44:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0101b47:	88 90 40 35 12 c0    	mov    %dl,-0x3fedcac0(%eax)
             if (cons.wpos == CONSBUFSIZE) {
-c0101bb2:	a1 44 27 12 c0       	mov    0xc0122744,%eax
-c0101bb7:	3d 00 02 00 00       	cmp    $0x200,%eax
-c0101bbc:	75 0a                	jne    c0101bc8 <cons_intr+0x3b>
+c0101b4d:	a1 44 37 12 c0       	mov    0xc0123744,%eax
+c0101b52:	3d 00 02 00 00       	cmp    $0x200,%eax
+c0101b57:	75 0a                	jne    c0101b63 <cons_intr+0x3b>
                 cons.wpos = 0;
-c0101bbe:	c7 05 44 27 12 c0 00 	movl   $0x0,0xc0122744
-c0101bc5:	00 00 00 
+c0101b59:	c7 05 44 37 12 c0 00 	movl   $0x0,0xc0123744
+c0101b60:	00 00 00 
  * characters into the circular console input buffer.
  * */
 static void
 cons_intr(int (*proc)(void)) {
     int c;
     while ((c = (*proc)()) != -1) {
-c0101bc8:	8b 45 08             	mov    0x8(%ebp),%eax
-c0101bcb:	ff d0                	call   *%eax
-c0101bcd:	89 45 f4             	mov    %eax,-0xc(%ebp)
-c0101bd0:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
-c0101bd4:	75 bf                	jne    c0101b95 <cons_intr+0x8>
+c0101b63:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101b66:	ff d0                	call   *%eax
+c0101b68:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0101b6b:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
+c0101b6f:	75 bf                	jne    c0101b30 <cons_intr+0x8>
             if (cons.wpos == CONSBUFSIZE) {
                 cons.wpos = 0;
             }
         }
     }
 }
-c0101bd6:	90                   	nop
-c0101bd7:	c9                   	leave  
-c0101bd8:	c3                   	ret    
+c0101b71:	90                   	nop
+c0101b72:	c9                   	leave  
+c0101b73:	c3                   	ret    
 
-c0101bd9 <serial_proc_data>:
+c0101b74 <serial_proc_data>:
 
 /* serial_proc_data - get data from serial port */
 static int
 serial_proc_data(void) {
-c0101bd9:	55                   	push   %ebp
-c0101bda:	89 e5                	mov    %esp,%ebp
-c0101bdc:	83 ec 10             	sub    $0x10,%esp
-c0101bdf:	66 c7 45 f8 fd 03    	movw   $0x3fd,-0x8(%ebp)
+c0101b74:	55                   	push   %ebp
+c0101b75:	89 e5                	mov    %esp,%ebp
+c0101b77:	83 ec 10             	sub    $0x10,%esp
+c0101b7a:	66 c7 45 f8 fd 03    	movw   $0x3fd,-0x8(%ebp)
 static inline void invlpg(void *addr) __attribute__((always_inline));
 
 static inline uint8_t
 inb(uint16_t port) {
     uint8_t data;
     asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
-c0101be5:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
-c0101be9:	89 c2                	mov    %eax,%edx
-c0101beb:	ec                   	in     (%dx),%al
-c0101bec:	88 45 f7             	mov    %al,-0x9(%ebp)
+c0101b80:	8b 45 f8             	mov    -0x8(%ebp),%eax
+c0101b83:	89 c2                	mov    %eax,%edx
+c0101b85:	ec                   	in     (%dx),%al
+c0101b86:	88 45 f7             	mov    %al,-0x9(%ebp)
     return data;
-c0101bef:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
+c0101b89:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
     if (!(inb(COM1 + COM_LSR) & COM_LSR_DATA)) {
-c0101bf3:	0f b6 c0             	movzbl %al,%eax
-c0101bf6:	83 e0 01             	and    $0x1,%eax
-c0101bf9:	85 c0                	test   %eax,%eax
-c0101bfb:	75 07                	jne    c0101c04 <serial_proc_data+0x2b>
+c0101b8d:	0f b6 c0             	movzbl %al,%eax
+c0101b90:	83 e0 01             	and    $0x1,%eax
+c0101b93:	85 c0                	test   %eax,%eax
+c0101b95:	75 07                	jne    c0101b9e <serial_proc_data+0x2a>
         return -1;
-c0101bfd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-c0101c02:	eb 2a                	jmp    c0101c2e <serial_proc_data+0x55>
-c0101c04:	66 c7 45 fa f8 03    	movw   $0x3f8,-0x6(%ebp)
+c0101b97:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+c0101b9c:	eb 2a                	jmp    c0101bc8 <serial_proc_data+0x54>
+c0101b9e:	66 c7 45 fa f8 03    	movw   $0x3f8,-0x6(%ebp)
 static inline void invlpg(void *addr) __attribute__((always_inline));
 
 static inline uint8_t
 inb(uint16_t port) {
     uint8_t data;
     asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
-c0101c0a:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
-c0101c0e:	89 c2                	mov    %eax,%edx
-c0101c10:	ec                   	in     (%dx),%al
-c0101c11:	88 45 f6             	mov    %al,-0xa(%ebp)
+c0101ba4:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
+c0101ba8:	89 c2                	mov    %eax,%edx
+c0101baa:	ec                   	in     (%dx),%al
+c0101bab:	88 45 f6             	mov    %al,-0xa(%ebp)
     return data;
-c0101c14:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
+c0101bae:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
     }
     int c = inb(COM1 + COM_RX);
-c0101c18:	0f b6 c0             	movzbl %al,%eax
-c0101c1b:	89 45 fc             	mov    %eax,-0x4(%ebp)
+c0101bb2:	0f b6 c0             	movzbl %al,%eax
+c0101bb5:	89 45 fc             	mov    %eax,-0x4(%ebp)
     if (c == 127) {
-c0101c1e:	83 7d fc 7f          	cmpl   $0x7f,-0x4(%ebp)
-c0101c22:	75 07                	jne    c0101c2b <serial_proc_data+0x52>
+c0101bb8:	83 7d fc 7f          	cmpl   $0x7f,-0x4(%ebp)
+c0101bbc:	75 07                	jne    c0101bc5 <serial_proc_data+0x51>
         c = '\b';
-c0101c24:	c7 45 fc 08 00 00 00 	movl   $0x8,-0x4(%ebp)
+c0101bbe:	c7 45 fc 08 00 00 00 	movl   $0x8,-0x4(%ebp)
     }
     return c;
-c0101c2b:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0101bc5:	8b 45 fc             	mov    -0x4(%ebp),%eax
 }
-c0101c2e:	c9                   	leave  
-c0101c2f:	c3                   	ret    
+c0101bc8:	c9                   	leave  
+c0101bc9:	c3                   	ret    
 
-c0101c30 <serial_intr>:
+c0101bca <serial_intr>:
 
 /* serial_intr - try to feed input characters from serial port */
 void
 serial_intr(void) {
-c0101c30:	55                   	push   %ebp
-c0101c31:	89 e5                	mov    %esp,%ebp
-c0101c33:	83 ec 08             	sub    $0x8,%esp
+c0101bca:	55                   	push   %ebp
+c0101bcb:	89 e5                	mov    %esp,%ebp
+c0101bcd:	83 ec 18             	sub    $0x18,%esp
     if (serial_exists) {
-c0101c36:	a1 28 25 12 c0       	mov    0xc0122528,%eax
-c0101c3b:	85 c0                	test   %eax,%eax
-c0101c3d:	74 10                	je     c0101c4f <serial_intr+0x1f>
+c0101bd0:	a1 28 35 12 c0       	mov    0xc0123528,%eax
+c0101bd5:	85 c0                	test   %eax,%eax
+c0101bd7:	74 0c                	je     c0101be5 <serial_intr+0x1b>
         cons_intr(serial_proc_data);
-c0101c3f:	83 ec 0c             	sub    $0xc,%esp
-c0101c42:	68 d9 1b 10 c0       	push   $0xc0101bd9
-c0101c47:	e8 41 ff ff ff       	call   c0101b8d <cons_intr>
-c0101c4c:	83 c4 10             	add    $0x10,%esp
+c0101bd9:	c7 04 24 74 1b 10 c0 	movl   $0xc0101b74,(%esp)
+c0101be0:	e8 43 ff ff ff       	call   c0101b28 <cons_intr>
     }
 }
-c0101c4f:	90                   	nop
-c0101c50:	c9                   	leave  
-c0101c51:	c3                   	ret    
+c0101be5:	90                   	nop
+c0101be6:	c9                   	leave  
+c0101be7:	c3                   	ret    
 
-c0101c52 <kbd_proc_data>:
+c0101be8 <kbd_proc_data>:
  *
  * The kbd_proc_data() function gets data from the keyboard.
  * If we finish a character, return it, else 0. And return -1 if no data.
  * */
 static int
 kbd_proc_data(void) {
-c0101c52:	55                   	push   %ebp
-c0101c53:	89 e5                	mov    %esp,%ebp
-c0101c55:	83 ec 18             	sub    $0x18,%esp
-c0101c58:	66 c7 45 ec 64 00    	movw   $0x64,-0x14(%ebp)
+c0101be8:	55                   	push   %ebp
+c0101be9:	89 e5                	mov    %esp,%ebp
+c0101beb:	83 ec 28             	sub    $0x28,%esp
+c0101bee:	66 c7 45 ec 64 00    	movw   $0x64,-0x14(%ebp)
 static inline void invlpg(void *addr) __attribute__((always_inline));
 
 static inline uint8_t
 inb(uint16_t port) {
     uint8_t data;
     asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
-c0101c5e:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
-c0101c62:	89 c2                	mov    %eax,%edx
-c0101c64:	ec                   	in     (%dx),%al
-c0101c65:	88 45 eb             	mov    %al,-0x15(%ebp)
+c0101bf4:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0101bf7:	89 c2                	mov    %eax,%edx
+c0101bf9:	ec                   	in     (%dx),%al
+c0101bfa:	88 45 eb             	mov    %al,-0x15(%ebp)
     return data;
-c0101c68:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
+c0101bfd:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
     int c;
     uint8_t data;
     static uint32_t shift;
 
     if ((inb(KBSTATP) & KBS_DIB) == 0) {
-c0101c6c:	0f b6 c0             	movzbl %al,%eax
-c0101c6f:	83 e0 01             	and    $0x1,%eax
-c0101c72:	85 c0                	test   %eax,%eax
-c0101c74:	75 0a                	jne    c0101c80 <kbd_proc_data+0x2e>
+c0101c01:	0f b6 c0             	movzbl %al,%eax
+c0101c04:	83 e0 01             	and    $0x1,%eax
+c0101c07:	85 c0                	test   %eax,%eax
+c0101c09:	75 0a                	jne    c0101c15 <kbd_proc_data+0x2d>
         return -1;
-c0101c76:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
-c0101c7b:	e9 5d 01 00 00       	jmp    c0101ddd <kbd_proc_data+0x18b>
-c0101c80:	66 c7 45 f0 60 00    	movw   $0x60,-0x10(%ebp)
+c0101c0b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+c0101c10:	e9 56 01 00 00       	jmp    c0101d6b <kbd_proc_data+0x183>
+c0101c15:	66 c7 45 f0 60 00    	movw   $0x60,-0x10(%ebp)
 static inline void invlpg(void *addr) __attribute__((always_inline));
 
 static inline uint8_t
 inb(uint16_t port) {
     uint8_t data;
     asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
-c0101c86:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
-c0101c8a:	89 c2                	mov    %eax,%edx
-c0101c8c:	ec                   	in     (%dx),%al
-c0101c8d:	88 45 ea             	mov    %al,-0x16(%ebp)
+c0101c1b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0101c1e:	89 c2                	mov    %eax,%edx
+c0101c20:	ec                   	in     (%dx),%al
+c0101c21:	88 45 ea             	mov    %al,-0x16(%ebp)
     return data;
-c0101c90:	0f b6 45 ea          	movzbl -0x16(%ebp),%eax
+c0101c24:	0f b6 45 ea          	movzbl -0x16(%ebp),%eax
     }
 
     data = inb(KBDATAP);
-c0101c94:	88 45 f3             	mov    %al,-0xd(%ebp)
+c0101c28:	88 45 f3             	mov    %al,-0xd(%ebp)
 
     if (data == 0xE0) {
-c0101c97:	80 7d f3 e0          	cmpb   $0xe0,-0xd(%ebp)
-c0101c9b:	75 17                	jne    c0101cb4 <kbd_proc_data+0x62>
+c0101c2b:	80 7d f3 e0          	cmpb   $0xe0,-0xd(%ebp)
+c0101c2f:	75 17                	jne    c0101c48 <kbd_proc_data+0x60>
         // E0 escape character
         shift |= E0ESC;
-c0101c9d:	a1 48 27 12 c0       	mov    0xc0122748,%eax
-c0101ca2:	83 c8 40             	or     $0x40,%eax
-c0101ca5:	a3 48 27 12 c0       	mov    %eax,0xc0122748
+c0101c31:	a1 48 37 12 c0       	mov    0xc0123748,%eax
+c0101c36:	83 c8 40             	or     $0x40,%eax
+c0101c39:	a3 48 37 12 c0       	mov    %eax,0xc0123748
         return 0;
-c0101caa:	b8 00 00 00 00       	mov    $0x0,%eax
-c0101caf:	e9 29 01 00 00       	jmp    c0101ddd <kbd_proc_data+0x18b>
+c0101c3e:	b8 00 00 00 00       	mov    $0x0,%eax
+c0101c43:	e9 23 01 00 00       	jmp    c0101d6b <kbd_proc_data+0x183>
     } else if (data & 0x80) {
-c0101cb4:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
-c0101cb8:	84 c0                	test   %al,%al
-c0101cba:	79 47                	jns    c0101d03 <kbd_proc_data+0xb1>
+c0101c48:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+c0101c4c:	84 c0                	test   %al,%al
+c0101c4e:	79 45                	jns    c0101c95 <kbd_proc_data+0xad>
         // Key released
         data = (shift & E0ESC ? data : data & 0x7F);
-c0101cbc:	a1 48 27 12 c0       	mov    0xc0122748,%eax
-c0101cc1:	83 e0 40             	and    $0x40,%eax
-c0101cc4:	85 c0                	test   %eax,%eax
-c0101cc6:	75 09                	jne    c0101cd1 <kbd_proc_data+0x7f>
-c0101cc8:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
-c0101ccc:	83 e0 7f             	and    $0x7f,%eax
-c0101ccf:	eb 04                	jmp    c0101cd5 <kbd_proc_data+0x83>
-c0101cd1:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
-c0101cd5:	88 45 f3             	mov    %al,-0xd(%ebp)
+c0101c50:	a1 48 37 12 c0       	mov    0xc0123748,%eax
+c0101c55:	83 e0 40             	and    $0x40,%eax
+c0101c58:	85 c0                	test   %eax,%eax
+c0101c5a:	75 08                	jne    c0101c64 <kbd_proc_data+0x7c>
+c0101c5c:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+c0101c60:	24 7f                	and    $0x7f,%al
+c0101c62:	eb 04                	jmp    c0101c68 <kbd_proc_data+0x80>
+c0101c64:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+c0101c68:	88 45 f3             	mov    %al,-0xd(%ebp)
         shift &= ~(shiftcode[data] | E0ESC);
-c0101cd8:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
-c0101cdc:	0f b6 80 40 f0 11 c0 	movzbl -0x3fee0fc0(%eax),%eax
-c0101ce3:	83 c8 40             	or     $0x40,%eax
-c0101ce6:	0f b6 c0             	movzbl %al,%eax
-c0101ce9:	f7 d0                	not    %eax
-c0101ceb:	89 c2                	mov    %eax,%edx
-c0101ced:	a1 48 27 12 c0       	mov    0xc0122748,%eax
-c0101cf2:	21 d0                	and    %edx,%eax
-c0101cf4:	a3 48 27 12 c0       	mov    %eax,0xc0122748
+c0101c6b:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+c0101c6f:	0f b6 80 40 00 12 c0 	movzbl -0x3fedffc0(%eax),%eax
+c0101c76:	0c 40                	or     $0x40,%al
+c0101c78:	0f b6 c0             	movzbl %al,%eax
+c0101c7b:	f7 d0                	not    %eax
+c0101c7d:	89 c2                	mov    %eax,%edx
+c0101c7f:	a1 48 37 12 c0       	mov    0xc0123748,%eax
+c0101c84:	21 d0                	and    %edx,%eax
+c0101c86:	a3 48 37 12 c0       	mov    %eax,0xc0123748
         return 0;
-c0101cf9:	b8 00 00 00 00       	mov    $0x0,%eax
-c0101cfe:	e9 da 00 00 00       	jmp    c0101ddd <kbd_proc_data+0x18b>
+c0101c8b:	b8 00 00 00 00       	mov    $0x0,%eax
+c0101c90:	e9 d6 00 00 00       	jmp    c0101d6b <kbd_proc_data+0x183>
     } else if (shift & E0ESC) {
-c0101d03:	a1 48 27 12 c0       	mov    0xc0122748,%eax
-c0101d08:	83 e0 40             	and    $0x40,%eax
-c0101d0b:	85 c0                	test   %eax,%eax
-c0101d0d:	74 11                	je     c0101d20 <kbd_proc_data+0xce>
+c0101c95:	a1 48 37 12 c0       	mov    0xc0123748,%eax
+c0101c9a:	83 e0 40             	and    $0x40,%eax
+c0101c9d:	85 c0                	test   %eax,%eax
+c0101c9f:	74 11                	je     c0101cb2 <kbd_proc_data+0xca>
         // Last character was an E0 escape; or with 0x80
         data |= 0x80;
-c0101d0f:	80 4d f3 80          	orb    $0x80,-0xd(%ebp)
+c0101ca1:	80 4d f3 80          	orb    $0x80,-0xd(%ebp)
         shift &= ~E0ESC;
-c0101d13:	a1 48 27 12 c0       	mov    0xc0122748,%eax
-c0101d18:	83 e0 bf             	and    $0xffffffbf,%eax
-c0101d1b:	a3 48 27 12 c0       	mov    %eax,0xc0122748
+c0101ca5:	a1 48 37 12 c0       	mov    0xc0123748,%eax
+c0101caa:	83 e0 bf             	and    $0xffffffbf,%eax
+c0101cad:	a3 48 37 12 c0       	mov    %eax,0xc0123748
     }
 
     shift |= shiftcode[data];
-c0101d20:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
-c0101d24:	0f b6 80 40 f0 11 c0 	movzbl -0x3fee0fc0(%eax),%eax
-c0101d2b:	0f b6 d0             	movzbl %al,%edx
-c0101d2e:	a1 48 27 12 c0       	mov    0xc0122748,%eax
-c0101d33:	09 d0                	or     %edx,%eax
-c0101d35:	a3 48 27 12 c0       	mov    %eax,0xc0122748
+c0101cb2:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+c0101cb6:	0f b6 80 40 00 12 c0 	movzbl -0x3fedffc0(%eax),%eax
+c0101cbd:	0f b6 d0             	movzbl %al,%edx
+c0101cc0:	a1 48 37 12 c0       	mov    0xc0123748,%eax
+c0101cc5:	09 d0                	or     %edx,%eax
+c0101cc7:	a3 48 37 12 c0       	mov    %eax,0xc0123748
     shift ^= togglecode[data];
-c0101d3a:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
-c0101d3e:	0f b6 80 40 f1 11 c0 	movzbl -0x3fee0ec0(%eax),%eax
-c0101d45:	0f b6 d0             	movzbl %al,%edx
-c0101d48:	a1 48 27 12 c0       	mov    0xc0122748,%eax
-c0101d4d:	31 d0                	xor    %edx,%eax
-c0101d4f:	a3 48 27 12 c0       	mov    %eax,0xc0122748
+c0101ccc:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+c0101cd0:	0f b6 80 40 01 12 c0 	movzbl -0x3fedfec0(%eax),%eax
+c0101cd7:	0f b6 d0             	movzbl %al,%edx
+c0101cda:	a1 48 37 12 c0       	mov    0xc0123748,%eax
+c0101cdf:	31 d0                	xor    %edx,%eax
+c0101ce1:	a3 48 37 12 c0       	mov    %eax,0xc0123748
 
     c = charcode[shift & (CTL | SHIFT)][data];
-c0101d54:	a1 48 27 12 c0       	mov    0xc0122748,%eax
-c0101d59:	83 e0 03             	and    $0x3,%eax
-c0101d5c:	8b 14 85 40 f5 11 c0 	mov    -0x3fee0ac0(,%eax,4),%edx
-c0101d63:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
-c0101d67:	01 d0                	add    %edx,%eax
-c0101d69:	0f b6 00             	movzbl (%eax),%eax
-c0101d6c:	0f b6 c0             	movzbl %al,%eax
-c0101d6f:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0101ce6:	a1 48 37 12 c0       	mov    0xc0123748,%eax
+c0101ceb:	83 e0 03             	and    $0x3,%eax
+c0101cee:	8b 14 85 40 05 12 c0 	mov    -0x3fedfac0(,%eax,4),%edx
+c0101cf5:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+c0101cf9:	01 d0                	add    %edx,%eax
+c0101cfb:	0f b6 00             	movzbl (%eax),%eax
+c0101cfe:	0f b6 c0             	movzbl %al,%eax
+c0101d01:	89 45 f4             	mov    %eax,-0xc(%ebp)
     if (shift & CAPSLOCK) {
-c0101d72:	a1 48 27 12 c0       	mov    0xc0122748,%eax
-c0101d77:	83 e0 08             	and    $0x8,%eax
-c0101d7a:	85 c0                	test   %eax,%eax
-c0101d7c:	74 22                	je     c0101da0 <kbd_proc_data+0x14e>
+c0101d04:	a1 48 37 12 c0       	mov    0xc0123748,%eax
+c0101d09:	83 e0 08             	and    $0x8,%eax
+c0101d0c:	85 c0                	test   %eax,%eax
+c0101d0e:	74 22                	je     c0101d32 <kbd_proc_data+0x14a>
         if ('a' <= c && c <= 'z')
-c0101d7e:	83 7d f4 60          	cmpl   $0x60,-0xc(%ebp)
-c0101d82:	7e 0c                	jle    c0101d90 <kbd_proc_data+0x13e>
-c0101d84:	83 7d f4 7a          	cmpl   $0x7a,-0xc(%ebp)
-c0101d88:	7f 06                	jg     c0101d90 <kbd_proc_data+0x13e>
+c0101d10:	83 7d f4 60          	cmpl   $0x60,-0xc(%ebp)
+c0101d14:	7e 0c                	jle    c0101d22 <kbd_proc_data+0x13a>
+c0101d16:	83 7d f4 7a          	cmpl   $0x7a,-0xc(%ebp)
+c0101d1a:	7f 06                	jg     c0101d22 <kbd_proc_data+0x13a>
             c += 'A' - 'a';
-c0101d8a:	83 6d f4 20          	subl   $0x20,-0xc(%ebp)
-c0101d8e:	eb 10                	jmp    c0101da0 <kbd_proc_data+0x14e>
+c0101d1c:	83 6d f4 20          	subl   $0x20,-0xc(%ebp)
+c0101d20:	eb 10                	jmp    c0101d32 <kbd_proc_data+0x14a>
         else if ('A' <= c && c <= 'Z')
-c0101d90:	83 7d f4 40          	cmpl   $0x40,-0xc(%ebp)
-c0101d94:	7e 0a                	jle    c0101da0 <kbd_proc_data+0x14e>
-c0101d96:	83 7d f4 5a          	cmpl   $0x5a,-0xc(%ebp)
-c0101d9a:	7f 04                	jg     c0101da0 <kbd_proc_data+0x14e>
+c0101d22:	83 7d f4 40          	cmpl   $0x40,-0xc(%ebp)
+c0101d26:	7e 0a                	jle    c0101d32 <kbd_proc_data+0x14a>
+c0101d28:	83 7d f4 5a          	cmpl   $0x5a,-0xc(%ebp)
+c0101d2c:	7f 04                	jg     c0101d32 <kbd_proc_data+0x14a>
             c += 'a' - 'A';
-c0101d9c:	83 45 f4 20          	addl   $0x20,-0xc(%ebp)
+c0101d2e:	83 45 f4 20          	addl   $0x20,-0xc(%ebp)
     }
 
     // Process special keys
     // Ctrl-Alt-Del: reboot
     if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
-c0101da0:	a1 48 27 12 c0       	mov    0xc0122748,%eax
-c0101da5:	f7 d0                	not    %eax
-c0101da7:	83 e0 06             	and    $0x6,%eax
-c0101daa:	85 c0                	test   %eax,%eax
-c0101dac:	75 2c                	jne    c0101dda <kbd_proc_data+0x188>
-c0101dae:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
-c0101db5:	75 23                	jne    c0101dda <kbd_proc_data+0x188>
+c0101d32:	a1 48 37 12 c0       	mov    0xc0123748,%eax
+c0101d37:	f7 d0                	not    %eax
+c0101d39:	83 e0 06             	and    $0x6,%eax
+c0101d3c:	85 c0                	test   %eax,%eax
+c0101d3e:	75 28                	jne    c0101d68 <kbd_proc_data+0x180>
+c0101d40:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
+c0101d47:	75 1f                	jne    c0101d68 <kbd_proc_data+0x180>
         cprintf("Rebooting!\n");
-c0101db7:	83 ec 0c             	sub    $0xc,%esp
-c0101dba:	68 a1 87 10 c0       	push   $0xc01087a1
-c0101dbf:	e8 be e4 ff ff       	call   c0100282 <cprintf>
-c0101dc4:	83 c4 10             	add    $0x10,%esp
-c0101dc7:	66 c7 45 ee 92 00    	movw   $0x92,-0x12(%ebp)
-c0101dcd:	c6 45 e9 03          	movb   $0x3,-0x17(%ebp)
+c0101d49:	c7 04 24 b9 8e 10 c0 	movl   $0xc0108eb9,(%esp)
+c0101d50:	e8 4c e5 ff ff       	call   c01002a1 <cprintf>
+c0101d55:	66 c7 45 ee 92 00    	movw   $0x92,-0x12(%ebp)
+c0101d5b:	c6 45 e9 03          	movb   $0x3,-0x17(%ebp)
         : "memory", "cc");
 }
 
 static inline void
 outb(uint16_t port, uint8_t data) {
     asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
-c0101dd1:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
-c0101dd5:	0f b7 55 ee          	movzwl -0x12(%ebp),%edx
-c0101dd9:	ee                   	out    %al,(%dx)
+c0101d5f:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
+c0101d63:	0f b7 55 ee          	movzwl -0x12(%ebp),%edx
+c0101d67:	ee                   	out    %al,(%dx)
         outb(0x92, 0x3); // courtesy of Chris Frost
     }
     return c;
-c0101dda:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0101d68:	8b 45 f4             	mov    -0xc(%ebp),%eax
 }
-c0101ddd:	c9                   	leave  
-c0101dde:	c3                   	ret    
+c0101d6b:	c9                   	leave  
+c0101d6c:	c3                   	ret    
 
-c0101ddf <kbd_intr>:
+c0101d6d <kbd_intr>:
 
 /* kbd_intr - try to feed input characters from keyboard */
 static void
 kbd_intr(void) {
-c0101ddf:	55                   	push   %ebp
-c0101de0:	89 e5                	mov    %esp,%ebp
-c0101de2:	83 ec 08             	sub    $0x8,%esp
+c0101d6d:	55                   	push   %ebp
+c0101d6e:	89 e5                	mov    %esp,%ebp
+c0101d70:	83 ec 18             	sub    $0x18,%esp
     cons_intr(kbd_proc_data);
-c0101de5:	83 ec 0c             	sub    $0xc,%esp
-c0101de8:	68 52 1c 10 c0       	push   $0xc0101c52
-c0101ded:	e8 9b fd ff ff       	call   c0101b8d <cons_intr>
-c0101df2:	83 c4 10             	add    $0x10,%esp
-}
-c0101df5:	90                   	nop
-c0101df6:	c9                   	leave  
-c0101df7:	c3                   	ret    
+c0101d73:	c7 04 24 e8 1b 10 c0 	movl   $0xc0101be8,(%esp)
+c0101d7a:	e8 a9 fd ff ff       	call   c0101b28 <cons_intr>
+}
+c0101d7f:	90                   	nop
+c0101d80:	c9                   	leave  
+c0101d81:	c3                   	ret    
 
-c0101df8 <kbd_init>:
+c0101d82 <kbd_init>:
 
 static void
 kbd_init(void) {
-c0101df8:	55                   	push   %ebp
-c0101df9:	89 e5                	mov    %esp,%ebp
-c0101dfb:	83 ec 08             	sub    $0x8,%esp
+c0101d82:	55                   	push   %ebp
+c0101d83:	89 e5                	mov    %esp,%ebp
+c0101d85:	83 ec 18             	sub    $0x18,%esp
     // drain the kbd buffer
     kbd_intr();
-c0101dfe:	e8 dc ff ff ff       	call   c0101ddf <kbd_intr>
+c0101d88:	e8 e0 ff ff ff       	call   c0101d6d <kbd_intr>
     pic_enable(IRQ_KBD);
-c0101e03:	83 ec 0c             	sub    $0xc,%esp
-c0101e06:	6a 01                	push   $0x1
-c0101e08:	e8 4b 01 00 00       	call   c0101f58 <pic_enable>
-c0101e0d:	83 c4 10             	add    $0x10,%esp
-}
-c0101e10:	90                   	nop
-c0101e11:	c9                   	leave  
-c0101e12:	c3                   	ret    
+c0101d8d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c0101d94:	e8 34 01 00 00       	call   c0101ecd <pic_enable>
+}
+c0101d99:	90                   	nop
+c0101d9a:	c9                   	leave  
+c0101d9b:	c3                   	ret    
 
-c0101e13 <cons_init>:
+c0101d9c <cons_init>:
 
 /* cons_init - initializes the console devices */
 void
 cons_init(void) {
-c0101e13:	55                   	push   %ebp
-c0101e14:	89 e5                	mov    %esp,%ebp
-c0101e16:	83 ec 08             	sub    $0x8,%esp
+c0101d9c:	55                   	push   %ebp
+c0101d9d:	89 e5                	mov    %esp,%ebp
+c0101d9f:	83 ec 18             	sub    $0x18,%esp
     cga_init();
-c0101e19:	e8 8c f8 ff ff       	call   c01016aa <cga_init>
+c0101da2:	e8 90 f8 ff ff       	call   c0101637 <cga_init>
     serial_init();
-c0101e1e:	e8 6e f9 ff ff       	call   c0101791 <serial_init>
+c0101da7:	e8 6d f9 ff ff       	call   c0101719 <serial_init>
     kbd_init();
-c0101e23:	e8 d0 ff ff ff       	call   c0101df8 <kbd_init>
+c0101dac:	e8 d1 ff ff ff       	call   c0101d82 <kbd_init>
     if (!serial_exists) {
-c0101e28:	a1 28 25 12 c0       	mov    0xc0122528,%eax
-c0101e2d:	85 c0                	test   %eax,%eax
-c0101e2f:	75 10                	jne    c0101e41 <cons_init+0x2e>
+c0101db1:	a1 28 35 12 c0       	mov    0xc0123528,%eax
+c0101db6:	85 c0                	test   %eax,%eax
+c0101db8:	75 0c                	jne    c0101dc6 <cons_init+0x2a>
         cprintf("serial port does not exist!!\n");
-c0101e31:	83 ec 0c             	sub    $0xc,%esp
-c0101e34:	68 ad 87 10 c0       	push   $0xc01087ad
-c0101e39:	e8 44 e4 ff ff       	call   c0100282 <cprintf>
-c0101e3e:	83 c4 10             	add    $0x10,%esp
+c0101dba:	c7 04 24 c5 8e 10 c0 	movl   $0xc0108ec5,(%esp)
+c0101dc1:	e8 db e4 ff ff       	call   c01002a1 <cprintf>
     }
 }
-c0101e41:	90                   	nop
-c0101e42:	c9                   	leave  
-c0101e43:	c3                   	ret    
+c0101dc6:	90                   	nop
+c0101dc7:	c9                   	leave  
+c0101dc8:	c3                   	ret    
 
-c0101e44 <cons_putc>:
+c0101dc9 <cons_putc>:
 
 /* cons_putc - print a single character @c to console devices */
 void
 cons_putc(int c) {
-c0101e44:	55                   	push   %ebp
-c0101e45:	89 e5                	mov    %esp,%ebp
-c0101e47:	83 ec 18             	sub    $0x18,%esp
+c0101dc9:	55                   	push   %ebp
+c0101dca:	89 e5                	mov    %esp,%ebp
+c0101dcc:	83 ec 28             	sub    $0x28,%esp
     bool intr_flag;
     local_intr_save(intr_flag);
-c0101e4a:	e8 d4 f7 ff ff       	call   c0101623 <__intr_save>
-c0101e4f:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0101dcf:	e8 de f7 ff ff       	call   c01015b2 <__intr_save>
+c0101dd4:	89 45 f4             	mov    %eax,-0xc(%ebp)
     {
         lpt_putc(c);
-c0101e52:	83 ec 0c             	sub    $0xc,%esp
-c0101e55:	ff 75 08             	pushl  0x8(%ebp)
-c0101e58:	e8 93 fa ff ff       	call   c01018f0 <lpt_putc>
-c0101e5d:	83 c4 10             	add    $0x10,%esp
+c0101dd7:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101dda:	89 04 24             	mov    %eax,(%esp)
+c0101ddd:	e8 8d fa ff ff       	call   c010186f <lpt_putc>
         cga_putc(c);
-c0101e60:	83 ec 0c             	sub    $0xc,%esp
-c0101e63:	ff 75 08             	pushl  0x8(%ebp)
-c0101e66:	e8 bc fa ff ff       	call   c0101927 <cga_putc>
-c0101e6b:	83 c4 10             	add    $0x10,%esp
+c0101de2:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101de5:	89 04 24             	mov    %eax,(%esp)
+c0101de8:	e8 c2 fa ff ff       	call   c01018af <cga_putc>
         serial_putc(c);
-c0101e6e:	83 ec 0c             	sub    $0xc,%esp
-c0101e71:	ff 75 08             	pushl  0x8(%ebp)
-c0101e74:	e8 dd fc ff ff       	call   c0101b56 <serial_putc>
-c0101e79:	83 c4 10             	add    $0x10,%esp
+c0101ded:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101df0:	89 04 24             	mov    %eax,(%esp)
+c0101df3:	e8 f0 fc ff ff       	call   c0101ae8 <serial_putc>
     }
     local_intr_restore(intr_flag);
-c0101e7c:	83 ec 0c             	sub    $0xc,%esp
-c0101e7f:	ff 75 f4             	pushl  -0xc(%ebp)
-c0101e82:	e8 c6 f7 ff ff       	call   c010164d <__intr_restore>
-c0101e87:	83 c4 10             	add    $0x10,%esp
-}
-c0101e8a:	90                   	nop
-c0101e8b:	c9                   	leave  
-c0101e8c:	c3                   	ret    
+c0101df8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0101dfb:	89 04 24             	mov    %eax,(%esp)
+c0101dfe:	e8 d9 f7 ff ff       	call   c01015dc <__intr_restore>
+}
+c0101e03:	90                   	nop
+c0101e04:	c9                   	leave  
+c0101e05:	c3                   	ret    
 
-c0101e8d <cons_getc>:
+c0101e06 <cons_getc>:
 /* *
  * cons_getc - return the next input character from console,
  * or 0 if none waiting.
  * */
 int
 cons_getc(void) {
-c0101e8d:	55                   	push   %ebp
-c0101e8e:	89 e5                	mov    %esp,%ebp
-c0101e90:	83 ec 18             	sub    $0x18,%esp
+c0101e06:	55                   	push   %ebp
+c0101e07:	89 e5                	mov    %esp,%ebp
+c0101e09:	83 ec 28             	sub    $0x28,%esp
     int c = 0;
-c0101e93:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+c0101e0c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     bool intr_flag;
     local_intr_save(intr_flag);
-c0101e9a:	e8 84 f7 ff ff       	call   c0101623 <__intr_save>
-c0101e9f:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0101e13:	e8 9a f7 ff ff       	call   c01015b2 <__intr_save>
+c0101e18:	89 45 f0             	mov    %eax,-0x10(%ebp)
     {
         // poll for any pending input characters,
         // so that this function works even when interrupts are disabled
         // (e.g., when called from the kernel monitor).
         serial_intr();
-c0101ea2:	e8 89 fd ff ff       	call   c0101c30 <serial_intr>
+c0101e1b:	e8 aa fd ff ff       	call   c0101bca <serial_intr>
         kbd_intr();
-c0101ea7:	e8 33 ff ff ff       	call   c0101ddf <kbd_intr>
+c0101e20:	e8 48 ff ff ff       	call   c0101d6d <kbd_intr>
 
         // grab the next character from the input buffer.
         if (cons.rpos != cons.wpos) {
-c0101eac:	8b 15 40 27 12 c0    	mov    0xc0122740,%edx
-c0101eb2:	a1 44 27 12 c0       	mov    0xc0122744,%eax
-c0101eb7:	39 c2                	cmp    %eax,%edx
-c0101eb9:	74 31                	je     c0101eec <cons_getc+0x5f>
+c0101e25:	8b 15 40 37 12 c0    	mov    0xc0123740,%edx
+c0101e2b:	a1 44 37 12 c0       	mov    0xc0123744,%eax
+c0101e30:	39 c2                	cmp    %eax,%edx
+c0101e32:	74 31                	je     c0101e65 <cons_getc+0x5f>
             c = cons.buf[cons.rpos ++];
-c0101ebb:	a1 40 27 12 c0       	mov    0xc0122740,%eax
-c0101ec0:	8d 50 01             	lea    0x1(%eax),%edx
-c0101ec3:	89 15 40 27 12 c0    	mov    %edx,0xc0122740
-c0101ec9:	0f b6 80 40 25 12 c0 	movzbl -0x3feddac0(%eax),%eax
-c0101ed0:	0f b6 c0             	movzbl %al,%eax
-c0101ed3:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0101e34:	a1 40 37 12 c0       	mov    0xc0123740,%eax
+c0101e39:	8d 50 01             	lea    0x1(%eax),%edx
+c0101e3c:	89 15 40 37 12 c0    	mov    %edx,0xc0123740
+c0101e42:	0f b6 80 40 35 12 c0 	movzbl -0x3fedcac0(%eax),%eax
+c0101e49:	0f b6 c0             	movzbl %al,%eax
+c0101e4c:	89 45 f4             	mov    %eax,-0xc(%ebp)
             if (cons.rpos == CONSBUFSIZE) {
-c0101ed6:	a1 40 27 12 c0       	mov    0xc0122740,%eax
-c0101edb:	3d 00 02 00 00       	cmp    $0x200,%eax
-c0101ee0:	75 0a                	jne    c0101eec <cons_getc+0x5f>
+c0101e4f:	a1 40 37 12 c0       	mov    0xc0123740,%eax
+c0101e54:	3d 00 02 00 00       	cmp    $0x200,%eax
+c0101e59:	75 0a                	jne    c0101e65 <cons_getc+0x5f>
                 cons.rpos = 0;
-c0101ee2:	c7 05 40 27 12 c0 00 	movl   $0x0,0xc0122740
-c0101ee9:	00 00 00 
+c0101e5b:	c7 05 40 37 12 c0 00 	movl   $0x0,0xc0123740
+c0101e62:	00 00 00 
             }
         }
     }
     local_intr_restore(intr_flag);
-c0101eec:	83 ec 0c             	sub    $0xc,%esp
-c0101eef:	ff 75 f0             	pushl  -0x10(%ebp)
-c0101ef2:	e8 56 f7 ff ff       	call   c010164d <__intr_restore>
-c0101ef7:	83 c4 10             	add    $0x10,%esp
+c0101e65:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0101e68:	89 04 24             	mov    %eax,(%esp)
+c0101e6b:	e8 6c f7 ff ff       	call   c01015dc <__intr_restore>
     return c;
-c0101efa:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0101e70:	8b 45 f4             	mov    -0xc(%ebp),%eax
 }
-c0101efd:	c9                   	leave  
-c0101efe:	c3                   	ret    
+c0101e73:	c9                   	leave  
+c0101e74:	c3                   	ret    
 
-c0101eff <pic_setmask>:
+c0101e75 <pic_setmask>:
 // Initial IRQ mask has interrupt 2 enabled (for slave 8259A).
 static uint16_t irq_mask = 0xFFFF & ~(1 << IRQ_SLAVE);
 static bool did_init = 0;
 
 static void
 pic_setmask(uint16_t mask) {
-c0101eff:	55                   	push   %ebp
-c0101f00:	89 e5                	mov    %esp,%ebp
-c0101f02:	83 ec 14             	sub    $0x14,%esp
-c0101f05:	8b 45 08             	mov    0x8(%ebp),%eax
-c0101f08:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
+c0101e75:	55                   	push   %ebp
+c0101e76:	89 e5                	mov    %esp,%ebp
+c0101e78:	83 ec 14             	sub    $0x14,%esp
+c0101e7b:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101e7e:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
     irq_mask = mask;
-c0101f0c:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
-c0101f10:	66 a3 50 f5 11 c0    	mov    %ax,0xc011f550
+c0101e82:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0101e85:	66 a3 50 05 12 c0    	mov    %ax,0xc0120550
     if (did_init) {
-c0101f16:	a1 4c 27 12 c0       	mov    0xc012274c,%eax
-c0101f1b:	85 c0                	test   %eax,%eax
-c0101f1d:	74 36                	je     c0101f55 <pic_setmask+0x56>
+c0101e8b:	a1 4c 37 12 c0       	mov    0xc012374c,%eax
+c0101e90:	85 c0                	test   %eax,%eax
+c0101e92:	74 36                	je     c0101eca <pic_setmask+0x55>
         outb(IO_PIC1 + 1, mask);
-c0101f1f:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
-c0101f23:	0f b6 c0             	movzbl %al,%eax
-c0101f26:	66 c7 45 fe 21 00    	movw   $0x21,-0x2(%ebp)
-c0101f2c:	88 45 fa             	mov    %al,-0x6(%ebp)
-c0101f2f:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
-c0101f33:	0f b7 55 fe          	movzwl -0x2(%ebp),%edx
-c0101f37:	ee                   	out    %al,(%dx)
+c0101e94:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0101e97:	0f b6 c0             	movzbl %al,%eax
+c0101e9a:	66 c7 45 fe 21 00    	movw   $0x21,-0x2(%ebp)
+c0101ea0:	88 45 fa             	mov    %al,-0x6(%ebp)
+c0101ea3:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
+c0101ea7:	0f b7 55 fe          	movzwl -0x2(%ebp),%edx
+c0101eab:	ee                   	out    %al,(%dx)
         outb(IO_PIC2 + 1, mask >> 8);
-c0101f38:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
-c0101f3c:	66 c1 e8 08          	shr    $0x8,%ax
-c0101f40:	0f b6 c0             	movzbl %al,%eax
-c0101f43:	66 c7 45 fc a1 00    	movw   $0xa1,-0x4(%ebp)
-c0101f49:	88 45 fb             	mov    %al,-0x5(%ebp)
-c0101f4c:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
-c0101f50:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
-c0101f54:	ee                   	out    %al,(%dx)
-    }
-}
-c0101f55:	90                   	nop
-c0101f56:	c9                   	leave  
-c0101f57:	c3                   	ret    
+c0101eac:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
+c0101eb0:	c1 e8 08             	shr    $0x8,%eax
+c0101eb3:	0f b7 c0             	movzwl %ax,%eax
+c0101eb6:	0f b6 c0             	movzbl %al,%eax
+c0101eb9:	66 c7 45 fc a1 00    	movw   $0xa1,-0x4(%ebp)
+c0101ebf:	88 45 fb             	mov    %al,-0x5(%ebp)
+c0101ec2:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
+c0101ec6:	8b 55 fc             	mov    -0x4(%ebp),%edx
+c0101ec9:	ee                   	out    %al,(%dx)
+    }
+}
+c0101eca:	90                   	nop
+c0101ecb:	c9                   	leave  
+c0101ecc:	c3                   	ret    
 
-c0101f58 <pic_enable>:
+c0101ecd <pic_enable>:
 
 void
 pic_enable(unsigned int irq) {
-c0101f58:	55                   	push   %ebp
-c0101f59:	89 e5                	mov    %esp,%ebp
+c0101ecd:	55                   	push   %ebp
+c0101ece:	89 e5                	mov    %esp,%ebp
+c0101ed0:	83 ec 04             	sub    $0x4,%esp
     pic_setmask(irq_mask & ~(1 << irq));
-c0101f5b:	8b 45 08             	mov    0x8(%ebp),%eax
-c0101f5e:	ba 01 00 00 00       	mov    $0x1,%edx
-c0101f63:	89 c1                	mov    %eax,%ecx
-c0101f65:	d3 e2                	shl    %cl,%edx
-c0101f67:	89 d0                	mov    %edx,%eax
-c0101f69:	f7 d0                	not    %eax
-c0101f6b:	89 c2                	mov    %eax,%edx
-c0101f6d:	0f b7 05 50 f5 11 c0 	movzwl 0xc011f550,%eax
-c0101f74:	21 d0                	and    %edx,%eax
-c0101f76:	0f b7 c0             	movzwl %ax,%eax
-c0101f79:	50                   	push   %eax
-c0101f7a:	e8 80 ff ff ff       	call   c0101eff <pic_setmask>
-c0101f7f:	83 c4 04             	add    $0x4,%esp
-}
-c0101f82:	90                   	nop
-c0101f83:	c9                   	leave  
-c0101f84:	c3                   	ret    
+c0101ed3:	8b 45 08             	mov    0x8(%ebp),%eax
+c0101ed6:	ba 01 00 00 00       	mov    $0x1,%edx
+c0101edb:	88 c1                	mov    %al,%cl
+c0101edd:	d3 e2                	shl    %cl,%edx
+c0101edf:	89 d0                	mov    %edx,%eax
+c0101ee1:	98                   	cwtl   
+c0101ee2:	f7 d0                	not    %eax
+c0101ee4:	0f bf d0             	movswl %ax,%edx
+c0101ee7:	0f b7 05 50 05 12 c0 	movzwl 0xc0120550,%eax
+c0101eee:	98                   	cwtl   
+c0101eef:	21 d0                	and    %edx,%eax
+c0101ef1:	98                   	cwtl   
+c0101ef2:	0f b7 c0             	movzwl %ax,%eax
+c0101ef5:	89 04 24             	mov    %eax,(%esp)
+c0101ef8:	e8 78 ff ff ff       	call   c0101e75 <pic_setmask>
+}
+c0101efd:	90                   	nop
+c0101efe:	c9                   	leave  
+c0101eff:	c3                   	ret    
 
-c0101f85 <pic_init>:
+c0101f00 <pic_init>:
 
 /* pic_init - initialize the 8259A interrupt controllers */
 void
 pic_init(void) {
-c0101f85:	55                   	push   %ebp
-c0101f86:	89 e5                	mov    %esp,%ebp
-c0101f88:	83 ec 30             	sub    $0x30,%esp
+c0101f00:	55                   	push   %ebp
+c0101f01:	89 e5                	mov    %esp,%ebp
+c0101f03:	83 ec 34             	sub    $0x34,%esp
     did_init = 1;
-c0101f8b:	c7 05 4c 27 12 c0 01 	movl   $0x1,0xc012274c
-c0101f92:	00 00 00 
-c0101f95:	66 c7 45 fe 21 00    	movw   $0x21,-0x2(%ebp)
-c0101f9b:	c6 45 d6 ff          	movb   $0xff,-0x2a(%ebp)
-c0101f9f:	0f b6 45 d6          	movzbl -0x2a(%ebp),%eax
-c0101fa3:	0f b7 55 fe          	movzwl -0x2(%ebp),%edx
-c0101fa7:	ee                   	out    %al,(%dx)
-c0101fa8:	66 c7 45 fc a1 00    	movw   $0xa1,-0x4(%ebp)
-c0101fae:	c6 45 d7 ff          	movb   $0xff,-0x29(%ebp)
-c0101fb2:	0f b6 45 d7          	movzbl -0x29(%ebp),%eax
-c0101fb6:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
-c0101fba:	ee                   	out    %al,(%dx)
-c0101fbb:	66 c7 45 fa 20 00    	movw   $0x20,-0x6(%ebp)
-c0101fc1:	c6 45 d8 11          	movb   $0x11,-0x28(%ebp)
-c0101fc5:	0f b6 45 d8          	movzbl -0x28(%ebp),%eax
-c0101fc9:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
-c0101fcd:	ee                   	out    %al,(%dx)
-c0101fce:	66 c7 45 f8 21 00    	movw   $0x21,-0x8(%ebp)
-c0101fd4:	c6 45 d9 20          	movb   $0x20,-0x27(%ebp)
-c0101fd8:	0f b6 45 d9          	movzbl -0x27(%ebp),%eax
-c0101fdc:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
-c0101fe0:	ee                   	out    %al,(%dx)
-c0101fe1:	66 c7 45 f6 21 00    	movw   $0x21,-0xa(%ebp)
-c0101fe7:	c6 45 da 04          	movb   $0x4,-0x26(%ebp)
-c0101feb:	0f b6 45 da          	movzbl -0x26(%ebp),%eax
-c0101fef:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
-c0101ff3:	ee                   	out    %al,(%dx)
-c0101ff4:	66 c7 45 f4 21 00    	movw   $0x21,-0xc(%ebp)
-c0101ffa:	c6 45 db 03          	movb   $0x3,-0x25(%ebp)
-c0101ffe:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
-c0102002:	0f b7 55 f4          	movzwl -0xc(%ebp),%edx
-c0102006:	ee                   	out    %al,(%dx)
-c0102007:	66 c7 45 f2 a0 00    	movw   $0xa0,-0xe(%ebp)
-c010200d:	c6 45 dc 11          	movb   $0x11,-0x24(%ebp)
-c0102011:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
-c0102015:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
-c0102019:	ee                   	out    %al,(%dx)
-c010201a:	66 c7 45 f0 a1 00    	movw   $0xa1,-0x10(%ebp)
-c0102020:	c6 45 dd 28          	movb   $0x28,-0x23(%ebp)
-c0102024:	0f b6 45 dd          	movzbl -0x23(%ebp),%eax
-c0102028:	0f b7 55 f0          	movzwl -0x10(%ebp),%edx
-c010202c:	ee                   	out    %al,(%dx)
-c010202d:	66 c7 45 ee a1 00    	movw   $0xa1,-0x12(%ebp)
-c0102033:	c6 45 de 02          	movb   $0x2,-0x22(%ebp)
-c0102037:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
-c010203b:	0f b7 55 ee          	movzwl -0x12(%ebp),%edx
-c010203f:	ee                   	out    %al,(%dx)
-c0102040:	66 c7 45 ec a1 00    	movw   $0xa1,-0x14(%ebp)
-c0102046:	c6 45 df 03          	movb   $0x3,-0x21(%ebp)
-c010204a:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
-c010204e:	0f b7 55 ec          	movzwl -0x14(%ebp),%edx
-c0102052:	ee                   	out    %al,(%dx)
-c0102053:	66 c7 45 ea 20 00    	movw   $0x20,-0x16(%ebp)
-c0102059:	c6 45 e0 68          	movb   $0x68,-0x20(%ebp)
-c010205d:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
-c0102061:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
-c0102065:	ee                   	out    %al,(%dx)
-c0102066:	66 c7 45 e8 20 00    	movw   $0x20,-0x18(%ebp)
-c010206c:	c6 45 e1 0a          	movb   $0xa,-0x1f(%ebp)
-c0102070:	0f b6 45 e1          	movzbl -0x1f(%ebp),%eax
-c0102074:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
-c0102078:	ee                   	out    %al,(%dx)
-c0102079:	66 c7 45 e6 a0 00    	movw   $0xa0,-0x1a(%ebp)
-c010207f:	c6 45 e2 68          	movb   $0x68,-0x1e(%ebp)
-c0102083:	0f b6 45 e2          	movzbl -0x1e(%ebp),%eax
-c0102087:	0f b7 55 e6          	movzwl -0x1a(%ebp),%edx
-c010208b:	ee                   	out    %al,(%dx)
-c010208c:	66 c7 45 e4 a0 00    	movw   $0xa0,-0x1c(%ebp)
-c0102092:	c6 45 e3 0a          	movb   $0xa,-0x1d(%ebp)
-c0102096:	0f b6 45 e3          	movzbl -0x1d(%ebp),%eax
-c010209a:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
-c010209e:	ee                   	out    %al,(%dx)
+c0101f06:	c7 05 4c 37 12 c0 01 	movl   $0x1,0xc012374c
+c0101f0d:	00 00 00 
+c0101f10:	66 c7 45 fe 21 00    	movw   $0x21,-0x2(%ebp)
+c0101f16:	c6 45 d6 ff          	movb   $0xff,-0x2a(%ebp)
+c0101f1a:	0f b6 45 d6          	movzbl -0x2a(%ebp),%eax
+c0101f1e:	0f b7 55 fe          	movzwl -0x2(%ebp),%edx
+c0101f22:	ee                   	out    %al,(%dx)
+c0101f23:	66 c7 45 fc a1 00    	movw   $0xa1,-0x4(%ebp)
+c0101f29:	c6 45 d7 ff          	movb   $0xff,-0x29(%ebp)
+c0101f2d:	0f b6 45 d7          	movzbl -0x29(%ebp),%eax
+c0101f31:	8b 55 fc             	mov    -0x4(%ebp),%edx
+c0101f34:	ee                   	out    %al,(%dx)
+c0101f35:	66 c7 45 fa 20 00    	movw   $0x20,-0x6(%ebp)
+c0101f3b:	c6 45 d8 11          	movb   $0x11,-0x28(%ebp)
+c0101f3f:	0f b6 45 d8          	movzbl -0x28(%ebp),%eax
+c0101f43:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
+c0101f47:	ee                   	out    %al,(%dx)
+c0101f48:	66 c7 45 f8 21 00    	movw   $0x21,-0x8(%ebp)
+c0101f4e:	c6 45 d9 20          	movb   $0x20,-0x27(%ebp)
+c0101f52:	0f b6 45 d9          	movzbl -0x27(%ebp),%eax
+c0101f56:	8b 55 f8             	mov    -0x8(%ebp),%edx
+c0101f59:	ee                   	out    %al,(%dx)
+c0101f5a:	66 c7 45 f6 21 00    	movw   $0x21,-0xa(%ebp)
+c0101f60:	c6 45 da 04          	movb   $0x4,-0x26(%ebp)
+c0101f64:	0f b6 45 da          	movzbl -0x26(%ebp),%eax
+c0101f68:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
+c0101f6c:	ee                   	out    %al,(%dx)
+c0101f6d:	66 c7 45 f4 21 00    	movw   $0x21,-0xc(%ebp)
+c0101f73:	c6 45 db 03          	movb   $0x3,-0x25(%ebp)
+c0101f77:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
+c0101f7b:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0101f7e:	ee                   	out    %al,(%dx)
+c0101f7f:	66 c7 45 f2 a0 00    	movw   $0xa0,-0xe(%ebp)
+c0101f85:	c6 45 dc 11          	movb   $0x11,-0x24(%ebp)
+c0101f89:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
+c0101f8d:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+c0101f91:	ee                   	out    %al,(%dx)
+c0101f92:	66 c7 45 f0 a1 00    	movw   $0xa1,-0x10(%ebp)
+c0101f98:	c6 45 dd 28          	movb   $0x28,-0x23(%ebp)
+c0101f9c:	0f b6 45 dd          	movzbl -0x23(%ebp),%eax
+c0101fa0:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c0101fa3:	ee                   	out    %al,(%dx)
+c0101fa4:	66 c7 45 ee a1 00    	movw   $0xa1,-0x12(%ebp)
+c0101faa:	c6 45 de 02          	movb   $0x2,-0x22(%ebp)
+c0101fae:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
+c0101fb2:	0f b7 55 ee          	movzwl -0x12(%ebp),%edx
+c0101fb6:	ee                   	out    %al,(%dx)
+c0101fb7:	66 c7 45 ec a1 00    	movw   $0xa1,-0x14(%ebp)
+c0101fbd:	c6 45 df 03          	movb   $0x3,-0x21(%ebp)
+c0101fc1:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
+c0101fc5:	8b 55 ec             	mov    -0x14(%ebp),%edx
+c0101fc8:	ee                   	out    %al,(%dx)
+c0101fc9:	66 c7 45 ea 20 00    	movw   $0x20,-0x16(%ebp)
+c0101fcf:	c6 45 e0 68          	movb   $0x68,-0x20(%ebp)
+c0101fd3:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
+c0101fd7:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
+c0101fdb:	ee                   	out    %al,(%dx)
+c0101fdc:	66 c7 45 e8 20 00    	movw   $0x20,-0x18(%ebp)
+c0101fe2:	c6 45 e1 0a          	movb   $0xa,-0x1f(%ebp)
+c0101fe6:	0f b6 45 e1          	movzbl -0x1f(%ebp),%eax
+c0101fea:	8b 55 e8             	mov    -0x18(%ebp),%edx
+c0101fed:	ee                   	out    %al,(%dx)
+c0101fee:	66 c7 45 e6 a0 00    	movw   $0xa0,-0x1a(%ebp)
+c0101ff4:	c6 45 e2 68          	movb   $0x68,-0x1e(%ebp)
+c0101ff8:	0f b6 45 e2          	movzbl -0x1e(%ebp),%eax
+c0101ffc:	0f b7 55 e6          	movzwl -0x1a(%ebp),%edx
+c0102000:	ee                   	out    %al,(%dx)
+c0102001:	66 c7 45 e4 a0 00    	movw   $0xa0,-0x1c(%ebp)
+c0102007:	c6 45 e3 0a          	movb   $0xa,-0x1d(%ebp)
+c010200b:	0f b6 45 e3          	movzbl -0x1d(%ebp),%eax
+c010200f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c0102012:	ee                   	out    %al,(%dx)
     outb(IO_PIC1, 0x0a);    // read IRR by default
 
     outb(IO_PIC2, 0x68);    // OCW3
     outb(IO_PIC2, 0x0a);    // OCW3
 
     if (irq_mask != 0xFFFF) {
-c010209f:	0f b7 05 50 f5 11 c0 	movzwl 0xc011f550,%eax
-c01020a6:	66 83 f8 ff          	cmp    $0xffff,%ax
-c01020aa:	74 13                	je     c01020bf <pic_init+0x13a>
+c0102013:	0f b7 05 50 05 12 c0 	movzwl 0xc0120550,%eax
+c010201a:	3d ff ff 00 00       	cmp    $0xffff,%eax
+c010201f:	74 0f                	je     c0102030 <pic_init+0x130>
         pic_setmask(irq_mask);
-c01020ac:	0f b7 05 50 f5 11 c0 	movzwl 0xc011f550,%eax
-c01020b3:	0f b7 c0             	movzwl %ax,%eax
-c01020b6:	50                   	push   %eax
-c01020b7:	e8 43 fe ff ff       	call   c0101eff <pic_setmask>
-c01020bc:	83 c4 04             	add    $0x4,%esp
+c0102021:	0f b7 05 50 05 12 c0 	movzwl 0xc0120550,%eax
+c0102028:	89 04 24             	mov    %eax,(%esp)
+c010202b:	e8 45 fe ff ff       	call   c0101e75 <pic_setmask>
     }
 }
-c01020bf:	90                   	nop
-c01020c0:	c9                   	leave  
-c01020c1:	c3                   	ret    
+c0102030:	90                   	nop
+c0102031:	c9                   	leave  
+c0102032:	c3                   	ret    
 
-c01020c2 <intr_enable>:
+c0102033 <intr_enable>:
 #include <x86.h>
 #include <intr.h>
 
 /* intr_enable - enable irq interrupt */
 void
 intr_enable(void) {
-c01020c2:	55                   	push   %ebp
-c01020c3:	89 e5                	mov    %esp,%ebp
+c0102033:	55                   	push   %ebp
+c0102034:	89 e5                	mov    %esp,%ebp
     asm volatile ("lidt (%0)" :: "r" (pd) : "memory");
 }
 
 static inline void
 sti(void) {
     asm volatile ("sti");
-c01020c5:	fb                   	sti    
+c0102036:	fb                   	sti    
     sti();
 }
-c01020c6:	90                   	nop
-c01020c7:	5d                   	pop    %ebp
-c01020c8:	c3                   	ret    
+c0102037:	90                   	nop
+c0102038:	5d                   	pop    %ebp
+c0102039:	c3                   	ret    
 
-c01020c9 <intr_disable>:
+c010203a <intr_disable>:
 
 /* intr_disable - disable irq interrupt */
 void
 intr_disable(void) {
-c01020c9:	55                   	push   %ebp
-c01020ca:	89 e5                	mov    %esp,%ebp
+c010203a:	55                   	push   %ebp
+c010203b:	89 e5                	mov    %esp,%ebp
 }
 
 static inline void
 cli(void) {
     asm volatile ("cli" ::: "memory");
-c01020cc:	fa                   	cli    
+c010203d:	fa                   	cli    
     cli();
 }
-c01020cd:	90                   	nop
-c01020ce:	5d                   	pop    %ebp
-c01020cf:	c3                   	ret    
+c010203e:	90                   	nop
+c010203f:	5d                   	pop    %ebp
+c0102040:	c3                   	ret    
 
-c01020d0 <print_ticks>:
+c0102041 <print_ticks>:
 #include <swap.h>
 #include <kdebug.h>
 
 #define TICK_NUM 100
 
 static void print_ticks() {
-c01020d0:	55                   	push   %ebp
-c01020d1:	89 e5                	mov    %esp,%ebp
-c01020d3:	83 ec 08             	sub    $0x8,%esp
+c0102041:	55                   	push   %ebp
+c0102042:	89 e5                	mov    %esp,%ebp
+c0102044:	83 ec 18             	sub    $0x18,%esp
     cprintf("%d ticks\n",TICK_NUM);
-c01020d6:	83 ec 08             	sub    $0x8,%esp
-c01020d9:	6a 64                	push   $0x64
-c01020db:	68 e0 87 10 c0       	push   $0xc01087e0
-c01020e0:	e8 9d e1 ff ff       	call   c0100282 <cprintf>
-c01020e5:	83 c4 10             	add    $0x10,%esp
+c0102047:	c7 44 24 04 64 00 00 	movl   $0x64,0x4(%esp)
+c010204e:	00 
+c010204f:	c7 04 24 00 8f 10 c0 	movl   $0xc0108f00,(%esp)
+c0102056:	e8 46 e2 ff ff       	call   c01002a1 <cprintf>
 #ifdef DEBUG_GRADE
     cprintf("End of Test.\n");
-c01020e8:	83 ec 0c             	sub    $0xc,%esp
-c01020eb:	68 ea 87 10 c0       	push   $0xc01087ea
-c01020f0:	e8 8d e1 ff ff       	call   c0100282 <cprintf>
-c01020f5:	83 c4 10             	add    $0x10,%esp
+c010205b:	c7 04 24 0a 8f 10 c0 	movl   $0xc0108f0a,(%esp)
+c0102062:	e8 3a e2 ff ff       	call   c01002a1 <cprintf>
     panic("EOT: kernel seems ok.");
-c01020f8:	83 ec 04             	sub    $0x4,%esp
-c01020fb:	68 f8 87 10 c0       	push   $0xc01087f8
-c0102100:	6a 14                	push   $0x14
-c0102102:	68 0e 88 10 c0       	push   $0xc010880e
-c0102107:	e8 dc e2 ff ff       	call   c01003e8 <__panic>
+c0102067:	c7 44 24 08 18 8f 10 	movl   $0xc0108f18,0x8(%esp)
+c010206e:	c0 
+c010206f:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
+c0102076:	00 
+c0102077:	c7 04 24 2e 8f 10 c0 	movl   $0xc0108f2e,(%esp)
+c010207e:	e8 75 e3 ff ff       	call   c01003f8 <__panic>
 
-c010210c <idt_init>:
+c0102083 <idt_init>:
     sizeof(idt) - 1, (uintptr_t)idt
 };
 
 /* idt_init - initialize IDT to each of the entry points in kern/trap/vectors.S */
 void
 idt_init(void) {
-c010210c:	55                   	push   %ebp
-c010210d:	89 e5                	mov    %esp,%ebp
-c010210f:	83 ec 10             	sub    $0x10,%esp
-      *     You don't know the meaning of this instruction? just google it! and check the libs/x86.h to know more.
-      *     Notice: the argument of lidt is idt_pd. try to find it!
-      */
-    extern uintptr_t __vectors[];
-    int i;
-    for (i = 0; i < sizeof(idt) / sizeof(struct gatedesc); i ++) {
-c0102112:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
-c0102119:	e9 c3 00 00 00       	jmp    c01021e1 <idt_init+0xd5>
-        SETGATE(idt[i], 0, GD_KTEXT, __vectors[i], DPL_KERNEL);
-c010211e:	8b 45 fc             	mov    -0x4(%ebp),%eax
-c0102121:	8b 04 85 e0 f5 11 c0 	mov    -0x3fee0a20(,%eax,4),%eax
-c0102128:	89 c2                	mov    %eax,%edx
-c010212a:	8b 45 fc             	mov    -0x4(%ebp),%eax
-c010212d:	66 89 14 c5 60 27 12 	mov    %dx,-0x3fedd8a0(,%eax,8)
-c0102134:	c0 
-c0102135:	8b 45 fc             	mov    -0x4(%ebp),%eax
-c0102138:	66 c7 04 c5 62 27 12 	movw   $0x8,-0x3fedd89e(,%eax,8)
-c010213f:	c0 08 00 
-c0102142:	8b 45 fc             	mov    -0x4(%ebp),%eax
-c0102145:	0f b6 14 c5 64 27 12 	movzbl -0x3fedd89c(,%eax,8),%edx
-c010214c:	c0 
-c010214d:	83 e2 e0             	and    $0xffffffe0,%edx
-c0102150:	88 14 c5 64 27 12 c0 	mov    %dl,-0x3fedd89c(,%eax,8)
-c0102157:	8b 45 fc             	mov    -0x4(%ebp),%eax
-c010215a:	0f b6 14 c5 64 27 12 	movzbl -0x3fedd89c(,%eax,8),%edx
-c0102161:	c0 
-c0102162:	83 e2 1f             	and    $0x1f,%edx
-c0102165:	88 14 c5 64 27 12 c0 	mov    %dl,-0x3fedd89c(,%eax,8)
-c010216c:	8b 45 fc             	mov    -0x4(%ebp),%eax
-c010216f:	0f b6 14 c5 65 27 12 	movzbl -0x3fedd89b(,%eax,8),%edx
-c0102176:	c0 
-c0102177:	83 e2 f0             	and    $0xfffffff0,%edx
-c010217a:	83 ca 0e             	or     $0xe,%edx
-c010217d:	88 14 c5 65 27 12 c0 	mov    %dl,-0x3fedd89b(,%eax,8)
-c0102184:	8b 45 fc             	mov    -0x4(%ebp),%eax
-c0102187:	0f b6 14 c5 65 27 12 	movzbl -0x3fedd89b(,%eax,8),%edx
-c010218e:	c0 
-c010218f:	83 e2 ef             	and    $0xffffffef,%edx
-c0102192:	88 14 c5 65 27 12 c0 	mov    %dl,-0x3fedd89b(,%eax,8)
-c0102199:	8b 45 fc             	mov    -0x4(%ebp),%eax
-c010219c:	0f b6 14 c5 65 27 12 	movzbl -0x3fedd89b(,%eax,8),%edx
-c01021a3:	c0 
-c01021a4:	83 e2 9f             	and    $0xffffff9f,%edx
-c01021a7:	88 14 c5 65 27 12 c0 	mov    %dl,-0x3fedd89b(,%eax,8)
-c01021ae:	8b 45 fc             	mov    -0x4(%ebp),%eax
-c01021b1:	0f b6 14 c5 65 27 12 	movzbl -0x3fedd89b(,%eax,8),%edx
-c01021b8:	c0 
-c01021b9:	83 ca 80             	or     $0xffffff80,%edx
-c01021bc:	88 14 c5 65 27 12 c0 	mov    %dl,-0x3fedd89b(,%eax,8)
-c01021c3:	8b 45 fc             	mov    -0x4(%ebp),%eax
-c01021c6:	8b 04 85 e0 f5 11 c0 	mov    -0x3fee0a20(,%eax,4),%eax
-c01021cd:	c1 e8 10             	shr    $0x10,%eax
-c01021d0:	89 c2                	mov    %eax,%edx
-c01021d2:	8b 45 fc             	mov    -0x4(%ebp),%eax
-c01021d5:	66 89 14 c5 66 27 12 	mov    %dx,-0x3fedd89a(,%eax,8)
-c01021dc:	c0 
+c0102083:	55                   	push   %ebp
+c0102084:	89 e5                	mov    %esp,%ebp
+      *     Can you see idt[256] in this file? Yes, it's IDT! you can use SETGATE macro to setup each item of IDT
+      * (3) After setup the contents of IDT, you will let CPU know where is the IDT by using 'lidt' instruction.
       *     You don't know the meaning of this instruction? just google it! and check the libs/x86.h to know more.
       *     Notice: the argument of lidt is idt_pd. try to find it!
       */
-    extern uintptr_t __vectors[];
-    int i;
-    for (i = 0; i < sizeof(idt) / sizeof(struct gatedesc); i ++) {
-c01021dd:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
-c01021e1:	8b 45 fc             	mov    -0x4(%ebp),%eax
-c01021e4:	3d ff 00 00 00       	cmp    $0xff,%eax
-c01021e9:	0f 86 2f ff ff ff    	jbe    c010211e <idt_init+0x12>
-c01021ef:	c7 45 f8 60 f5 11 c0 	movl   $0xc011f560,-0x8(%ebp)
-    }
-}
-
-static inline void
-lidt(struct pseudodesc *pd) {
-    asm volatile ("lidt (%0)" :: "r" (pd) : "memory");
-c01021f6:	8b 45 f8             	mov    -0x8(%ebp),%eax
-c01021f9:	0f 01 18             	lidtl  (%eax)
-        SETGATE(idt[i], 0, GD_KTEXT, __vectors[i], DPL_KERNEL);
-    }
-    lidt(&idt_pd);
 }
-c01021fc:	90                   	nop
-c01021fd:	c9                   	leave  
-c01021fe:	c3                   	ret    
+c0102086:	90                   	nop
+c0102087:	5d                   	pop    %ebp
+c0102088:	c3                   	ret    
 
-c01021ff <trapname>:
+c0102089 <trapname>:
 
 static const char *
 trapname(int trapno) {
-c01021ff:	55                   	push   %ebp
-c0102200:	89 e5                	mov    %esp,%ebp
+c0102089:	55                   	push   %ebp
+c010208a:	89 e5                	mov    %esp,%ebp
         "Alignment Check",
         "Machine-Check",
         "SIMD Floating-Point Exception"
     };
 
     if (trapno < sizeof(excnames)/sizeof(const char * const)) {
-c0102202:	8b 45 08             	mov    0x8(%ebp),%eax
-c0102205:	83 f8 13             	cmp    $0x13,%eax
-c0102208:	77 0c                	ja     c0102216 <trapname+0x17>
+c010208c:	8b 45 08             	mov    0x8(%ebp),%eax
+c010208f:	83 f8 13             	cmp    $0x13,%eax
+c0102092:	77 0c                	ja     c01020a0 <trapname+0x17>
         return excnames[trapno];
-c010220a:	8b 45 08             	mov    0x8(%ebp),%eax
-c010220d:	8b 04 85 e0 8b 10 c0 	mov    -0x3fef7420(,%eax,4),%eax
-c0102214:	eb 18                	jmp    c010222e <trapname+0x2f>
+c0102094:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102097:	8b 04 85 00 93 10 c0 	mov    -0x3fef6d00(,%eax,4),%eax
+c010209e:	eb 18                	jmp    c01020b8 <trapname+0x2f>
     }
     if (trapno >= IRQ_OFFSET && trapno < IRQ_OFFSET + 16) {
-c0102216:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
-c010221a:	7e 0d                	jle    c0102229 <trapname+0x2a>
-c010221c:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
-c0102220:	7f 07                	jg     c0102229 <trapname+0x2a>
+c01020a0:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
+c01020a4:	7e 0d                	jle    c01020b3 <trapname+0x2a>
+c01020a6:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
+c01020aa:	7f 07                	jg     c01020b3 <trapname+0x2a>
         return "Hardware Interrupt";
-c0102222:	b8 1f 88 10 c0       	mov    $0xc010881f,%eax
-c0102227:	eb 05                	jmp    c010222e <trapname+0x2f>
+c01020ac:	b8 3f 8f 10 c0       	mov    $0xc0108f3f,%eax
+c01020b1:	eb 05                	jmp    c01020b8 <trapname+0x2f>
     }
     return "(unknown trap)";
-c0102229:	b8 32 88 10 c0       	mov    $0xc0108832,%eax
+c01020b3:	b8 52 8f 10 c0       	mov    $0xc0108f52,%eax
 }
-c010222e:	5d                   	pop    %ebp
-c010222f:	c3                   	ret    
+c01020b8:	5d                   	pop    %ebp
+c01020b9:	c3                   	ret    
 
-c0102230 <trap_in_kernel>:
+c01020ba <trap_in_kernel>:
 
 /* trap_in_kernel - test if trap happened in kernel */
 bool
 trap_in_kernel(struct trapframe *tf) {
-c0102230:	55                   	push   %ebp
-c0102231:	89 e5                	mov    %esp,%ebp
+c01020ba:	55                   	push   %ebp
+c01020bb:	89 e5                	mov    %esp,%ebp
     return (tf->tf_cs == (uint16_t)KERNEL_CS);
-c0102233:	8b 45 08             	mov    0x8(%ebp),%eax
-c0102236:	0f b7 40 3c          	movzwl 0x3c(%eax),%eax
-c010223a:	66 83 f8 08          	cmp    $0x8,%ax
-c010223e:	0f 94 c0             	sete   %al
-c0102241:	0f b6 c0             	movzbl %al,%eax
+c01020bd:	8b 45 08             	mov    0x8(%ebp),%eax
+c01020c0:	0f b7 40 3c          	movzwl 0x3c(%eax),%eax
+c01020c4:	83 f8 08             	cmp    $0x8,%eax
+c01020c7:	0f 94 c0             	sete   %al
+c01020ca:	0f b6 c0             	movzbl %al,%eax
 }
-c0102244:	5d                   	pop    %ebp
-c0102245:	c3                   	ret    
+c01020cd:	5d                   	pop    %ebp
+c01020ce:	c3                   	ret    
 
-c0102246 <print_trapframe>:
+c01020cf <print_trapframe>:
     "TF", "IF", "DF", "OF", NULL, NULL, "NT", NULL,
     "RF", "VM", "AC", "VIF", "VIP", "ID", NULL, NULL,
 };
 
 void
 print_trapframe(struct trapframe *tf) {
-c0102246:	55                   	push   %ebp
-c0102247:	89 e5                	mov    %esp,%ebp
-c0102249:	83 ec 18             	sub    $0x18,%esp
+c01020cf:	55                   	push   %ebp
+c01020d0:	89 e5                	mov    %esp,%ebp
+c01020d2:	83 ec 28             	sub    $0x28,%esp
     cprintf("trapframe at %p\n", tf);
-c010224c:	83 ec 08             	sub    $0x8,%esp
-c010224f:	ff 75 08             	pushl  0x8(%ebp)
-c0102252:	68 73 88 10 c0       	push   $0xc0108873
-c0102257:	e8 26 e0 ff ff       	call   c0100282 <cprintf>
-c010225c:	83 c4 10             	add    $0x10,%esp
+c01020d5:	8b 45 08             	mov    0x8(%ebp),%eax
+c01020d8:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01020dc:	c7 04 24 93 8f 10 c0 	movl   $0xc0108f93,(%esp)
+c01020e3:	e8 b9 e1 ff ff       	call   c01002a1 <cprintf>
     print_regs(&tf->tf_regs);
-c010225f:	8b 45 08             	mov    0x8(%ebp),%eax
-c0102262:	83 ec 0c             	sub    $0xc,%esp
-c0102265:	50                   	push   %eax
-c0102266:	e8 b8 01 00 00       	call   c0102423 <print_regs>
-c010226b:	83 c4 10             	add    $0x10,%esp
+c01020e8:	8b 45 08             	mov    0x8(%ebp),%eax
+c01020eb:	89 04 24             	mov    %eax,(%esp)
+c01020ee:	e8 91 01 00 00       	call   c0102284 <print_regs>
     cprintf("  ds   0x----%04x\n", tf->tf_ds);
-c010226e:	8b 45 08             	mov    0x8(%ebp),%eax
-c0102271:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
-c0102275:	0f b7 c0             	movzwl %ax,%eax
-c0102278:	83 ec 08             	sub    $0x8,%esp
-c010227b:	50                   	push   %eax
-c010227c:	68 84 88 10 c0       	push   $0xc0108884
-c0102281:	e8 fc df ff ff       	call   c0100282 <cprintf>
-c0102286:	83 c4 10             	add    $0x10,%esp
+c01020f3:	8b 45 08             	mov    0x8(%ebp),%eax
+c01020f6:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
+c01020fa:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01020fe:	c7 04 24 a4 8f 10 c0 	movl   $0xc0108fa4,(%esp)
+c0102105:	e8 97 e1 ff ff       	call   c01002a1 <cprintf>
     cprintf("  es   0x----%04x\n", tf->tf_es);
-c0102289:	8b 45 08             	mov    0x8(%ebp),%eax
-c010228c:	0f b7 40 28          	movzwl 0x28(%eax),%eax
-c0102290:	0f b7 c0             	movzwl %ax,%eax
-c0102293:	83 ec 08             	sub    $0x8,%esp
-c0102296:	50                   	push   %eax
-c0102297:	68 97 88 10 c0       	push   $0xc0108897
-c010229c:	e8 e1 df ff ff       	call   c0100282 <cprintf>
-c01022a1:	83 c4 10             	add    $0x10,%esp
+c010210a:	8b 45 08             	mov    0x8(%ebp),%eax
+c010210d:	0f b7 40 28          	movzwl 0x28(%eax),%eax
+c0102111:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0102115:	c7 04 24 b7 8f 10 c0 	movl   $0xc0108fb7,(%esp)
+c010211c:	e8 80 e1 ff ff       	call   c01002a1 <cprintf>
     cprintf("  fs   0x----%04x\n", tf->tf_fs);
-c01022a4:	8b 45 08             	mov    0x8(%ebp),%eax
-c01022a7:	0f b7 40 24          	movzwl 0x24(%eax),%eax
-c01022ab:	0f b7 c0             	movzwl %ax,%eax
-c01022ae:	83 ec 08             	sub    $0x8,%esp
-c01022b1:	50                   	push   %eax
-c01022b2:	68 aa 88 10 c0       	push   $0xc01088aa
-c01022b7:	e8 c6 df ff ff       	call   c0100282 <cprintf>
-c01022bc:	83 c4 10             	add    $0x10,%esp
+c0102121:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102124:	0f b7 40 24          	movzwl 0x24(%eax),%eax
+c0102128:	89 44 24 04          	mov    %eax,0x4(%esp)
+c010212c:	c7 04 24 ca 8f 10 c0 	movl   $0xc0108fca,(%esp)
+c0102133:	e8 69 e1 ff ff       	call   c01002a1 <cprintf>
     cprintf("  gs   0x----%04x\n", tf->tf_gs);
-c01022bf:	8b 45 08             	mov    0x8(%ebp),%eax
-c01022c2:	0f b7 40 20          	movzwl 0x20(%eax),%eax
-c01022c6:	0f b7 c0             	movzwl %ax,%eax
-c01022c9:	83 ec 08             	sub    $0x8,%esp
-c01022cc:	50                   	push   %eax
-c01022cd:	68 bd 88 10 c0       	push   $0xc01088bd
-c01022d2:	e8 ab df ff ff       	call   c0100282 <cprintf>
-c01022d7:	83 c4 10             	add    $0x10,%esp
+c0102138:	8b 45 08             	mov    0x8(%ebp),%eax
+c010213b:	0f b7 40 20          	movzwl 0x20(%eax),%eax
+c010213f:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0102143:	c7 04 24 dd 8f 10 c0 	movl   $0xc0108fdd,(%esp)
+c010214a:	e8 52 e1 ff ff       	call   c01002a1 <cprintf>
     cprintf("  trap 0x%08x %s\n", tf->tf_trapno, trapname(tf->tf_trapno));
-c01022da:	8b 45 08             	mov    0x8(%ebp),%eax
-c01022dd:	8b 40 30             	mov    0x30(%eax),%eax
-c01022e0:	83 ec 0c             	sub    $0xc,%esp
-c01022e3:	50                   	push   %eax
-c01022e4:	e8 16 ff ff ff       	call   c01021ff <trapname>
-c01022e9:	83 c4 10             	add    $0x10,%esp
-c01022ec:	89 c2                	mov    %eax,%edx
-c01022ee:	8b 45 08             	mov    0x8(%ebp),%eax
-c01022f1:	8b 40 30             	mov    0x30(%eax),%eax
-c01022f4:	83 ec 04             	sub    $0x4,%esp
-c01022f7:	52                   	push   %edx
-c01022f8:	50                   	push   %eax
-c01022f9:	68 d0 88 10 c0       	push   $0xc01088d0
-c01022fe:	e8 7f df ff ff       	call   c0100282 <cprintf>
-c0102303:	83 c4 10             	add    $0x10,%esp
+c010214f:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102152:	8b 40 30             	mov    0x30(%eax),%eax
+c0102155:	89 04 24             	mov    %eax,(%esp)
+c0102158:	e8 2c ff ff ff       	call   c0102089 <trapname>
+c010215d:	89 c2                	mov    %eax,%edx
+c010215f:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102162:	8b 40 30             	mov    0x30(%eax),%eax
+c0102165:	89 54 24 08          	mov    %edx,0x8(%esp)
+c0102169:	89 44 24 04          	mov    %eax,0x4(%esp)
+c010216d:	c7 04 24 f0 8f 10 c0 	movl   $0xc0108ff0,(%esp)
+c0102174:	e8 28 e1 ff ff       	call   c01002a1 <cprintf>
     cprintf("  err  0x%08x\n", tf->tf_err);
-c0102306:	8b 45 08             	mov    0x8(%ebp),%eax
-c0102309:	8b 40 34             	mov    0x34(%eax),%eax
-c010230c:	83 ec 08             	sub    $0x8,%esp
-c010230f:	50                   	push   %eax
-c0102310:	68 e2 88 10 c0       	push   $0xc01088e2
-c0102315:	e8 68 df ff ff       	call   c0100282 <cprintf>
-c010231a:	83 c4 10             	add    $0x10,%esp
+c0102179:	8b 45 08             	mov    0x8(%ebp),%eax
+c010217c:	8b 40 34             	mov    0x34(%eax),%eax
+c010217f:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0102183:	c7 04 24 02 90 10 c0 	movl   $0xc0109002,(%esp)
+c010218a:	e8 12 e1 ff ff       	call   c01002a1 <cprintf>
     cprintf("  eip  0x%08x\n", tf->tf_eip);
-c010231d:	8b 45 08             	mov    0x8(%ebp),%eax
-c0102320:	8b 40 38             	mov    0x38(%eax),%eax
-c0102323:	83 ec 08             	sub    $0x8,%esp
-c0102326:	50                   	push   %eax
-c0102327:	68 f1 88 10 c0       	push   $0xc01088f1
-c010232c:	e8 51 df ff ff       	call   c0100282 <cprintf>
-c0102331:	83 c4 10             	add    $0x10,%esp
+c010218f:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102192:	8b 40 38             	mov    0x38(%eax),%eax
+c0102195:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0102199:	c7 04 24 11 90 10 c0 	movl   $0xc0109011,(%esp)
+c01021a0:	e8 fc e0 ff ff       	call   c01002a1 <cprintf>
     cprintf("  cs   0x----%04x\n", tf->tf_cs);
-c0102334:	8b 45 08             	mov    0x8(%ebp),%eax
-c0102337:	0f b7 40 3c          	movzwl 0x3c(%eax),%eax
-c010233b:	0f b7 c0             	movzwl %ax,%eax
-c010233e:	83 ec 08             	sub    $0x8,%esp
-c0102341:	50                   	push   %eax
-c0102342:	68 00 89 10 c0       	push   $0xc0108900
-c0102347:	e8 36 df ff ff       	call   c0100282 <cprintf>
-c010234c:	83 c4 10             	add    $0x10,%esp
+c01021a5:	8b 45 08             	mov    0x8(%ebp),%eax
+c01021a8:	0f b7 40 3c          	movzwl 0x3c(%eax),%eax
+c01021ac:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01021b0:	c7 04 24 20 90 10 c0 	movl   $0xc0109020,(%esp)
+c01021b7:	e8 e5 e0 ff ff       	call   c01002a1 <cprintf>
     cprintf("  flag 0x%08x ", tf->tf_eflags);
-c010234f:	8b 45 08             	mov    0x8(%ebp),%eax
-c0102352:	8b 40 40             	mov    0x40(%eax),%eax
-c0102355:	83 ec 08             	sub    $0x8,%esp
-c0102358:	50                   	push   %eax
-c0102359:	68 13 89 10 c0       	push   $0xc0108913
-c010235e:	e8 1f df ff ff       	call   c0100282 <cprintf>
-c0102363:	83 c4 10             	add    $0x10,%esp
+c01021bc:	8b 45 08             	mov    0x8(%ebp),%eax
+c01021bf:	8b 40 40             	mov    0x40(%eax),%eax
+c01021c2:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01021c6:	c7 04 24 33 90 10 c0 	movl   $0xc0109033,(%esp)
+c01021cd:	e8 cf e0 ff ff       	call   c01002a1 <cprintf>
 
     int i, j;
     for (i = 0, j = 1; i < sizeof(IA32flags) / sizeof(IA32flags[0]); i ++, j <<= 1) {
-c0102366:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
-c010236d:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
-c0102374:	eb 3f                	jmp    c01023b5 <print_trapframe+0x16f>
+c01021d2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+c01021d9:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+c01021e0:	eb 3d                	jmp    c010221f <print_trapframe+0x150>
         if ((tf->tf_eflags & j) && IA32flags[i] != NULL) {
-c0102376:	8b 45 08             	mov    0x8(%ebp),%eax
-c0102379:	8b 50 40             	mov    0x40(%eax),%edx
-c010237c:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c010237f:	21 d0                	and    %edx,%eax
-c0102381:	85 c0                	test   %eax,%eax
-c0102383:	74 29                	je     c01023ae <print_trapframe+0x168>
-c0102385:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0102388:	8b 04 85 80 f5 11 c0 	mov    -0x3fee0a80(,%eax,4),%eax
-c010238f:	85 c0                	test   %eax,%eax
-c0102391:	74 1b                	je     c01023ae <print_trapframe+0x168>
+c01021e2:	8b 45 08             	mov    0x8(%ebp),%eax
+c01021e5:	8b 50 40             	mov    0x40(%eax),%edx
+c01021e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01021eb:	21 d0                	and    %edx,%eax
+c01021ed:	85 c0                	test   %eax,%eax
+c01021ef:	74 28                	je     c0102219 <print_trapframe+0x14a>
+c01021f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01021f4:	8b 04 85 80 05 12 c0 	mov    -0x3fedfa80(,%eax,4),%eax
+c01021fb:	85 c0                	test   %eax,%eax
+c01021fd:	74 1a                	je     c0102219 <print_trapframe+0x14a>
             cprintf("%s,", IA32flags[i]);
-c0102393:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0102396:	8b 04 85 80 f5 11 c0 	mov    -0x3fee0a80(,%eax,4),%eax
-c010239d:	83 ec 08             	sub    $0x8,%esp
-c01023a0:	50                   	push   %eax
-c01023a1:	68 22 89 10 c0       	push   $0xc0108922
-c01023a6:	e8 d7 de ff ff       	call   c0100282 <cprintf>
-c01023ab:	83 c4 10             	add    $0x10,%esp
+c01021ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0102202:	8b 04 85 80 05 12 c0 	mov    -0x3fedfa80(,%eax,4),%eax
+c0102209:	89 44 24 04          	mov    %eax,0x4(%esp)
+c010220d:	c7 04 24 42 90 10 c0 	movl   $0xc0109042,(%esp)
+c0102214:	e8 88 e0 ff ff       	call   c01002a1 <cprintf>
     cprintf("  eip  0x%08x\n", tf->tf_eip);
     cprintf("  cs   0x----%04x\n", tf->tf_cs);
     cprintf("  flag 0x%08x ", tf->tf_eflags);
 
     int i, j;
     for (i = 0, j = 1; i < sizeof(IA32flags) / sizeof(IA32flags[0]); i ++, j <<= 1) {
-c01023ae:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
-c01023b2:	d1 65 f0             	shll   -0x10(%ebp)
-c01023b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c01023b8:	83 f8 17             	cmp    $0x17,%eax
-c01023bb:	76 b9                	jbe    c0102376 <print_trapframe+0x130>
+c0102219:	ff 45 f4             	incl   -0xc(%ebp)
+c010221c:	d1 65 f0             	shll   -0x10(%ebp)
+c010221f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0102222:	83 f8 17             	cmp    $0x17,%eax
+c0102225:	76 bb                	jbe    c01021e2 <print_trapframe+0x113>
         if ((tf->tf_eflags & j) && IA32flags[i] != NULL) {
             cprintf("%s,", IA32flags[i]);
         }
     }
     cprintf("IOPL=%d\n", (tf->tf_eflags & FL_IOPL_MASK) >> 12);
-c01023bd:	8b 45 08             	mov    0x8(%ebp),%eax
-c01023c0:	8b 40 40             	mov    0x40(%eax),%eax
-c01023c3:	25 00 30 00 00       	and    $0x3000,%eax
-c01023c8:	c1 e8 0c             	shr    $0xc,%eax
-c01023cb:	83 ec 08             	sub    $0x8,%esp
-c01023ce:	50                   	push   %eax
-c01023cf:	68 26 89 10 c0       	push   $0xc0108926
-c01023d4:	e8 a9 de ff ff       	call   c0100282 <cprintf>
-c01023d9:	83 c4 10             	add    $0x10,%esp
+c0102227:	8b 45 08             	mov    0x8(%ebp),%eax
+c010222a:	8b 40 40             	mov    0x40(%eax),%eax
+c010222d:	25 00 30 00 00       	and    $0x3000,%eax
+c0102232:	c1 e8 0c             	shr    $0xc,%eax
+c0102235:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0102239:	c7 04 24 46 90 10 c0 	movl   $0xc0109046,(%esp)
+c0102240:	e8 5c e0 ff ff       	call   c01002a1 <cprintf>
 
     if (!trap_in_kernel(tf)) {
-c01023dc:	83 ec 0c             	sub    $0xc,%esp
-c01023df:	ff 75 08             	pushl  0x8(%ebp)
-c01023e2:	e8 49 fe ff ff       	call   c0102230 <trap_in_kernel>
-c01023e7:	83 c4 10             	add    $0x10,%esp
-c01023ea:	85 c0                	test   %eax,%eax
-c01023ec:	75 32                	jne    c0102420 <print_trapframe+0x1da>
+c0102245:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102248:	89 04 24             	mov    %eax,(%esp)
+c010224b:	e8 6a fe ff ff       	call   c01020ba <trap_in_kernel>
+c0102250:	85 c0                	test   %eax,%eax
+c0102252:	75 2d                	jne    c0102281 <print_trapframe+0x1b2>
         cprintf("  esp  0x%08x\n", tf->tf_esp);
-c01023ee:	8b 45 08             	mov    0x8(%ebp),%eax
-c01023f1:	8b 40 44             	mov    0x44(%eax),%eax
-c01023f4:	83 ec 08             	sub    $0x8,%esp
-c01023f7:	50                   	push   %eax
-c01023f8:	68 2f 89 10 c0       	push   $0xc010892f
-c01023fd:	e8 80 de ff ff       	call   c0100282 <cprintf>
-c0102402:	83 c4 10             	add    $0x10,%esp
+c0102254:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102257:	8b 40 44             	mov    0x44(%eax),%eax
+c010225a:	89 44 24 04          	mov    %eax,0x4(%esp)
+c010225e:	c7 04 24 4f 90 10 c0 	movl   $0xc010904f,(%esp)
+c0102265:	e8 37 e0 ff ff       	call   c01002a1 <cprintf>
         cprintf("  ss   0x----%04x\n", tf->tf_ss);
-c0102405:	8b 45 08             	mov    0x8(%ebp),%eax
-c0102408:	0f b7 40 48          	movzwl 0x48(%eax),%eax
-c010240c:	0f b7 c0             	movzwl %ax,%eax
-c010240f:	83 ec 08             	sub    $0x8,%esp
-c0102412:	50                   	push   %eax
-c0102413:	68 3e 89 10 c0       	push   $0xc010893e
-c0102418:	e8 65 de ff ff       	call   c0100282 <cprintf>
-c010241d:	83 c4 10             	add    $0x10,%esp
+c010226a:	8b 45 08             	mov    0x8(%ebp),%eax
+c010226d:	0f b7 40 48          	movzwl 0x48(%eax),%eax
+c0102271:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0102275:	c7 04 24 5e 90 10 c0 	movl   $0xc010905e,(%esp)
+c010227c:	e8 20 e0 ff ff       	call   c01002a1 <cprintf>
     }
 }
-c0102420:	90                   	nop
-c0102421:	c9                   	leave  
-c0102422:	c3                   	ret    
+c0102281:	90                   	nop
+c0102282:	c9                   	leave  
+c0102283:	c3                   	ret    
 
-c0102423 <print_regs>:
+c0102284 <print_regs>:
 
 void
 print_regs(struct pushregs *regs) {
-c0102423:	55                   	push   %ebp
-c0102424:	89 e5                	mov    %esp,%ebp
-c0102426:	83 ec 08             	sub    $0x8,%esp
+c0102284:	55                   	push   %ebp
+c0102285:	89 e5                	mov    %esp,%ebp
+c0102287:	83 ec 18             	sub    $0x18,%esp
     cprintf("  edi  0x%08x\n", regs->reg_edi);
-c0102429:	8b 45 08             	mov    0x8(%ebp),%eax
-c010242c:	8b 00                	mov    (%eax),%eax
-c010242e:	83 ec 08             	sub    $0x8,%esp
-c0102431:	50                   	push   %eax
-c0102432:	68 51 89 10 c0       	push   $0xc0108951
-c0102437:	e8 46 de ff ff       	call   c0100282 <cprintf>
-c010243c:	83 c4 10             	add    $0x10,%esp
+c010228a:	8b 45 08             	mov    0x8(%ebp),%eax
+c010228d:	8b 00                	mov    (%eax),%eax
+c010228f:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0102293:	c7 04 24 71 90 10 c0 	movl   $0xc0109071,(%esp)
+c010229a:	e8 02 e0 ff ff       	call   c01002a1 <cprintf>
     cprintf("  esi  0x%08x\n", regs->reg_esi);
-c010243f:	8b 45 08             	mov    0x8(%ebp),%eax
-c0102442:	8b 40 04             	mov    0x4(%eax),%eax
-c0102445:	83 ec 08             	sub    $0x8,%esp
-c0102448:	50                   	push   %eax
-c0102449:	68 60 89 10 c0       	push   $0xc0108960
-c010244e:	e8 2f de ff ff       	call   c0100282 <cprintf>
-c0102453:	83 c4 10             	add    $0x10,%esp
+c010229f:	8b 45 08             	mov    0x8(%ebp),%eax
+c01022a2:	8b 40 04             	mov    0x4(%eax),%eax
+c01022a5:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01022a9:	c7 04 24 80 90 10 c0 	movl   $0xc0109080,(%esp)
+c01022b0:	e8 ec df ff ff       	call   c01002a1 <cprintf>
     cprintf("  ebp  0x%08x\n", regs->reg_ebp);
-c0102456:	8b 45 08             	mov    0x8(%ebp),%eax
-c0102459:	8b 40 08             	mov    0x8(%eax),%eax
-c010245c:	83 ec 08             	sub    $0x8,%esp
-c010245f:	50                   	push   %eax
-c0102460:	68 6f 89 10 c0       	push   $0xc010896f
-c0102465:	e8 18 de ff ff       	call   c0100282 <cprintf>
-c010246a:	83 c4 10             	add    $0x10,%esp
+c01022b5:	8b 45 08             	mov    0x8(%ebp),%eax
+c01022b8:	8b 40 08             	mov    0x8(%eax),%eax
+c01022bb:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01022bf:	c7 04 24 8f 90 10 c0 	movl   $0xc010908f,(%esp)
+c01022c6:	e8 d6 df ff ff       	call   c01002a1 <cprintf>
     cprintf("  oesp 0x%08x\n", regs->reg_oesp);
-c010246d:	8b 45 08             	mov    0x8(%ebp),%eax
-c0102470:	8b 40 0c             	mov    0xc(%eax),%eax
-c0102473:	83 ec 08             	sub    $0x8,%esp
-c0102476:	50                   	push   %eax
-c0102477:	68 7e 89 10 c0       	push   $0xc010897e
-c010247c:	e8 01 de ff ff       	call   c0100282 <cprintf>
-c0102481:	83 c4 10             	add    $0x10,%esp
+c01022cb:	8b 45 08             	mov    0x8(%ebp),%eax
+c01022ce:	8b 40 0c             	mov    0xc(%eax),%eax
+c01022d1:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01022d5:	c7 04 24 9e 90 10 c0 	movl   $0xc010909e,(%esp)
+c01022dc:	e8 c0 df ff ff       	call   c01002a1 <cprintf>
     cprintf("  ebx  0x%08x\n", regs->reg_ebx);
-c0102484:	8b 45 08             	mov    0x8(%ebp),%eax
-c0102487:	8b 40 10             	mov    0x10(%eax),%eax
-c010248a:	83 ec 08             	sub    $0x8,%esp
-c010248d:	50                   	push   %eax
-c010248e:	68 8d 89 10 c0       	push   $0xc010898d
-c0102493:	e8 ea dd ff ff       	call   c0100282 <cprintf>
-c0102498:	83 c4 10             	add    $0x10,%esp
+c01022e1:	8b 45 08             	mov    0x8(%ebp),%eax
+c01022e4:	8b 40 10             	mov    0x10(%eax),%eax
+c01022e7:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01022eb:	c7 04 24 ad 90 10 c0 	movl   $0xc01090ad,(%esp)
+c01022f2:	e8 aa df ff ff       	call   c01002a1 <cprintf>
     cprintf("  edx  0x%08x\n", regs->reg_edx);
-c010249b:	8b 45 08             	mov    0x8(%ebp),%eax
-c010249e:	8b 40 14             	mov    0x14(%eax),%eax
-c01024a1:	83 ec 08             	sub    $0x8,%esp
-c01024a4:	50                   	push   %eax
-c01024a5:	68 9c 89 10 c0       	push   $0xc010899c
-c01024aa:	e8 d3 dd ff ff       	call   c0100282 <cprintf>
-c01024af:	83 c4 10             	add    $0x10,%esp
+c01022f7:	8b 45 08             	mov    0x8(%ebp),%eax
+c01022fa:	8b 40 14             	mov    0x14(%eax),%eax
+c01022fd:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0102301:	c7 04 24 bc 90 10 c0 	movl   $0xc01090bc,(%esp)
+c0102308:	e8 94 df ff ff       	call   c01002a1 <cprintf>
     cprintf("  ecx  0x%08x\n", regs->reg_ecx);
-c01024b2:	8b 45 08             	mov    0x8(%ebp),%eax
-c01024b5:	8b 40 18             	mov    0x18(%eax),%eax
-c01024b8:	83 ec 08             	sub    $0x8,%esp
-c01024bb:	50                   	push   %eax
-c01024bc:	68 ab 89 10 c0       	push   $0xc01089ab
-c01024c1:	e8 bc dd ff ff       	call   c0100282 <cprintf>
-c01024c6:	83 c4 10             	add    $0x10,%esp
+c010230d:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102310:	8b 40 18             	mov    0x18(%eax),%eax
+c0102313:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0102317:	c7 04 24 cb 90 10 c0 	movl   $0xc01090cb,(%esp)
+c010231e:	e8 7e df ff ff       	call   c01002a1 <cprintf>
     cprintf("  eax  0x%08x\n", regs->reg_eax);
-c01024c9:	8b 45 08             	mov    0x8(%ebp),%eax
-c01024cc:	8b 40 1c             	mov    0x1c(%eax),%eax
-c01024cf:	83 ec 08             	sub    $0x8,%esp
-c01024d2:	50                   	push   %eax
-c01024d3:	68 ba 89 10 c0       	push   $0xc01089ba
-c01024d8:	e8 a5 dd ff ff       	call   c0100282 <cprintf>
-c01024dd:	83 c4 10             	add    $0x10,%esp
-}
-c01024e0:	90                   	nop
-c01024e1:	c9                   	leave  
-c01024e2:	c3                   	ret    
+c0102323:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102326:	8b 40 1c             	mov    0x1c(%eax),%eax
+c0102329:	89 44 24 04          	mov    %eax,0x4(%esp)
+c010232d:	c7 04 24 da 90 10 c0 	movl   $0xc01090da,(%esp)
+c0102334:	e8 68 df ff ff       	call   c01002a1 <cprintf>
+}
+c0102339:	90                   	nop
+c010233a:	c9                   	leave  
+c010233b:	c3                   	ret    
 
-c01024e3 <print_pgfault>:
+c010233c <print_pgfault>:
 
 static inline void
 print_pgfault(struct trapframe *tf) {
-c01024e3:	55                   	push   %ebp
-c01024e4:	89 e5                	mov    %esp,%ebp
-c01024e6:	53                   	push   %ebx
-c01024e7:	83 ec 14             	sub    $0x14,%esp
+c010233c:	55                   	push   %ebp
+c010233d:	89 e5                	mov    %esp,%ebp
+c010233f:	53                   	push   %ebx
+c0102340:	83 ec 34             	sub    $0x34,%esp
      * bit 2 == 0 means kernel, 1 means user
      * */
     cprintf("page fault at 0x%08x: %c/%c [%s].\n", rcr2(),
             (tf->tf_err & 4) ? 'U' : 'K',
             (tf->tf_err & 2) ? 'W' : 'R',
             (tf->tf_err & 1) ? "protection fault" : "no page found");
-c01024ea:	8b 45 08             	mov    0x8(%ebp),%eax
-c01024ed:	8b 40 34             	mov    0x34(%eax),%eax
-c01024f0:	83 e0 01             	and    $0x1,%eax
+c0102343:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102346:	8b 40 34             	mov    0x34(%eax),%eax
+c0102349:	83 e0 01             	and    $0x1,%eax
     /* error_code:
      * bit 0 == 0 means no page found, 1 means protection fault
      * bit 1 == 0 means read, 1 means write
      * bit 2 == 0 means kernel, 1 means user
      * */
     cprintf("page fault at 0x%08x: %c/%c [%s].\n", rcr2(),
-c01024f3:	85 c0                	test   %eax,%eax
-c01024f5:	74 07                	je     c01024fe <print_pgfault+0x1b>
-c01024f7:	bb c9 89 10 c0       	mov    $0xc01089c9,%ebx
-c01024fc:	eb 05                	jmp    c0102503 <print_pgfault+0x20>
-c01024fe:	bb da 89 10 c0       	mov    $0xc01089da,%ebx
+c010234c:	85 c0                	test   %eax,%eax
+c010234e:	74 07                	je     c0102357 <print_pgfault+0x1b>
+c0102350:	bb e9 90 10 c0       	mov    $0xc01090e9,%ebx
+c0102355:	eb 05                	jmp    c010235c <print_pgfault+0x20>
+c0102357:	bb fa 90 10 c0       	mov    $0xc01090fa,%ebx
             (tf->tf_err & 4) ? 'U' : 'K',
             (tf->tf_err & 2) ? 'W' : 'R',
-c0102503:	8b 45 08             	mov    0x8(%ebp),%eax
-c0102506:	8b 40 34             	mov    0x34(%eax),%eax
-c0102509:	83 e0 02             	and    $0x2,%eax
+c010235c:	8b 45 08             	mov    0x8(%ebp),%eax
+c010235f:	8b 40 34             	mov    0x34(%eax),%eax
+c0102362:	83 e0 02             	and    $0x2,%eax
     /* error_code:
      * bit 0 == 0 means no page found, 1 means protection fault
      * bit 1 == 0 means read, 1 means write
      * bit 2 == 0 means kernel, 1 means user
      * */
     cprintf("page fault at 0x%08x: %c/%c [%s].\n", rcr2(),
-c010250c:	85 c0                	test   %eax,%eax
-c010250e:	74 07                	je     c0102517 <print_pgfault+0x34>
-c0102510:	b9 57 00 00 00       	mov    $0x57,%ecx
-c0102515:	eb 05                	jmp    c010251c <print_pgfault+0x39>
-c0102517:	b9 52 00 00 00       	mov    $0x52,%ecx
+c0102365:	85 c0                	test   %eax,%eax
+c0102367:	74 07                	je     c0102370 <print_pgfault+0x34>
+c0102369:	b9 57 00 00 00       	mov    $0x57,%ecx
+c010236e:	eb 05                	jmp    c0102375 <print_pgfault+0x39>
+c0102370:	b9 52 00 00 00       	mov    $0x52,%ecx
             (tf->tf_err & 4) ? 'U' : 'K',
-c010251c:	8b 45 08             	mov    0x8(%ebp),%eax
-c010251f:	8b 40 34             	mov    0x34(%eax),%eax
-c0102522:	83 e0 04             	and    $0x4,%eax
+c0102375:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102378:	8b 40 34             	mov    0x34(%eax),%eax
+c010237b:	83 e0 04             	and    $0x4,%eax
     /* error_code:
      * bit 0 == 0 means no page found, 1 means protection fault
      * bit 1 == 0 means read, 1 means write
      * bit 2 == 0 means kernel, 1 means user
      * */
     cprintf("page fault at 0x%08x: %c/%c [%s].\n", rcr2(),
-c0102525:	85 c0                	test   %eax,%eax
-c0102527:	74 07                	je     c0102530 <print_pgfault+0x4d>
-c0102529:	ba 55 00 00 00       	mov    $0x55,%edx
-c010252e:	eb 05                	jmp    c0102535 <print_pgfault+0x52>
-c0102530:	ba 4b 00 00 00       	mov    $0x4b,%edx
+c010237e:	85 c0                	test   %eax,%eax
+c0102380:	74 07                	je     c0102389 <print_pgfault+0x4d>
+c0102382:	ba 55 00 00 00       	mov    $0x55,%edx
+c0102387:	eb 05                	jmp    c010238e <print_pgfault+0x52>
+c0102389:	ba 4b 00 00 00       	mov    $0x4b,%edx
 }
 
 static inline uintptr_t
 rcr2(void) {
     uintptr_t cr2;
     asm volatile ("mov %%cr2, %0" : "=r" (cr2) :: "memory");
-c0102535:	0f 20 d0             	mov    %cr2,%eax
-c0102538:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c010238e:	0f 20 d0             	mov    %cr2,%eax
+c0102391:	89 45 f4             	mov    %eax,-0xc(%ebp)
     return cr2;
-c010253b:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c010253e:	83 ec 0c             	sub    $0xc,%esp
-c0102541:	53                   	push   %ebx
-c0102542:	51                   	push   %ecx
-c0102543:	52                   	push   %edx
-c0102544:	50                   	push   %eax
-c0102545:	68 e8 89 10 c0       	push   $0xc01089e8
-c010254a:	e8 33 dd ff ff       	call   c0100282 <cprintf>
-c010254f:	83 c4 20             	add    $0x20,%esp
+c0102394:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0102397:	89 5c 24 10          	mov    %ebx,0x10(%esp)
+c010239b:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
+c010239f:	89 54 24 08          	mov    %edx,0x8(%esp)
+c01023a3:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01023a7:	c7 04 24 08 91 10 c0 	movl   $0xc0109108,(%esp)
+c01023ae:	e8 ee de ff ff       	call   c01002a1 <cprintf>
             (tf->tf_err & 4) ? 'U' : 'K',
             (tf->tf_err & 2) ? 'W' : 'R',
             (tf->tf_err & 1) ? "protection fault" : "no page found");
 }
-c0102552:	90                   	nop
-c0102553:	8b 5d fc             	mov    -0x4(%ebp),%ebx
-c0102556:	c9                   	leave  
-c0102557:	c3                   	ret    
+c01023b3:	90                   	nop
+c01023b4:	83 c4 34             	add    $0x34,%esp
+c01023b7:	5b                   	pop    %ebx
+c01023b8:	5d                   	pop    %ebp
+c01023b9:	c3                   	ret    
 
-c0102558 <pgfault_handler>:
+c01023ba <pgfault_handler>:
 
 static int
 pgfault_handler(struct trapframe *tf) {
-c0102558:	55                   	push   %ebp
-c0102559:	89 e5                	mov    %esp,%ebp
-c010255b:	83 ec 18             	sub    $0x18,%esp
+c01023ba:	55                   	push   %ebp
+c01023bb:	89 e5                	mov    %esp,%ebp
+c01023bd:	83 ec 28             	sub    $0x28,%esp
     extern struct mm_struct *check_mm_struct;
     print_pgfault(tf);
-c010255e:	83 ec 0c             	sub    $0xc,%esp
-c0102561:	ff 75 08             	pushl  0x8(%ebp)
-c0102564:	e8 7a ff ff ff       	call   c01024e3 <print_pgfault>
-c0102569:	83 c4 10             	add    $0x10,%esp
+c01023c0:	8b 45 08             	mov    0x8(%ebp),%eax
+c01023c3:	89 04 24             	mov    %eax,(%esp)
+c01023c6:	e8 71 ff ff ff       	call   c010233c <print_pgfault>
     if (check_mm_struct != NULL) {
-c010256c:	a1 2c 30 12 c0       	mov    0xc012302c,%eax
-c0102571:	85 c0                	test   %eax,%eax
-c0102573:	74 24                	je     c0102599 <pgfault_handler+0x41>
+c01023cb:	a1 2c 40 12 c0       	mov    0xc012402c,%eax
+c01023d0:	85 c0                	test   %eax,%eax
+c01023d2:	74 26                	je     c01023fa <pgfault_handler+0x40>
 }
 
 static inline uintptr_t
 rcr2(void) {
     uintptr_t cr2;
     asm volatile ("mov %%cr2, %0" : "=r" (cr2) :: "memory");
-c0102575:	0f 20 d0             	mov    %cr2,%eax
-c0102578:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c01023d4:	0f 20 d0             	mov    %cr2,%eax
+c01023d7:	89 45 f4             	mov    %eax,-0xc(%ebp)
     return cr2;
-c010257b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
+c01023da:	8b 4d f4             	mov    -0xc(%ebp),%ecx
         return do_pgfault(check_mm_struct, tf->tf_err, rcr2());
-c010257e:	8b 45 08             	mov    0x8(%ebp),%eax
-c0102581:	8b 50 34             	mov    0x34(%eax),%edx
-c0102584:	a1 2c 30 12 c0       	mov    0xc012302c,%eax
-c0102589:	83 ec 04             	sub    $0x4,%esp
-c010258c:	51                   	push   %ecx
-c010258d:	52                   	push   %edx
-c010258e:	50                   	push   %eax
-c010258f:	e8 f7 2f 00 00       	call   c010558b <do_pgfault>
-c0102594:	83 c4 10             	add    $0x10,%esp
-c0102597:	eb 17                	jmp    c01025b0 <pgfault_handler+0x58>
+c01023dd:	8b 45 08             	mov    0x8(%ebp),%eax
+c01023e0:	8b 50 34             	mov    0x34(%eax),%edx
+c01023e3:	a1 2c 40 12 c0       	mov    0xc012402c,%eax
+c01023e8:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+c01023ec:	89 54 24 04          	mov    %edx,0x4(%esp)
+c01023f0:	89 04 24             	mov    %eax,(%esp)
+c01023f3:	e8 e1 33 00 00       	call   c01057d9 <do_pgfault>
+c01023f8:	eb 1c                	jmp    c0102416 <pgfault_handler+0x5c>
     }
     panic("unhandled page fault.\n");
-c0102599:	83 ec 04             	sub    $0x4,%esp
-c010259c:	68 0b 8a 10 c0       	push   $0xc0108a0b
-c01025a1:	68 a5 00 00 00       	push   $0xa5
-c01025a6:	68 0e 88 10 c0       	push   $0xc010880e
-c01025ab:	e8 38 de ff ff       	call   c01003e8 <__panic>
+c01023fa:	c7 44 24 08 2b 91 10 	movl   $0xc010912b,0x8(%esp)
+c0102401:	c0 
+c0102402:	c7 44 24 04 9f 00 00 	movl   $0x9f,0x4(%esp)
+c0102409:	00 
+c010240a:	c7 04 24 2e 8f 10 c0 	movl   $0xc0108f2e,(%esp)
+c0102411:	e8 e2 df ff ff       	call   c01003f8 <__panic>
 }
-c01025b0:	c9                   	leave  
-c01025b1:	c3                   	ret    
+c0102416:	c9                   	leave  
+c0102417:	c3                   	ret    
 
-c01025b2 <trap_dispatch>:
+c0102418 <trap_dispatch>:
 
 static volatile int in_swap_tick_event = 0;
 extern struct mm_struct *check_mm_struct;
 
 static void
 trap_dispatch(struct trapframe *tf) {
-c01025b2:	55                   	push   %ebp
-c01025b3:	89 e5                	mov    %esp,%ebp
-c01025b5:	83 ec 18             	sub    $0x18,%esp
+c0102418:	55                   	push   %ebp
+c0102419:	89 e5                	mov    %esp,%ebp
+c010241b:	83 ec 28             	sub    $0x28,%esp
     char c;
 
     int ret;
 
     switch (tf->tf_trapno) {
-c01025b8:	8b 45 08             	mov    0x8(%ebp),%eax
-c01025bb:	8b 40 30             	mov    0x30(%eax),%eax
-c01025be:	83 f8 24             	cmp    $0x24,%eax
-c01025c1:	0f 84 ba 00 00 00    	je     c0102681 <trap_dispatch+0xcf>
-c01025c7:	83 f8 24             	cmp    $0x24,%eax
-c01025ca:	77 18                	ja     c01025e4 <trap_dispatch+0x32>
-c01025cc:	83 f8 20             	cmp    $0x20,%eax
-c01025cf:	74 76                	je     c0102647 <trap_dispatch+0x95>
-c01025d1:	83 f8 21             	cmp    $0x21,%eax
-c01025d4:	0f 84 cb 00 00 00    	je     c01026a5 <trap_dispatch+0xf3>
-c01025da:	83 f8 0e             	cmp    $0xe,%eax
-c01025dd:	74 28                	je     c0102607 <trap_dispatch+0x55>
-c01025df:	e9 fc 00 00 00       	jmp    c01026e0 <trap_dispatch+0x12e>
-c01025e4:	83 f8 2e             	cmp    $0x2e,%eax
-c01025e7:	0f 82 f3 00 00 00    	jb     c01026e0 <trap_dispatch+0x12e>
-c01025ed:	83 f8 2f             	cmp    $0x2f,%eax
-c01025f0:	0f 86 20 01 00 00    	jbe    c0102716 <trap_dispatch+0x164>
-c01025f6:	83 e8 78             	sub    $0x78,%eax
-c01025f9:	83 f8 01             	cmp    $0x1,%eax
-c01025fc:	0f 87 de 00 00 00    	ja     c01026e0 <trap_dispatch+0x12e>
-c0102602:	e9 c2 00 00 00       	jmp    c01026c9 <trap_dispatch+0x117>
+c010241e:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102421:	8b 40 30             	mov    0x30(%eax),%eax
+c0102424:	83 f8 24             	cmp    $0x24,%eax
+c0102427:	0f 84 8a 00 00 00    	je     c01024b7 <trap_dispatch+0x9f>
+c010242d:	83 f8 24             	cmp    $0x24,%eax
+c0102430:	77 1c                	ja     c010244e <trap_dispatch+0x36>
+c0102432:	83 f8 20             	cmp    $0x20,%eax
+c0102435:	0f 84 19 01 00 00    	je     c0102554 <trap_dispatch+0x13c>
+c010243b:	83 f8 21             	cmp    $0x21,%eax
+c010243e:	0f 84 99 00 00 00    	je     c01024dd <trap_dispatch+0xc5>
+c0102444:	83 f8 0e             	cmp    $0xe,%eax
+c0102447:	74 28                	je     c0102471 <trap_dispatch+0x59>
+c0102449:	e9 d1 00 00 00       	jmp    c010251f <trap_dispatch+0x107>
+c010244e:	83 f8 2e             	cmp    $0x2e,%eax
+c0102451:	0f 82 c8 00 00 00    	jb     c010251f <trap_dispatch+0x107>
+c0102457:	83 f8 2f             	cmp    $0x2f,%eax
+c010245a:	0f 86 f7 00 00 00    	jbe    c0102557 <trap_dispatch+0x13f>
+c0102460:	83 e8 78             	sub    $0x78,%eax
+c0102463:	83 f8 01             	cmp    $0x1,%eax
+c0102466:	0f 87 b3 00 00 00    	ja     c010251f <trap_dispatch+0x107>
+c010246c:	e9 92 00 00 00       	jmp    c0102503 <trap_dispatch+0xeb>
     case T_PGFLT:  //page fault
         if ((ret = pgfault_handler(tf)) != 0) {
-c0102607:	83 ec 0c             	sub    $0xc,%esp
-c010260a:	ff 75 08             	pushl  0x8(%ebp)
-c010260d:	e8 46 ff ff ff       	call   c0102558 <pgfault_handler>
-c0102612:	83 c4 10             	add    $0x10,%esp
-c0102615:	89 45 f4             	mov    %eax,-0xc(%ebp)
-c0102618:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
-c010261c:	0f 84 f7 00 00 00    	je     c0102719 <trap_dispatch+0x167>
+c0102471:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102474:	89 04 24             	mov    %eax,(%esp)
+c0102477:	e8 3e ff ff ff       	call   c01023ba <pgfault_handler>
+c010247c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c010247f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0102483:	0f 84 d1 00 00 00    	je     c010255a <trap_dispatch+0x142>
             print_trapframe(tf);
-c0102622:	83 ec 0c             	sub    $0xc,%esp
-c0102625:	ff 75 08             	pushl  0x8(%ebp)
-c0102628:	e8 19 fc ff ff       	call   c0102246 <print_trapframe>
-c010262d:	83 c4 10             	add    $0x10,%esp
+c0102489:	8b 45 08             	mov    0x8(%ebp),%eax
+c010248c:	89 04 24             	mov    %eax,(%esp)
+c010248f:	e8 3b fc ff ff       	call   c01020cf <print_trapframe>
             panic("handle pgfault failed. %e\n", ret);
-c0102630:	ff 75 f4             	pushl  -0xc(%ebp)
-c0102633:	68 22 8a 10 c0       	push   $0xc0108a22
-c0102638:	68 b5 00 00 00       	push   $0xb5
-c010263d:	68 0e 88 10 c0       	push   $0xc010880e
-c0102642:	e8 a1 dd ff ff       	call   c01003e8 <__panic>
-        /* handle the timer interrupt */
-        /* (1) After a timer interrupt, you should record this event using a global variable (increase it), such as ticks in kern/driver/clock.c
+c0102494:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0102497:	89 44 24 0c          	mov    %eax,0xc(%esp)
+c010249b:	c7 44 24 08 42 91 10 	movl   $0xc0109142,0x8(%esp)
+c01024a2:	c0 
+c01024a3:	c7 44 24 04 af 00 00 	movl   $0xaf,0x4(%esp)
+c01024aa:	00 
+c01024ab:	c7 04 24 2e 8f 10 c0 	movl   $0xc0108f2e,(%esp)
+c01024b2:	e8 41 df ff ff       	call   c01003f8 <__panic>
          * (2) Every TICK_NUM cycle, you can print some info using a funciton, such as print_ticks().
          * (3) Too Simple? Yes, I think so!
          */
-        ticks ++;
-c0102647:	a1 1c 30 12 c0       	mov    0xc012301c,%eax
-c010264c:	83 c0 01             	add    $0x1,%eax
-c010264f:	a3 1c 30 12 c0       	mov    %eax,0xc012301c
-        if (ticks % TICK_NUM == 0) {
-c0102654:	8b 0d 1c 30 12 c0    	mov    0xc012301c,%ecx
-c010265a:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
-c010265f:	89 c8                	mov    %ecx,%eax
-c0102661:	f7 e2                	mul    %edx
-c0102663:	89 d0                	mov    %edx,%eax
-c0102665:	c1 e8 05             	shr    $0x5,%eax
-c0102668:	6b c0 64             	imul   $0x64,%eax,%eax
-c010266b:	29 c1                	sub    %eax,%ecx
-c010266d:	89 c8                	mov    %ecx,%eax
-c010266f:	85 c0                	test   %eax,%eax
-c0102671:	0f 85 a5 00 00 00    	jne    c010271c <trap_dispatch+0x16a>
-            print_ticks();
-c0102677:	e8 54 fa ff ff       	call   c01020d0 <print_ticks>
-        }
         break;
-c010267c:	e9 9b 00 00 00       	jmp    c010271c <trap_dispatch+0x16a>
     case IRQ_OFFSET + IRQ_COM1:
         c = cons_getc();
-c0102681:	e8 07 f8 ff ff       	call   c0101e8d <cons_getc>
-c0102686:	88 45 f3             	mov    %al,-0xd(%ebp)
+c01024b7:	e8 4a f9 ff ff       	call   c0101e06 <cons_getc>
+c01024bc:	88 45 f3             	mov    %al,-0xd(%ebp)
         cprintf("serial [%03d] %c\n", c, c);
-c0102689:	0f be 55 f3          	movsbl -0xd(%ebp),%edx
-c010268d:	0f be 45 f3          	movsbl -0xd(%ebp),%eax
-c0102691:	83 ec 04             	sub    $0x4,%esp
-c0102694:	52                   	push   %edx
-c0102695:	50                   	push   %eax
-c0102696:	68 3d 8a 10 c0       	push   $0xc0108a3d
-c010269b:	e8 e2 db ff ff       	call   c0100282 <cprintf>
-c01026a0:	83 c4 10             	add    $0x10,%esp
+c01024bf:	0f be 55 f3          	movsbl -0xd(%ebp),%edx
+c01024c3:	0f be 45 f3          	movsbl -0xd(%ebp),%eax
+c01024c7:	89 54 24 08          	mov    %edx,0x8(%esp)
+c01024cb:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01024cf:	c7 04 24 5d 91 10 c0 	movl   $0xc010915d,(%esp)
+c01024d6:	e8 c6 dd ff ff       	call   c01002a1 <cprintf>
         break;
-c01026a3:	eb 78                	jmp    c010271d <trap_dispatch+0x16b>
+c01024db:	eb 7e                	jmp    c010255b <trap_dispatch+0x143>
     case IRQ_OFFSET + IRQ_KBD:
         c = cons_getc();
-c01026a5:	e8 e3 f7 ff ff       	call   c0101e8d <cons_getc>
-c01026aa:	88 45 f3             	mov    %al,-0xd(%ebp)
+c01024dd:	e8 24 f9 ff ff       	call   c0101e06 <cons_getc>
+c01024e2:	88 45 f3             	mov    %al,-0xd(%ebp)
         cprintf("kbd [%03d] %c\n", c, c);
-c01026ad:	0f be 55 f3          	movsbl -0xd(%ebp),%edx
-c01026b1:	0f be 45 f3          	movsbl -0xd(%ebp),%eax
-c01026b5:	83 ec 04             	sub    $0x4,%esp
-c01026b8:	52                   	push   %edx
-c01026b9:	50                   	push   %eax
-c01026ba:	68 4f 8a 10 c0       	push   $0xc0108a4f
-c01026bf:	e8 be db ff ff       	call   c0100282 <cprintf>
-c01026c4:	83 c4 10             	add    $0x10,%esp
+c01024e5:	0f be 55 f3          	movsbl -0xd(%ebp),%edx
+c01024e9:	0f be 45 f3          	movsbl -0xd(%ebp),%eax
+c01024ed:	89 54 24 08          	mov    %edx,0x8(%esp)
+c01024f1:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01024f5:	c7 04 24 6f 91 10 c0 	movl   $0xc010916f,(%esp)
+c01024fc:	e8 a0 dd ff ff       	call   c01002a1 <cprintf>
         break;
-c01026c7:	eb 54                	jmp    c010271d <trap_dispatch+0x16b>
+c0102501:	eb 58                	jmp    c010255b <trap_dispatch+0x143>
     //LAB1 CHALLENGE 1 : YOUR CODE you should modify below codes.
     case T_SWITCH_TOU:
     case T_SWITCH_TOK:
         panic("T_SWITCH_** ??\n");
-c01026c9:	83 ec 04             	sub    $0x4,%esp
-c01026cc:	68 5e 8a 10 c0       	push   $0xc0108a5e
-c01026d1:	68 d3 00 00 00       	push   $0xd3
-c01026d6:	68 0e 88 10 c0       	push   $0xc010880e
-c01026db:	e8 08 dd ff ff       	call   c01003e8 <__panic>
+c0102503:	c7 44 24 08 7e 91 10 	movl   $0xc010917e,0x8(%esp)
+c010250a:	c0 
+c010250b:	c7 44 24 04 c9 00 00 	movl   $0xc9,0x4(%esp)
+c0102512:	00 
+c0102513:	c7 04 24 2e 8f 10 c0 	movl   $0xc0108f2e,(%esp)
+c010251a:	e8 d9 de ff ff       	call   c01003f8 <__panic>
     case IRQ_OFFSET + IRQ_IDE2:
         /* do nothing */
         break;
     default:
         // in kernel, it must be a mistake
         if ((tf->tf_cs & 3) == 0) {
-c01026e0:	8b 45 08             	mov    0x8(%ebp),%eax
-c01026e3:	0f b7 40 3c          	movzwl 0x3c(%eax),%eax
-c01026e7:	0f b7 c0             	movzwl %ax,%eax
-c01026ea:	83 e0 03             	and    $0x3,%eax
-c01026ed:	85 c0                	test   %eax,%eax
-c01026ef:	75 2c                	jne    c010271d <trap_dispatch+0x16b>
+c010251f:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102522:	0f b7 40 3c          	movzwl 0x3c(%eax),%eax
+c0102526:	83 e0 03             	and    $0x3,%eax
+c0102529:	85 c0                	test   %eax,%eax
+c010252b:	75 2e                	jne    c010255b <trap_dispatch+0x143>
             print_trapframe(tf);
-c01026f1:	83 ec 0c             	sub    $0xc,%esp
-c01026f4:	ff 75 08             	pushl  0x8(%ebp)
-c01026f7:	e8 4a fb ff ff       	call   c0102246 <print_trapframe>
-c01026fc:	83 c4 10             	add    $0x10,%esp
+c010252d:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102530:	89 04 24             	mov    %eax,(%esp)
+c0102533:	e8 97 fb ff ff       	call   c01020cf <print_trapframe>
             panic("unexpected trap in kernel.\n");
-c01026ff:	83 ec 04             	sub    $0x4,%esp
-c0102702:	68 6e 8a 10 c0       	push   $0xc0108a6e
-c0102707:	68 dd 00 00 00       	push   $0xdd
-c010270c:	68 0e 88 10 c0       	push   $0xc010880e
-c0102711:	e8 d2 dc ff ff       	call   c01003e8 <__panic>
+c0102538:	c7 44 24 08 8e 91 10 	movl   $0xc010918e,0x8(%esp)
+c010253f:	c0 
+c0102540:	c7 44 24 04 d3 00 00 	movl   $0xd3,0x4(%esp)
+c0102547:	00 
+c0102548:	c7 04 24 2e 8f 10 c0 	movl   $0xc0108f2e,(%esp)
+c010254f:	e8 a4 de ff ff       	call   c01003f8 <__panic>
+        /* handle the timer interrupt */
+        /* (1) After a timer interrupt, you should record this event using a global variable (increase it), such as ticks in kern/driver/clock.c
+         * (2) Every TICK_NUM cycle, you can print some info using a funciton, such as print_ticks().
+         * (3) Too Simple? Yes, I think so!
+         */
+        break;
+c0102554:	90                   	nop
+c0102555:	eb 04                	jmp    c010255b <trap_dispatch+0x143>
         panic("T_SWITCH_** ??\n");
         break;
     case IRQ_OFFSET + IRQ_IDE1:
     case IRQ_OFFSET + IRQ_IDE2:
         /* do nothing */
         break;
-c0102716:	90                   	nop
-c0102717:	eb 04                	jmp    c010271d <trap_dispatch+0x16b>
+c0102557:	90                   	nop
+c0102558:	eb 01                	jmp    c010255b <trap_dispatch+0x143>
     case T_PGFLT:  //page fault
         if ((ret = pgfault_handler(tf)) != 0) {
             print_trapframe(tf);
             panic("handle pgfault failed. %e\n", ret);
         }
         break;
-c0102719:	90                   	nop
-c010271a:	eb 01                	jmp    c010271d <trap_dispatch+0x16b>
-         */
-        ticks ++;
-        if (ticks % TICK_NUM == 0) {
-            print_ticks();
-        }
-        break;
-c010271c:	90                   	nop
+c010255a:	90                   	nop
         if ((tf->tf_cs & 3) == 0) {
             print_trapframe(tf);
             panic("unexpected trap in kernel.\n");
         }
     }
 }
-c010271d:	90                   	nop
-c010271e:	c9                   	leave  
-c010271f:	c3                   	ret    
+c010255b:	90                   	nop
+c010255c:	c9                   	leave  
+c010255d:	c3                   	ret    
 
-c0102720 <trap>:
+c010255e <trap>:
  * trap - handles or dispatches an exception/interrupt. if and when trap() returns,
  * the code in kern/trap/trapentry.S restores the old CPU state saved in the
  * trapframe and then uses the iret instruction to return from the exception.
  * */
 void
 trap(struct trapframe *tf) {
-c0102720:	55                   	push   %ebp
-c0102721:	89 e5                	mov    %esp,%ebp
-c0102723:	83 ec 08             	sub    $0x8,%esp
+c010255e:	55                   	push   %ebp
+c010255f:	89 e5                	mov    %esp,%ebp
+c0102561:	83 ec 18             	sub    $0x18,%esp
     // dispatch based on what type of trap occurred
     trap_dispatch(tf);
-c0102726:	83 ec 0c             	sub    $0xc,%esp
-c0102729:	ff 75 08             	pushl  0x8(%ebp)
-c010272c:	e8 81 fe ff ff       	call   c01025b2 <trap_dispatch>
-c0102731:	83 c4 10             	add    $0x10,%esp
-}
-c0102734:	90                   	nop
-c0102735:	c9                   	leave  
-c0102736:	c3                   	ret    
+c0102564:	8b 45 08             	mov    0x8(%ebp),%eax
+c0102567:	89 04 24             	mov    %eax,(%esp)
+c010256a:	e8 a9 fe ff ff       	call   c0102418 <trap_dispatch>
+}
+c010256f:	90                   	nop
+c0102570:	c9                   	leave  
+c0102571:	c3                   	ret    
 
-c0102737 <vector0>:
+c0102572 <vector0>:
 # handler
 .text
 .globl __alltraps
 .globl vector0
 vector0:
   pushl $0
-c0102737:	6a 00                	push   $0x0
+c0102572:	6a 00                	push   $0x0
   pushl $0
-c0102739:	6a 00                	push   $0x0
+c0102574:	6a 00                	push   $0x0
   jmp __alltraps
-c010273b:	e9 67 0a 00 00       	jmp    c01031a7 <__alltraps>
+c0102576:	e9 69 0a 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102740 <vector1>:
+c010257b <vector1>:
 .globl vector1
 vector1:
   pushl $0
-c0102740:	6a 00                	push   $0x0
+c010257b:	6a 00                	push   $0x0
   pushl $1
-c0102742:	6a 01                	push   $0x1
+c010257d:	6a 01                	push   $0x1
   jmp __alltraps
-c0102744:	e9 5e 0a 00 00       	jmp    c01031a7 <__alltraps>
+c010257f:	e9 60 0a 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102749 <vector2>:
+c0102584 <vector2>:
 .globl vector2
 vector2:
   pushl $0
-c0102749:	6a 00                	push   $0x0
+c0102584:	6a 00                	push   $0x0
   pushl $2
-c010274b:	6a 02                	push   $0x2
+c0102586:	6a 02                	push   $0x2
   jmp __alltraps
-c010274d:	e9 55 0a 00 00       	jmp    c01031a7 <__alltraps>
+c0102588:	e9 57 0a 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102752 <vector3>:
+c010258d <vector3>:
 .globl vector3
 vector3:
   pushl $0
-c0102752:	6a 00                	push   $0x0
+c010258d:	6a 00                	push   $0x0
   pushl $3
-c0102754:	6a 03                	push   $0x3
+c010258f:	6a 03                	push   $0x3
   jmp __alltraps
-c0102756:	e9 4c 0a 00 00       	jmp    c01031a7 <__alltraps>
+c0102591:	e9 4e 0a 00 00       	jmp    c0102fe4 <__alltraps>
 
-c010275b <vector4>:
+c0102596 <vector4>:
 .globl vector4
 vector4:
   pushl $0
-c010275b:	6a 00                	push   $0x0
+c0102596:	6a 00                	push   $0x0
   pushl $4
-c010275d:	6a 04                	push   $0x4
+c0102598:	6a 04                	push   $0x4
   jmp __alltraps
-c010275f:	e9 43 0a 00 00       	jmp    c01031a7 <__alltraps>
+c010259a:	e9 45 0a 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102764 <vector5>:
+c010259f <vector5>:
 .globl vector5
 vector5:
   pushl $0
-c0102764:	6a 00                	push   $0x0
+c010259f:	6a 00                	push   $0x0
   pushl $5
-c0102766:	6a 05                	push   $0x5
+c01025a1:	6a 05                	push   $0x5
   jmp __alltraps
-c0102768:	e9 3a 0a 00 00       	jmp    c01031a7 <__alltraps>
+c01025a3:	e9 3c 0a 00 00       	jmp    c0102fe4 <__alltraps>
 
-c010276d <vector6>:
+c01025a8 <vector6>:
 .globl vector6
 vector6:
   pushl $0
-c010276d:	6a 00                	push   $0x0
+c01025a8:	6a 00                	push   $0x0
   pushl $6
-c010276f:	6a 06                	push   $0x6
+c01025aa:	6a 06                	push   $0x6
   jmp __alltraps
-c0102771:	e9 31 0a 00 00       	jmp    c01031a7 <__alltraps>
+c01025ac:	e9 33 0a 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102776 <vector7>:
+c01025b1 <vector7>:
 .globl vector7
 vector7:
   pushl $0
-c0102776:	6a 00                	push   $0x0
+c01025b1:	6a 00                	push   $0x0
   pushl $7
-c0102778:	6a 07                	push   $0x7
+c01025b3:	6a 07                	push   $0x7
   jmp __alltraps
-c010277a:	e9 28 0a 00 00       	jmp    c01031a7 <__alltraps>
+c01025b5:	e9 2a 0a 00 00       	jmp    c0102fe4 <__alltraps>
 
-c010277f <vector8>:
+c01025ba <vector8>:
 .globl vector8
 vector8:
   pushl $8
-c010277f:	6a 08                	push   $0x8
+c01025ba:	6a 08                	push   $0x8
   jmp __alltraps
-c0102781:	e9 21 0a 00 00       	jmp    c01031a7 <__alltraps>
+c01025bc:	e9 23 0a 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102786 <vector9>:
+c01025c1 <vector9>:
 .globl vector9
 vector9:
+  pushl $0
+c01025c1:	6a 00                	push   $0x0
   pushl $9
-c0102786:	6a 09                	push   $0x9
+c01025c3:	6a 09                	push   $0x9
   jmp __alltraps
-c0102788:	e9 1a 0a 00 00       	jmp    c01031a7 <__alltraps>
+c01025c5:	e9 1a 0a 00 00       	jmp    c0102fe4 <__alltraps>
 
-c010278d <vector10>:
+c01025ca <vector10>:
 .globl vector10
 vector10:
   pushl $10
-c010278d:	6a 0a                	push   $0xa
+c01025ca:	6a 0a                	push   $0xa
   jmp __alltraps
-c010278f:	e9 13 0a 00 00       	jmp    c01031a7 <__alltraps>
+c01025cc:	e9 13 0a 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102794 <vector11>:
+c01025d1 <vector11>:
 .globl vector11
 vector11:
   pushl $11
-c0102794:	6a 0b                	push   $0xb
+c01025d1:	6a 0b                	push   $0xb
   jmp __alltraps
-c0102796:	e9 0c 0a 00 00       	jmp    c01031a7 <__alltraps>
+c01025d3:	e9 0c 0a 00 00       	jmp    c0102fe4 <__alltraps>
 
-c010279b <vector12>:
+c01025d8 <vector12>:
 .globl vector12
 vector12:
   pushl $12
-c010279b:	6a 0c                	push   $0xc
+c01025d8:	6a 0c                	push   $0xc
   jmp __alltraps
-c010279d:	e9 05 0a 00 00       	jmp    c01031a7 <__alltraps>
+c01025da:	e9 05 0a 00 00       	jmp    c0102fe4 <__alltraps>
 
-c01027a2 <vector13>:
+c01025df <vector13>:
 .globl vector13
 vector13:
   pushl $13
-c01027a2:	6a 0d                	push   $0xd
+c01025df:	6a 0d                	push   $0xd
   jmp __alltraps
-c01027a4:	e9 fe 09 00 00       	jmp    c01031a7 <__alltraps>
+c01025e1:	e9 fe 09 00 00       	jmp    c0102fe4 <__alltraps>
 
-c01027a9 <vector14>:
+c01025e6 <vector14>:
 .globl vector14
 vector14:
   pushl $14
-c01027a9:	6a 0e                	push   $0xe
+c01025e6:	6a 0e                	push   $0xe
   jmp __alltraps
-c01027ab:	e9 f7 09 00 00       	jmp    c01031a7 <__alltraps>
+c01025e8:	e9 f7 09 00 00       	jmp    c0102fe4 <__alltraps>
 
-c01027b0 <vector15>:
+c01025ed <vector15>:
 .globl vector15
 vector15:
   pushl $0
-c01027b0:	6a 00                	push   $0x0
+c01025ed:	6a 00                	push   $0x0
   pushl $15
-c01027b2:	6a 0f                	push   $0xf
+c01025ef:	6a 0f                	push   $0xf
   jmp __alltraps
-c01027b4:	e9 ee 09 00 00       	jmp    c01031a7 <__alltraps>
+c01025f1:	e9 ee 09 00 00       	jmp    c0102fe4 <__alltraps>
 
-c01027b9 <vector16>:
+c01025f6 <vector16>:
 .globl vector16
 vector16:
   pushl $0
-c01027b9:	6a 00                	push   $0x0
+c01025f6:	6a 00                	push   $0x0
   pushl $16
-c01027bb:	6a 10                	push   $0x10
+c01025f8:	6a 10                	push   $0x10
   jmp __alltraps
-c01027bd:	e9 e5 09 00 00       	jmp    c01031a7 <__alltraps>
+c01025fa:	e9 e5 09 00 00       	jmp    c0102fe4 <__alltraps>
 
-c01027c2 <vector17>:
+c01025ff <vector17>:
 .globl vector17
 vector17:
   pushl $17
-c01027c2:	6a 11                	push   $0x11
+c01025ff:	6a 11                	push   $0x11
   jmp __alltraps
-c01027c4:	e9 de 09 00 00       	jmp    c01031a7 <__alltraps>
+c0102601:	e9 de 09 00 00       	jmp    c0102fe4 <__alltraps>
 
-c01027c9 <vector18>:
+c0102606 <vector18>:
 .globl vector18
 vector18:
   pushl $0
-c01027c9:	6a 00                	push   $0x0
+c0102606:	6a 00                	push   $0x0
   pushl $18
-c01027cb:	6a 12                	push   $0x12
+c0102608:	6a 12                	push   $0x12
   jmp __alltraps
-c01027cd:	e9 d5 09 00 00       	jmp    c01031a7 <__alltraps>
+c010260a:	e9 d5 09 00 00       	jmp    c0102fe4 <__alltraps>
 
-c01027d2 <vector19>:
+c010260f <vector19>:
 .globl vector19
 vector19:
   pushl $0
-c01027d2:	6a 00                	push   $0x0
+c010260f:	6a 00                	push   $0x0
   pushl $19
-c01027d4:	6a 13                	push   $0x13
+c0102611:	6a 13                	push   $0x13
   jmp __alltraps
-c01027d6:	e9 cc 09 00 00       	jmp    c01031a7 <__alltraps>
+c0102613:	e9 cc 09 00 00       	jmp    c0102fe4 <__alltraps>
 
-c01027db <vector20>:
+c0102618 <vector20>:
 .globl vector20
 vector20:
   pushl $0
-c01027db:	6a 00                	push   $0x0
+c0102618:	6a 00                	push   $0x0
   pushl $20
-c01027dd:	6a 14                	push   $0x14
+c010261a:	6a 14                	push   $0x14
   jmp __alltraps
-c01027df:	e9 c3 09 00 00       	jmp    c01031a7 <__alltraps>
+c010261c:	e9 c3 09 00 00       	jmp    c0102fe4 <__alltraps>
 
-c01027e4 <vector21>:
+c0102621 <vector21>:
 .globl vector21
 vector21:
   pushl $0
-c01027e4:	6a 00                	push   $0x0
+c0102621:	6a 00                	push   $0x0
   pushl $21
-c01027e6:	6a 15                	push   $0x15
+c0102623:	6a 15                	push   $0x15
   jmp __alltraps
-c01027e8:	e9 ba 09 00 00       	jmp    c01031a7 <__alltraps>
+c0102625:	e9 ba 09 00 00       	jmp    c0102fe4 <__alltraps>
 
-c01027ed <vector22>:
+c010262a <vector22>:
 .globl vector22
 vector22:
   pushl $0
-c01027ed:	6a 00                	push   $0x0
+c010262a:	6a 00                	push   $0x0
   pushl $22
-c01027ef:	6a 16                	push   $0x16
+c010262c:	6a 16                	push   $0x16
   jmp __alltraps
-c01027f1:	e9 b1 09 00 00       	jmp    c01031a7 <__alltraps>
+c010262e:	e9 b1 09 00 00       	jmp    c0102fe4 <__alltraps>
 
-c01027f6 <vector23>:
+c0102633 <vector23>:
 .globl vector23
 vector23:
   pushl $0
-c01027f6:	6a 00                	push   $0x0
+c0102633:	6a 00                	push   $0x0
   pushl $23
-c01027f8:	6a 17                	push   $0x17
+c0102635:	6a 17                	push   $0x17
   jmp __alltraps
-c01027fa:	e9 a8 09 00 00       	jmp    c01031a7 <__alltraps>
+c0102637:	e9 a8 09 00 00       	jmp    c0102fe4 <__alltraps>
 
-c01027ff <vector24>:
+c010263c <vector24>:
 .globl vector24
 vector24:
   pushl $0
-c01027ff:	6a 00                	push   $0x0
+c010263c:	6a 00                	push   $0x0
   pushl $24
-c0102801:	6a 18                	push   $0x18
+c010263e:	6a 18                	push   $0x18
   jmp __alltraps
-c0102803:	e9 9f 09 00 00       	jmp    c01031a7 <__alltraps>
+c0102640:	e9 9f 09 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102808 <vector25>:
+c0102645 <vector25>:
 .globl vector25
 vector25:
   pushl $0
-c0102808:	6a 00                	push   $0x0
+c0102645:	6a 00                	push   $0x0
   pushl $25
-c010280a:	6a 19                	push   $0x19
+c0102647:	6a 19                	push   $0x19
   jmp __alltraps
-c010280c:	e9 96 09 00 00       	jmp    c01031a7 <__alltraps>
+c0102649:	e9 96 09 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102811 <vector26>:
+c010264e <vector26>:
 .globl vector26
 vector26:
   pushl $0
-c0102811:	6a 00                	push   $0x0
+c010264e:	6a 00                	push   $0x0
   pushl $26
-c0102813:	6a 1a                	push   $0x1a
+c0102650:	6a 1a                	push   $0x1a
   jmp __alltraps
-c0102815:	e9 8d 09 00 00       	jmp    c01031a7 <__alltraps>
+c0102652:	e9 8d 09 00 00       	jmp    c0102fe4 <__alltraps>
 
-c010281a <vector27>:
+c0102657 <vector27>:
 .globl vector27
 vector27:
   pushl $0
-c010281a:	6a 00                	push   $0x0
+c0102657:	6a 00                	push   $0x0
   pushl $27
-c010281c:	6a 1b                	push   $0x1b
+c0102659:	6a 1b                	push   $0x1b
   jmp __alltraps
-c010281e:	e9 84 09 00 00       	jmp    c01031a7 <__alltraps>
+c010265b:	e9 84 09 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102823 <vector28>:
+c0102660 <vector28>:
 .globl vector28
 vector28:
   pushl $0
-c0102823:	6a 00                	push   $0x0
+c0102660:	6a 00                	push   $0x0
   pushl $28
-c0102825:	6a 1c                	push   $0x1c
+c0102662:	6a 1c                	push   $0x1c
   jmp __alltraps
-c0102827:	e9 7b 09 00 00       	jmp    c01031a7 <__alltraps>
+c0102664:	e9 7b 09 00 00       	jmp    c0102fe4 <__alltraps>
 
-c010282c <vector29>:
+c0102669 <vector29>:
 .globl vector29
 vector29:
   pushl $0
-c010282c:	6a 00                	push   $0x0
+c0102669:	6a 00                	push   $0x0
   pushl $29
-c010282e:	6a 1d                	push   $0x1d
+c010266b:	6a 1d                	push   $0x1d
   jmp __alltraps
-c0102830:	e9 72 09 00 00       	jmp    c01031a7 <__alltraps>
+c010266d:	e9 72 09 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102835 <vector30>:
+c0102672 <vector30>:
 .globl vector30
 vector30:
   pushl $0
-c0102835:	6a 00                	push   $0x0
+c0102672:	6a 00                	push   $0x0
   pushl $30
-c0102837:	6a 1e                	push   $0x1e
+c0102674:	6a 1e                	push   $0x1e
   jmp __alltraps
-c0102839:	e9 69 09 00 00       	jmp    c01031a7 <__alltraps>
+c0102676:	e9 69 09 00 00       	jmp    c0102fe4 <__alltraps>
 
-c010283e <vector31>:
+c010267b <vector31>:
 .globl vector31
 vector31:
   pushl $0
-c010283e:	6a 00                	push   $0x0
+c010267b:	6a 00                	push   $0x0
   pushl $31
-c0102840:	6a 1f                	push   $0x1f
+c010267d:	6a 1f                	push   $0x1f
   jmp __alltraps
-c0102842:	e9 60 09 00 00       	jmp    c01031a7 <__alltraps>
+c010267f:	e9 60 09 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102847 <vector32>:
+c0102684 <vector32>:
 .globl vector32
 vector32:
   pushl $0
-c0102847:	6a 00                	push   $0x0
+c0102684:	6a 00                	push   $0x0
   pushl $32
-c0102849:	6a 20                	push   $0x20
+c0102686:	6a 20                	push   $0x20
   jmp __alltraps
-c010284b:	e9 57 09 00 00       	jmp    c01031a7 <__alltraps>
+c0102688:	e9 57 09 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102850 <vector33>:
+c010268d <vector33>:
 .globl vector33
 vector33:
   pushl $0
-c0102850:	6a 00                	push   $0x0
+c010268d:	6a 00                	push   $0x0
   pushl $33
-c0102852:	6a 21                	push   $0x21
+c010268f:	6a 21                	push   $0x21
   jmp __alltraps
-c0102854:	e9 4e 09 00 00       	jmp    c01031a7 <__alltraps>
+c0102691:	e9 4e 09 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102859 <vector34>:
+c0102696 <vector34>:
 .globl vector34
 vector34:
   pushl $0
-c0102859:	6a 00                	push   $0x0
+c0102696:	6a 00                	push   $0x0
   pushl $34
-c010285b:	6a 22                	push   $0x22
+c0102698:	6a 22                	push   $0x22
   jmp __alltraps
-c010285d:	e9 45 09 00 00       	jmp    c01031a7 <__alltraps>
+c010269a:	e9 45 09 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102862 <vector35>:
+c010269f <vector35>:
 .globl vector35
 vector35:
   pushl $0
-c0102862:	6a 00                	push   $0x0
+c010269f:	6a 00                	push   $0x0
   pushl $35
-c0102864:	6a 23                	push   $0x23
+c01026a1:	6a 23                	push   $0x23
   jmp __alltraps
-c0102866:	e9 3c 09 00 00       	jmp    c01031a7 <__alltraps>
+c01026a3:	e9 3c 09 00 00       	jmp    c0102fe4 <__alltraps>
 
-c010286b <vector36>:
+c01026a8 <vector36>:
 .globl vector36
 vector36:
   pushl $0
-c010286b:	6a 00                	push   $0x0
+c01026a8:	6a 00                	push   $0x0
   pushl $36
-c010286d:	6a 24                	push   $0x24
+c01026aa:	6a 24                	push   $0x24
   jmp __alltraps
-c010286f:	e9 33 09 00 00       	jmp    c01031a7 <__alltraps>
+c01026ac:	e9 33 09 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102874 <vector37>:
+c01026b1 <vector37>:
 .globl vector37
 vector37:
   pushl $0
-c0102874:	6a 00                	push   $0x0
+c01026b1:	6a 00                	push   $0x0
   pushl $37
-c0102876:	6a 25                	push   $0x25
+c01026b3:	6a 25                	push   $0x25
   jmp __alltraps
-c0102878:	e9 2a 09 00 00       	jmp    c01031a7 <__alltraps>
+c01026b5:	e9 2a 09 00 00       	jmp    c0102fe4 <__alltraps>
 
-c010287d <vector38>:
+c01026ba <vector38>:
 .globl vector38
 vector38:
   pushl $0
-c010287d:	6a 00                	push   $0x0
+c01026ba:	6a 00                	push   $0x0
   pushl $38
-c010287f:	6a 26                	push   $0x26
+c01026bc:	6a 26                	push   $0x26
   jmp __alltraps
-c0102881:	e9 21 09 00 00       	jmp    c01031a7 <__alltraps>
+c01026be:	e9 21 09 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102886 <vector39>:
+c01026c3 <vector39>:
 .globl vector39
 vector39:
   pushl $0
-c0102886:	6a 00                	push   $0x0
+c01026c3:	6a 00                	push   $0x0
   pushl $39
-c0102888:	6a 27                	push   $0x27
+c01026c5:	6a 27                	push   $0x27
   jmp __alltraps
-c010288a:	e9 18 09 00 00       	jmp    c01031a7 <__alltraps>
+c01026c7:	e9 18 09 00 00       	jmp    c0102fe4 <__alltraps>
 
-c010288f <vector40>:
+c01026cc <vector40>:
 .globl vector40
 vector40:
   pushl $0
-c010288f:	6a 00                	push   $0x0
+c01026cc:	6a 00                	push   $0x0
   pushl $40
-c0102891:	6a 28                	push   $0x28
+c01026ce:	6a 28                	push   $0x28
   jmp __alltraps
-c0102893:	e9 0f 09 00 00       	jmp    c01031a7 <__alltraps>
+c01026d0:	e9 0f 09 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102898 <vector41>:
+c01026d5 <vector41>:
 .globl vector41
 vector41:
   pushl $0
-c0102898:	6a 00                	push   $0x0
+c01026d5:	6a 00                	push   $0x0
   pushl $41
-c010289a:	6a 29                	push   $0x29
+c01026d7:	6a 29                	push   $0x29
   jmp __alltraps
-c010289c:	e9 06 09 00 00       	jmp    c01031a7 <__alltraps>
+c01026d9:	e9 06 09 00 00       	jmp    c0102fe4 <__alltraps>
 
-c01028a1 <vector42>:
+c01026de <vector42>:
 .globl vector42
 vector42:
   pushl $0
-c01028a1:	6a 00                	push   $0x0
+c01026de:	6a 00                	push   $0x0
   pushl $42
-c01028a3:	6a 2a                	push   $0x2a
+c01026e0:	6a 2a                	push   $0x2a
   jmp __alltraps
-c01028a5:	e9 fd 08 00 00       	jmp    c01031a7 <__alltraps>
+c01026e2:	e9 fd 08 00 00       	jmp    c0102fe4 <__alltraps>
 
-c01028aa <vector43>:
+c01026e7 <vector43>:
 .globl vector43
 vector43:
   pushl $0
-c01028aa:	6a 00                	push   $0x0
+c01026e7:	6a 00                	push   $0x0
   pushl $43
-c01028ac:	6a 2b                	push   $0x2b
+c01026e9:	6a 2b                	push   $0x2b
   jmp __alltraps
-c01028ae:	e9 f4 08 00 00       	jmp    c01031a7 <__alltraps>
+c01026eb:	e9 f4 08 00 00       	jmp    c0102fe4 <__alltraps>
 
-c01028b3 <vector44>:
+c01026f0 <vector44>:
 .globl vector44
 vector44:
   pushl $0
-c01028b3:	6a 00                	push   $0x0
+c01026f0:	6a 00                	push   $0x0
   pushl $44
-c01028b5:	6a 2c                	push   $0x2c
+c01026f2:	6a 2c                	push   $0x2c
   jmp __alltraps
-c01028b7:	e9 eb 08 00 00       	jmp    c01031a7 <__alltraps>
+c01026f4:	e9 eb 08 00 00       	jmp    c0102fe4 <__alltraps>
 
-c01028bc <vector45>:
+c01026f9 <vector45>:
 .globl vector45
 vector45:
   pushl $0
-c01028bc:	6a 00                	push   $0x0
+c01026f9:	6a 00                	push   $0x0
   pushl $45
-c01028be:	6a 2d                	push   $0x2d
+c01026fb:	6a 2d                	push   $0x2d
   jmp __alltraps
-c01028c0:	e9 e2 08 00 00       	jmp    c01031a7 <__alltraps>
+c01026fd:	e9 e2 08 00 00       	jmp    c0102fe4 <__alltraps>
 
-c01028c5 <vector46>:
+c0102702 <vector46>:
 .globl vector46
 vector46:
   pushl $0
-c01028c5:	6a 00                	push   $0x0
+c0102702:	6a 00                	push   $0x0
   pushl $46
-c01028c7:	6a 2e                	push   $0x2e
+c0102704:	6a 2e                	push   $0x2e
   jmp __alltraps
-c01028c9:	e9 d9 08 00 00       	jmp    c01031a7 <__alltraps>
+c0102706:	e9 d9 08 00 00       	jmp    c0102fe4 <__alltraps>
 
-c01028ce <vector47>:
+c010270b <vector47>:
 .globl vector47
 vector47:
   pushl $0
-c01028ce:	6a 00                	push   $0x0
+c010270b:	6a 00                	push   $0x0
   pushl $47
-c01028d0:	6a 2f                	push   $0x2f
+c010270d:	6a 2f                	push   $0x2f
   jmp __alltraps
-c01028d2:	e9 d0 08 00 00       	jmp    c01031a7 <__alltraps>
+c010270f:	e9 d0 08 00 00       	jmp    c0102fe4 <__alltraps>
 
-c01028d7 <vector48>:
+c0102714 <vector48>:
 .globl vector48
 vector48:
   pushl $0
-c01028d7:	6a 00                	push   $0x0
+c0102714:	6a 00                	push   $0x0
   pushl $48
-c01028d9:	6a 30                	push   $0x30
+c0102716:	6a 30                	push   $0x30
   jmp __alltraps
-c01028db:	e9 c7 08 00 00       	jmp    c01031a7 <__alltraps>
+c0102718:	e9 c7 08 00 00       	jmp    c0102fe4 <__alltraps>
 
-c01028e0 <vector49>:
+c010271d <vector49>:
 .globl vector49
 vector49:
   pushl $0
-c01028e0:	6a 00                	push   $0x0
+c010271d:	6a 00                	push   $0x0
   pushl $49
-c01028e2:	6a 31                	push   $0x31
+c010271f:	6a 31                	push   $0x31
   jmp __alltraps
-c01028e4:	e9 be 08 00 00       	jmp    c01031a7 <__alltraps>
+c0102721:	e9 be 08 00 00       	jmp    c0102fe4 <__alltraps>
 
-c01028e9 <vector50>:
+c0102726 <vector50>:
 .globl vector50
 vector50:
   pushl $0
-c01028e9:	6a 00                	push   $0x0
+c0102726:	6a 00                	push   $0x0
   pushl $50
-c01028eb:	6a 32                	push   $0x32
+c0102728:	6a 32                	push   $0x32
   jmp __alltraps
-c01028ed:	e9 b5 08 00 00       	jmp    c01031a7 <__alltraps>
+c010272a:	e9 b5 08 00 00       	jmp    c0102fe4 <__alltraps>
 
-c01028f2 <vector51>:
+c010272f <vector51>:
 .globl vector51
 vector51:
   pushl $0
-c01028f2:	6a 00                	push   $0x0
+c010272f:	6a 00                	push   $0x0
   pushl $51
-c01028f4:	6a 33                	push   $0x33
+c0102731:	6a 33                	push   $0x33
   jmp __alltraps
-c01028f6:	e9 ac 08 00 00       	jmp    c01031a7 <__alltraps>
+c0102733:	e9 ac 08 00 00       	jmp    c0102fe4 <__alltraps>
 
-c01028fb <vector52>:
+c0102738 <vector52>:
 .globl vector52
 vector52:
   pushl $0
-c01028fb:	6a 00                	push   $0x0
+c0102738:	6a 00                	push   $0x0
   pushl $52
-c01028fd:	6a 34                	push   $0x34
+c010273a:	6a 34                	push   $0x34
   jmp __alltraps
-c01028ff:	e9 a3 08 00 00       	jmp    c01031a7 <__alltraps>
+c010273c:	e9 a3 08 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102904 <vector53>:
+c0102741 <vector53>:
 .globl vector53
 vector53:
   pushl $0
-c0102904:	6a 00                	push   $0x0
+c0102741:	6a 00                	push   $0x0
   pushl $53
-c0102906:	6a 35                	push   $0x35
+c0102743:	6a 35                	push   $0x35
   jmp __alltraps
-c0102908:	e9 9a 08 00 00       	jmp    c01031a7 <__alltraps>
+c0102745:	e9 9a 08 00 00       	jmp    c0102fe4 <__alltraps>
 
-c010290d <vector54>:
+c010274a <vector54>:
 .globl vector54
 vector54:
   pushl $0
-c010290d:	6a 00                	push   $0x0
+c010274a:	6a 00                	push   $0x0
   pushl $54
-c010290f:	6a 36                	push   $0x36
+c010274c:	6a 36                	push   $0x36
   jmp __alltraps
-c0102911:	e9 91 08 00 00       	jmp    c01031a7 <__alltraps>
+c010274e:	e9 91 08 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102916 <vector55>:
+c0102753 <vector55>:
 .globl vector55
 vector55:
   pushl $0
-c0102916:	6a 00                	push   $0x0
+c0102753:	6a 00                	push   $0x0
   pushl $55
-c0102918:	6a 37                	push   $0x37
+c0102755:	6a 37                	push   $0x37
   jmp __alltraps
-c010291a:	e9 88 08 00 00       	jmp    c01031a7 <__alltraps>
+c0102757:	e9 88 08 00 00       	jmp    c0102fe4 <__alltraps>
 
-c010291f <vector56>:
+c010275c <vector56>:
 .globl vector56
 vector56:
   pushl $0
-c010291f:	6a 00                	push   $0x0
+c010275c:	6a 00                	push   $0x0
   pushl $56
-c0102921:	6a 38                	push   $0x38
+c010275e:	6a 38                	push   $0x38
   jmp __alltraps
-c0102923:	e9 7f 08 00 00       	jmp    c01031a7 <__alltraps>
+c0102760:	e9 7f 08 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102928 <vector57>:
+c0102765 <vector57>:
 .globl vector57
 vector57:
   pushl $0
-c0102928:	6a 00                	push   $0x0
+c0102765:	6a 00                	push   $0x0
   pushl $57
-c010292a:	6a 39                	push   $0x39
+c0102767:	6a 39                	push   $0x39
   jmp __alltraps
-c010292c:	e9 76 08 00 00       	jmp    c01031a7 <__alltraps>
+c0102769:	e9 76 08 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102931 <vector58>:
+c010276e <vector58>:
 .globl vector58
 vector58:
   pushl $0
-c0102931:	6a 00                	push   $0x0
+c010276e:	6a 00                	push   $0x0
   pushl $58
-c0102933:	6a 3a                	push   $0x3a
+c0102770:	6a 3a                	push   $0x3a
   jmp __alltraps
-c0102935:	e9 6d 08 00 00       	jmp    c01031a7 <__alltraps>
+c0102772:	e9 6d 08 00 00       	jmp    c0102fe4 <__alltraps>
 
-c010293a <vector59>:
+c0102777 <vector59>:
 .globl vector59
 vector59:
   pushl $0
-c010293a:	6a 00                	push   $0x0
+c0102777:	6a 00                	push   $0x0
   pushl $59
-c010293c:	6a 3b                	push   $0x3b
+c0102779:	6a 3b                	push   $0x3b
   jmp __alltraps
-c010293e:	e9 64 08 00 00       	jmp    c01031a7 <__alltraps>
+c010277b:	e9 64 08 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102943 <vector60>:
+c0102780 <vector60>:
 .globl vector60
 vector60:
   pushl $0
-c0102943:	6a 00                	push   $0x0
+c0102780:	6a 00                	push   $0x0
   pushl $60
-c0102945:	6a 3c                	push   $0x3c
+c0102782:	6a 3c                	push   $0x3c
   jmp __alltraps
-c0102947:	e9 5b 08 00 00       	jmp    c01031a7 <__alltraps>
+c0102784:	e9 5b 08 00 00       	jmp    c0102fe4 <__alltraps>
 
-c010294c <vector61>:
+c0102789 <vector61>:
 .globl vector61
 vector61:
   pushl $0
-c010294c:	6a 00                	push   $0x0
+c0102789:	6a 00                	push   $0x0
   pushl $61
-c010294e:	6a 3d                	push   $0x3d
+c010278b:	6a 3d                	push   $0x3d
   jmp __alltraps
-c0102950:	e9 52 08 00 00       	jmp    c01031a7 <__alltraps>
+c010278d:	e9 52 08 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102955 <vector62>:
+c0102792 <vector62>:
 .globl vector62
 vector62:
   pushl $0
-c0102955:	6a 00                	push   $0x0
+c0102792:	6a 00                	push   $0x0
   pushl $62
-c0102957:	6a 3e                	push   $0x3e
+c0102794:	6a 3e                	push   $0x3e
   jmp __alltraps
-c0102959:	e9 49 08 00 00       	jmp    c01031a7 <__alltraps>
+c0102796:	e9 49 08 00 00       	jmp    c0102fe4 <__alltraps>
 
-c010295e <vector63>:
+c010279b <vector63>:
 .globl vector63
 vector63:
   pushl $0
-c010295e:	6a 00                	push   $0x0
+c010279b:	6a 00                	push   $0x0
   pushl $63
-c0102960:	6a 3f                	push   $0x3f
+c010279d:	6a 3f                	push   $0x3f
   jmp __alltraps
-c0102962:	e9 40 08 00 00       	jmp    c01031a7 <__alltraps>
+c010279f:	e9 40 08 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102967 <vector64>:
+c01027a4 <vector64>:
 .globl vector64
 vector64:
   pushl $0
-c0102967:	6a 00                	push   $0x0
+c01027a4:	6a 00                	push   $0x0
   pushl $64
-c0102969:	6a 40                	push   $0x40
+c01027a6:	6a 40                	push   $0x40
   jmp __alltraps
-c010296b:	e9 37 08 00 00       	jmp    c01031a7 <__alltraps>
+c01027a8:	e9 37 08 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102970 <vector65>:
+c01027ad <vector65>:
 .globl vector65
 vector65:
   pushl $0
-c0102970:	6a 00                	push   $0x0
+c01027ad:	6a 00                	push   $0x0
   pushl $65
-c0102972:	6a 41                	push   $0x41
+c01027af:	6a 41                	push   $0x41
   jmp __alltraps
-c0102974:	e9 2e 08 00 00       	jmp    c01031a7 <__alltraps>
+c01027b1:	e9 2e 08 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102979 <vector66>:
+c01027b6 <vector66>:
 .globl vector66
 vector66:
   pushl $0
-c0102979:	6a 00                	push   $0x0
+c01027b6:	6a 00                	push   $0x0
   pushl $66
-c010297b:	6a 42                	push   $0x42
+c01027b8:	6a 42                	push   $0x42
   jmp __alltraps
-c010297d:	e9 25 08 00 00       	jmp    c01031a7 <__alltraps>
+c01027ba:	e9 25 08 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102982 <vector67>:
+c01027bf <vector67>:
 .globl vector67
 vector67:
   pushl $0
-c0102982:	6a 00                	push   $0x0
+c01027bf:	6a 00                	push   $0x0
   pushl $67
-c0102984:	6a 43                	push   $0x43
+c01027c1:	6a 43                	push   $0x43
   jmp __alltraps
-c0102986:	e9 1c 08 00 00       	jmp    c01031a7 <__alltraps>
+c01027c3:	e9 1c 08 00 00       	jmp    c0102fe4 <__alltraps>
 
-c010298b <vector68>:
+c01027c8 <vector68>:
 .globl vector68
 vector68:
   pushl $0
-c010298b:	6a 00                	push   $0x0
+c01027c8:	6a 00                	push   $0x0
   pushl $68
-c010298d:	6a 44                	push   $0x44
+c01027ca:	6a 44                	push   $0x44
   jmp __alltraps
-c010298f:	e9 13 08 00 00       	jmp    c01031a7 <__alltraps>
+c01027cc:	e9 13 08 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102994 <vector69>:
+c01027d1 <vector69>:
 .globl vector69
 vector69:
   pushl $0
-c0102994:	6a 00                	push   $0x0
+c01027d1:	6a 00                	push   $0x0
   pushl $69
-c0102996:	6a 45                	push   $0x45
+c01027d3:	6a 45                	push   $0x45
   jmp __alltraps
-c0102998:	e9 0a 08 00 00       	jmp    c01031a7 <__alltraps>
+c01027d5:	e9 0a 08 00 00       	jmp    c0102fe4 <__alltraps>
 
-c010299d <vector70>:
+c01027da <vector70>:
 .globl vector70
 vector70:
   pushl $0
-c010299d:	6a 00                	push   $0x0
+c01027da:	6a 00                	push   $0x0
   pushl $70
-c010299f:	6a 46                	push   $0x46
+c01027dc:	6a 46                	push   $0x46
   jmp __alltraps
-c01029a1:	e9 01 08 00 00       	jmp    c01031a7 <__alltraps>
+c01027de:	e9 01 08 00 00       	jmp    c0102fe4 <__alltraps>
 
-c01029a6 <vector71>:
+c01027e3 <vector71>:
 .globl vector71
 vector71:
   pushl $0
-c01029a6:	6a 00                	push   $0x0
+c01027e3:	6a 00                	push   $0x0
   pushl $71
-c01029a8:	6a 47                	push   $0x47
+c01027e5:	6a 47                	push   $0x47
   jmp __alltraps
-c01029aa:	e9 f8 07 00 00       	jmp    c01031a7 <__alltraps>
+c01027e7:	e9 f8 07 00 00       	jmp    c0102fe4 <__alltraps>
 
-c01029af <vector72>:
+c01027ec <vector72>:
 .globl vector72
 vector72:
   pushl $0
-c01029af:	6a 00                	push   $0x0
+c01027ec:	6a 00                	push   $0x0
   pushl $72
-c01029b1:	6a 48                	push   $0x48
+c01027ee:	6a 48                	push   $0x48
   jmp __alltraps
-c01029b3:	e9 ef 07 00 00       	jmp    c01031a7 <__alltraps>
+c01027f0:	e9 ef 07 00 00       	jmp    c0102fe4 <__alltraps>
 
-c01029b8 <vector73>:
+c01027f5 <vector73>:
 .globl vector73
 vector73:
   pushl $0
-c01029b8:	6a 00                	push   $0x0
+c01027f5:	6a 00                	push   $0x0
   pushl $73
-c01029ba:	6a 49                	push   $0x49
+c01027f7:	6a 49                	push   $0x49
   jmp __alltraps
-c01029bc:	e9 e6 07 00 00       	jmp    c01031a7 <__alltraps>
+c01027f9:	e9 e6 07 00 00       	jmp    c0102fe4 <__alltraps>
 
-c01029c1 <vector74>:
+c01027fe <vector74>:
 .globl vector74
 vector74:
   pushl $0
-c01029c1:	6a 00                	push   $0x0
+c01027fe:	6a 00                	push   $0x0
   pushl $74
-c01029c3:	6a 4a                	push   $0x4a
+c0102800:	6a 4a                	push   $0x4a
   jmp __alltraps
-c01029c5:	e9 dd 07 00 00       	jmp    c01031a7 <__alltraps>
+c0102802:	e9 dd 07 00 00       	jmp    c0102fe4 <__alltraps>
 
-c01029ca <vector75>:
+c0102807 <vector75>:
 .globl vector75
 vector75:
   pushl $0
-c01029ca:	6a 00                	push   $0x0
+c0102807:	6a 00                	push   $0x0
   pushl $75
-c01029cc:	6a 4b                	push   $0x4b
+c0102809:	6a 4b                	push   $0x4b
   jmp __alltraps
-c01029ce:	e9 d4 07 00 00       	jmp    c01031a7 <__alltraps>
+c010280b:	e9 d4 07 00 00       	jmp    c0102fe4 <__alltraps>
 
-c01029d3 <vector76>:
+c0102810 <vector76>:
 .globl vector76
 vector76:
   pushl $0
-c01029d3:	6a 00                	push   $0x0
+c0102810:	6a 00                	push   $0x0
   pushl $76
-c01029d5:	6a 4c                	push   $0x4c
+c0102812:	6a 4c                	push   $0x4c
   jmp __alltraps
-c01029d7:	e9 cb 07 00 00       	jmp    c01031a7 <__alltraps>
+c0102814:	e9 cb 07 00 00       	jmp    c0102fe4 <__alltraps>
 
-c01029dc <vector77>:
+c0102819 <vector77>:
 .globl vector77
 vector77:
   pushl $0
-c01029dc:	6a 00                	push   $0x0
+c0102819:	6a 00                	push   $0x0
   pushl $77
-c01029de:	6a 4d                	push   $0x4d
+c010281b:	6a 4d                	push   $0x4d
   jmp __alltraps
-c01029e0:	e9 c2 07 00 00       	jmp    c01031a7 <__alltraps>
+c010281d:	e9 c2 07 00 00       	jmp    c0102fe4 <__alltraps>
 
-c01029e5 <vector78>:
+c0102822 <vector78>:
 .globl vector78
 vector78:
   pushl $0
-c01029e5:	6a 00                	push   $0x0
+c0102822:	6a 00                	push   $0x0
   pushl $78
-c01029e7:	6a 4e                	push   $0x4e
+c0102824:	6a 4e                	push   $0x4e
   jmp __alltraps
-c01029e9:	e9 b9 07 00 00       	jmp    c01031a7 <__alltraps>
+c0102826:	e9 b9 07 00 00       	jmp    c0102fe4 <__alltraps>
 
-c01029ee <vector79>:
+c010282b <vector79>:
 .globl vector79
 vector79:
   pushl $0
-c01029ee:	6a 00                	push   $0x0
+c010282b:	6a 00                	push   $0x0
   pushl $79
-c01029f0:	6a 4f                	push   $0x4f
+c010282d:	6a 4f                	push   $0x4f
   jmp __alltraps
-c01029f2:	e9 b0 07 00 00       	jmp    c01031a7 <__alltraps>
+c010282f:	e9 b0 07 00 00       	jmp    c0102fe4 <__alltraps>
 
-c01029f7 <vector80>:
+c0102834 <vector80>:
 .globl vector80
 vector80:
   pushl $0
-c01029f7:	6a 00                	push   $0x0
+c0102834:	6a 00                	push   $0x0
   pushl $80
-c01029f9:	6a 50                	push   $0x50
+c0102836:	6a 50                	push   $0x50
   jmp __alltraps
-c01029fb:	e9 a7 07 00 00       	jmp    c01031a7 <__alltraps>
+c0102838:	e9 a7 07 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102a00 <vector81>:
+c010283d <vector81>:
 .globl vector81
 vector81:
   pushl $0
-c0102a00:	6a 00                	push   $0x0
+c010283d:	6a 00                	push   $0x0
   pushl $81
-c0102a02:	6a 51                	push   $0x51
+c010283f:	6a 51                	push   $0x51
   jmp __alltraps
-c0102a04:	e9 9e 07 00 00       	jmp    c01031a7 <__alltraps>
+c0102841:	e9 9e 07 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102a09 <vector82>:
+c0102846 <vector82>:
 .globl vector82
 vector82:
   pushl $0
-c0102a09:	6a 00                	push   $0x0
+c0102846:	6a 00                	push   $0x0
   pushl $82
-c0102a0b:	6a 52                	push   $0x52
+c0102848:	6a 52                	push   $0x52
   jmp __alltraps
-c0102a0d:	e9 95 07 00 00       	jmp    c01031a7 <__alltraps>
+c010284a:	e9 95 07 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102a12 <vector83>:
+c010284f <vector83>:
 .globl vector83
 vector83:
   pushl $0
-c0102a12:	6a 00                	push   $0x0
+c010284f:	6a 00                	push   $0x0
   pushl $83
-c0102a14:	6a 53                	push   $0x53
+c0102851:	6a 53                	push   $0x53
   jmp __alltraps
-c0102a16:	e9 8c 07 00 00       	jmp    c01031a7 <__alltraps>
+c0102853:	e9 8c 07 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102a1b <vector84>:
+c0102858 <vector84>:
 .globl vector84
 vector84:
   pushl $0
-c0102a1b:	6a 00                	push   $0x0
+c0102858:	6a 00                	push   $0x0
   pushl $84
-c0102a1d:	6a 54                	push   $0x54
+c010285a:	6a 54                	push   $0x54
   jmp __alltraps
-c0102a1f:	e9 83 07 00 00       	jmp    c01031a7 <__alltraps>
+c010285c:	e9 83 07 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102a24 <vector85>:
+c0102861 <vector85>:
 .globl vector85
 vector85:
   pushl $0
-c0102a24:	6a 00                	push   $0x0
+c0102861:	6a 00                	push   $0x0
   pushl $85
-c0102a26:	6a 55                	push   $0x55
+c0102863:	6a 55                	push   $0x55
   jmp __alltraps
-c0102a28:	e9 7a 07 00 00       	jmp    c01031a7 <__alltraps>
+c0102865:	e9 7a 07 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102a2d <vector86>:
+c010286a <vector86>:
 .globl vector86
 vector86:
   pushl $0
-c0102a2d:	6a 00                	push   $0x0
+c010286a:	6a 00                	push   $0x0
   pushl $86
-c0102a2f:	6a 56                	push   $0x56
+c010286c:	6a 56                	push   $0x56
   jmp __alltraps
-c0102a31:	e9 71 07 00 00       	jmp    c01031a7 <__alltraps>
+c010286e:	e9 71 07 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102a36 <vector87>:
+c0102873 <vector87>:
 .globl vector87
 vector87:
   pushl $0
-c0102a36:	6a 00                	push   $0x0
+c0102873:	6a 00                	push   $0x0
   pushl $87
-c0102a38:	6a 57                	push   $0x57
+c0102875:	6a 57                	push   $0x57
   jmp __alltraps
-c0102a3a:	e9 68 07 00 00       	jmp    c01031a7 <__alltraps>
+c0102877:	e9 68 07 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102a3f <vector88>:
+c010287c <vector88>:
 .globl vector88
 vector88:
   pushl $0
-c0102a3f:	6a 00                	push   $0x0
+c010287c:	6a 00                	push   $0x0
   pushl $88
-c0102a41:	6a 58                	push   $0x58
+c010287e:	6a 58                	push   $0x58
   jmp __alltraps
-c0102a43:	e9 5f 07 00 00       	jmp    c01031a7 <__alltraps>
+c0102880:	e9 5f 07 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102a48 <vector89>:
+c0102885 <vector89>:
 .globl vector89
 vector89:
   pushl $0
-c0102a48:	6a 00                	push   $0x0
+c0102885:	6a 00                	push   $0x0
   pushl $89
-c0102a4a:	6a 59                	push   $0x59
+c0102887:	6a 59                	push   $0x59
   jmp __alltraps
-c0102a4c:	e9 56 07 00 00       	jmp    c01031a7 <__alltraps>
+c0102889:	e9 56 07 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102a51 <vector90>:
+c010288e <vector90>:
 .globl vector90
 vector90:
   pushl $0
-c0102a51:	6a 00                	push   $0x0
+c010288e:	6a 00                	push   $0x0
   pushl $90
-c0102a53:	6a 5a                	push   $0x5a
+c0102890:	6a 5a                	push   $0x5a
   jmp __alltraps
-c0102a55:	e9 4d 07 00 00       	jmp    c01031a7 <__alltraps>
+c0102892:	e9 4d 07 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102a5a <vector91>:
+c0102897 <vector91>:
 .globl vector91
 vector91:
   pushl $0
-c0102a5a:	6a 00                	push   $0x0
+c0102897:	6a 00                	push   $0x0
   pushl $91
-c0102a5c:	6a 5b                	push   $0x5b
+c0102899:	6a 5b                	push   $0x5b
   jmp __alltraps
-c0102a5e:	e9 44 07 00 00       	jmp    c01031a7 <__alltraps>
+c010289b:	e9 44 07 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102a63 <vector92>:
+c01028a0 <vector92>:
 .globl vector92
 vector92:
   pushl $0
-c0102a63:	6a 00                	push   $0x0
+c01028a0:	6a 00                	push   $0x0
   pushl $92
-c0102a65:	6a 5c                	push   $0x5c
+c01028a2:	6a 5c                	push   $0x5c
   jmp __alltraps
-c0102a67:	e9 3b 07 00 00       	jmp    c01031a7 <__alltraps>
+c01028a4:	e9 3b 07 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102a6c <vector93>:
+c01028a9 <vector93>:
 .globl vector93
 vector93:
   pushl $0
-c0102a6c:	6a 00                	push   $0x0
+c01028a9:	6a 00                	push   $0x0
   pushl $93
-c0102a6e:	6a 5d                	push   $0x5d
+c01028ab:	6a 5d                	push   $0x5d
   jmp __alltraps
-c0102a70:	e9 32 07 00 00       	jmp    c01031a7 <__alltraps>
+c01028ad:	e9 32 07 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102a75 <vector94>:
+c01028b2 <vector94>:
 .globl vector94
 vector94:
   pushl $0
-c0102a75:	6a 00                	push   $0x0
+c01028b2:	6a 00                	push   $0x0
   pushl $94
-c0102a77:	6a 5e                	push   $0x5e
+c01028b4:	6a 5e                	push   $0x5e
   jmp __alltraps
-c0102a79:	e9 29 07 00 00       	jmp    c01031a7 <__alltraps>
+c01028b6:	e9 29 07 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102a7e <vector95>:
+c01028bb <vector95>:
 .globl vector95
 vector95:
   pushl $0
-c0102a7e:	6a 00                	push   $0x0
+c01028bb:	6a 00                	push   $0x0
   pushl $95
-c0102a80:	6a 5f                	push   $0x5f
+c01028bd:	6a 5f                	push   $0x5f
   jmp __alltraps
-c0102a82:	e9 20 07 00 00       	jmp    c01031a7 <__alltraps>
+c01028bf:	e9 20 07 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102a87 <vector96>:
+c01028c4 <vector96>:
 .globl vector96
 vector96:
   pushl $0
-c0102a87:	6a 00                	push   $0x0
+c01028c4:	6a 00                	push   $0x0
   pushl $96
-c0102a89:	6a 60                	push   $0x60
+c01028c6:	6a 60                	push   $0x60
   jmp __alltraps
-c0102a8b:	e9 17 07 00 00       	jmp    c01031a7 <__alltraps>
+c01028c8:	e9 17 07 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102a90 <vector97>:
+c01028cd <vector97>:
 .globl vector97
 vector97:
   pushl $0
-c0102a90:	6a 00                	push   $0x0
+c01028cd:	6a 00                	push   $0x0
   pushl $97
-c0102a92:	6a 61                	push   $0x61
+c01028cf:	6a 61                	push   $0x61
   jmp __alltraps
-c0102a94:	e9 0e 07 00 00       	jmp    c01031a7 <__alltraps>
+c01028d1:	e9 0e 07 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102a99 <vector98>:
+c01028d6 <vector98>:
 .globl vector98
 vector98:
   pushl $0
-c0102a99:	6a 00                	push   $0x0
+c01028d6:	6a 00                	push   $0x0
   pushl $98
-c0102a9b:	6a 62                	push   $0x62
+c01028d8:	6a 62                	push   $0x62
   jmp __alltraps
-c0102a9d:	e9 05 07 00 00       	jmp    c01031a7 <__alltraps>
+c01028da:	e9 05 07 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102aa2 <vector99>:
+c01028df <vector99>:
 .globl vector99
 vector99:
   pushl $0
-c0102aa2:	6a 00                	push   $0x0
+c01028df:	6a 00                	push   $0x0
   pushl $99
-c0102aa4:	6a 63                	push   $0x63
+c01028e1:	6a 63                	push   $0x63
   jmp __alltraps
-c0102aa6:	e9 fc 06 00 00       	jmp    c01031a7 <__alltraps>
+c01028e3:	e9 fc 06 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102aab <vector100>:
+c01028e8 <vector100>:
 .globl vector100
 vector100:
   pushl $0
-c0102aab:	6a 00                	push   $0x0
+c01028e8:	6a 00                	push   $0x0
   pushl $100
-c0102aad:	6a 64                	push   $0x64
+c01028ea:	6a 64                	push   $0x64
   jmp __alltraps
-c0102aaf:	e9 f3 06 00 00       	jmp    c01031a7 <__alltraps>
+c01028ec:	e9 f3 06 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102ab4 <vector101>:
+c01028f1 <vector101>:
 .globl vector101
 vector101:
   pushl $0
-c0102ab4:	6a 00                	push   $0x0
+c01028f1:	6a 00                	push   $0x0
   pushl $101
-c0102ab6:	6a 65                	push   $0x65
+c01028f3:	6a 65                	push   $0x65
   jmp __alltraps
-c0102ab8:	e9 ea 06 00 00       	jmp    c01031a7 <__alltraps>
+c01028f5:	e9 ea 06 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102abd <vector102>:
+c01028fa <vector102>:
 .globl vector102
 vector102:
   pushl $0
-c0102abd:	6a 00                	push   $0x0
+c01028fa:	6a 00                	push   $0x0
   pushl $102
-c0102abf:	6a 66                	push   $0x66
+c01028fc:	6a 66                	push   $0x66
   jmp __alltraps
-c0102ac1:	e9 e1 06 00 00       	jmp    c01031a7 <__alltraps>
+c01028fe:	e9 e1 06 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102ac6 <vector103>:
+c0102903 <vector103>:
 .globl vector103
 vector103:
   pushl $0
-c0102ac6:	6a 00                	push   $0x0
+c0102903:	6a 00                	push   $0x0
   pushl $103
-c0102ac8:	6a 67                	push   $0x67
+c0102905:	6a 67                	push   $0x67
   jmp __alltraps
-c0102aca:	e9 d8 06 00 00       	jmp    c01031a7 <__alltraps>
+c0102907:	e9 d8 06 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102acf <vector104>:
+c010290c <vector104>:
 .globl vector104
 vector104:
   pushl $0
-c0102acf:	6a 00                	push   $0x0
+c010290c:	6a 00                	push   $0x0
   pushl $104
-c0102ad1:	6a 68                	push   $0x68
+c010290e:	6a 68                	push   $0x68
   jmp __alltraps
-c0102ad3:	e9 cf 06 00 00       	jmp    c01031a7 <__alltraps>
+c0102910:	e9 cf 06 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102ad8 <vector105>:
+c0102915 <vector105>:
 .globl vector105
 vector105:
   pushl $0
-c0102ad8:	6a 00                	push   $0x0
+c0102915:	6a 00                	push   $0x0
   pushl $105
-c0102ada:	6a 69                	push   $0x69
+c0102917:	6a 69                	push   $0x69
   jmp __alltraps
-c0102adc:	e9 c6 06 00 00       	jmp    c01031a7 <__alltraps>
+c0102919:	e9 c6 06 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102ae1 <vector106>:
+c010291e <vector106>:
 .globl vector106
 vector106:
   pushl $0
-c0102ae1:	6a 00                	push   $0x0
+c010291e:	6a 00                	push   $0x0
   pushl $106
-c0102ae3:	6a 6a                	push   $0x6a
+c0102920:	6a 6a                	push   $0x6a
   jmp __alltraps
-c0102ae5:	e9 bd 06 00 00       	jmp    c01031a7 <__alltraps>
+c0102922:	e9 bd 06 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102aea <vector107>:
+c0102927 <vector107>:
 .globl vector107
 vector107:
   pushl $0
-c0102aea:	6a 00                	push   $0x0
+c0102927:	6a 00                	push   $0x0
   pushl $107
-c0102aec:	6a 6b                	push   $0x6b
+c0102929:	6a 6b                	push   $0x6b
   jmp __alltraps
-c0102aee:	e9 b4 06 00 00       	jmp    c01031a7 <__alltraps>
+c010292b:	e9 b4 06 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102af3 <vector108>:
+c0102930 <vector108>:
 .globl vector108
 vector108:
   pushl $0
-c0102af3:	6a 00                	push   $0x0
+c0102930:	6a 00                	push   $0x0
   pushl $108
-c0102af5:	6a 6c                	push   $0x6c
+c0102932:	6a 6c                	push   $0x6c
   jmp __alltraps
-c0102af7:	e9 ab 06 00 00       	jmp    c01031a7 <__alltraps>
+c0102934:	e9 ab 06 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102afc <vector109>:
+c0102939 <vector109>:
 .globl vector109
 vector109:
   pushl $0
-c0102afc:	6a 00                	push   $0x0
+c0102939:	6a 00                	push   $0x0
   pushl $109
-c0102afe:	6a 6d                	push   $0x6d
+c010293b:	6a 6d                	push   $0x6d
   jmp __alltraps
-c0102b00:	e9 a2 06 00 00       	jmp    c01031a7 <__alltraps>
+c010293d:	e9 a2 06 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102b05 <vector110>:
+c0102942 <vector110>:
 .globl vector110
 vector110:
   pushl $0
-c0102b05:	6a 00                	push   $0x0
+c0102942:	6a 00                	push   $0x0
   pushl $110
-c0102b07:	6a 6e                	push   $0x6e
+c0102944:	6a 6e                	push   $0x6e
   jmp __alltraps
-c0102b09:	e9 99 06 00 00       	jmp    c01031a7 <__alltraps>
+c0102946:	e9 99 06 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102b0e <vector111>:
+c010294b <vector111>:
 .globl vector111
 vector111:
   pushl $0
-c0102b0e:	6a 00                	push   $0x0
+c010294b:	6a 00                	push   $0x0
   pushl $111
-c0102b10:	6a 6f                	push   $0x6f
+c010294d:	6a 6f                	push   $0x6f
   jmp __alltraps
-c0102b12:	e9 90 06 00 00       	jmp    c01031a7 <__alltraps>
+c010294f:	e9 90 06 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102b17 <vector112>:
+c0102954 <vector112>:
 .globl vector112
 vector112:
   pushl $0
-c0102b17:	6a 00                	push   $0x0
+c0102954:	6a 00                	push   $0x0
   pushl $112
-c0102b19:	6a 70                	push   $0x70
+c0102956:	6a 70                	push   $0x70
   jmp __alltraps
-c0102b1b:	e9 87 06 00 00       	jmp    c01031a7 <__alltraps>
+c0102958:	e9 87 06 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102b20 <vector113>:
+c010295d <vector113>:
 .globl vector113
 vector113:
   pushl $0
-c0102b20:	6a 00                	push   $0x0
+c010295d:	6a 00                	push   $0x0
   pushl $113
-c0102b22:	6a 71                	push   $0x71
+c010295f:	6a 71                	push   $0x71
   jmp __alltraps
-c0102b24:	e9 7e 06 00 00       	jmp    c01031a7 <__alltraps>
+c0102961:	e9 7e 06 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102b29 <vector114>:
+c0102966 <vector114>:
 .globl vector114
 vector114:
   pushl $0
-c0102b29:	6a 00                	push   $0x0
+c0102966:	6a 00                	push   $0x0
   pushl $114
-c0102b2b:	6a 72                	push   $0x72
+c0102968:	6a 72                	push   $0x72
   jmp __alltraps
-c0102b2d:	e9 75 06 00 00       	jmp    c01031a7 <__alltraps>
+c010296a:	e9 75 06 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102b32 <vector115>:
+c010296f <vector115>:
 .globl vector115
 vector115:
   pushl $0
-c0102b32:	6a 00                	push   $0x0
+c010296f:	6a 00                	push   $0x0
   pushl $115
-c0102b34:	6a 73                	push   $0x73
+c0102971:	6a 73                	push   $0x73
   jmp __alltraps
-c0102b36:	e9 6c 06 00 00       	jmp    c01031a7 <__alltraps>
+c0102973:	e9 6c 06 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102b3b <vector116>:
+c0102978 <vector116>:
 .globl vector116
 vector116:
   pushl $0
-c0102b3b:	6a 00                	push   $0x0
+c0102978:	6a 00                	push   $0x0
   pushl $116
-c0102b3d:	6a 74                	push   $0x74
+c010297a:	6a 74                	push   $0x74
   jmp __alltraps
-c0102b3f:	e9 63 06 00 00       	jmp    c01031a7 <__alltraps>
+c010297c:	e9 63 06 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102b44 <vector117>:
+c0102981 <vector117>:
 .globl vector117
 vector117:
   pushl $0
-c0102b44:	6a 00                	push   $0x0
+c0102981:	6a 00                	push   $0x0
   pushl $117
-c0102b46:	6a 75                	push   $0x75
+c0102983:	6a 75                	push   $0x75
   jmp __alltraps
-c0102b48:	e9 5a 06 00 00       	jmp    c01031a7 <__alltraps>
+c0102985:	e9 5a 06 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102b4d <vector118>:
+c010298a <vector118>:
 .globl vector118
 vector118:
   pushl $0
-c0102b4d:	6a 00                	push   $0x0
+c010298a:	6a 00                	push   $0x0
   pushl $118
-c0102b4f:	6a 76                	push   $0x76
+c010298c:	6a 76                	push   $0x76
   jmp __alltraps
-c0102b51:	e9 51 06 00 00       	jmp    c01031a7 <__alltraps>
+c010298e:	e9 51 06 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102b56 <vector119>:
+c0102993 <vector119>:
 .globl vector119
 vector119:
   pushl $0
-c0102b56:	6a 00                	push   $0x0
+c0102993:	6a 00                	push   $0x0
   pushl $119
-c0102b58:	6a 77                	push   $0x77
+c0102995:	6a 77                	push   $0x77
   jmp __alltraps
-c0102b5a:	e9 48 06 00 00       	jmp    c01031a7 <__alltraps>
+c0102997:	e9 48 06 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102b5f <vector120>:
+c010299c <vector120>:
 .globl vector120
 vector120:
   pushl $0
-c0102b5f:	6a 00                	push   $0x0
+c010299c:	6a 00                	push   $0x0
   pushl $120
-c0102b61:	6a 78                	push   $0x78
+c010299e:	6a 78                	push   $0x78
   jmp __alltraps
-c0102b63:	e9 3f 06 00 00       	jmp    c01031a7 <__alltraps>
+c01029a0:	e9 3f 06 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102b68 <vector121>:
+c01029a5 <vector121>:
 .globl vector121
 vector121:
   pushl $0
-c0102b68:	6a 00                	push   $0x0
+c01029a5:	6a 00                	push   $0x0
   pushl $121
-c0102b6a:	6a 79                	push   $0x79
+c01029a7:	6a 79                	push   $0x79
   jmp __alltraps
-c0102b6c:	e9 36 06 00 00       	jmp    c01031a7 <__alltraps>
+c01029a9:	e9 36 06 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102b71 <vector122>:
+c01029ae <vector122>:
 .globl vector122
 vector122:
   pushl $0
-c0102b71:	6a 00                	push   $0x0
+c01029ae:	6a 00                	push   $0x0
   pushl $122
-c0102b73:	6a 7a                	push   $0x7a
+c01029b0:	6a 7a                	push   $0x7a
   jmp __alltraps
-c0102b75:	e9 2d 06 00 00       	jmp    c01031a7 <__alltraps>
+c01029b2:	e9 2d 06 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102b7a <vector123>:
+c01029b7 <vector123>:
 .globl vector123
 vector123:
   pushl $0
-c0102b7a:	6a 00                	push   $0x0
+c01029b7:	6a 00                	push   $0x0
   pushl $123
-c0102b7c:	6a 7b                	push   $0x7b
+c01029b9:	6a 7b                	push   $0x7b
   jmp __alltraps
-c0102b7e:	e9 24 06 00 00       	jmp    c01031a7 <__alltraps>
+c01029bb:	e9 24 06 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102b83 <vector124>:
+c01029c0 <vector124>:
 .globl vector124
 vector124:
   pushl $0
-c0102b83:	6a 00                	push   $0x0
+c01029c0:	6a 00                	push   $0x0
   pushl $124
-c0102b85:	6a 7c                	push   $0x7c
+c01029c2:	6a 7c                	push   $0x7c
   jmp __alltraps
-c0102b87:	e9 1b 06 00 00       	jmp    c01031a7 <__alltraps>
+c01029c4:	e9 1b 06 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102b8c <vector125>:
+c01029c9 <vector125>:
 .globl vector125
 vector125:
   pushl $0
-c0102b8c:	6a 00                	push   $0x0
+c01029c9:	6a 00                	push   $0x0
   pushl $125
-c0102b8e:	6a 7d                	push   $0x7d
+c01029cb:	6a 7d                	push   $0x7d
   jmp __alltraps
-c0102b90:	e9 12 06 00 00       	jmp    c01031a7 <__alltraps>
+c01029cd:	e9 12 06 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102b95 <vector126>:
+c01029d2 <vector126>:
 .globl vector126
 vector126:
   pushl $0
-c0102b95:	6a 00                	push   $0x0
+c01029d2:	6a 00                	push   $0x0
   pushl $126
-c0102b97:	6a 7e                	push   $0x7e
+c01029d4:	6a 7e                	push   $0x7e
   jmp __alltraps
-c0102b99:	e9 09 06 00 00       	jmp    c01031a7 <__alltraps>
+c01029d6:	e9 09 06 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102b9e <vector127>:
+c01029db <vector127>:
 .globl vector127
 vector127:
   pushl $0
-c0102b9e:	6a 00                	push   $0x0
+c01029db:	6a 00                	push   $0x0
   pushl $127
-c0102ba0:	6a 7f                	push   $0x7f
+c01029dd:	6a 7f                	push   $0x7f
   jmp __alltraps
-c0102ba2:	e9 00 06 00 00       	jmp    c01031a7 <__alltraps>
+c01029df:	e9 00 06 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102ba7 <vector128>:
+c01029e4 <vector128>:
 .globl vector128
 vector128:
   pushl $0
-c0102ba7:	6a 00                	push   $0x0
+c01029e4:	6a 00                	push   $0x0
   pushl $128
-c0102ba9:	68 80 00 00 00       	push   $0x80
+c01029e6:	68 80 00 00 00       	push   $0x80
   jmp __alltraps
-c0102bae:	e9 f4 05 00 00       	jmp    c01031a7 <__alltraps>
+c01029eb:	e9 f4 05 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102bb3 <vector129>:
+c01029f0 <vector129>:
 .globl vector129
 vector129:
   pushl $0
-c0102bb3:	6a 00                	push   $0x0
+c01029f0:	6a 00                	push   $0x0
   pushl $129
-c0102bb5:	68 81 00 00 00       	push   $0x81
+c01029f2:	68 81 00 00 00       	push   $0x81
   jmp __alltraps
-c0102bba:	e9 e8 05 00 00       	jmp    c01031a7 <__alltraps>
+c01029f7:	e9 e8 05 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102bbf <vector130>:
+c01029fc <vector130>:
 .globl vector130
 vector130:
   pushl $0
-c0102bbf:	6a 00                	push   $0x0
+c01029fc:	6a 00                	push   $0x0
   pushl $130
-c0102bc1:	68 82 00 00 00       	push   $0x82
+c01029fe:	68 82 00 00 00       	push   $0x82
   jmp __alltraps
-c0102bc6:	e9 dc 05 00 00       	jmp    c01031a7 <__alltraps>
+c0102a03:	e9 dc 05 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102bcb <vector131>:
+c0102a08 <vector131>:
 .globl vector131
 vector131:
   pushl $0
-c0102bcb:	6a 00                	push   $0x0
+c0102a08:	6a 00                	push   $0x0
   pushl $131
-c0102bcd:	68 83 00 00 00       	push   $0x83
+c0102a0a:	68 83 00 00 00       	push   $0x83
   jmp __alltraps
-c0102bd2:	e9 d0 05 00 00       	jmp    c01031a7 <__alltraps>
+c0102a0f:	e9 d0 05 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102bd7 <vector132>:
+c0102a14 <vector132>:
 .globl vector132
 vector132:
   pushl $0
-c0102bd7:	6a 00                	push   $0x0
+c0102a14:	6a 00                	push   $0x0
   pushl $132
-c0102bd9:	68 84 00 00 00       	push   $0x84
+c0102a16:	68 84 00 00 00       	push   $0x84
   jmp __alltraps
-c0102bde:	e9 c4 05 00 00       	jmp    c01031a7 <__alltraps>
+c0102a1b:	e9 c4 05 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102be3 <vector133>:
+c0102a20 <vector133>:
 .globl vector133
 vector133:
   pushl $0
-c0102be3:	6a 00                	push   $0x0
+c0102a20:	6a 00                	push   $0x0
   pushl $133
-c0102be5:	68 85 00 00 00       	push   $0x85
+c0102a22:	68 85 00 00 00       	push   $0x85
   jmp __alltraps
-c0102bea:	e9 b8 05 00 00       	jmp    c01031a7 <__alltraps>
+c0102a27:	e9 b8 05 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102bef <vector134>:
+c0102a2c <vector134>:
 .globl vector134
 vector134:
   pushl $0
-c0102bef:	6a 00                	push   $0x0
+c0102a2c:	6a 00                	push   $0x0
   pushl $134
-c0102bf1:	68 86 00 00 00       	push   $0x86
+c0102a2e:	68 86 00 00 00       	push   $0x86
   jmp __alltraps
-c0102bf6:	e9 ac 05 00 00       	jmp    c01031a7 <__alltraps>
+c0102a33:	e9 ac 05 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102bfb <vector135>:
+c0102a38 <vector135>:
 .globl vector135
 vector135:
   pushl $0
-c0102bfb:	6a 00                	push   $0x0
+c0102a38:	6a 00                	push   $0x0
   pushl $135
-c0102bfd:	68 87 00 00 00       	push   $0x87
+c0102a3a:	68 87 00 00 00       	push   $0x87
   jmp __alltraps
-c0102c02:	e9 a0 05 00 00       	jmp    c01031a7 <__alltraps>
+c0102a3f:	e9 a0 05 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102c07 <vector136>:
+c0102a44 <vector136>:
 .globl vector136
 vector136:
   pushl $0
-c0102c07:	6a 00                	push   $0x0
+c0102a44:	6a 00                	push   $0x0
   pushl $136
-c0102c09:	68 88 00 00 00       	push   $0x88
+c0102a46:	68 88 00 00 00       	push   $0x88
   jmp __alltraps
-c0102c0e:	e9 94 05 00 00       	jmp    c01031a7 <__alltraps>
+c0102a4b:	e9 94 05 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102c13 <vector137>:
+c0102a50 <vector137>:
 .globl vector137
 vector137:
   pushl $0
-c0102c13:	6a 00                	push   $0x0
+c0102a50:	6a 00                	push   $0x0
   pushl $137
-c0102c15:	68 89 00 00 00       	push   $0x89
+c0102a52:	68 89 00 00 00       	push   $0x89
   jmp __alltraps
-c0102c1a:	e9 88 05 00 00       	jmp    c01031a7 <__alltraps>
+c0102a57:	e9 88 05 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102c1f <vector138>:
+c0102a5c <vector138>:
 .globl vector138
 vector138:
   pushl $0
-c0102c1f:	6a 00                	push   $0x0
+c0102a5c:	6a 00                	push   $0x0
   pushl $138
-c0102c21:	68 8a 00 00 00       	push   $0x8a
+c0102a5e:	68 8a 00 00 00       	push   $0x8a
   jmp __alltraps
-c0102c26:	e9 7c 05 00 00       	jmp    c01031a7 <__alltraps>
+c0102a63:	e9 7c 05 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102c2b <vector139>:
+c0102a68 <vector139>:
 .globl vector139
 vector139:
   pushl $0
-c0102c2b:	6a 00                	push   $0x0
+c0102a68:	6a 00                	push   $0x0
   pushl $139
-c0102c2d:	68 8b 00 00 00       	push   $0x8b
+c0102a6a:	68 8b 00 00 00       	push   $0x8b
   jmp __alltraps
-c0102c32:	e9 70 05 00 00       	jmp    c01031a7 <__alltraps>
+c0102a6f:	e9 70 05 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102c37 <vector140>:
+c0102a74 <vector140>:
 .globl vector140
 vector140:
   pushl $0
-c0102c37:	6a 00                	push   $0x0
+c0102a74:	6a 00                	push   $0x0
   pushl $140
-c0102c39:	68 8c 00 00 00       	push   $0x8c
+c0102a76:	68 8c 00 00 00       	push   $0x8c
   jmp __alltraps
-c0102c3e:	e9 64 05 00 00       	jmp    c01031a7 <__alltraps>
+c0102a7b:	e9 64 05 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102c43 <vector141>:
+c0102a80 <vector141>:
 .globl vector141
 vector141:
   pushl $0
-c0102c43:	6a 00                	push   $0x0
+c0102a80:	6a 00                	push   $0x0
   pushl $141
-c0102c45:	68 8d 00 00 00       	push   $0x8d
+c0102a82:	68 8d 00 00 00       	push   $0x8d
   jmp __alltraps
-c0102c4a:	e9 58 05 00 00       	jmp    c01031a7 <__alltraps>
+c0102a87:	e9 58 05 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102c4f <vector142>:
+c0102a8c <vector142>:
 .globl vector142
 vector142:
   pushl $0
-c0102c4f:	6a 00                	push   $0x0
+c0102a8c:	6a 00                	push   $0x0
   pushl $142
-c0102c51:	68 8e 00 00 00       	push   $0x8e
+c0102a8e:	68 8e 00 00 00       	push   $0x8e
   jmp __alltraps
-c0102c56:	e9 4c 05 00 00       	jmp    c01031a7 <__alltraps>
+c0102a93:	e9 4c 05 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102c5b <vector143>:
+c0102a98 <vector143>:
 .globl vector143
 vector143:
   pushl $0
-c0102c5b:	6a 00                	push   $0x0
+c0102a98:	6a 00                	push   $0x0
   pushl $143
-c0102c5d:	68 8f 00 00 00       	push   $0x8f
+c0102a9a:	68 8f 00 00 00       	push   $0x8f
   jmp __alltraps
-c0102c62:	e9 40 05 00 00       	jmp    c01031a7 <__alltraps>
+c0102a9f:	e9 40 05 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102c67 <vector144>:
+c0102aa4 <vector144>:
 .globl vector144
 vector144:
   pushl $0
-c0102c67:	6a 00                	push   $0x0
+c0102aa4:	6a 00                	push   $0x0
   pushl $144
-c0102c69:	68 90 00 00 00       	push   $0x90
+c0102aa6:	68 90 00 00 00       	push   $0x90
   jmp __alltraps
-c0102c6e:	e9 34 05 00 00       	jmp    c01031a7 <__alltraps>
+c0102aab:	e9 34 05 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102c73 <vector145>:
+c0102ab0 <vector145>:
 .globl vector145
 vector145:
   pushl $0
-c0102c73:	6a 00                	push   $0x0
+c0102ab0:	6a 00                	push   $0x0
   pushl $145
-c0102c75:	68 91 00 00 00       	push   $0x91
+c0102ab2:	68 91 00 00 00       	push   $0x91
   jmp __alltraps
-c0102c7a:	e9 28 05 00 00       	jmp    c01031a7 <__alltraps>
+c0102ab7:	e9 28 05 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102c7f <vector146>:
+c0102abc <vector146>:
 .globl vector146
 vector146:
   pushl $0
-c0102c7f:	6a 00                	push   $0x0
+c0102abc:	6a 00                	push   $0x0
   pushl $146
-c0102c81:	68 92 00 00 00       	push   $0x92
+c0102abe:	68 92 00 00 00       	push   $0x92
   jmp __alltraps
-c0102c86:	e9 1c 05 00 00       	jmp    c01031a7 <__alltraps>
+c0102ac3:	e9 1c 05 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102c8b <vector147>:
+c0102ac8 <vector147>:
 .globl vector147
 vector147:
   pushl $0
-c0102c8b:	6a 00                	push   $0x0
+c0102ac8:	6a 00                	push   $0x0
   pushl $147
-c0102c8d:	68 93 00 00 00       	push   $0x93
+c0102aca:	68 93 00 00 00       	push   $0x93
   jmp __alltraps
-c0102c92:	e9 10 05 00 00       	jmp    c01031a7 <__alltraps>
+c0102acf:	e9 10 05 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102c97 <vector148>:
+c0102ad4 <vector148>:
 .globl vector148
 vector148:
   pushl $0
-c0102c97:	6a 00                	push   $0x0
+c0102ad4:	6a 00                	push   $0x0
   pushl $148
-c0102c99:	68 94 00 00 00       	push   $0x94
+c0102ad6:	68 94 00 00 00       	push   $0x94
   jmp __alltraps
-c0102c9e:	e9 04 05 00 00       	jmp    c01031a7 <__alltraps>
+c0102adb:	e9 04 05 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102ca3 <vector149>:
+c0102ae0 <vector149>:
 .globl vector149
 vector149:
   pushl $0
-c0102ca3:	6a 00                	push   $0x0
+c0102ae0:	6a 00                	push   $0x0
   pushl $149
-c0102ca5:	68 95 00 00 00       	push   $0x95
+c0102ae2:	68 95 00 00 00       	push   $0x95
   jmp __alltraps
-c0102caa:	e9 f8 04 00 00       	jmp    c01031a7 <__alltraps>
+c0102ae7:	e9 f8 04 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102caf <vector150>:
+c0102aec <vector150>:
 .globl vector150
 vector150:
   pushl $0
-c0102caf:	6a 00                	push   $0x0
+c0102aec:	6a 00                	push   $0x0
   pushl $150
-c0102cb1:	68 96 00 00 00       	push   $0x96
+c0102aee:	68 96 00 00 00       	push   $0x96
   jmp __alltraps
-c0102cb6:	e9 ec 04 00 00       	jmp    c01031a7 <__alltraps>
+c0102af3:	e9 ec 04 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102cbb <vector151>:
+c0102af8 <vector151>:
 .globl vector151
 vector151:
   pushl $0
-c0102cbb:	6a 00                	push   $0x0
+c0102af8:	6a 00                	push   $0x0
   pushl $151
-c0102cbd:	68 97 00 00 00       	push   $0x97
+c0102afa:	68 97 00 00 00       	push   $0x97
   jmp __alltraps
-c0102cc2:	e9 e0 04 00 00       	jmp    c01031a7 <__alltraps>
+c0102aff:	e9 e0 04 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102cc7 <vector152>:
+c0102b04 <vector152>:
 .globl vector152
 vector152:
   pushl $0
-c0102cc7:	6a 00                	push   $0x0
+c0102b04:	6a 00                	push   $0x0
   pushl $152
-c0102cc9:	68 98 00 00 00       	push   $0x98
+c0102b06:	68 98 00 00 00       	push   $0x98
   jmp __alltraps
-c0102cce:	e9 d4 04 00 00       	jmp    c01031a7 <__alltraps>
+c0102b0b:	e9 d4 04 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102cd3 <vector153>:
+c0102b10 <vector153>:
 .globl vector153
 vector153:
   pushl $0
-c0102cd3:	6a 00                	push   $0x0
+c0102b10:	6a 00                	push   $0x0
   pushl $153
-c0102cd5:	68 99 00 00 00       	push   $0x99
+c0102b12:	68 99 00 00 00       	push   $0x99
   jmp __alltraps
-c0102cda:	e9 c8 04 00 00       	jmp    c01031a7 <__alltraps>
+c0102b17:	e9 c8 04 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102cdf <vector154>:
+c0102b1c <vector154>:
 .globl vector154
 vector154:
   pushl $0
-c0102cdf:	6a 00                	push   $0x0
+c0102b1c:	6a 00                	push   $0x0
   pushl $154
-c0102ce1:	68 9a 00 00 00       	push   $0x9a
+c0102b1e:	68 9a 00 00 00       	push   $0x9a
   jmp __alltraps
-c0102ce6:	e9 bc 04 00 00       	jmp    c01031a7 <__alltraps>
+c0102b23:	e9 bc 04 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102ceb <vector155>:
+c0102b28 <vector155>:
 .globl vector155
 vector155:
   pushl $0
-c0102ceb:	6a 00                	push   $0x0
+c0102b28:	6a 00                	push   $0x0
   pushl $155
-c0102ced:	68 9b 00 00 00       	push   $0x9b
+c0102b2a:	68 9b 00 00 00       	push   $0x9b
   jmp __alltraps
-c0102cf2:	e9 b0 04 00 00       	jmp    c01031a7 <__alltraps>
+c0102b2f:	e9 b0 04 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102cf7 <vector156>:
+c0102b34 <vector156>:
 .globl vector156
 vector156:
   pushl $0
-c0102cf7:	6a 00                	push   $0x0
+c0102b34:	6a 00                	push   $0x0
   pushl $156
-c0102cf9:	68 9c 00 00 00       	push   $0x9c
+c0102b36:	68 9c 00 00 00       	push   $0x9c
   jmp __alltraps
-c0102cfe:	e9 a4 04 00 00       	jmp    c01031a7 <__alltraps>
+c0102b3b:	e9 a4 04 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102d03 <vector157>:
+c0102b40 <vector157>:
 .globl vector157
 vector157:
   pushl $0
-c0102d03:	6a 00                	push   $0x0
+c0102b40:	6a 00                	push   $0x0
   pushl $157
-c0102d05:	68 9d 00 00 00       	push   $0x9d
+c0102b42:	68 9d 00 00 00       	push   $0x9d
   jmp __alltraps
-c0102d0a:	e9 98 04 00 00       	jmp    c01031a7 <__alltraps>
+c0102b47:	e9 98 04 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102d0f <vector158>:
+c0102b4c <vector158>:
 .globl vector158
 vector158:
   pushl $0
-c0102d0f:	6a 00                	push   $0x0
+c0102b4c:	6a 00                	push   $0x0
   pushl $158
-c0102d11:	68 9e 00 00 00       	push   $0x9e
+c0102b4e:	68 9e 00 00 00       	push   $0x9e
   jmp __alltraps
-c0102d16:	e9 8c 04 00 00       	jmp    c01031a7 <__alltraps>
+c0102b53:	e9 8c 04 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102d1b <vector159>:
+c0102b58 <vector159>:
 .globl vector159
 vector159:
   pushl $0
-c0102d1b:	6a 00                	push   $0x0
+c0102b58:	6a 00                	push   $0x0
   pushl $159
-c0102d1d:	68 9f 00 00 00       	push   $0x9f
+c0102b5a:	68 9f 00 00 00       	push   $0x9f
   jmp __alltraps
-c0102d22:	e9 80 04 00 00       	jmp    c01031a7 <__alltraps>
+c0102b5f:	e9 80 04 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102d27 <vector160>:
+c0102b64 <vector160>:
 .globl vector160
 vector160:
   pushl $0
-c0102d27:	6a 00                	push   $0x0
+c0102b64:	6a 00                	push   $0x0
   pushl $160
-c0102d29:	68 a0 00 00 00       	push   $0xa0
+c0102b66:	68 a0 00 00 00       	push   $0xa0
   jmp __alltraps
-c0102d2e:	e9 74 04 00 00       	jmp    c01031a7 <__alltraps>
+c0102b6b:	e9 74 04 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102d33 <vector161>:
+c0102b70 <vector161>:
 .globl vector161
 vector161:
   pushl $0
-c0102d33:	6a 00                	push   $0x0
+c0102b70:	6a 00                	push   $0x0
   pushl $161
-c0102d35:	68 a1 00 00 00       	push   $0xa1
+c0102b72:	68 a1 00 00 00       	push   $0xa1
   jmp __alltraps
-c0102d3a:	e9 68 04 00 00       	jmp    c01031a7 <__alltraps>
+c0102b77:	e9 68 04 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102d3f <vector162>:
+c0102b7c <vector162>:
 .globl vector162
 vector162:
   pushl $0
-c0102d3f:	6a 00                	push   $0x0
+c0102b7c:	6a 00                	push   $0x0
   pushl $162
-c0102d41:	68 a2 00 00 00       	push   $0xa2
+c0102b7e:	68 a2 00 00 00       	push   $0xa2
   jmp __alltraps
-c0102d46:	e9 5c 04 00 00       	jmp    c01031a7 <__alltraps>
+c0102b83:	e9 5c 04 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102d4b <vector163>:
+c0102b88 <vector163>:
 .globl vector163
 vector163:
   pushl $0
-c0102d4b:	6a 00                	push   $0x0
+c0102b88:	6a 00                	push   $0x0
   pushl $163
-c0102d4d:	68 a3 00 00 00       	push   $0xa3
+c0102b8a:	68 a3 00 00 00       	push   $0xa3
   jmp __alltraps
-c0102d52:	e9 50 04 00 00       	jmp    c01031a7 <__alltraps>
+c0102b8f:	e9 50 04 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102d57 <vector164>:
+c0102b94 <vector164>:
 .globl vector164
 vector164:
   pushl $0
-c0102d57:	6a 00                	push   $0x0
+c0102b94:	6a 00                	push   $0x0
   pushl $164
-c0102d59:	68 a4 00 00 00       	push   $0xa4
+c0102b96:	68 a4 00 00 00       	push   $0xa4
   jmp __alltraps
-c0102d5e:	e9 44 04 00 00       	jmp    c01031a7 <__alltraps>
+c0102b9b:	e9 44 04 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102d63 <vector165>:
+c0102ba0 <vector165>:
 .globl vector165
 vector165:
   pushl $0
-c0102d63:	6a 00                	push   $0x0
+c0102ba0:	6a 00                	push   $0x0
   pushl $165
-c0102d65:	68 a5 00 00 00       	push   $0xa5
+c0102ba2:	68 a5 00 00 00       	push   $0xa5
   jmp __alltraps
-c0102d6a:	e9 38 04 00 00       	jmp    c01031a7 <__alltraps>
+c0102ba7:	e9 38 04 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102d6f <vector166>:
+c0102bac <vector166>:
 .globl vector166
 vector166:
   pushl $0
-c0102d6f:	6a 00                	push   $0x0
+c0102bac:	6a 00                	push   $0x0
   pushl $166
-c0102d71:	68 a6 00 00 00       	push   $0xa6
+c0102bae:	68 a6 00 00 00       	push   $0xa6
   jmp __alltraps
-c0102d76:	e9 2c 04 00 00       	jmp    c01031a7 <__alltraps>
+c0102bb3:	e9 2c 04 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102d7b <vector167>:
+c0102bb8 <vector167>:
 .globl vector167
 vector167:
   pushl $0
-c0102d7b:	6a 00                	push   $0x0
+c0102bb8:	6a 00                	push   $0x0
   pushl $167
-c0102d7d:	68 a7 00 00 00       	push   $0xa7
+c0102bba:	68 a7 00 00 00       	push   $0xa7
   jmp __alltraps
-c0102d82:	e9 20 04 00 00       	jmp    c01031a7 <__alltraps>
+c0102bbf:	e9 20 04 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102d87 <vector168>:
+c0102bc4 <vector168>:
 .globl vector168
 vector168:
   pushl $0
-c0102d87:	6a 00                	push   $0x0
+c0102bc4:	6a 00                	push   $0x0
   pushl $168
-c0102d89:	68 a8 00 00 00       	push   $0xa8
+c0102bc6:	68 a8 00 00 00       	push   $0xa8
   jmp __alltraps
-c0102d8e:	e9 14 04 00 00       	jmp    c01031a7 <__alltraps>
+c0102bcb:	e9 14 04 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102d93 <vector169>:
+c0102bd0 <vector169>:
 .globl vector169
 vector169:
   pushl $0
-c0102d93:	6a 00                	push   $0x0
+c0102bd0:	6a 00                	push   $0x0
   pushl $169
-c0102d95:	68 a9 00 00 00       	push   $0xa9
+c0102bd2:	68 a9 00 00 00       	push   $0xa9
   jmp __alltraps
-c0102d9a:	e9 08 04 00 00       	jmp    c01031a7 <__alltraps>
+c0102bd7:	e9 08 04 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102d9f <vector170>:
+c0102bdc <vector170>:
 .globl vector170
 vector170:
   pushl $0
-c0102d9f:	6a 00                	push   $0x0
+c0102bdc:	6a 00                	push   $0x0
   pushl $170
-c0102da1:	68 aa 00 00 00       	push   $0xaa
+c0102bde:	68 aa 00 00 00       	push   $0xaa
   jmp __alltraps
-c0102da6:	e9 fc 03 00 00       	jmp    c01031a7 <__alltraps>
+c0102be3:	e9 fc 03 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102dab <vector171>:
+c0102be8 <vector171>:
 .globl vector171
 vector171:
   pushl $0
-c0102dab:	6a 00                	push   $0x0
+c0102be8:	6a 00                	push   $0x0
   pushl $171
-c0102dad:	68 ab 00 00 00       	push   $0xab
+c0102bea:	68 ab 00 00 00       	push   $0xab
   jmp __alltraps
-c0102db2:	e9 f0 03 00 00       	jmp    c01031a7 <__alltraps>
+c0102bef:	e9 f0 03 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102db7 <vector172>:
+c0102bf4 <vector172>:
 .globl vector172
 vector172:
   pushl $0
-c0102db7:	6a 00                	push   $0x0
+c0102bf4:	6a 00                	push   $0x0
   pushl $172
-c0102db9:	68 ac 00 00 00       	push   $0xac
+c0102bf6:	68 ac 00 00 00       	push   $0xac
   jmp __alltraps
-c0102dbe:	e9 e4 03 00 00       	jmp    c01031a7 <__alltraps>
+c0102bfb:	e9 e4 03 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102dc3 <vector173>:
+c0102c00 <vector173>:
 .globl vector173
 vector173:
   pushl $0
-c0102dc3:	6a 00                	push   $0x0
+c0102c00:	6a 00                	push   $0x0
   pushl $173
-c0102dc5:	68 ad 00 00 00       	push   $0xad
+c0102c02:	68 ad 00 00 00       	push   $0xad
   jmp __alltraps
-c0102dca:	e9 d8 03 00 00       	jmp    c01031a7 <__alltraps>
+c0102c07:	e9 d8 03 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102dcf <vector174>:
+c0102c0c <vector174>:
 .globl vector174
 vector174:
   pushl $0
-c0102dcf:	6a 00                	push   $0x0
+c0102c0c:	6a 00                	push   $0x0
   pushl $174
-c0102dd1:	68 ae 00 00 00       	push   $0xae
+c0102c0e:	68 ae 00 00 00       	push   $0xae
   jmp __alltraps
-c0102dd6:	e9 cc 03 00 00       	jmp    c01031a7 <__alltraps>
+c0102c13:	e9 cc 03 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102ddb <vector175>:
+c0102c18 <vector175>:
 .globl vector175
 vector175:
   pushl $0
-c0102ddb:	6a 00                	push   $0x0
+c0102c18:	6a 00                	push   $0x0
   pushl $175
-c0102ddd:	68 af 00 00 00       	push   $0xaf
+c0102c1a:	68 af 00 00 00       	push   $0xaf
   jmp __alltraps
-c0102de2:	e9 c0 03 00 00       	jmp    c01031a7 <__alltraps>
+c0102c1f:	e9 c0 03 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102de7 <vector176>:
+c0102c24 <vector176>:
 .globl vector176
 vector176:
   pushl $0
-c0102de7:	6a 00                	push   $0x0
+c0102c24:	6a 00                	push   $0x0
   pushl $176
-c0102de9:	68 b0 00 00 00       	push   $0xb0
+c0102c26:	68 b0 00 00 00       	push   $0xb0
   jmp __alltraps
-c0102dee:	e9 b4 03 00 00       	jmp    c01031a7 <__alltraps>
+c0102c2b:	e9 b4 03 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102df3 <vector177>:
+c0102c30 <vector177>:
 .globl vector177
 vector177:
   pushl $0
-c0102df3:	6a 00                	push   $0x0
+c0102c30:	6a 00                	push   $0x0
   pushl $177
-c0102df5:	68 b1 00 00 00       	push   $0xb1
+c0102c32:	68 b1 00 00 00       	push   $0xb1
   jmp __alltraps
-c0102dfa:	e9 a8 03 00 00       	jmp    c01031a7 <__alltraps>
+c0102c37:	e9 a8 03 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102dff <vector178>:
+c0102c3c <vector178>:
 .globl vector178
 vector178:
   pushl $0
-c0102dff:	6a 00                	push   $0x0
+c0102c3c:	6a 00                	push   $0x0
   pushl $178
-c0102e01:	68 b2 00 00 00       	push   $0xb2
+c0102c3e:	68 b2 00 00 00       	push   $0xb2
   jmp __alltraps
-c0102e06:	e9 9c 03 00 00       	jmp    c01031a7 <__alltraps>
+c0102c43:	e9 9c 03 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102e0b <vector179>:
+c0102c48 <vector179>:
 .globl vector179
 vector179:
   pushl $0
-c0102e0b:	6a 00                	push   $0x0
+c0102c48:	6a 00                	push   $0x0
   pushl $179
-c0102e0d:	68 b3 00 00 00       	push   $0xb3
+c0102c4a:	68 b3 00 00 00       	push   $0xb3
   jmp __alltraps
-c0102e12:	e9 90 03 00 00       	jmp    c01031a7 <__alltraps>
+c0102c4f:	e9 90 03 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102e17 <vector180>:
+c0102c54 <vector180>:
 .globl vector180
 vector180:
   pushl $0
-c0102e17:	6a 00                	push   $0x0
+c0102c54:	6a 00                	push   $0x0
   pushl $180
-c0102e19:	68 b4 00 00 00       	push   $0xb4
+c0102c56:	68 b4 00 00 00       	push   $0xb4
   jmp __alltraps
-c0102e1e:	e9 84 03 00 00       	jmp    c01031a7 <__alltraps>
+c0102c5b:	e9 84 03 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102e23 <vector181>:
+c0102c60 <vector181>:
 .globl vector181
 vector181:
   pushl $0
-c0102e23:	6a 00                	push   $0x0
+c0102c60:	6a 00                	push   $0x0
   pushl $181
-c0102e25:	68 b5 00 00 00       	push   $0xb5
+c0102c62:	68 b5 00 00 00       	push   $0xb5
   jmp __alltraps
-c0102e2a:	e9 78 03 00 00       	jmp    c01031a7 <__alltraps>
+c0102c67:	e9 78 03 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102e2f <vector182>:
+c0102c6c <vector182>:
 .globl vector182
 vector182:
   pushl $0
-c0102e2f:	6a 00                	push   $0x0
+c0102c6c:	6a 00                	push   $0x0
   pushl $182
-c0102e31:	68 b6 00 00 00       	push   $0xb6
+c0102c6e:	68 b6 00 00 00       	push   $0xb6
   jmp __alltraps
-c0102e36:	e9 6c 03 00 00       	jmp    c01031a7 <__alltraps>
+c0102c73:	e9 6c 03 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102e3b <vector183>:
+c0102c78 <vector183>:
 .globl vector183
 vector183:
   pushl $0
-c0102e3b:	6a 00                	push   $0x0
+c0102c78:	6a 00                	push   $0x0
   pushl $183
-c0102e3d:	68 b7 00 00 00       	push   $0xb7
+c0102c7a:	68 b7 00 00 00       	push   $0xb7
   jmp __alltraps
-c0102e42:	e9 60 03 00 00       	jmp    c01031a7 <__alltraps>
+c0102c7f:	e9 60 03 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102e47 <vector184>:
+c0102c84 <vector184>:
 .globl vector184
 vector184:
   pushl $0
-c0102e47:	6a 00                	push   $0x0
+c0102c84:	6a 00                	push   $0x0
   pushl $184
-c0102e49:	68 b8 00 00 00       	push   $0xb8
+c0102c86:	68 b8 00 00 00       	push   $0xb8
   jmp __alltraps
-c0102e4e:	e9 54 03 00 00       	jmp    c01031a7 <__alltraps>
+c0102c8b:	e9 54 03 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102e53 <vector185>:
+c0102c90 <vector185>:
 .globl vector185
 vector185:
   pushl $0
-c0102e53:	6a 00                	push   $0x0
+c0102c90:	6a 00                	push   $0x0
   pushl $185
-c0102e55:	68 b9 00 00 00       	push   $0xb9
+c0102c92:	68 b9 00 00 00       	push   $0xb9
   jmp __alltraps
-c0102e5a:	e9 48 03 00 00       	jmp    c01031a7 <__alltraps>
+c0102c97:	e9 48 03 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102e5f <vector186>:
+c0102c9c <vector186>:
 .globl vector186
 vector186:
   pushl $0
-c0102e5f:	6a 00                	push   $0x0
+c0102c9c:	6a 00                	push   $0x0
   pushl $186
-c0102e61:	68 ba 00 00 00       	push   $0xba
+c0102c9e:	68 ba 00 00 00       	push   $0xba
   jmp __alltraps
-c0102e66:	e9 3c 03 00 00       	jmp    c01031a7 <__alltraps>
+c0102ca3:	e9 3c 03 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102e6b <vector187>:
+c0102ca8 <vector187>:
 .globl vector187
 vector187:
   pushl $0
-c0102e6b:	6a 00                	push   $0x0
+c0102ca8:	6a 00                	push   $0x0
   pushl $187
-c0102e6d:	68 bb 00 00 00       	push   $0xbb
+c0102caa:	68 bb 00 00 00       	push   $0xbb
   jmp __alltraps
-c0102e72:	e9 30 03 00 00       	jmp    c01031a7 <__alltraps>
+c0102caf:	e9 30 03 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102e77 <vector188>:
+c0102cb4 <vector188>:
 .globl vector188
 vector188:
   pushl $0
-c0102e77:	6a 00                	push   $0x0
+c0102cb4:	6a 00                	push   $0x0
   pushl $188
-c0102e79:	68 bc 00 00 00       	push   $0xbc
+c0102cb6:	68 bc 00 00 00       	push   $0xbc
   jmp __alltraps
-c0102e7e:	e9 24 03 00 00       	jmp    c01031a7 <__alltraps>
+c0102cbb:	e9 24 03 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102e83 <vector189>:
+c0102cc0 <vector189>:
 .globl vector189
 vector189:
   pushl $0
-c0102e83:	6a 00                	push   $0x0
+c0102cc0:	6a 00                	push   $0x0
   pushl $189
-c0102e85:	68 bd 00 00 00       	push   $0xbd
+c0102cc2:	68 bd 00 00 00       	push   $0xbd
   jmp __alltraps
-c0102e8a:	e9 18 03 00 00       	jmp    c01031a7 <__alltraps>
+c0102cc7:	e9 18 03 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102e8f <vector190>:
+c0102ccc <vector190>:
 .globl vector190
 vector190:
   pushl $0
-c0102e8f:	6a 00                	push   $0x0
+c0102ccc:	6a 00                	push   $0x0
   pushl $190
-c0102e91:	68 be 00 00 00       	push   $0xbe
+c0102cce:	68 be 00 00 00       	push   $0xbe
   jmp __alltraps
-c0102e96:	e9 0c 03 00 00       	jmp    c01031a7 <__alltraps>
+c0102cd3:	e9 0c 03 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102e9b <vector191>:
+c0102cd8 <vector191>:
 .globl vector191
 vector191:
   pushl $0
-c0102e9b:	6a 00                	push   $0x0
+c0102cd8:	6a 00                	push   $0x0
   pushl $191
-c0102e9d:	68 bf 00 00 00       	push   $0xbf
+c0102cda:	68 bf 00 00 00       	push   $0xbf
   jmp __alltraps
-c0102ea2:	e9 00 03 00 00       	jmp    c01031a7 <__alltraps>
+c0102cdf:	e9 00 03 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102ea7 <vector192>:
+c0102ce4 <vector192>:
 .globl vector192
 vector192:
   pushl $0
-c0102ea7:	6a 00                	push   $0x0
+c0102ce4:	6a 00                	push   $0x0
   pushl $192
-c0102ea9:	68 c0 00 00 00       	push   $0xc0
+c0102ce6:	68 c0 00 00 00       	push   $0xc0
   jmp __alltraps
-c0102eae:	e9 f4 02 00 00       	jmp    c01031a7 <__alltraps>
+c0102ceb:	e9 f4 02 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102eb3 <vector193>:
+c0102cf0 <vector193>:
 .globl vector193
 vector193:
   pushl $0
-c0102eb3:	6a 00                	push   $0x0
+c0102cf0:	6a 00                	push   $0x0
   pushl $193
-c0102eb5:	68 c1 00 00 00       	push   $0xc1
+c0102cf2:	68 c1 00 00 00       	push   $0xc1
   jmp __alltraps
-c0102eba:	e9 e8 02 00 00       	jmp    c01031a7 <__alltraps>
+c0102cf7:	e9 e8 02 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102ebf <vector194>:
+c0102cfc <vector194>:
 .globl vector194
 vector194:
   pushl $0
-c0102ebf:	6a 00                	push   $0x0
+c0102cfc:	6a 00                	push   $0x0
   pushl $194
-c0102ec1:	68 c2 00 00 00       	push   $0xc2
+c0102cfe:	68 c2 00 00 00       	push   $0xc2
   jmp __alltraps
-c0102ec6:	e9 dc 02 00 00       	jmp    c01031a7 <__alltraps>
+c0102d03:	e9 dc 02 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102ecb <vector195>:
+c0102d08 <vector195>:
 .globl vector195
 vector195:
   pushl $0
-c0102ecb:	6a 00                	push   $0x0
+c0102d08:	6a 00                	push   $0x0
   pushl $195
-c0102ecd:	68 c3 00 00 00       	push   $0xc3
+c0102d0a:	68 c3 00 00 00       	push   $0xc3
   jmp __alltraps
-c0102ed2:	e9 d0 02 00 00       	jmp    c01031a7 <__alltraps>
+c0102d0f:	e9 d0 02 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102ed7 <vector196>:
+c0102d14 <vector196>:
 .globl vector196
 vector196:
   pushl $0
-c0102ed7:	6a 00                	push   $0x0
+c0102d14:	6a 00                	push   $0x0
   pushl $196
-c0102ed9:	68 c4 00 00 00       	push   $0xc4
+c0102d16:	68 c4 00 00 00       	push   $0xc4
   jmp __alltraps
-c0102ede:	e9 c4 02 00 00       	jmp    c01031a7 <__alltraps>
+c0102d1b:	e9 c4 02 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102ee3 <vector197>:
+c0102d20 <vector197>:
 .globl vector197
 vector197:
   pushl $0
-c0102ee3:	6a 00                	push   $0x0
+c0102d20:	6a 00                	push   $0x0
   pushl $197
-c0102ee5:	68 c5 00 00 00       	push   $0xc5
+c0102d22:	68 c5 00 00 00       	push   $0xc5
   jmp __alltraps
-c0102eea:	e9 b8 02 00 00       	jmp    c01031a7 <__alltraps>
+c0102d27:	e9 b8 02 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102eef <vector198>:
+c0102d2c <vector198>:
 .globl vector198
 vector198:
   pushl $0
-c0102eef:	6a 00                	push   $0x0
+c0102d2c:	6a 00                	push   $0x0
   pushl $198
-c0102ef1:	68 c6 00 00 00       	push   $0xc6
+c0102d2e:	68 c6 00 00 00       	push   $0xc6
   jmp __alltraps
-c0102ef6:	e9 ac 02 00 00       	jmp    c01031a7 <__alltraps>
+c0102d33:	e9 ac 02 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102efb <vector199>:
+c0102d38 <vector199>:
 .globl vector199
 vector199:
   pushl $0
-c0102efb:	6a 00                	push   $0x0
+c0102d38:	6a 00                	push   $0x0
   pushl $199
-c0102efd:	68 c7 00 00 00       	push   $0xc7
+c0102d3a:	68 c7 00 00 00       	push   $0xc7
   jmp __alltraps
-c0102f02:	e9 a0 02 00 00       	jmp    c01031a7 <__alltraps>
+c0102d3f:	e9 a0 02 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102f07 <vector200>:
+c0102d44 <vector200>:
 .globl vector200
 vector200:
   pushl $0
-c0102f07:	6a 00                	push   $0x0
+c0102d44:	6a 00                	push   $0x0
   pushl $200
-c0102f09:	68 c8 00 00 00       	push   $0xc8
+c0102d46:	68 c8 00 00 00       	push   $0xc8
   jmp __alltraps
-c0102f0e:	e9 94 02 00 00       	jmp    c01031a7 <__alltraps>
+c0102d4b:	e9 94 02 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102f13 <vector201>:
+c0102d50 <vector201>:
 .globl vector201
 vector201:
   pushl $0
-c0102f13:	6a 00                	push   $0x0
+c0102d50:	6a 00                	push   $0x0
   pushl $201
-c0102f15:	68 c9 00 00 00       	push   $0xc9
+c0102d52:	68 c9 00 00 00       	push   $0xc9
   jmp __alltraps
-c0102f1a:	e9 88 02 00 00       	jmp    c01031a7 <__alltraps>
+c0102d57:	e9 88 02 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102f1f <vector202>:
+c0102d5c <vector202>:
 .globl vector202
 vector202:
   pushl $0
-c0102f1f:	6a 00                	push   $0x0
+c0102d5c:	6a 00                	push   $0x0
   pushl $202
-c0102f21:	68 ca 00 00 00       	push   $0xca
+c0102d5e:	68 ca 00 00 00       	push   $0xca
   jmp __alltraps
-c0102f26:	e9 7c 02 00 00       	jmp    c01031a7 <__alltraps>
+c0102d63:	e9 7c 02 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102f2b <vector203>:
+c0102d68 <vector203>:
 .globl vector203
 vector203:
   pushl $0
-c0102f2b:	6a 00                	push   $0x0
+c0102d68:	6a 00                	push   $0x0
   pushl $203
-c0102f2d:	68 cb 00 00 00       	push   $0xcb
+c0102d6a:	68 cb 00 00 00       	push   $0xcb
   jmp __alltraps
-c0102f32:	e9 70 02 00 00       	jmp    c01031a7 <__alltraps>
+c0102d6f:	e9 70 02 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102f37 <vector204>:
+c0102d74 <vector204>:
 .globl vector204
 vector204:
   pushl $0
-c0102f37:	6a 00                	push   $0x0
+c0102d74:	6a 00                	push   $0x0
   pushl $204
-c0102f39:	68 cc 00 00 00       	push   $0xcc
+c0102d76:	68 cc 00 00 00       	push   $0xcc
   jmp __alltraps
-c0102f3e:	e9 64 02 00 00       	jmp    c01031a7 <__alltraps>
+c0102d7b:	e9 64 02 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102f43 <vector205>:
+c0102d80 <vector205>:
 .globl vector205
 vector205:
   pushl $0
-c0102f43:	6a 00                	push   $0x0
+c0102d80:	6a 00                	push   $0x0
   pushl $205
-c0102f45:	68 cd 00 00 00       	push   $0xcd
+c0102d82:	68 cd 00 00 00       	push   $0xcd
   jmp __alltraps
-c0102f4a:	e9 58 02 00 00       	jmp    c01031a7 <__alltraps>
+c0102d87:	e9 58 02 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102f4f <vector206>:
+c0102d8c <vector206>:
 .globl vector206
 vector206:
   pushl $0
-c0102f4f:	6a 00                	push   $0x0
+c0102d8c:	6a 00                	push   $0x0
   pushl $206
-c0102f51:	68 ce 00 00 00       	push   $0xce
+c0102d8e:	68 ce 00 00 00       	push   $0xce
   jmp __alltraps
-c0102f56:	e9 4c 02 00 00       	jmp    c01031a7 <__alltraps>
+c0102d93:	e9 4c 02 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102f5b <vector207>:
+c0102d98 <vector207>:
 .globl vector207
 vector207:
   pushl $0
-c0102f5b:	6a 00                	push   $0x0
+c0102d98:	6a 00                	push   $0x0
   pushl $207
-c0102f5d:	68 cf 00 00 00       	push   $0xcf
+c0102d9a:	68 cf 00 00 00       	push   $0xcf
   jmp __alltraps
-c0102f62:	e9 40 02 00 00       	jmp    c01031a7 <__alltraps>
+c0102d9f:	e9 40 02 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102f67 <vector208>:
+c0102da4 <vector208>:
 .globl vector208
 vector208:
   pushl $0
-c0102f67:	6a 00                	push   $0x0
+c0102da4:	6a 00                	push   $0x0
   pushl $208
-c0102f69:	68 d0 00 00 00       	push   $0xd0
+c0102da6:	68 d0 00 00 00       	push   $0xd0
   jmp __alltraps
-c0102f6e:	e9 34 02 00 00       	jmp    c01031a7 <__alltraps>
+c0102dab:	e9 34 02 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102f73 <vector209>:
+c0102db0 <vector209>:
 .globl vector209
 vector209:
   pushl $0
-c0102f73:	6a 00                	push   $0x0
+c0102db0:	6a 00                	push   $0x0
   pushl $209
-c0102f75:	68 d1 00 00 00       	push   $0xd1
+c0102db2:	68 d1 00 00 00       	push   $0xd1
   jmp __alltraps
-c0102f7a:	e9 28 02 00 00       	jmp    c01031a7 <__alltraps>
+c0102db7:	e9 28 02 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102f7f <vector210>:
+c0102dbc <vector210>:
 .globl vector210
 vector210:
   pushl $0
-c0102f7f:	6a 00                	push   $0x0
+c0102dbc:	6a 00                	push   $0x0
   pushl $210
-c0102f81:	68 d2 00 00 00       	push   $0xd2
+c0102dbe:	68 d2 00 00 00       	push   $0xd2
   jmp __alltraps
-c0102f86:	e9 1c 02 00 00       	jmp    c01031a7 <__alltraps>
+c0102dc3:	e9 1c 02 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102f8b <vector211>:
+c0102dc8 <vector211>:
 .globl vector211
 vector211:
   pushl $0
-c0102f8b:	6a 00                	push   $0x0
+c0102dc8:	6a 00                	push   $0x0
   pushl $211
-c0102f8d:	68 d3 00 00 00       	push   $0xd3
+c0102dca:	68 d3 00 00 00       	push   $0xd3
   jmp __alltraps
-c0102f92:	e9 10 02 00 00       	jmp    c01031a7 <__alltraps>
+c0102dcf:	e9 10 02 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102f97 <vector212>:
+c0102dd4 <vector212>:
 .globl vector212
 vector212:
   pushl $0
-c0102f97:	6a 00                	push   $0x0
+c0102dd4:	6a 00                	push   $0x0
   pushl $212
-c0102f99:	68 d4 00 00 00       	push   $0xd4
+c0102dd6:	68 d4 00 00 00       	push   $0xd4
   jmp __alltraps
-c0102f9e:	e9 04 02 00 00       	jmp    c01031a7 <__alltraps>
+c0102ddb:	e9 04 02 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102fa3 <vector213>:
+c0102de0 <vector213>:
 .globl vector213
 vector213:
   pushl $0
-c0102fa3:	6a 00                	push   $0x0
+c0102de0:	6a 00                	push   $0x0
   pushl $213
-c0102fa5:	68 d5 00 00 00       	push   $0xd5
+c0102de2:	68 d5 00 00 00       	push   $0xd5
   jmp __alltraps
-c0102faa:	e9 f8 01 00 00       	jmp    c01031a7 <__alltraps>
+c0102de7:	e9 f8 01 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102faf <vector214>:
+c0102dec <vector214>:
 .globl vector214
 vector214:
   pushl $0
-c0102faf:	6a 00                	push   $0x0
+c0102dec:	6a 00                	push   $0x0
   pushl $214
-c0102fb1:	68 d6 00 00 00       	push   $0xd6
+c0102dee:	68 d6 00 00 00       	push   $0xd6
   jmp __alltraps
-c0102fb6:	e9 ec 01 00 00       	jmp    c01031a7 <__alltraps>
+c0102df3:	e9 ec 01 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102fbb <vector215>:
+c0102df8 <vector215>:
 .globl vector215
 vector215:
   pushl $0
-c0102fbb:	6a 00                	push   $0x0
+c0102df8:	6a 00                	push   $0x0
   pushl $215
-c0102fbd:	68 d7 00 00 00       	push   $0xd7
+c0102dfa:	68 d7 00 00 00       	push   $0xd7
   jmp __alltraps
-c0102fc2:	e9 e0 01 00 00       	jmp    c01031a7 <__alltraps>
+c0102dff:	e9 e0 01 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102fc7 <vector216>:
+c0102e04 <vector216>:
 .globl vector216
 vector216:
   pushl $0
-c0102fc7:	6a 00                	push   $0x0
+c0102e04:	6a 00                	push   $0x0
   pushl $216
-c0102fc9:	68 d8 00 00 00       	push   $0xd8
+c0102e06:	68 d8 00 00 00       	push   $0xd8
   jmp __alltraps
-c0102fce:	e9 d4 01 00 00       	jmp    c01031a7 <__alltraps>
+c0102e0b:	e9 d4 01 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102fd3 <vector217>:
+c0102e10 <vector217>:
 .globl vector217
 vector217:
   pushl $0
-c0102fd3:	6a 00                	push   $0x0
+c0102e10:	6a 00                	push   $0x0
   pushl $217
-c0102fd5:	68 d9 00 00 00       	push   $0xd9
+c0102e12:	68 d9 00 00 00       	push   $0xd9
   jmp __alltraps
-c0102fda:	e9 c8 01 00 00       	jmp    c01031a7 <__alltraps>
+c0102e17:	e9 c8 01 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102fdf <vector218>:
+c0102e1c <vector218>:
 .globl vector218
 vector218:
   pushl $0
-c0102fdf:	6a 00                	push   $0x0
+c0102e1c:	6a 00                	push   $0x0
   pushl $218
-c0102fe1:	68 da 00 00 00       	push   $0xda
+c0102e1e:	68 da 00 00 00       	push   $0xda
   jmp __alltraps
-c0102fe6:	e9 bc 01 00 00       	jmp    c01031a7 <__alltraps>
+c0102e23:	e9 bc 01 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102feb <vector219>:
+c0102e28 <vector219>:
 .globl vector219
 vector219:
   pushl $0
-c0102feb:	6a 00                	push   $0x0
+c0102e28:	6a 00                	push   $0x0
   pushl $219
-c0102fed:	68 db 00 00 00       	push   $0xdb
+c0102e2a:	68 db 00 00 00       	push   $0xdb
   jmp __alltraps
-c0102ff2:	e9 b0 01 00 00       	jmp    c01031a7 <__alltraps>
+c0102e2f:	e9 b0 01 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0102ff7 <vector220>:
+c0102e34 <vector220>:
 .globl vector220
 vector220:
   pushl $0
-c0102ff7:	6a 00                	push   $0x0
+c0102e34:	6a 00                	push   $0x0
   pushl $220
-c0102ff9:	68 dc 00 00 00       	push   $0xdc
+c0102e36:	68 dc 00 00 00       	push   $0xdc
   jmp __alltraps
-c0102ffe:	e9 a4 01 00 00       	jmp    c01031a7 <__alltraps>
+c0102e3b:	e9 a4 01 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0103003 <vector221>:
+c0102e40 <vector221>:
 .globl vector221
 vector221:
   pushl $0
-c0103003:	6a 00                	push   $0x0
+c0102e40:	6a 00                	push   $0x0
   pushl $221
-c0103005:	68 dd 00 00 00       	push   $0xdd
+c0102e42:	68 dd 00 00 00       	push   $0xdd
   jmp __alltraps
-c010300a:	e9 98 01 00 00       	jmp    c01031a7 <__alltraps>
+c0102e47:	e9 98 01 00 00       	jmp    c0102fe4 <__alltraps>
 
-c010300f <vector222>:
+c0102e4c <vector222>:
 .globl vector222
 vector222:
   pushl $0
-c010300f:	6a 00                	push   $0x0
+c0102e4c:	6a 00                	push   $0x0
   pushl $222
-c0103011:	68 de 00 00 00       	push   $0xde
+c0102e4e:	68 de 00 00 00       	push   $0xde
   jmp __alltraps
-c0103016:	e9 8c 01 00 00       	jmp    c01031a7 <__alltraps>
+c0102e53:	e9 8c 01 00 00       	jmp    c0102fe4 <__alltraps>
 
-c010301b <vector223>:
+c0102e58 <vector223>:
 .globl vector223
 vector223:
   pushl $0
-c010301b:	6a 00                	push   $0x0
+c0102e58:	6a 00                	push   $0x0
   pushl $223
-c010301d:	68 df 00 00 00       	push   $0xdf
+c0102e5a:	68 df 00 00 00       	push   $0xdf
   jmp __alltraps
-c0103022:	e9 80 01 00 00       	jmp    c01031a7 <__alltraps>
+c0102e5f:	e9 80 01 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0103027 <vector224>:
+c0102e64 <vector224>:
 .globl vector224
 vector224:
   pushl $0
-c0103027:	6a 00                	push   $0x0
+c0102e64:	6a 00                	push   $0x0
   pushl $224
-c0103029:	68 e0 00 00 00       	push   $0xe0
+c0102e66:	68 e0 00 00 00       	push   $0xe0
   jmp __alltraps
-c010302e:	e9 74 01 00 00       	jmp    c01031a7 <__alltraps>
+c0102e6b:	e9 74 01 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0103033 <vector225>:
+c0102e70 <vector225>:
 .globl vector225
 vector225:
   pushl $0
-c0103033:	6a 00                	push   $0x0
+c0102e70:	6a 00                	push   $0x0
   pushl $225
-c0103035:	68 e1 00 00 00       	push   $0xe1
+c0102e72:	68 e1 00 00 00       	push   $0xe1
   jmp __alltraps
-c010303a:	e9 68 01 00 00       	jmp    c01031a7 <__alltraps>
+c0102e77:	e9 68 01 00 00       	jmp    c0102fe4 <__alltraps>
 
-c010303f <vector226>:
+c0102e7c <vector226>:
 .globl vector226
 vector226:
   pushl $0
-c010303f:	6a 00                	push   $0x0
+c0102e7c:	6a 00                	push   $0x0
   pushl $226
-c0103041:	68 e2 00 00 00       	push   $0xe2
+c0102e7e:	68 e2 00 00 00       	push   $0xe2
   jmp __alltraps
-c0103046:	e9 5c 01 00 00       	jmp    c01031a7 <__alltraps>
+c0102e83:	e9 5c 01 00 00       	jmp    c0102fe4 <__alltraps>
 
-c010304b <vector227>:
+c0102e88 <vector227>:
 .globl vector227
 vector227:
   pushl $0
-c010304b:	6a 00                	push   $0x0
+c0102e88:	6a 00                	push   $0x0
   pushl $227
-c010304d:	68 e3 00 00 00       	push   $0xe3
+c0102e8a:	68 e3 00 00 00       	push   $0xe3
   jmp __alltraps
-c0103052:	e9 50 01 00 00       	jmp    c01031a7 <__alltraps>
+c0102e8f:	e9 50 01 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0103057 <vector228>:
+c0102e94 <vector228>:
 .globl vector228
 vector228:
   pushl $0
-c0103057:	6a 00                	push   $0x0
+c0102e94:	6a 00                	push   $0x0
   pushl $228
-c0103059:	68 e4 00 00 00       	push   $0xe4
+c0102e96:	68 e4 00 00 00       	push   $0xe4
   jmp __alltraps
-c010305e:	e9 44 01 00 00       	jmp    c01031a7 <__alltraps>
+c0102e9b:	e9 44 01 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0103063 <vector229>:
+c0102ea0 <vector229>:
 .globl vector229
 vector229:
   pushl $0
-c0103063:	6a 00                	push   $0x0
+c0102ea0:	6a 00                	push   $0x0
   pushl $229
-c0103065:	68 e5 00 00 00       	push   $0xe5
+c0102ea2:	68 e5 00 00 00       	push   $0xe5
   jmp __alltraps
-c010306a:	e9 38 01 00 00       	jmp    c01031a7 <__alltraps>
+c0102ea7:	e9 38 01 00 00       	jmp    c0102fe4 <__alltraps>
 
-c010306f <vector230>:
+c0102eac <vector230>:
 .globl vector230
 vector230:
   pushl $0
-c010306f:	6a 00                	push   $0x0
+c0102eac:	6a 00                	push   $0x0
   pushl $230
-c0103071:	68 e6 00 00 00       	push   $0xe6
+c0102eae:	68 e6 00 00 00       	push   $0xe6
   jmp __alltraps
-c0103076:	e9 2c 01 00 00       	jmp    c01031a7 <__alltraps>
+c0102eb3:	e9 2c 01 00 00       	jmp    c0102fe4 <__alltraps>
 
-c010307b <vector231>:
+c0102eb8 <vector231>:
 .globl vector231
 vector231:
   pushl $0
-c010307b:	6a 00                	push   $0x0
+c0102eb8:	6a 00                	push   $0x0
   pushl $231
-c010307d:	68 e7 00 00 00       	push   $0xe7
+c0102eba:	68 e7 00 00 00       	push   $0xe7
   jmp __alltraps
-c0103082:	e9 20 01 00 00       	jmp    c01031a7 <__alltraps>
+c0102ebf:	e9 20 01 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0103087 <vector232>:
+c0102ec4 <vector232>:
 .globl vector232
 vector232:
   pushl $0
-c0103087:	6a 00                	push   $0x0
+c0102ec4:	6a 00                	push   $0x0
   pushl $232
-c0103089:	68 e8 00 00 00       	push   $0xe8
+c0102ec6:	68 e8 00 00 00       	push   $0xe8
   jmp __alltraps
-c010308e:	e9 14 01 00 00       	jmp    c01031a7 <__alltraps>
+c0102ecb:	e9 14 01 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0103093 <vector233>:
+c0102ed0 <vector233>:
 .globl vector233
 vector233:
   pushl $0
-c0103093:	6a 00                	push   $0x0
+c0102ed0:	6a 00                	push   $0x0
   pushl $233
-c0103095:	68 e9 00 00 00       	push   $0xe9
+c0102ed2:	68 e9 00 00 00       	push   $0xe9
   jmp __alltraps
-c010309a:	e9 08 01 00 00       	jmp    c01031a7 <__alltraps>
+c0102ed7:	e9 08 01 00 00       	jmp    c0102fe4 <__alltraps>
 
-c010309f <vector234>:
+c0102edc <vector234>:
 .globl vector234
 vector234:
   pushl $0
-c010309f:	6a 00                	push   $0x0
+c0102edc:	6a 00                	push   $0x0
   pushl $234
-c01030a1:	68 ea 00 00 00       	push   $0xea
+c0102ede:	68 ea 00 00 00       	push   $0xea
   jmp __alltraps
-c01030a6:	e9 fc 00 00 00       	jmp    c01031a7 <__alltraps>
+c0102ee3:	e9 fc 00 00 00       	jmp    c0102fe4 <__alltraps>
 
-c01030ab <vector235>:
+c0102ee8 <vector235>:
 .globl vector235
 vector235:
   pushl $0
-c01030ab:	6a 00                	push   $0x0
+c0102ee8:	6a 00                	push   $0x0
   pushl $235
-c01030ad:	68 eb 00 00 00       	push   $0xeb
+c0102eea:	68 eb 00 00 00       	push   $0xeb
   jmp __alltraps
-c01030b2:	e9 f0 00 00 00       	jmp    c01031a7 <__alltraps>
+c0102eef:	e9 f0 00 00 00       	jmp    c0102fe4 <__alltraps>
 
-c01030b7 <vector236>:
+c0102ef4 <vector236>:
 .globl vector236
 vector236:
   pushl $0
-c01030b7:	6a 00                	push   $0x0
+c0102ef4:	6a 00                	push   $0x0
   pushl $236
-c01030b9:	68 ec 00 00 00       	push   $0xec
+c0102ef6:	68 ec 00 00 00       	push   $0xec
   jmp __alltraps
-c01030be:	e9 e4 00 00 00       	jmp    c01031a7 <__alltraps>
+c0102efb:	e9 e4 00 00 00       	jmp    c0102fe4 <__alltraps>
 
-c01030c3 <vector237>:
+c0102f00 <vector237>:
 .globl vector237
 vector237:
   pushl $0
-c01030c3:	6a 00                	push   $0x0
+c0102f00:	6a 00                	push   $0x0
   pushl $237
-c01030c5:	68 ed 00 00 00       	push   $0xed
+c0102f02:	68 ed 00 00 00       	push   $0xed
   jmp __alltraps
-c01030ca:	e9 d8 00 00 00       	jmp    c01031a7 <__alltraps>
+c0102f07:	e9 d8 00 00 00       	jmp    c0102fe4 <__alltraps>
 
-c01030cf <vector238>:
+c0102f0c <vector238>:
 .globl vector238
 vector238:
   pushl $0
-c01030cf:	6a 00                	push   $0x0
+c0102f0c:	6a 00                	push   $0x0
   pushl $238
-c01030d1:	68 ee 00 00 00       	push   $0xee
+c0102f0e:	68 ee 00 00 00       	push   $0xee
   jmp __alltraps
-c01030d6:	e9 cc 00 00 00       	jmp    c01031a7 <__alltraps>
+c0102f13:	e9 cc 00 00 00       	jmp    c0102fe4 <__alltraps>
 
-c01030db <vector239>:
+c0102f18 <vector239>:
 .globl vector239
 vector239:
   pushl $0
-c01030db:	6a 00                	push   $0x0
+c0102f18:	6a 00                	push   $0x0
   pushl $239
-c01030dd:	68 ef 00 00 00       	push   $0xef
+c0102f1a:	68 ef 00 00 00       	push   $0xef
   jmp __alltraps
-c01030e2:	e9 c0 00 00 00       	jmp    c01031a7 <__alltraps>
+c0102f1f:	e9 c0 00 00 00       	jmp    c0102fe4 <__alltraps>
 
-c01030e7 <vector240>:
+c0102f24 <vector240>:
 .globl vector240
 vector240:
   pushl $0
-c01030e7:	6a 00                	push   $0x0
+c0102f24:	6a 00                	push   $0x0
   pushl $240
-c01030e9:	68 f0 00 00 00       	push   $0xf0
+c0102f26:	68 f0 00 00 00       	push   $0xf0
   jmp __alltraps
-c01030ee:	e9 b4 00 00 00       	jmp    c01031a7 <__alltraps>
+c0102f2b:	e9 b4 00 00 00       	jmp    c0102fe4 <__alltraps>
 
-c01030f3 <vector241>:
+c0102f30 <vector241>:
 .globl vector241
 vector241:
   pushl $0
-c01030f3:	6a 00                	push   $0x0
+c0102f30:	6a 00                	push   $0x0
   pushl $241
-c01030f5:	68 f1 00 00 00       	push   $0xf1
+c0102f32:	68 f1 00 00 00       	push   $0xf1
   jmp __alltraps
-c01030fa:	e9 a8 00 00 00       	jmp    c01031a7 <__alltraps>
+c0102f37:	e9 a8 00 00 00       	jmp    c0102fe4 <__alltraps>
 
-c01030ff <vector242>:
+c0102f3c <vector242>:
 .globl vector242
 vector242:
   pushl $0
-c01030ff:	6a 00                	push   $0x0
+c0102f3c:	6a 00                	push   $0x0
   pushl $242
-c0103101:	68 f2 00 00 00       	push   $0xf2
+c0102f3e:	68 f2 00 00 00       	push   $0xf2
   jmp __alltraps
-c0103106:	e9 9c 00 00 00       	jmp    c01031a7 <__alltraps>
+c0102f43:	e9 9c 00 00 00       	jmp    c0102fe4 <__alltraps>
 
-c010310b <vector243>:
+c0102f48 <vector243>:
 .globl vector243
 vector243:
   pushl $0
-c010310b:	6a 00                	push   $0x0
+c0102f48:	6a 00                	push   $0x0
   pushl $243
-c010310d:	68 f3 00 00 00       	push   $0xf3
+c0102f4a:	68 f3 00 00 00       	push   $0xf3
   jmp __alltraps
-c0103112:	e9 90 00 00 00       	jmp    c01031a7 <__alltraps>
+c0102f4f:	e9 90 00 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0103117 <vector244>:
+c0102f54 <vector244>:
 .globl vector244
 vector244:
   pushl $0
-c0103117:	6a 00                	push   $0x0
+c0102f54:	6a 00                	push   $0x0
   pushl $244
-c0103119:	68 f4 00 00 00       	push   $0xf4
+c0102f56:	68 f4 00 00 00       	push   $0xf4
   jmp __alltraps
-c010311e:	e9 84 00 00 00       	jmp    c01031a7 <__alltraps>
+c0102f5b:	e9 84 00 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0103123 <vector245>:
+c0102f60 <vector245>:
 .globl vector245
 vector245:
   pushl $0
-c0103123:	6a 00                	push   $0x0
+c0102f60:	6a 00                	push   $0x0
   pushl $245
-c0103125:	68 f5 00 00 00       	push   $0xf5
+c0102f62:	68 f5 00 00 00       	push   $0xf5
   jmp __alltraps
-c010312a:	e9 78 00 00 00       	jmp    c01031a7 <__alltraps>
+c0102f67:	e9 78 00 00 00       	jmp    c0102fe4 <__alltraps>
 
-c010312f <vector246>:
+c0102f6c <vector246>:
 .globl vector246
 vector246:
   pushl $0
-c010312f:	6a 00                	push   $0x0
+c0102f6c:	6a 00                	push   $0x0
   pushl $246
-c0103131:	68 f6 00 00 00       	push   $0xf6
+c0102f6e:	68 f6 00 00 00       	push   $0xf6
   jmp __alltraps
-c0103136:	e9 6c 00 00 00       	jmp    c01031a7 <__alltraps>
+c0102f73:	e9 6c 00 00 00       	jmp    c0102fe4 <__alltraps>
 
-c010313b <vector247>:
+c0102f78 <vector247>:
 .globl vector247
 vector247:
   pushl $0
-c010313b:	6a 00                	push   $0x0
+c0102f78:	6a 00                	push   $0x0
   pushl $247
-c010313d:	68 f7 00 00 00       	push   $0xf7
+c0102f7a:	68 f7 00 00 00       	push   $0xf7
   jmp __alltraps
-c0103142:	e9 60 00 00 00       	jmp    c01031a7 <__alltraps>
+c0102f7f:	e9 60 00 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0103147 <vector248>:
+c0102f84 <vector248>:
 .globl vector248
 vector248:
   pushl $0
-c0103147:	6a 00                	push   $0x0
+c0102f84:	6a 00                	push   $0x0
   pushl $248
-c0103149:	68 f8 00 00 00       	push   $0xf8
+c0102f86:	68 f8 00 00 00       	push   $0xf8
   jmp __alltraps
-c010314e:	e9 54 00 00 00       	jmp    c01031a7 <__alltraps>
+c0102f8b:	e9 54 00 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0103153 <vector249>:
+c0102f90 <vector249>:
 .globl vector249
 vector249:
   pushl $0
-c0103153:	6a 00                	push   $0x0
+c0102f90:	6a 00                	push   $0x0
   pushl $249
-c0103155:	68 f9 00 00 00       	push   $0xf9
+c0102f92:	68 f9 00 00 00       	push   $0xf9
   jmp __alltraps
-c010315a:	e9 48 00 00 00       	jmp    c01031a7 <__alltraps>
+c0102f97:	e9 48 00 00 00       	jmp    c0102fe4 <__alltraps>
 
-c010315f <vector250>:
+c0102f9c <vector250>:
 .globl vector250
 vector250:
   pushl $0
-c010315f:	6a 00                	push   $0x0
+c0102f9c:	6a 00                	push   $0x0
   pushl $250
-c0103161:	68 fa 00 00 00       	push   $0xfa
+c0102f9e:	68 fa 00 00 00       	push   $0xfa
   jmp __alltraps
-c0103166:	e9 3c 00 00 00       	jmp    c01031a7 <__alltraps>
+c0102fa3:	e9 3c 00 00 00       	jmp    c0102fe4 <__alltraps>
 
-c010316b <vector251>:
+c0102fa8 <vector251>:
 .globl vector251
 vector251:
   pushl $0
-c010316b:	6a 00                	push   $0x0
+c0102fa8:	6a 00                	push   $0x0
   pushl $251
-c010316d:	68 fb 00 00 00       	push   $0xfb
+c0102faa:	68 fb 00 00 00       	push   $0xfb
   jmp __alltraps
-c0103172:	e9 30 00 00 00       	jmp    c01031a7 <__alltraps>
+c0102faf:	e9 30 00 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0103177 <vector252>:
+c0102fb4 <vector252>:
 .globl vector252
 vector252:
   pushl $0
-c0103177:	6a 00                	push   $0x0
+c0102fb4:	6a 00                	push   $0x0
   pushl $252
-c0103179:	68 fc 00 00 00       	push   $0xfc
+c0102fb6:	68 fc 00 00 00       	push   $0xfc
   jmp __alltraps
-c010317e:	e9 24 00 00 00       	jmp    c01031a7 <__alltraps>
+c0102fbb:	e9 24 00 00 00       	jmp    c0102fe4 <__alltraps>
 
-c0103183 <vector253>:
+c0102fc0 <vector253>:
 .globl vector253
 vector253:
   pushl $0
-c0103183:	6a 00                	push   $0x0
+c0102fc0:	6a 00                	push   $0x0
   pushl $253
-c0103185:	68 fd 00 00 00       	push   $0xfd
+c0102fc2:	68 fd 00 00 00       	push   $0xfd
   jmp __alltraps
-c010318a:	e9 18 00 00 00       	jmp    c01031a7 <__alltraps>
+c0102fc7:	e9 18 00 00 00       	jmp    c0102fe4 <__alltraps>
 
-c010318f <vector254>:
+c0102fcc <vector254>:
 .globl vector254
 vector254:
   pushl $0
-c010318f:	6a 00                	push   $0x0
+c0102fcc:	6a 00                	push   $0x0
   pushl $254
-c0103191:	68 fe 00 00 00       	push   $0xfe
+c0102fce:	68 fe 00 00 00       	push   $0xfe
   jmp __alltraps
-c0103196:	e9 0c 00 00 00       	jmp    c01031a7 <__alltraps>
+c0102fd3:	e9 0c 00 00 00       	jmp    c0102fe4 <__alltraps>
 
-c010319b <vector255>:
+c0102fd8 <vector255>:
 .globl vector255
 vector255:
   pushl $0
-c010319b:	6a 00                	push   $0x0
+c0102fd8:	6a 00                	push   $0x0
   pushl $255
-c010319d:	68 ff 00 00 00       	push   $0xff
+c0102fda:	68 ff 00 00 00       	push   $0xff
   jmp __alltraps
-c01031a2:	e9 00 00 00 00       	jmp    c01031a7 <__alltraps>
+c0102fdf:	e9 00 00 00 00       	jmp    c0102fe4 <__alltraps>
 
-c01031a7 <__alltraps>:
+c0102fe4 <__alltraps>:
 .text
 .globl __alltraps
 __alltraps:
     # push registers to build a trap frame
     # therefore make the stack look like a struct trapframe
     pushl %ds
-c01031a7:	1e                   	push   %ds
+c0102fe4:	1e                   	push   %ds
     pushl %es
-c01031a8:	06                   	push   %es
+c0102fe5:	06                   	push   %es
     pushl %fs
-c01031a9:	0f a0                	push   %fs
+c0102fe6:	0f a0                	push   %fs
     pushl %gs
-c01031ab:	0f a8                	push   %gs
+c0102fe8:	0f a8                	push   %gs
     pushal
-c01031ad:	60                   	pusha  
+c0102fea:	60                   	pusha  
 
     # load GD_KDATA into %ds and %es to set up data segments for kernel
     movl $GD_KDATA, %eax
-c01031ae:	b8 10 00 00 00       	mov    $0x10,%eax
+c0102feb:	b8 10 00 00 00       	mov    $0x10,%eax
     movw %ax, %ds
-c01031b3:	8e d8                	mov    %eax,%ds
+c0102ff0:	8e d8                	mov    %eax,%ds
     movw %ax, %es
-c01031b5:	8e c0                	mov    %eax,%es
+c0102ff2:	8e c0                	mov    %eax,%es
 
     # push %esp to pass a pointer to the trapframe as an argument to trap()
     pushl %esp
-c01031b7:	54                   	push   %esp
+c0102ff4:	54                   	push   %esp
 
     # call trap(tf), where tf=%esp
     call trap
-c01031b8:	e8 63 f5 ff ff       	call   c0102720 <trap>
+c0102ff5:	e8 64 f5 ff ff       	call   c010255e <trap>
 
     # pop the pushed stack pointer
     popl %esp
-c01031bd:	5c                   	pop    %esp
+c0102ffa:	5c                   	pop    %esp
 
-c01031be <__trapret>:
+c0102ffb <__trapret>:
 
     # return falls through to trapret...
 .globl __trapret
 __trapret:
     # restore registers from stack
     popal
-c01031be:	61                   	popa   
+c0102ffb:	61                   	popa   
 
     # restore %ds, %es, %fs and %gs
     popl %gs
-c01031bf:	0f a9                	pop    %gs
+c0102ffc:	0f a9                	pop    %gs
     popl %fs
-c01031c1:	0f a1                	pop    %fs
+c0102ffe:	0f a1                	pop    %fs
     popl %es
-c01031c3:	07                   	pop    %es
+c0103000:	07                   	pop    %es
     popl %ds
-c01031c4:	1f                   	pop    %ds
+c0103001:	1f                   	pop    %ds
 
     # get rid of the trap number and error code
     addl $0x8, %esp
-c01031c5:	83 c4 08             	add    $0x8,%esp
+c0103002:	83 c4 08             	add    $0x8,%esp
     iret
-c01031c8:	cf                   	iret   
+c0103005:	cf                   	iret   
 
-c01031c9 <page2ppn>:
+c0103006 <page2ppn>:
 
 extern struct Page *pages;
 extern size_t npage;
 
 static inline ppn_t
 page2ppn(struct Page *page) {
-c01031c9:	55                   	push   %ebp
-c01031ca:	89 e5                	mov    %esp,%ebp
+c0103006:	55                   	push   %ebp
+c0103007:	89 e5                	mov    %esp,%ebp
     return page - pages;
-c01031cc:	8b 45 08             	mov    0x8(%ebp),%eax
-c01031cf:	8b 15 28 30 12 c0    	mov    0xc0123028,%edx
-c01031d5:	29 d0                	sub    %edx,%eax
-c01031d7:	c1 f8 05             	sar    $0x5,%eax
+c0103009:	8b 45 08             	mov    0x8(%ebp),%eax
+c010300c:	8b 15 28 40 12 c0    	mov    0xc0124028,%edx
+c0103012:	29 d0                	sub    %edx,%eax
+c0103014:	c1 f8 05             	sar    $0x5,%eax
 }
-c01031da:	5d                   	pop    %ebp
-c01031db:	c3                   	ret    
+c0103017:	5d                   	pop    %ebp
+c0103018:	c3                   	ret    
 
-c01031dc <page2pa>:
+c0103019 <page2pa>:
 
 static inline uintptr_t
 page2pa(struct Page *page) {
-c01031dc:	55                   	push   %ebp
-c01031dd:	89 e5                	mov    %esp,%ebp
+c0103019:	55                   	push   %ebp
+c010301a:	89 e5                	mov    %esp,%ebp
+c010301c:	83 ec 04             	sub    $0x4,%esp
     return page2ppn(page) << PGSHIFT;
-c01031df:	ff 75 08             	pushl  0x8(%ebp)
-c01031e2:	e8 e2 ff ff ff       	call   c01031c9 <page2ppn>
-c01031e7:	83 c4 04             	add    $0x4,%esp
-c01031ea:	c1 e0 0c             	shl    $0xc,%eax
+c010301f:	8b 45 08             	mov    0x8(%ebp),%eax
+c0103022:	89 04 24             	mov    %eax,(%esp)
+c0103025:	e8 dc ff ff ff       	call   c0103006 <page2ppn>
+c010302a:	c1 e0 0c             	shl    $0xc,%eax
 }
-c01031ed:	c9                   	leave  
-c01031ee:	c3                   	ret    
+c010302d:	c9                   	leave  
+c010302e:	c3                   	ret    
 
-c01031ef <pa2page>:
+c010302f <pa2page>:
 
 static inline struct Page *
 pa2page(uintptr_t pa) {
-c01031ef:	55                   	push   %ebp
-c01031f0:	89 e5                	mov    %esp,%ebp
-c01031f2:	83 ec 08             	sub    $0x8,%esp
+c010302f:	55                   	push   %ebp
+c0103030:	89 e5                	mov    %esp,%ebp
+c0103032:	83 ec 18             	sub    $0x18,%esp
     if (PPN(pa) >= npage) {
-c01031f5:	8b 45 08             	mov    0x8(%ebp),%eax
-c01031f8:	c1 e8 0c             	shr    $0xc,%eax
-c01031fb:	89 c2                	mov    %eax,%edx
-c01031fd:	a1 80 2f 12 c0       	mov    0xc0122f80,%eax
-c0103202:	39 c2                	cmp    %eax,%edx
-c0103204:	72 14                	jb     c010321a <pa2page+0x2b>
+c0103035:	8b 45 08             	mov    0x8(%ebp),%eax
+c0103038:	c1 e8 0c             	shr    $0xc,%eax
+c010303b:	89 c2                	mov    %eax,%edx
+c010303d:	a1 80 3f 12 c0       	mov    0xc0123f80,%eax
+c0103042:	39 c2                	cmp    %eax,%edx
+c0103044:	72 1c                	jb     c0103062 <pa2page+0x33>
         panic("pa2page called with invalid pa");
-c0103206:	83 ec 04             	sub    $0x4,%esp
-c0103209:	68 30 8c 10 c0       	push   $0xc0108c30
-c010320e:	6a 5b                	push   $0x5b
-c0103210:	68 4f 8c 10 c0       	push   $0xc0108c4f
-c0103215:	e8 ce d1 ff ff       	call   c01003e8 <__panic>
+c0103046:	c7 44 24 08 50 93 10 	movl   $0xc0109350,0x8(%esp)
+c010304d:	c0 
+c010304e:	c7 44 24 04 5b 00 00 	movl   $0x5b,0x4(%esp)
+c0103055:	00 
+c0103056:	c7 04 24 6f 93 10 c0 	movl   $0xc010936f,(%esp)
+c010305d:	e8 96 d3 ff ff       	call   c01003f8 <__panic>
     }
     return &pages[PPN(pa)];
-c010321a:	a1 28 30 12 c0       	mov    0xc0123028,%eax
-c010321f:	8b 55 08             	mov    0x8(%ebp),%edx
-c0103222:	c1 ea 0c             	shr    $0xc,%edx
-c0103225:	c1 e2 05             	shl    $0x5,%edx
-c0103228:	01 d0                	add    %edx,%eax
+c0103062:	a1 28 40 12 c0       	mov    0xc0124028,%eax
+c0103067:	8b 55 08             	mov    0x8(%ebp),%edx
+c010306a:	c1 ea 0c             	shr    $0xc,%edx
+c010306d:	c1 e2 05             	shl    $0x5,%edx
+c0103070:	01 d0                	add    %edx,%eax
 }
-c010322a:	c9                   	leave  
-c010322b:	c3                   	ret    
+c0103072:	c9                   	leave  
+c0103073:	c3                   	ret    
 
-c010322c <page2kva>:
+c0103074 <page2kva>:
 
 static inline void *
 page2kva(struct Page *page) {
-c010322c:	55                   	push   %ebp
-c010322d:	89 e5                	mov    %esp,%ebp
-c010322f:	83 ec 18             	sub    $0x18,%esp
+c0103074:	55                   	push   %ebp
+c0103075:	89 e5                	mov    %esp,%ebp
+c0103077:	83 ec 28             	sub    $0x28,%esp
     return KADDR(page2pa(page));
-c0103232:	ff 75 08             	pushl  0x8(%ebp)
-c0103235:	e8 a2 ff ff ff       	call   c01031dc <page2pa>
-c010323a:	83 c4 04             	add    $0x4,%esp
-c010323d:	89 45 f4             	mov    %eax,-0xc(%ebp)
-c0103240:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0103243:	c1 e8 0c             	shr    $0xc,%eax
-c0103246:	89 45 f0             	mov    %eax,-0x10(%ebp)
-c0103249:	a1 80 2f 12 c0       	mov    0xc0122f80,%eax
-c010324e:	39 45 f0             	cmp    %eax,-0x10(%ebp)
-c0103251:	72 14                	jb     c0103267 <page2kva+0x3b>
-c0103253:	ff 75 f4             	pushl  -0xc(%ebp)
-c0103256:	68 60 8c 10 c0       	push   $0xc0108c60
-c010325b:	6a 62                	push   $0x62
-c010325d:	68 4f 8c 10 c0       	push   $0xc0108c4f
-c0103262:	e8 81 d1 ff ff       	call   c01003e8 <__panic>
-c0103267:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c010326a:	2d 00 00 00 40       	sub    $0x40000000,%eax
+c010307a:	8b 45 08             	mov    0x8(%ebp),%eax
+c010307d:	89 04 24             	mov    %eax,(%esp)
+c0103080:	e8 94 ff ff ff       	call   c0103019 <page2pa>
+c0103085:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0103088:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010308b:	c1 e8 0c             	shr    $0xc,%eax
+c010308e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0103091:	a1 80 3f 12 c0       	mov    0xc0123f80,%eax
+c0103096:	39 45 f0             	cmp    %eax,-0x10(%ebp)
+c0103099:	72 23                	jb     c01030be <page2kva+0x4a>
+c010309b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010309e:	89 44 24 0c          	mov    %eax,0xc(%esp)
+c01030a2:	c7 44 24 08 80 93 10 	movl   $0xc0109380,0x8(%esp)
+c01030a9:	c0 
+c01030aa:	c7 44 24 04 62 00 00 	movl   $0x62,0x4(%esp)
+c01030b1:	00 
+c01030b2:	c7 04 24 6f 93 10 c0 	movl   $0xc010936f,(%esp)
+c01030b9:	e8 3a d3 ff ff       	call   c01003f8 <__panic>
+c01030be:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01030c1:	2d 00 00 00 40       	sub    $0x40000000,%eax
 }
-c010326f:	c9                   	leave  
-c0103270:	c3                   	ret    
+c01030c6:	c9                   	leave  
+c01030c7:	c3                   	ret    
 
-c0103271 <kva2page>:
+c01030c8 <kva2page>:
 
 static inline struct Page *
 kva2page(void *kva) {
-c0103271:	55                   	push   %ebp
-c0103272:	89 e5                	mov    %esp,%ebp
-c0103274:	83 ec 18             	sub    $0x18,%esp
+c01030c8:	55                   	push   %ebp
+c01030c9:	89 e5                	mov    %esp,%ebp
+c01030cb:	83 ec 28             	sub    $0x28,%esp
     return pa2page(PADDR(kva));
-c0103277:	8b 45 08             	mov    0x8(%ebp),%eax
-c010327a:	89 45 f4             	mov    %eax,-0xc(%ebp)
-c010327d:	81 7d f4 ff ff ff bf 	cmpl   $0xbfffffff,-0xc(%ebp)
-c0103284:	77 14                	ja     c010329a <kva2page+0x29>
-c0103286:	ff 75 f4             	pushl  -0xc(%ebp)
-c0103289:	68 84 8c 10 c0       	push   $0xc0108c84
-c010328e:	6a 67                	push   $0x67
-c0103290:	68 4f 8c 10 c0       	push   $0xc0108c4f
-c0103295:	e8 4e d1 ff ff       	call   c01003e8 <__panic>
-c010329a:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c010329d:	05 00 00 00 40       	add    $0x40000000,%eax
-c01032a2:	83 ec 0c             	sub    $0xc,%esp
-c01032a5:	50                   	push   %eax
-c01032a6:	e8 44 ff ff ff       	call   c01031ef <pa2page>
-c01032ab:	83 c4 10             	add    $0x10,%esp
+c01030ce:	8b 45 08             	mov    0x8(%ebp),%eax
+c01030d1:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c01030d4:	81 7d f4 ff ff ff bf 	cmpl   $0xbfffffff,-0xc(%ebp)
+c01030db:	77 23                	ja     c0103100 <kva2page+0x38>
+c01030dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01030e0:	89 44 24 0c          	mov    %eax,0xc(%esp)
+c01030e4:	c7 44 24 08 a4 93 10 	movl   $0xc01093a4,0x8(%esp)
+c01030eb:	c0 
+c01030ec:	c7 44 24 04 67 00 00 	movl   $0x67,0x4(%esp)
+c01030f3:	00 
+c01030f4:	c7 04 24 6f 93 10 c0 	movl   $0xc010936f,(%esp)
+c01030fb:	e8 f8 d2 ff ff       	call   c01003f8 <__panic>
+c0103100:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0103103:	05 00 00 00 40       	add    $0x40000000,%eax
+c0103108:	89 04 24             	mov    %eax,(%esp)
+c010310b:	e8 1f ff ff ff       	call   c010302f <pa2page>
 }
-c01032ae:	c9                   	leave  
-c01032af:	c3                   	ret    
+c0103110:	c9                   	leave  
+c0103111:	c3                   	ret    
 
-c01032b0 <pte2page>:
+c0103112 <pte2page>:
 
 static inline struct Page *
 pte2page(pte_t pte) {
-c01032b0:	55                   	push   %ebp
-c01032b1:	89 e5                	mov    %esp,%ebp
-c01032b3:	83 ec 08             	sub    $0x8,%esp
+c0103112:	55                   	push   %ebp
+c0103113:	89 e5                	mov    %esp,%ebp
+c0103115:	83 ec 18             	sub    $0x18,%esp
     if (!(pte & PTE_P)) {
-c01032b6:	8b 45 08             	mov    0x8(%ebp),%eax
-c01032b9:	83 e0 01             	and    $0x1,%eax
-c01032bc:	85 c0                	test   %eax,%eax
-c01032be:	75 14                	jne    c01032d4 <pte2page+0x24>
+c0103118:	8b 45 08             	mov    0x8(%ebp),%eax
+c010311b:	83 e0 01             	and    $0x1,%eax
+c010311e:	85 c0                	test   %eax,%eax
+c0103120:	75 1c                	jne    c010313e <pte2page+0x2c>
         panic("pte2page called with invalid pte");
-c01032c0:	83 ec 04             	sub    $0x4,%esp
-c01032c3:	68 a8 8c 10 c0       	push   $0xc0108ca8
-c01032c8:	6a 6d                	push   $0x6d
-c01032ca:	68 4f 8c 10 c0       	push   $0xc0108c4f
-c01032cf:	e8 14 d1 ff ff       	call   c01003e8 <__panic>
+c0103122:	c7 44 24 08 c8 93 10 	movl   $0xc01093c8,0x8(%esp)
+c0103129:	c0 
+c010312a:	c7 44 24 04 6d 00 00 	movl   $0x6d,0x4(%esp)
+c0103131:	00 
+c0103132:	c7 04 24 6f 93 10 c0 	movl   $0xc010936f,(%esp)
+c0103139:	e8 ba d2 ff ff       	call   c01003f8 <__panic>
     }
     return pa2page(PTE_ADDR(pte));
-c01032d4:	8b 45 08             	mov    0x8(%ebp),%eax
-c01032d7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
-c01032dc:	83 ec 0c             	sub    $0xc,%esp
-c01032df:	50                   	push   %eax
-c01032e0:	e8 0a ff ff ff       	call   c01031ef <pa2page>
-c01032e5:	83 c4 10             	add    $0x10,%esp
+c010313e:	8b 45 08             	mov    0x8(%ebp),%eax
+c0103141:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+c0103146:	89 04 24             	mov    %eax,(%esp)
+c0103149:	e8 e1 fe ff ff       	call   c010302f <pa2page>
 }
-c01032e8:	c9                   	leave  
-c01032e9:	c3                   	ret    
+c010314e:	c9                   	leave  
+c010314f:	c3                   	ret    
 
-c01032ea <pde2page>:
+c0103150 <pde2page>:
 
 static inline struct Page *
 pde2page(pde_t pde) {
-c01032ea:	55                   	push   %ebp
-c01032eb:	89 e5                	mov    %esp,%ebp
-c01032ed:	83 ec 08             	sub    $0x8,%esp
+c0103150:	55                   	push   %ebp
+c0103151:	89 e5                	mov    %esp,%ebp
+c0103153:	83 ec 18             	sub    $0x18,%esp
     return pa2page(PDE_ADDR(pde));
-c01032f0:	8b 45 08             	mov    0x8(%ebp),%eax
-c01032f3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
-c01032f8:	83 ec 0c             	sub    $0xc,%esp
-c01032fb:	50                   	push   %eax
-c01032fc:	e8 ee fe ff ff       	call   c01031ef <pa2page>
-c0103301:	83 c4 10             	add    $0x10,%esp
+c0103156:	8b 45 08             	mov    0x8(%ebp),%eax
+c0103159:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+c010315e:	89 04 24             	mov    %eax,(%esp)
+c0103161:	e8 c9 fe ff ff       	call   c010302f <pa2page>
 }
-c0103304:	c9                   	leave  
-c0103305:	c3                   	ret    
+c0103166:	c9                   	leave  
+c0103167:	c3                   	ret    
 
-c0103306 <page_ref>:
+c0103168 <page_ref>:
 
 static inline int
 page_ref(struct Page *page) {
-c0103306:	55                   	push   %ebp
-c0103307:	89 e5                	mov    %esp,%ebp
+c0103168:	55                   	push   %ebp
+c0103169:	89 e5                	mov    %esp,%ebp
     return page->ref;
-c0103309:	8b 45 08             	mov    0x8(%ebp),%eax
-c010330c:	8b 00                	mov    (%eax),%eax
+c010316b:	8b 45 08             	mov    0x8(%ebp),%eax
+c010316e:	8b 00                	mov    (%eax),%eax
 }
-c010330e:	5d                   	pop    %ebp
-c010330f:	c3                   	ret    
+c0103170:	5d                   	pop    %ebp
+c0103171:	c3                   	ret    
 
-c0103310 <set_page_ref>:
+c0103172 <set_page_ref>:
 
 static inline void
 set_page_ref(struct Page *page, int val) {
-c0103310:	55                   	push   %ebp
-c0103311:	89 e5                	mov    %esp,%ebp
+c0103172:	55                   	push   %ebp
+c0103173:	89 e5                	mov    %esp,%ebp
     page->ref = val;
-c0103313:	8b 45 08             	mov    0x8(%ebp),%eax
-c0103316:	8b 55 0c             	mov    0xc(%ebp),%edx
-c0103319:	89 10                	mov    %edx,(%eax)
-}
-c010331b:	90                   	nop
-c010331c:	5d                   	pop    %ebp
-c010331d:	c3                   	ret    
+c0103175:	8b 45 08             	mov    0x8(%ebp),%eax
+c0103178:	8b 55 0c             	mov    0xc(%ebp),%edx
+c010317b:	89 10                	mov    %edx,(%eax)
+}
+c010317d:	90                   	nop
+c010317e:	5d                   	pop    %ebp
+c010317f:	c3                   	ret    
 
-c010331e <page_ref_inc>:
+c0103180 <page_ref_inc>:
 
 static inline int
 page_ref_inc(struct Page *page) {
-c010331e:	55                   	push   %ebp
-c010331f:	89 e5                	mov    %esp,%ebp
+c0103180:	55                   	push   %ebp
+c0103181:	89 e5                	mov    %esp,%ebp
     page->ref += 1;
-c0103321:	8b 45 08             	mov    0x8(%ebp),%eax
-c0103324:	8b 00                	mov    (%eax),%eax
-c0103326:	8d 50 01             	lea    0x1(%eax),%edx
-c0103329:	8b 45 08             	mov    0x8(%ebp),%eax
-c010332c:	89 10                	mov    %edx,(%eax)
+c0103183:	8b 45 08             	mov    0x8(%ebp),%eax
+c0103186:	8b 00                	mov    (%eax),%eax
+c0103188:	8d 50 01             	lea    0x1(%eax),%edx
+c010318b:	8b 45 08             	mov    0x8(%ebp),%eax
+c010318e:	89 10                	mov    %edx,(%eax)
     return page->ref;
-c010332e:	8b 45 08             	mov    0x8(%ebp),%eax
-c0103331:	8b 00                	mov    (%eax),%eax
+c0103190:	8b 45 08             	mov    0x8(%ebp),%eax
+c0103193:	8b 00                	mov    (%eax),%eax
 }
-c0103333:	5d                   	pop    %ebp
-c0103334:	c3                   	ret    
+c0103195:	5d                   	pop    %ebp
+c0103196:	c3                   	ret    
 
-c0103335 <page_ref_dec>:
+c0103197 <page_ref_dec>:
 
 static inline int
 page_ref_dec(struct Page *page) {
-c0103335:	55                   	push   %ebp
-c0103336:	89 e5                	mov    %esp,%ebp
+c0103197:	55                   	push   %ebp
+c0103198:	89 e5                	mov    %esp,%ebp
     page->ref -= 1;
-c0103338:	8b 45 08             	mov    0x8(%ebp),%eax
-c010333b:	8b 00                	mov    (%eax),%eax
-c010333d:	8d 50 ff             	lea    -0x1(%eax),%edx
-c0103340:	8b 45 08             	mov    0x8(%ebp),%eax
-c0103343:	89 10                	mov    %edx,(%eax)
+c010319a:	8b 45 08             	mov    0x8(%ebp),%eax
+c010319d:	8b 00                	mov    (%eax),%eax
+c010319f:	8d 50 ff             	lea    -0x1(%eax),%edx
+c01031a2:	8b 45 08             	mov    0x8(%ebp),%eax
+c01031a5:	89 10                	mov    %edx,(%eax)
     return page->ref;
-c0103345:	8b 45 08             	mov    0x8(%ebp),%eax
-c0103348:	8b 00                	mov    (%eax),%eax
+c01031a7:	8b 45 08             	mov    0x8(%ebp),%eax
+c01031aa:	8b 00                	mov    (%eax),%eax
 }
-c010334a:	5d                   	pop    %ebp
-c010334b:	c3                   	ret    
+c01031ac:	5d                   	pop    %ebp
+c01031ad:	c3                   	ret    
 
-c010334c <__intr_save>:
+c01031ae <__intr_save>:
 #include <x86.h>
 #include <intr.h>
 #include <mmu.h>
 
 static inline bool
 __intr_save(void) {
-c010334c:	55                   	push   %ebp
-c010334d:	89 e5                	mov    %esp,%ebp
-c010334f:	83 ec 18             	sub    $0x18,%esp
+c01031ae:	55                   	push   %ebp
+c01031af:	89 e5                	mov    %esp,%ebp
+c01031b1:	83 ec 18             	sub    $0x18,%esp
 }
 
 static inline uint32_t
 read_eflags(void) {
     uint32_t eflags;
     asm volatile ("pushfl; popl %0" : "=r" (eflags));
-c0103352:	9c                   	pushf  
-c0103353:	58                   	pop    %eax
-c0103354:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c01031b4:	9c                   	pushf  
+c01031b5:	58                   	pop    %eax
+c01031b6:	89 45 f4             	mov    %eax,-0xc(%ebp)
     return eflags;
-c0103357:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01031b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
     if (read_eflags() & FL_IF) {
-c010335a:	25 00 02 00 00       	and    $0x200,%eax
-c010335f:	85 c0                	test   %eax,%eax
-c0103361:	74 0c                	je     c010336f <__intr_save+0x23>
+c01031bc:	25 00 02 00 00       	and    $0x200,%eax
+c01031c1:	85 c0                	test   %eax,%eax
+c01031c3:	74 0c                	je     c01031d1 <__intr_save+0x23>
         intr_disable();
-c0103363:	e8 61 ed ff ff       	call   c01020c9 <intr_disable>
+c01031c5:	e8 70 ee ff ff       	call   c010203a <intr_disable>
         return 1;
-c0103368:	b8 01 00 00 00       	mov    $0x1,%eax
-c010336d:	eb 05                	jmp    c0103374 <__intr_save+0x28>
+c01031ca:	b8 01 00 00 00       	mov    $0x1,%eax
+c01031cf:	eb 05                	jmp    c01031d6 <__intr_save+0x28>
     }
     return 0;
-c010336f:	b8 00 00 00 00       	mov    $0x0,%eax
+c01031d1:	b8 00 00 00 00       	mov    $0x0,%eax
 }
-c0103374:	c9                   	leave  
-c0103375:	c3                   	ret    
+c01031d6:	c9                   	leave  
+c01031d7:	c3                   	ret    
 
-c0103376 <__intr_restore>:
+c01031d8 <__intr_restore>:
 
 static inline void
 __intr_restore(bool flag) {
-c0103376:	55                   	push   %ebp
-c0103377:	89 e5                	mov    %esp,%ebp
-c0103379:	83 ec 08             	sub    $0x8,%esp
+c01031d8:	55                   	push   %ebp
+c01031d9:	89 e5                	mov    %esp,%ebp
+c01031db:	83 ec 08             	sub    $0x8,%esp
     if (flag) {
-c010337c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
-c0103380:	74 05                	je     c0103387 <__intr_restore+0x11>
+c01031de:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+c01031e2:	74 05                	je     c01031e9 <__intr_restore+0x11>
         intr_enable();
-c0103382:	e8 3b ed ff ff       	call   c01020c2 <intr_enable>
+c01031e4:	e8 4a ee ff ff       	call   c0102033 <intr_enable>
     }
 }
-c0103387:	90                   	nop
-c0103388:	c9                   	leave  
-c0103389:	c3                   	ret    
+c01031e9:	90                   	nop
+c01031ea:	c9                   	leave  
+c01031eb:	c3                   	ret    
 
-c010338a <lgdt>:
+c01031ec <lgdt>:
 /* *
  * lgdt - load the global descriptor table register and reset the
  * data/code segement registers for kernel.
  * */
 static inline void
 lgdt(struct pseudodesc *pd) {
-c010338a:	55                   	push   %ebp
-c010338b:	89 e5                	mov    %esp,%ebp
+c01031ec:	55                   	push   %ebp
+c01031ed:	89 e5                	mov    %esp,%ebp
     asm volatile ("lgdt (%0)" :: "r" (pd));
-c010338d:	8b 45 08             	mov    0x8(%ebp),%eax
-c0103390:	0f 01 10             	lgdtl  (%eax)
+c01031ef:	8b 45 08             	mov    0x8(%ebp),%eax
+c01031f2:	0f 01 10             	lgdtl  (%eax)
     asm volatile ("movw %%ax, %%gs" :: "a" (USER_DS));
-c0103393:	b8 23 00 00 00       	mov    $0x23,%eax
-c0103398:	8e e8                	mov    %eax,%gs
+c01031f5:	b8 23 00 00 00       	mov    $0x23,%eax
+c01031fa:	8e e8                	mov    %eax,%gs
     asm volatile ("movw %%ax, %%fs" :: "a" (USER_DS));
-c010339a:	b8 23 00 00 00       	mov    $0x23,%eax
-c010339f:	8e e0                	mov    %eax,%fs
+c01031fc:	b8 23 00 00 00       	mov    $0x23,%eax
+c0103201:	8e e0                	mov    %eax,%fs
     asm volatile ("movw %%ax, %%es" :: "a" (KERNEL_DS));
-c01033a1:	b8 10 00 00 00       	mov    $0x10,%eax
-c01033a6:	8e c0                	mov    %eax,%es
+c0103203:	b8 10 00 00 00       	mov    $0x10,%eax
+c0103208:	8e c0                	mov    %eax,%es
     asm volatile ("movw %%ax, %%ds" :: "a" (KERNEL_DS));
-c01033a8:	b8 10 00 00 00       	mov    $0x10,%eax
-c01033ad:	8e d8                	mov    %eax,%ds
+c010320a:	b8 10 00 00 00       	mov    $0x10,%eax
+c010320f:	8e d8                	mov    %eax,%ds
     asm volatile ("movw %%ax, %%ss" :: "a" (KERNEL_DS));
-c01033af:	b8 10 00 00 00       	mov    $0x10,%eax
-c01033b4:	8e d0                	mov    %eax,%ss
+c0103211:	b8 10 00 00 00       	mov    $0x10,%eax
+c0103216:	8e d0                	mov    %eax,%ss
     // reload cs
     asm volatile ("ljmp %0, $1f\n 1:\n" :: "i" (KERNEL_CS));
-c01033b6:	ea bd 33 10 c0 08 00 	ljmp   $0x8,$0xc01033bd
+c0103218:	ea 1f 32 10 c0 08 00 	ljmp   $0x8,$0xc010321f
 }
-c01033bd:	90                   	nop
-c01033be:	5d                   	pop    %ebp
-c01033bf:	c3                   	ret    
+c010321f:	90                   	nop
+c0103220:	5d                   	pop    %ebp
+c0103221:	c3                   	ret    
 
-c01033c0 <load_esp0>:
+c0103222 <load_esp0>:
  * load_esp0 - change the ESP0 in default task state segment,
  * so that we can use different kernel stack when we trap frame
  * user to kernel.
  * */
 void
 load_esp0(uintptr_t esp0) {
-c01033c0:	55                   	push   %ebp
-c01033c1:	89 e5                	mov    %esp,%ebp
+c0103222:	55                   	push   %ebp
+c0103223:	89 e5                	mov    %esp,%ebp
     ts.ts_esp0 = esp0;
-c01033c3:	8b 45 08             	mov    0x8(%ebp),%eax
-c01033c6:	a3 a4 2f 12 c0       	mov    %eax,0xc0122fa4
+c0103225:	8b 45 08             	mov    0x8(%ebp),%eax
+c0103228:	a3 a4 3f 12 c0       	mov    %eax,0xc0123fa4
 }
-c01033cb:	90                   	nop
-c01033cc:	5d                   	pop    %ebp
-c01033cd:	c3                   	ret    
+c010322d:	90                   	nop
+c010322e:	5d                   	pop    %ebp
+c010322f:	c3                   	ret    
 
-c01033ce <gdt_init>:
+c0103230 <gdt_init>:
 
 /* gdt_init - initialize the default GDT and TSS */
 static void
 gdt_init(void) {
-c01033ce:	55                   	push   %ebp
-c01033cf:	89 e5                	mov    %esp,%ebp
-c01033d1:	83 ec 10             	sub    $0x10,%esp
+c0103230:	55                   	push   %ebp
+c0103231:	89 e5                	mov    %esp,%ebp
+c0103233:	83 ec 14             	sub    $0x14,%esp
     // set boot kernel stack and default SS0
     load_esp0((uintptr_t)bootstacktop);
-c01033d4:	b8 00 f0 11 c0       	mov    $0xc011f000,%eax
-c01033d9:	50                   	push   %eax
-c01033da:	e8 e1 ff ff ff       	call   c01033c0 <load_esp0>
-c01033df:	83 c4 04             	add    $0x4,%esp
+c0103236:	b8 00 00 12 c0       	mov    $0xc0120000,%eax
+c010323b:	89 04 24             	mov    %eax,(%esp)
+c010323e:	e8 df ff ff ff       	call   c0103222 <load_esp0>
     ts.ts_ss0 = KERNEL_DS;
-c01033e2:	66 c7 05 a8 2f 12 c0 	movw   $0x10,0xc0122fa8
-c01033e9:	10 00 
+c0103243:	66 c7 05 a8 3f 12 c0 	movw   $0x10,0xc0123fa8
+c010324a:	10 00 
 
     // initialize the TSS filed of the gdt
     gdt[SEG_TSS] = SEGTSS(STS_T32A, (uintptr_t)&ts, sizeof(ts), DPL_KERNEL);
-c01033eb:	66 c7 05 28 fa 11 c0 	movw   $0x68,0xc011fa28
-c01033f2:	68 00 
-c01033f4:	b8 a0 2f 12 c0       	mov    $0xc0122fa0,%eax
-c01033f9:	66 a3 2a fa 11 c0    	mov    %ax,0xc011fa2a
-c01033ff:	b8 a0 2f 12 c0       	mov    $0xc0122fa0,%eax
-c0103404:	c1 e8 10             	shr    $0x10,%eax
-c0103407:	a2 2c fa 11 c0       	mov    %al,0xc011fa2c
-c010340c:	0f b6 05 2d fa 11 c0 	movzbl 0xc011fa2d,%eax
-c0103413:	83 e0 f0             	and    $0xfffffff0,%eax
-c0103416:	83 c8 09             	or     $0x9,%eax
-c0103419:	a2 2d fa 11 c0       	mov    %al,0xc011fa2d
-c010341e:	0f b6 05 2d fa 11 c0 	movzbl 0xc011fa2d,%eax
-c0103425:	83 e0 ef             	and    $0xffffffef,%eax
-c0103428:	a2 2d fa 11 c0       	mov    %al,0xc011fa2d
-c010342d:	0f b6 05 2d fa 11 c0 	movzbl 0xc011fa2d,%eax
-c0103434:	83 e0 9f             	and    $0xffffff9f,%eax
-c0103437:	a2 2d fa 11 c0       	mov    %al,0xc011fa2d
-c010343c:	0f b6 05 2d fa 11 c0 	movzbl 0xc011fa2d,%eax
-c0103443:	83 c8 80             	or     $0xffffff80,%eax
-c0103446:	a2 2d fa 11 c0       	mov    %al,0xc011fa2d
-c010344b:	0f b6 05 2e fa 11 c0 	movzbl 0xc011fa2e,%eax
-c0103452:	83 e0 f0             	and    $0xfffffff0,%eax
-c0103455:	a2 2e fa 11 c0       	mov    %al,0xc011fa2e
-c010345a:	0f b6 05 2e fa 11 c0 	movzbl 0xc011fa2e,%eax
-c0103461:	83 e0 ef             	and    $0xffffffef,%eax
-c0103464:	a2 2e fa 11 c0       	mov    %al,0xc011fa2e
-c0103469:	0f b6 05 2e fa 11 c0 	movzbl 0xc011fa2e,%eax
-c0103470:	83 e0 df             	and    $0xffffffdf,%eax
-c0103473:	a2 2e fa 11 c0       	mov    %al,0xc011fa2e
-c0103478:	0f b6 05 2e fa 11 c0 	movzbl 0xc011fa2e,%eax
-c010347f:	83 c8 40             	or     $0x40,%eax
-c0103482:	a2 2e fa 11 c0       	mov    %al,0xc011fa2e
-c0103487:	0f b6 05 2e fa 11 c0 	movzbl 0xc011fa2e,%eax
-c010348e:	83 e0 7f             	and    $0x7f,%eax
-c0103491:	a2 2e fa 11 c0       	mov    %al,0xc011fa2e
-c0103496:	b8 a0 2f 12 c0       	mov    $0xc0122fa0,%eax
-c010349b:	c1 e8 18             	shr    $0x18,%eax
-c010349e:	a2 2f fa 11 c0       	mov    %al,0xc011fa2f
+c010324c:	66 c7 05 28 0a 12 c0 	movw   $0x68,0xc0120a28
+c0103253:	68 00 
+c0103255:	b8 a0 3f 12 c0       	mov    $0xc0123fa0,%eax
+c010325a:	0f b7 c0             	movzwl %ax,%eax
+c010325d:	66 a3 2a 0a 12 c0    	mov    %ax,0xc0120a2a
+c0103263:	b8 a0 3f 12 c0       	mov    $0xc0123fa0,%eax
+c0103268:	c1 e8 10             	shr    $0x10,%eax
+c010326b:	a2 2c 0a 12 c0       	mov    %al,0xc0120a2c
+c0103270:	0f b6 05 2d 0a 12 c0 	movzbl 0xc0120a2d,%eax
+c0103277:	24 f0                	and    $0xf0,%al
+c0103279:	0c 09                	or     $0x9,%al
+c010327b:	a2 2d 0a 12 c0       	mov    %al,0xc0120a2d
+c0103280:	0f b6 05 2d 0a 12 c0 	movzbl 0xc0120a2d,%eax
+c0103287:	24 ef                	and    $0xef,%al
+c0103289:	a2 2d 0a 12 c0       	mov    %al,0xc0120a2d
+c010328e:	0f b6 05 2d 0a 12 c0 	movzbl 0xc0120a2d,%eax
+c0103295:	24 9f                	and    $0x9f,%al
+c0103297:	a2 2d 0a 12 c0       	mov    %al,0xc0120a2d
+c010329c:	0f b6 05 2d 0a 12 c0 	movzbl 0xc0120a2d,%eax
+c01032a3:	0c 80                	or     $0x80,%al
+c01032a5:	a2 2d 0a 12 c0       	mov    %al,0xc0120a2d
+c01032aa:	0f b6 05 2e 0a 12 c0 	movzbl 0xc0120a2e,%eax
+c01032b1:	24 f0                	and    $0xf0,%al
+c01032b3:	a2 2e 0a 12 c0       	mov    %al,0xc0120a2e
+c01032b8:	0f b6 05 2e 0a 12 c0 	movzbl 0xc0120a2e,%eax
+c01032bf:	24 ef                	and    $0xef,%al
+c01032c1:	a2 2e 0a 12 c0       	mov    %al,0xc0120a2e
+c01032c6:	0f b6 05 2e 0a 12 c0 	movzbl 0xc0120a2e,%eax
+c01032cd:	24 df                	and    $0xdf,%al
+c01032cf:	a2 2e 0a 12 c0       	mov    %al,0xc0120a2e
+c01032d4:	0f b6 05 2e 0a 12 c0 	movzbl 0xc0120a2e,%eax
+c01032db:	0c 40                	or     $0x40,%al
+c01032dd:	a2 2e 0a 12 c0       	mov    %al,0xc0120a2e
+c01032e2:	0f b6 05 2e 0a 12 c0 	movzbl 0xc0120a2e,%eax
+c01032e9:	24 7f                	and    $0x7f,%al
+c01032eb:	a2 2e 0a 12 c0       	mov    %al,0xc0120a2e
+c01032f0:	b8 a0 3f 12 c0       	mov    $0xc0123fa0,%eax
+c01032f5:	c1 e8 18             	shr    $0x18,%eax
+c01032f8:	a2 2f 0a 12 c0       	mov    %al,0xc0120a2f
 
     // reload all segment registers
     lgdt(&gdt_pd);
-c01034a3:	68 30 fa 11 c0       	push   $0xc011fa30
-c01034a8:	e8 dd fe ff ff       	call   c010338a <lgdt>
-c01034ad:	83 c4 04             	add    $0x4,%esp
-c01034b0:	66 c7 45 fe 28 00    	movw   $0x28,-0x2(%ebp)
+c01032fd:	c7 04 24 30 0a 12 c0 	movl   $0xc0120a30,(%esp)
+c0103304:	e8 e3 fe ff ff       	call   c01031ec <lgdt>
+c0103309:	66 c7 45 fe 28 00    	movw   $0x28,-0x2(%ebp)
     asm volatile ("cli" ::: "memory");
 }
 
 static inline void
 ltr(uint16_t sel) {
     asm volatile ("ltr %0" :: "r" (sel) : "memory");
-c01034b6:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
-c01034ba:	0f 00 d8             	ltr    %ax
+c010330f:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
+c0103313:	0f 00 d8             	ltr    %ax
 
     // load the TSS
     ltr(GD_TSS);
 }
-c01034bd:	90                   	nop
-c01034be:	c9                   	leave  
-c01034bf:	c3                   	ret    
+c0103316:	90                   	nop
+c0103317:	c9                   	leave  
+c0103318:	c3                   	ret    
 
-c01034c0 <init_pmm_manager>:
+c0103319 <init_pmm_manager>:
 
 //init_pmm_manager - initialize a pmm_manager instance
 static void
 init_pmm_manager(void) {
-c01034c0:	55                   	push   %ebp
-c01034c1:	89 e5                	mov    %esp,%ebp
-c01034c3:	83 ec 08             	sub    $0x8,%esp
+c0103319:	55                   	push   %ebp
+c010331a:	89 e5                	mov    %esp,%ebp
+c010331c:	83 ec 18             	sub    $0x18,%esp
     pmm_manager = &default_pmm_manager;
-c01034c6:	c7 05 20 30 12 c0 0c 	movl   $0xc010a10c,0xc0123020
-c01034cd:	a1 10 c0 
+c010331f:	c7 05 20 40 12 c0 3c 	movl   $0xc010a83c,0xc0124020
+c0103326:	a8 10 c0 
     cprintf("memory management: %s\n", pmm_manager->name);
-c01034d0:	a1 20 30 12 c0       	mov    0xc0123020,%eax
-c01034d5:	8b 00                	mov    (%eax),%eax
-c01034d7:	83 ec 08             	sub    $0x8,%esp
-c01034da:	50                   	push   %eax
-c01034db:	68 d4 8c 10 c0       	push   $0xc0108cd4
-c01034e0:	e8 9d cd ff ff       	call   c0100282 <cprintf>
-c01034e5:	83 c4 10             	add    $0x10,%esp
+c0103329:	a1 20 40 12 c0       	mov    0xc0124020,%eax
+c010332e:	8b 00                	mov    (%eax),%eax
+c0103330:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0103334:	c7 04 24 f4 93 10 c0 	movl   $0xc01093f4,(%esp)
+c010333b:	e8 61 cf ff ff       	call   c01002a1 <cprintf>
     pmm_manager->init();
-c01034e8:	a1 20 30 12 c0       	mov    0xc0123020,%eax
-c01034ed:	8b 40 04             	mov    0x4(%eax),%eax
-c01034f0:	ff d0                	call   *%eax
-}
-c01034f2:	90                   	nop
-c01034f3:	c9                   	leave  
-c01034f4:	c3                   	ret    
+c0103340:	a1 20 40 12 c0       	mov    0xc0124020,%eax
+c0103345:	8b 40 04             	mov    0x4(%eax),%eax
+c0103348:	ff d0                	call   *%eax
+}
+c010334a:	90                   	nop
+c010334b:	c9                   	leave  
+c010334c:	c3                   	ret    
 
-c01034f5 <init_memmap>:
+c010334d <init_memmap>:
 
 //init_memmap - call pmm->init_memmap to build Page struct for free memory  
 static void
 init_memmap(struct Page *base, size_t n) {
-c01034f5:	55                   	push   %ebp
-c01034f6:	89 e5                	mov    %esp,%ebp
-c01034f8:	83 ec 08             	sub    $0x8,%esp
+c010334d:	55                   	push   %ebp
+c010334e:	89 e5                	mov    %esp,%ebp
+c0103350:	83 ec 18             	sub    $0x18,%esp
     pmm_manager->init_memmap(base, n);
-c01034fb:	a1 20 30 12 c0       	mov    0xc0123020,%eax
-c0103500:	8b 40 08             	mov    0x8(%eax),%eax
-c0103503:	83 ec 08             	sub    $0x8,%esp
-c0103506:	ff 75 0c             	pushl  0xc(%ebp)
-c0103509:	ff 75 08             	pushl  0x8(%ebp)
-c010350c:	ff d0                	call   *%eax
-c010350e:	83 c4 10             	add    $0x10,%esp
-}
-c0103511:	90                   	nop
-c0103512:	c9                   	leave  
-c0103513:	c3                   	ret    
+c0103353:	a1 20 40 12 c0       	mov    0xc0124020,%eax
+c0103358:	8b 40 08             	mov    0x8(%eax),%eax
+c010335b:	8b 55 0c             	mov    0xc(%ebp),%edx
+c010335e:	89 54 24 04          	mov    %edx,0x4(%esp)
+c0103362:	8b 55 08             	mov    0x8(%ebp),%edx
+c0103365:	89 14 24             	mov    %edx,(%esp)
+c0103368:	ff d0                	call   *%eax
+}
+c010336a:	90                   	nop
+c010336b:	c9                   	leave  
+c010336c:	c3                   	ret    
 
-c0103514 <alloc_pages>:
+c010336d <alloc_pages>:
 
 //alloc_pages - call pmm->alloc_pages to allocate a continuous n*PAGESIZE memory 
 struct Page *
 alloc_pages(size_t n) {
-c0103514:	55                   	push   %ebp
-c0103515:	89 e5                	mov    %esp,%ebp
-c0103517:	83 ec 18             	sub    $0x18,%esp
+c010336d:	55                   	push   %ebp
+c010336e:	89 e5                	mov    %esp,%ebp
+c0103370:	83 ec 28             	sub    $0x28,%esp
     struct Page *page=NULL;
-c010351a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+c0103373:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     bool intr_flag;
     
     while (1)
     {
          local_intr_save(intr_flag);
-c0103521:	e8 26 fe ff ff       	call   c010334c <__intr_save>
-c0103526:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c010337a:	e8 2f fe ff ff       	call   c01031ae <__intr_save>
+c010337f:	89 45 f0             	mov    %eax,-0x10(%ebp)
          {
               page = pmm_manager->alloc_pages(n);
-c0103529:	a1 20 30 12 c0       	mov    0xc0123020,%eax
-c010352e:	8b 40 0c             	mov    0xc(%eax),%eax
-c0103531:	83 ec 0c             	sub    $0xc,%esp
-c0103534:	ff 75 08             	pushl  0x8(%ebp)
-c0103537:	ff d0                	call   *%eax
-c0103539:	83 c4 10             	add    $0x10,%esp
-c010353c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0103382:	a1 20 40 12 c0       	mov    0xc0124020,%eax
+c0103387:	8b 40 0c             	mov    0xc(%eax),%eax
+c010338a:	8b 55 08             	mov    0x8(%ebp),%edx
+c010338d:	89 14 24             	mov    %edx,(%esp)
+c0103390:	ff d0                	call   *%eax
+c0103392:	89 45 f4             	mov    %eax,-0xc(%ebp)
          }
          local_intr_restore(intr_flag);
-c010353f:	83 ec 0c             	sub    $0xc,%esp
-c0103542:	ff 75 f0             	pushl  -0x10(%ebp)
-c0103545:	e8 2c fe ff ff       	call   c0103376 <__intr_restore>
-c010354a:	83 c4 10             	add    $0x10,%esp
+c0103395:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0103398:	89 04 24             	mov    %eax,(%esp)
+c010339b:	e8 38 fe ff ff       	call   c01031d8 <__intr_restore>
 
          if (page != NULL || n > 1 || swap_init_ok == 0) break;
-c010354d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
-c0103551:	75 28                	jne    c010357b <alloc_pages+0x67>
-c0103553:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
-c0103557:	77 22                	ja     c010357b <alloc_pages+0x67>
-c0103559:	a1 10 30 12 c0       	mov    0xc0123010,%eax
-c010355e:	85 c0                	test   %eax,%eax
-c0103560:	74 19                	je     c010357b <alloc_pages+0x67>
+c01033a0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c01033a4:	75 2d                	jne    c01033d3 <alloc_pages+0x66>
+c01033a6:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
+c01033aa:	77 27                	ja     c01033d3 <alloc_pages+0x66>
+c01033ac:	a1 10 40 12 c0       	mov    0xc0124010,%eax
+c01033b1:	85 c0                	test   %eax,%eax
+c01033b3:	74 1e                	je     c01033d3 <alloc_pages+0x66>
          
          extern struct mm_struct *check_mm_struct;
          //cprintf("page %x, call swap_out in alloc_pages %d\n",page, n);
          swap_out(check_mm_struct, n, 0);
-c0103562:	8b 55 08             	mov    0x8(%ebp),%edx
-c0103565:	a1 2c 30 12 c0       	mov    0xc012302c,%eax
-c010356a:	83 ec 04             	sub    $0x4,%esp
-c010356d:	6a 00                	push   $0x0
-c010356f:	52                   	push   %edx
-c0103570:	50                   	push   %eax
-c0103571:	e8 87 23 00 00       	call   c01058fd <swap_out>
-c0103576:	83 c4 10             	add    $0x10,%esp
+c01033b5:	8b 55 08             	mov    0x8(%ebp),%edx
+c01033b8:	a1 2c 40 12 c0       	mov    0xc012402c,%eax
+c01033bd:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+c01033c4:	00 
+c01033c5:	89 54 24 04          	mov    %edx,0x4(%esp)
+c01033c9:	89 04 24             	mov    %eax,(%esp)
+c01033cc:	e8 ac 27 00 00       	call   c0105b7d <swap_out>
     }
-c0103579:	eb a6                	jmp    c0103521 <alloc_pages+0xd>
+c01033d1:	eb a7                	jmp    c010337a <alloc_pages+0xd>
     //cprintf("n %d,get page %x, No %d in alloc_pages\n",n,page,(page-pages));
     return page;
-c010357b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01033d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
 }
-c010357e:	c9                   	leave  
-c010357f:	c3                   	ret    
+c01033d6:	c9                   	leave  
+c01033d7:	c3                   	ret    
 
-c0103580 <free_pages>:
+c01033d8 <free_pages>:
 
 //free_pages - call pmm->free_pages to free a continuous n*PAGESIZE memory 
 void
 free_pages(struct Page *base, size_t n) {
-c0103580:	55                   	push   %ebp
-c0103581:	89 e5                	mov    %esp,%ebp
-c0103583:	83 ec 18             	sub    $0x18,%esp
+c01033d8:	55                   	push   %ebp
+c01033d9:	89 e5                	mov    %esp,%ebp
+c01033db:	83 ec 28             	sub    $0x28,%esp
     bool intr_flag;
     local_intr_save(intr_flag);
-c0103586:	e8 c1 fd ff ff       	call   c010334c <__intr_save>
-c010358b:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c01033de:	e8 cb fd ff ff       	call   c01031ae <__intr_save>
+c01033e3:	89 45 f4             	mov    %eax,-0xc(%ebp)
     {
         pmm_manager->free_pages(base, n);
-c010358e:	a1 20 30 12 c0       	mov    0xc0123020,%eax
-c0103593:	8b 40 10             	mov    0x10(%eax),%eax
-c0103596:	83 ec 08             	sub    $0x8,%esp
-c0103599:	ff 75 0c             	pushl  0xc(%ebp)
-c010359c:	ff 75 08             	pushl  0x8(%ebp)
-c010359f:	ff d0                	call   *%eax
-c01035a1:	83 c4 10             	add    $0x10,%esp
+c01033e6:	a1 20 40 12 c0       	mov    0xc0124020,%eax
+c01033eb:	8b 40 10             	mov    0x10(%eax),%eax
+c01033ee:	8b 55 0c             	mov    0xc(%ebp),%edx
+c01033f1:	89 54 24 04          	mov    %edx,0x4(%esp)
+c01033f5:	8b 55 08             	mov    0x8(%ebp),%edx
+c01033f8:	89 14 24             	mov    %edx,(%esp)
+c01033fb:	ff d0                	call   *%eax
     }
     local_intr_restore(intr_flag);
-c01035a4:	83 ec 0c             	sub    $0xc,%esp
-c01035a7:	ff 75 f4             	pushl  -0xc(%ebp)
-c01035aa:	e8 c7 fd ff ff       	call   c0103376 <__intr_restore>
-c01035af:	83 c4 10             	add    $0x10,%esp
-}
-c01035b2:	90                   	nop
-c01035b3:	c9                   	leave  
-c01035b4:	c3                   	ret    
+c01033fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0103400:	89 04 24             	mov    %eax,(%esp)
+c0103403:	e8 d0 fd ff ff       	call   c01031d8 <__intr_restore>
+}
+c0103408:	90                   	nop
+c0103409:	c9                   	leave  
+c010340a:	c3                   	ret    
 
-c01035b5 <nr_free_pages>:
+c010340b <nr_free_pages>:
 
 //nr_free_pages - call pmm->nr_free_pages to get the size (nr*PAGESIZE) 
 //of current free memory
 size_t
 nr_free_pages(void) {
-c01035b5:	55                   	push   %ebp
-c01035b6:	89 e5                	mov    %esp,%ebp
-c01035b8:	83 ec 18             	sub    $0x18,%esp
+c010340b:	55                   	push   %ebp
+c010340c:	89 e5                	mov    %esp,%ebp
+c010340e:	83 ec 28             	sub    $0x28,%esp
     size_t ret;
     bool intr_flag;
     local_intr_save(intr_flag);
-c01035bb:	e8 8c fd ff ff       	call   c010334c <__intr_save>
-c01035c0:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0103411:	e8 98 fd ff ff       	call   c01031ae <__intr_save>
+c0103416:	89 45 f4             	mov    %eax,-0xc(%ebp)
     {
         ret = pmm_manager->nr_free_pages();
-c01035c3:	a1 20 30 12 c0       	mov    0xc0123020,%eax
-c01035c8:	8b 40 14             	mov    0x14(%eax),%eax
-c01035cb:	ff d0                	call   *%eax
-c01035cd:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0103419:	a1 20 40 12 c0       	mov    0xc0124020,%eax
+c010341e:	8b 40 14             	mov    0x14(%eax),%eax
+c0103421:	ff d0                	call   *%eax
+c0103423:	89 45 f0             	mov    %eax,-0x10(%ebp)
     }
     local_intr_restore(intr_flag);
-c01035d0:	83 ec 0c             	sub    $0xc,%esp
-c01035d3:	ff 75 f4             	pushl  -0xc(%ebp)
-c01035d6:	e8 9b fd ff ff       	call   c0103376 <__intr_restore>
-c01035db:	83 c4 10             	add    $0x10,%esp
+c0103426:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0103429:	89 04 24             	mov    %eax,(%esp)
+c010342c:	e8 a7 fd ff ff       	call   c01031d8 <__intr_restore>
     return ret;
-c01035de:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0103431:	8b 45 f0             	mov    -0x10(%ebp),%eax
 }
-c01035e1:	c9                   	leave  
-c01035e2:	c3                   	ret    
+c0103434:	c9                   	leave  
+c0103435:	c3                   	ret    
 
-c01035e3 <page_init>:
+c0103436 <page_init>:
 
 /* pmm_init - initialize the physical memory management */
 static void
 page_init(void) {
-c01035e3:	55                   	push   %ebp
-c01035e4:	89 e5                	mov    %esp,%ebp
-c01035e6:	57                   	push   %edi
-c01035e7:	56                   	push   %esi
-c01035e8:	53                   	push   %ebx
-c01035e9:	83 ec 7c             	sub    $0x7c,%esp
+c0103436:	55                   	push   %ebp
+c0103437:	89 e5                	mov    %esp,%ebp
+c0103439:	57                   	push   %edi
+c010343a:	56                   	push   %esi
+c010343b:	53                   	push   %ebx
+c010343c:	81 ec 9c 00 00 00    	sub    $0x9c,%esp
     struct e820map *memmap = (struct e820map *)(0x8000 + KERNBASE);
-c01035ec:	c7 45 c4 00 80 00 c0 	movl   $0xc0008000,-0x3c(%ebp)
+c0103442:	c7 45 c4 00 80 00 c0 	movl   $0xc0008000,-0x3c(%ebp)
     uint64_t maxpa = 0;
-c01035f3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
-c01035fa:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+c0103449:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
+c0103450:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
 
     cprintf("e820map:\n");
-c0103601:	83 ec 0c             	sub    $0xc,%esp
-c0103604:	68 eb 8c 10 c0       	push   $0xc0108ceb
-c0103609:	e8 74 cc ff ff       	call   c0100282 <cprintf>
-c010360e:	83 c4 10             	add    $0x10,%esp
+c0103457:	c7 04 24 0b 94 10 c0 	movl   $0xc010940b,(%esp)
+c010345e:	e8 3e ce ff ff       	call   c01002a1 <cprintf>
     int i;
     for (i = 0; i < memmap->nr_map; i ++) {
-c0103611:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
-c0103618:	e9 fc 00 00 00       	jmp    c0103719 <page_init+0x136>
+c0103463:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+c010346a:	e9 22 01 00 00       	jmp    c0103591 <page_init+0x15b>
         uint64_t begin = memmap->map[i].addr, end = begin + memmap->map[i].size;
-c010361d:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
-c0103620:	8b 55 dc             	mov    -0x24(%ebp),%edx
-c0103623:	89 d0                	mov    %edx,%eax
-c0103625:	c1 e0 02             	shl    $0x2,%eax
-c0103628:	01 d0                	add    %edx,%eax
-c010362a:	c1 e0 02             	shl    $0x2,%eax
-c010362d:	01 c8                	add    %ecx,%eax
-c010362f:	8b 50 08             	mov    0x8(%eax),%edx
-c0103632:	8b 40 04             	mov    0x4(%eax),%eax
-c0103635:	89 45 b8             	mov    %eax,-0x48(%ebp)
-c0103638:	89 55 bc             	mov    %edx,-0x44(%ebp)
-c010363b:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
-c010363e:	8b 55 dc             	mov    -0x24(%ebp),%edx
-c0103641:	89 d0                	mov    %edx,%eax
-c0103643:	c1 e0 02             	shl    $0x2,%eax
-c0103646:	01 d0                	add    %edx,%eax
-c0103648:	c1 e0 02             	shl    $0x2,%eax
-c010364b:	01 c8                	add    %ecx,%eax
-c010364d:	8b 48 0c             	mov    0xc(%eax),%ecx
-c0103650:	8b 58 10             	mov    0x10(%eax),%ebx
-c0103653:	8b 45 b8             	mov    -0x48(%ebp),%eax
-c0103656:	8b 55 bc             	mov    -0x44(%ebp),%edx
-c0103659:	01 c8                	add    %ecx,%eax
-c010365b:	11 da                	adc    %ebx,%edx
-c010365d:	89 45 b0             	mov    %eax,-0x50(%ebp)
-c0103660:	89 55 b4             	mov    %edx,-0x4c(%ebp)
+c010346f:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
+c0103472:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c0103475:	89 d0                	mov    %edx,%eax
+c0103477:	c1 e0 02             	shl    $0x2,%eax
+c010347a:	01 d0                	add    %edx,%eax
+c010347c:	c1 e0 02             	shl    $0x2,%eax
+c010347f:	01 c8                	add    %ecx,%eax
+c0103481:	8b 50 08             	mov    0x8(%eax),%edx
+c0103484:	8b 40 04             	mov    0x4(%eax),%eax
+c0103487:	89 45 b8             	mov    %eax,-0x48(%ebp)
+c010348a:	89 55 bc             	mov    %edx,-0x44(%ebp)
+c010348d:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
+c0103490:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c0103493:	89 d0                	mov    %edx,%eax
+c0103495:	c1 e0 02             	shl    $0x2,%eax
+c0103498:	01 d0                	add    %edx,%eax
+c010349a:	c1 e0 02             	shl    $0x2,%eax
+c010349d:	01 c8                	add    %ecx,%eax
+c010349f:	8b 48 0c             	mov    0xc(%eax),%ecx
+c01034a2:	8b 58 10             	mov    0x10(%eax),%ebx
+c01034a5:	8b 45 b8             	mov    -0x48(%ebp),%eax
+c01034a8:	8b 55 bc             	mov    -0x44(%ebp),%edx
+c01034ab:	01 c8                	add    %ecx,%eax
+c01034ad:	11 da                	adc    %ebx,%edx
+c01034af:	89 45 b0             	mov    %eax,-0x50(%ebp)
+c01034b2:	89 55 b4             	mov    %edx,-0x4c(%ebp)
         cprintf("  memory: %08llx, [%08llx, %08llx], type = %d.\n",
-c0103663:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
-c0103666:	8b 55 dc             	mov    -0x24(%ebp),%edx
-c0103669:	89 d0                	mov    %edx,%eax
-c010366b:	c1 e0 02             	shl    $0x2,%eax
-c010366e:	01 d0                	add    %edx,%eax
-c0103670:	c1 e0 02             	shl    $0x2,%eax
-c0103673:	01 c8                	add    %ecx,%eax
-c0103675:	83 c0 14             	add    $0x14,%eax
-c0103678:	8b 00                	mov    (%eax),%eax
-c010367a:	89 45 84             	mov    %eax,-0x7c(%ebp)
-c010367d:	8b 45 b0             	mov    -0x50(%ebp),%eax
-c0103680:	8b 55 b4             	mov    -0x4c(%ebp),%edx
-c0103683:	83 c0 ff             	add    $0xffffffff,%eax
-c0103686:	83 d2 ff             	adc    $0xffffffff,%edx
-c0103689:	89 c1                	mov    %eax,%ecx
-c010368b:	89 d3                	mov    %edx,%ebx
-c010368d:	8b 55 c4             	mov    -0x3c(%ebp),%edx
-c0103690:	89 55 80             	mov    %edx,-0x80(%ebp)
-c0103693:	8b 55 dc             	mov    -0x24(%ebp),%edx
-c0103696:	89 d0                	mov    %edx,%eax
-c0103698:	c1 e0 02             	shl    $0x2,%eax
-c010369b:	01 d0                	add    %edx,%eax
-c010369d:	c1 e0 02             	shl    $0x2,%eax
-c01036a0:	03 45 80             	add    -0x80(%ebp),%eax
-c01036a3:	8b 50 10             	mov    0x10(%eax),%edx
-c01036a6:	8b 40 0c             	mov    0xc(%eax),%eax
-c01036a9:	ff 75 84             	pushl  -0x7c(%ebp)
-c01036ac:	53                   	push   %ebx
-c01036ad:	51                   	push   %ecx
-c01036ae:	ff 75 bc             	pushl  -0x44(%ebp)
-c01036b1:	ff 75 b8             	pushl  -0x48(%ebp)
-c01036b4:	52                   	push   %edx
-c01036b5:	50                   	push   %eax
-c01036b6:	68 f8 8c 10 c0       	push   $0xc0108cf8
-c01036bb:	e8 c2 cb ff ff       	call   c0100282 <cprintf>
-c01036c0:	83 c4 20             	add    $0x20,%esp
+c01034b5:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
+c01034b8:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c01034bb:	89 d0                	mov    %edx,%eax
+c01034bd:	c1 e0 02             	shl    $0x2,%eax
+c01034c0:	01 d0                	add    %edx,%eax
+c01034c2:	c1 e0 02             	shl    $0x2,%eax
+c01034c5:	01 c8                	add    %ecx,%eax
+c01034c7:	83 c0 14             	add    $0x14,%eax
+c01034ca:	8b 00                	mov    (%eax),%eax
+c01034cc:	89 45 84             	mov    %eax,-0x7c(%ebp)
+c01034cf:	8b 45 b0             	mov    -0x50(%ebp),%eax
+c01034d2:	8b 55 b4             	mov    -0x4c(%ebp),%edx
+c01034d5:	83 c0 ff             	add    $0xffffffff,%eax
+c01034d8:	83 d2 ff             	adc    $0xffffffff,%edx
+c01034db:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
+c01034e1:	89 95 7c ff ff ff    	mov    %edx,-0x84(%ebp)
+c01034e7:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
+c01034ea:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c01034ed:	89 d0                	mov    %edx,%eax
+c01034ef:	c1 e0 02             	shl    $0x2,%eax
+c01034f2:	01 d0                	add    %edx,%eax
+c01034f4:	c1 e0 02             	shl    $0x2,%eax
+c01034f7:	01 c8                	add    %ecx,%eax
+c01034f9:	8b 48 0c             	mov    0xc(%eax),%ecx
+c01034fc:	8b 58 10             	mov    0x10(%eax),%ebx
+c01034ff:	8b 55 84             	mov    -0x7c(%ebp),%edx
+c0103502:	89 54 24 1c          	mov    %edx,0x1c(%esp)
+c0103506:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
+c010350c:	8b 95 7c ff ff ff    	mov    -0x84(%ebp),%edx
+c0103512:	89 44 24 14          	mov    %eax,0x14(%esp)
+c0103516:	89 54 24 18          	mov    %edx,0x18(%esp)
+c010351a:	8b 45 b8             	mov    -0x48(%ebp),%eax
+c010351d:	8b 55 bc             	mov    -0x44(%ebp),%edx
+c0103520:	89 44 24 0c          	mov    %eax,0xc(%esp)
+c0103524:	89 54 24 10          	mov    %edx,0x10(%esp)
+c0103528:	89 4c 24 04          	mov    %ecx,0x4(%esp)
+c010352c:	89 5c 24 08          	mov    %ebx,0x8(%esp)
+c0103530:	c7 04 24 18 94 10 c0 	movl   $0xc0109418,(%esp)
+c0103537:	e8 65 cd ff ff       	call   c01002a1 <cprintf>
                 memmap->map[i].size, begin, end - 1, memmap->map[i].type);
         if (memmap->map[i].type == E820_ARM) {
-c01036c3:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
-c01036c6:	8b 55 dc             	mov    -0x24(%ebp),%edx
-c01036c9:	89 d0                	mov    %edx,%eax
-c01036cb:	c1 e0 02             	shl    $0x2,%eax
-c01036ce:	01 d0                	add    %edx,%eax
-c01036d0:	c1 e0 02             	shl    $0x2,%eax
-c01036d3:	01 c8                	add    %ecx,%eax
-c01036d5:	83 c0 14             	add    $0x14,%eax
-c01036d8:	8b 00                	mov    (%eax),%eax
-c01036da:	83 f8 01             	cmp    $0x1,%eax
-c01036dd:	75 36                	jne    c0103715 <page_init+0x132>
+c010353c:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
+c010353f:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c0103542:	89 d0                	mov    %edx,%eax
+c0103544:	c1 e0 02             	shl    $0x2,%eax
+c0103547:	01 d0                	add    %edx,%eax
+c0103549:	c1 e0 02             	shl    $0x2,%eax
+c010354c:	01 c8                	add    %ecx,%eax
+c010354e:	83 c0 14             	add    $0x14,%eax
+c0103551:	8b 00                	mov    (%eax),%eax
+c0103553:	83 f8 01             	cmp    $0x1,%eax
+c0103556:	75 36                	jne    c010358e <page_init+0x158>
             if (maxpa < end && begin < KMEMSIZE) {
-c01036df:	8b 45 e0             	mov    -0x20(%ebp),%eax
-c01036e2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
-c01036e5:	3b 55 b4             	cmp    -0x4c(%ebp),%edx
-c01036e8:	77 2b                	ja     c0103715 <page_init+0x132>
-c01036ea:	3b 55 b4             	cmp    -0x4c(%ebp),%edx
-c01036ed:	72 05                	jb     c01036f4 <page_init+0x111>
-c01036ef:	3b 45 b0             	cmp    -0x50(%ebp),%eax
-c01036f2:	73 21                	jae    c0103715 <page_init+0x132>
-c01036f4:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
-c01036f8:	77 1b                	ja     c0103715 <page_init+0x132>
-c01036fa:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
-c01036fe:	72 09                	jb     c0103709 <page_init+0x126>
-c0103700:	81 7d b8 ff ff ff 37 	cmpl   $0x37ffffff,-0x48(%ebp)
-c0103707:	77 0c                	ja     c0103715 <page_init+0x132>
+c0103558:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c010355b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c010355e:	3b 55 b4             	cmp    -0x4c(%ebp),%edx
+c0103561:	77 2b                	ja     c010358e <page_init+0x158>
+c0103563:	3b 55 b4             	cmp    -0x4c(%ebp),%edx
+c0103566:	72 05                	jb     c010356d <page_init+0x137>
+c0103568:	3b 45 b0             	cmp    -0x50(%ebp),%eax
+c010356b:	73 21                	jae    c010358e <page_init+0x158>
+c010356d:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
+c0103571:	77 1b                	ja     c010358e <page_init+0x158>
+c0103573:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
+c0103577:	72 09                	jb     c0103582 <page_init+0x14c>
+c0103579:	81 7d b8 ff ff ff 37 	cmpl   $0x37ffffff,-0x48(%ebp)
+c0103580:	77 0c                	ja     c010358e <page_init+0x158>
                 maxpa = end;
-c0103709:	8b 45 b0             	mov    -0x50(%ebp),%eax
-c010370c:	8b 55 b4             	mov    -0x4c(%ebp),%edx
-c010370f:	89 45 e0             	mov    %eax,-0x20(%ebp)
-c0103712:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+c0103582:	8b 45 b0             	mov    -0x50(%ebp),%eax
+c0103585:	8b 55 b4             	mov    -0x4c(%ebp),%edx
+c0103588:	89 45 e0             	mov    %eax,-0x20(%ebp)
+c010358b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
     struct e820map *memmap = (struct e820map *)(0x8000 + KERNBASE);
     uint64_t maxpa = 0;
 
     cprintf("e820map:\n");
     int i;
     for (i = 0; i < memmap->nr_map; i ++) {
-c0103715:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
-c0103719:	8b 45 c4             	mov    -0x3c(%ebp),%eax
-c010371c:	8b 00                	mov    (%eax),%eax
-c010371e:	3b 45 dc             	cmp    -0x24(%ebp),%eax
-c0103721:	0f 8f f6 fe ff ff    	jg     c010361d <page_init+0x3a>
+c010358e:	ff 45 dc             	incl   -0x24(%ebp)
+c0103591:	8b 45 c4             	mov    -0x3c(%ebp),%eax
+c0103594:	8b 00                	mov    (%eax),%eax
+c0103596:	3b 45 dc             	cmp    -0x24(%ebp),%eax
+c0103599:	0f 8f d0 fe ff ff    	jg     c010346f <page_init+0x39>
             if (maxpa < end && begin < KMEMSIZE) {
                 maxpa = end;
             }
         }
     }
     if (maxpa > KMEMSIZE) {
-c0103727:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
-c010372b:	72 1d                	jb     c010374a <page_init+0x167>
-c010372d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
-c0103731:	77 09                	ja     c010373c <page_init+0x159>
-c0103733:	81 7d e0 00 00 00 38 	cmpl   $0x38000000,-0x20(%ebp)
-c010373a:	76 0e                	jbe    c010374a <page_init+0x167>
+c010359f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+c01035a3:	72 1d                	jb     c01035c2 <page_init+0x18c>
+c01035a5:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+c01035a9:	77 09                	ja     c01035b4 <page_init+0x17e>
+c01035ab:	81 7d e0 00 00 00 38 	cmpl   $0x38000000,-0x20(%ebp)
+c01035b2:	76 0e                	jbe    c01035c2 <page_init+0x18c>
         maxpa = KMEMSIZE;
-c010373c:	c7 45 e0 00 00 00 38 	movl   $0x38000000,-0x20(%ebp)
-c0103743:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+c01035b4:	c7 45 e0 00 00 00 38 	movl   $0x38000000,-0x20(%ebp)
+c01035bb:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
     }
 
     extern char end[];
 
     npage = maxpa / PGSIZE;
-c010374a:	8b 45 e0             	mov    -0x20(%ebp),%eax
-c010374d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
-c0103750:	0f ac d0 0c          	shrd   $0xc,%edx,%eax
-c0103754:	c1 ea 0c             	shr    $0xc,%edx
-c0103757:	a3 80 2f 12 c0       	mov    %eax,0xc0122f80
+c01035c2:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c01035c5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c01035c8:	0f ac d0 0c          	shrd   $0xc,%edx,%eax
+c01035cc:	c1 ea 0c             	shr    $0xc,%edx
+c01035cf:	a3 80 3f 12 c0       	mov    %eax,0xc0123f80
     pages = (struct Page *)ROUNDUP((void *)end, PGSIZE);
-c010375c:	c7 45 ac 00 10 00 00 	movl   $0x1000,-0x54(%ebp)
-c0103763:	b8 18 31 12 c0       	mov    $0xc0123118,%eax
-c0103768:	8d 50 ff             	lea    -0x1(%eax),%edx
-c010376b:	8b 45 ac             	mov    -0x54(%ebp),%eax
-c010376e:	01 d0                	add    %edx,%eax
-c0103770:	89 45 a8             	mov    %eax,-0x58(%ebp)
-c0103773:	8b 45 a8             	mov    -0x58(%ebp),%eax
-c0103776:	ba 00 00 00 00       	mov    $0x0,%edx
-c010377b:	f7 75 ac             	divl   -0x54(%ebp)
-c010377e:	8b 45 a8             	mov    -0x58(%ebp),%eax
-c0103781:	29 d0                	sub    %edx,%eax
-c0103783:	a3 28 30 12 c0       	mov    %eax,0xc0123028
+c01035d4:	c7 45 ac 00 10 00 00 	movl   $0x1000,-0x54(%ebp)
+c01035db:	b8 18 41 12 c0       	mov    $0xc0124118,%eax
+c01035e0:	8d 50 ff             	lea    -0x1(%eax),%edx
+c01035e3:	8b 45 ac             	mov    -0x54(%ebp),%eax
+c01035e6:	01 d0                	add    %edx,%eax
+c01035e8:	89 45 a8             	mov    %eax,-0x58(%ebp)
+c01035eb:	8b 45 a8             	mov    -0x58(%ebp),%eax
+c01035ee:	ba 00 00 00 00       	mov    $0x0,%edx
+c01035f3:	f7 75 ac             	divl   -0x54(%ebp)
+c01035f6:	8b 45 a8             	mov    -0x58(%ebp),%eax
+c01035f9:	29 d0                	sub    %edx,%eax
+c01035fb:	a3 28 40 12 c0       	mov    %eax,0xc0124028
 
     for (i = 0; i < npage; i ++) {
-c0103788:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
-c010378f:	eb 27                	jmp    c01037b8 <page_init+0x1d5>
+c0103600:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+c0103607:	eb 26                	jmp    c010362f <page_init+0x1f9>
         SetPageReserved(pages + i);
-c0103791:	a1 28 30 12 c0       	mov    0xc0123028,%eax
-c0103796:	8b 55 dc             	mov    -0x24(%ebp),%edx
-c0103799:	c1 e2 05             	shl    $0x5,%edx
-c010379c:	01 d0                	add    %edx,%eax
-c010379e:	83 c0 04             	add    $0x4,%eax
-c01037a1:	c7 45 90 00 00 00 00 	movl   $0x0,-0x70(%ebp)
-c01037a8:	89 45 8c             	mov    %eax,-0x74(%ebp)
+c0103609:	a1 28 40 12 c0       	mov    0xc0124028,%eax
+c010360e:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c0103611:	c1 e2 05             	shl    $0x5,%edx
+c0103614:	01 d0                	add    %edx,%eax
+c0103616:	83 c0 04             	add    $0x4,%eax
+c0103619:	c7 45 90 00 00 00 00 	movl   $0x0,-0x70(%ebp)
+c0103620:	89 45 8c             	mov    %eax,-0x74(%ebp)
  * Note that @nr may be almost arbitrarily large; this function is not
  * restricted to acting on a single-word quantity.
  * */
 static inline void
 set_bit(int nr, volatile void *addr) {
     asm volatile ("btsl %1, %0" :"=m" (*(volatile long *)addr) : "Ir" (nr));
-c01037ab:	8b 45 8c             	mov    -0x74(%ebp),%eax
-c01037ae:	8b 55 90             	mov    -0x70(%ebp),%edx
-c01037b1:	0f ab 10             	bts    %edx,(%eax)
+c0103623:	8b 45 8c             	mov    -0x74(%ebp),%eax
+c0103626:	8b 55 90             	mov    -0x70(%ebp),%edx
+c0103629:	0f ab 10             	bts    %edx,(%eax)
     extern char end[];
 
     npage = maxpa / PGSIZE;
     pages = (struct Page *)ROUNDUP((void *)end, PGSIZE);
 
     for (i = 0; i < npage; i ++) {
-c01037b4:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
-c01037b8:	8b 55 dc             	mov    -0x24(%ebp),%edx
-c01037bb:	a1 80 2f 12 c0       	mov    0xc0122f80,%eax
-c01037c0:	39 c2                	cmp    %eax,%edx
-c01037c2:	72 cd                	jb     c0103791 <page_init+0x1ae>
+c010362c:	ff 45 dc             	incl   -0x24(%ebp)
+c010362f:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c0103632:	a1 80 3f 12 c0       	mov    0xc0123f80,%eax
+c0103637:	39 c2                	cmp    %eax,%edx
+c0103639:	72 ce                	jb     c0103609 <page_init+0x1d3>
         SetPageReserved(pages + i);
     }
 
     uintptr_t freemem = PADDR((uintptr_t)pages + sizeof(struct Page) * npage);
-c01037c4:	a1 80 2f 12 c0       	mov    0xc0122f80,%eax
-c01037c9:	c1 e0 05             	shl    $0x5,%eax
-c01037cc:	89 c2                	mov    %eax,%edx
-c01037ce:	a1 28 30 12 c0       	mov    0xc0123028,%eax
-c01037d3:	01 d0                	add    %edx,%eax
-c01037d5:	89 45 a4             	mov    %eax,-0x5c(%ebp)
-c01037d8:	81 7d a4 ff ff ff bf 	cmpl   $0xbfffffff,-0x5c(%ebp)
-c01037df:	77 17                	ja     c01037f8 <page_init+0x215>
-c01037e1:	ff 75 a4             	pushl  -0x5c(%ebp)
-c01037e4:	68 84 8c 10 c0       	push   $0xc0108c84
-c01037e9:	68 e9 00 00 00       	push   $0xe9
-c01037ee:	68 28 8d 10 c0       	push   $0xc0108d28
-c01037f3:	e8 f0 cb ff ff       	call   c01003e8 <__panic>
-c01037f8:	8b 45 a4             	mov    -0x5c(%ebp),%eax
-c01037fb:	05 00 00 00 40       	add    $0x40000000,%eax
-c0103800:	89 45 a0             	mov    %eax,-0x60(%ebp)
+c010363b:	a1 80 3f 12 c0       	mov    0xc0123f80,%eax
+c0103640:	c1 e0 05             	shl    $0x5,%eax
+c0103643:	89 c2                	mov    %eax,%edx
+c0103645:	a1 28 40 12 c0       	mov    0xc0124028,%eax
+c010364a:	01 d0                	add    %edx,%eax
+c010364c:	89 45 a4             	mov    %eax,-0x5c(%ebp)
+c010364f:	81 7d a4 ff ff ff bf 	cmpl   $0xbfffffff,-0x5c(%ebp)
+c0103656:	77 23                	ja     c010367b <page_init+0x245>
+c0103658:	8b 45 a4             	mov    -0x5c(%ebp),%eax
+c010365b:	89 44 24 0c          	mov    %eax,0xc(%esp)
+c010365f:	c7 44 24 08 a4 93 10 	movl   $0xc01093a4,0x8(%esp)
+c0103666:	c0 
+c0103667:	c7 44 24 04 e9 00 00 	movl   $0xe9,0x4(%esp)
+c010366e:	00 
+c010366f:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c0103676:	e8 7d cd ff ff       	call   c01003f8 <__panic>
+c010367b:	8b 45 a4             	mov    -0x5c(%ebp),%eax
+c010367e:	05 00 00 00 40       	add    $0x40000000,%eax
+c0103683:	89 45 a0             	mov    %eax,-0x60(%ebp)
 
     for (i = 0; i < memmap->nr_map; i ++) {
-c0103803:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
-c010380a:	e9 69 01 00 00       	jmp    c0103978 <page_init+0x395>
+c0103686:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+c010368d:	e9 61 01 00 00       	jmp    c01037f3 <page_init+0x3bd>
         uint64_t begin = memmap->map[i].addr, end = begin + memmap->map[i].size;
-c010380f:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
-c0103812:	8b 55 dc             	mov    -0x24(%ebp),%edx
-c0103815:	89 d0                	mov    %edx,%eax
-c0103817:	c1 e0 02             	shl    $0x2,%eax
-c010381a:	01 d0                	add    %edx,%eax
-c010381c:	c1 e0 02             	shl    $0x2,%eax
-c010381f:	01 c8                	add    %ecx,%eax
-c0103821:	8b 50 08             	mov    0x8(%eax),%edx
-c0103824:	8b 40 04             	mov    0x4(%eax),%eax
-c0103827:	89 45 d0             	mov    %eax,-0x30(%ebp)
-c010382a:	89 55 d4             	mov    %edx,-0x2c(%ebp)
-c010382d:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
-c0103830:	8b 55 dc             	mov    -0x24(%ebp),%edx
-c0103833:	89 d0                	mov    %edx,%eax
-c0103835:	c1 e0 02             	shl    $0x2,%eax
-c0103838:	01 d0                	add    %edx,%eax
-c010383a:	c1 e0 02             	shl    $0x2,%eax
-c010383d:	01 c8                	add    %ecx,%eax
-c010383f:	8b 48 0c             	mov    0xc(%eax),%ecx
-c0103842:	8b 58 10             	mov    0x10(%eax),%ebx
-c0103845:	8b 45 d0             	mov    -0x30(%ebp),%eax
-c0103848:	8b 55 d4             	mov    -0x2c(%ebp),%edx
-c010384b:	01 c8                	add    %ecx,%eax
-c010384d:	11 da                	adc    %ebx,%edx
-c010384f:	89 45 c8             	mov    %eax,-0x38(%ebp)
-c0103852:	89 55 cc             	mov    %edx,-0x34(%ebp)
+c0103692:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
+c0103695:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c0103698:	89 d0                	mov    %edx,%eax
+c010369a:	c1 e0 02             	shl    $0x2,%eax
+c010369d:	01 d0                	add    %edx,%eax
+c010369f:	c1 e0 02             	shl    $0x2,%eax
+c01036a2:	01 c8                	add    %ecx,%eax
+c01036a4:	8b 50 08             	mov    0x8(%eax),%edx
+c01036a7:	8b 40 04             	mov    0x4(%eax),%eax
+c01036aa:	89 45 d0             	mov    %eax,-0x30(%ebp)
+c01036ad:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+c01036b0:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
+c01036b3:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c01036b6:	89 d0                	mov    %edx,%eax
+c01036b8:	c1 e0 02             	shl    $0x2,%eax
+c01036bb:	01 d0                	add    %edx,%eax
+c01036bd:	c1 e0 02             	shl    $0x2,%eax
+c01036c0:	01 c8                	add    %ecx,%eax
+c01036c2:	8b 48 0c             	mov    0xc(%eax),%ecx
+c01036c5:	8b 58 10             	mov    0x10(%eax),%ebx
+c01036c8:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c01036cb:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c01036ce:	01 c8                	add    %ecx,%eax
+c01036d0:	11 da                	adc    %ebx,%edx
+c01036d2:	89 45 c8             	mov    %eax,-0x38(%ebp)
+c01036d5:	89 55 cc             	mov    %edx,-0x34(%ebp)
         if (memmap->map[i].type == E820_ARM) {
-c0103855:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
-c0103858:	8b 55 dc             	mov    -0x24(%ebp),%edx
-c010385b:	89 d0                	mov    %edx,%eax
-c010385d:	c1 e0 02             	shl    $0x2,%eax
-c0103860:	01 d0                	add    %edx,%eax
-c0103862:	c1 e0 02             	shl    $0x2,%eax
-c0103865:	01 c8                	add    %ecx,%eax
-c0103867:	83 c0 14             	add    $0x14,%eax
-c010386a:	8b 00                	mov    (%eax),%eax
-c010386c:	83 f8 01             	cmp    $0x1,%eax
-c010386f:	0f 85 ff 00 00 00    	jne    c0103974 <page_init+0x391>
+c01036d8:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
+c01036db:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c01036de:	89 d0                	mov    %edx,%eax
+c01036e0:	c1 e0 02             	shl    $0x2,%eax
+c01036e3:	01 d0                	add    %edx,%eax
+c01036e5:	c1 e0 02             	shl    $0x2,%eax
+c01036e8:	01 c8                	add    %ecx,%eax
+c01036ea:	83 c0 14             	add    $0x14,%eax
+c01036ed:	8b 00                	mov    (%eax),%eax
+c01036ef:	83 f8 01             	cmp    $0x1,%eax
+c01036f2:	0f 85 f8 00 00 00    	jne    c01037f0 <page_init+0x3ba>
             if (begin < freemem) {
-c0103875:	8b 45 a0             	mov    -0x60(%ebp),%eax
-c0103878:	ba 00 00 00 00       	mov    $0x0,%edx
-c010387d:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
-c0103880:	72 17                	jb     c0103899 <page_init+0x2b6>
-c0103882:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
-c0103885:	77 05                	ja     c010388c <page_init+0x2a9>
-c0103887:	3b 45 d0             	cmp    -0x30(%ebp),%eax
-c010388a:	76 0d                	jbe    c0103899 <page_init+0x2b6>
+c01036f8:	8b 45 a0             	mov    -0x60(%ebp),%eax
+c01036fb:	ba 00 00 00 00       	mov    $0x0,%edx
+c0103700:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+c0103703:	72 17                	jb     c010371c <page_init+0x2e6>
+c0103705:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+c0103708:	77 05                	ja     c010370f <page_init+0x2d9>
+c010370a:	3b 45 d0             	cmp    -0x30(%ebp),%eax
+c010370d:	76 0d                	jbe    c010371c <page_init+0x2e6>
                 begin = freemem;
-c010388c:	8b 45 a0             	mov    -0x60(%ebp),%eax
-c010388f:	89 45 d0             	mov    %eax,-0x30(%ebp)
-c0103892:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
+c010370f:	8b 45 a0             	mov    -0x60(%ebp),%eax
+c0103712:	89 45 d0             	mov    %eax,-0x30(%ebp)
+c0103715:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
             }
             if (end > KMEMSIZE) {
-c0103899:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
-c010389d:	72 1d                	jb     c01038bc <page_init+0x2d9>
-c010389f:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
-c01038a3:	77 09                	ja     c01038ae <page_init+0x2cb>
-c01038a5:	81 7d c8 00 00 00 38 	cmpl   $0x38000000,-0x38(%ebp)
-c01038ac:	76 0e                	jbe    c01038bc <page_init+0x2d9>
+c010371c:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
+c0103720:	72 1d                	jb     c010373f <page_init+0x309>
+c0103722:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
+c0103726:	77 09                	ja     c0103731 <page_init+0x2fb>
+c0103728:	81 7d c8 00 00 00 38 	cmpl   $0x38000000,-0x38(%ebp)
+c010372f:	76 0e                	jbe    c010373f <page_init+0x309>
                 end = KMEMSIZE;
-c01038ae:	c7 45 c8 00 00 00 38 	movl   $0x38000000,-0x38(%ebp)
-c01038b5:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
+c0103731:	c7 45 c8 00 00 00 38 	movl   $0x38000000,-0x38(%ebp)
+c0103738:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
             }
             if (begin < end) {
-c01038bc:	8b 45 d0             	mov    -0x30(%ebp),%eax
-c01038bf:	8b 55 d4             	mov    -0x2c(%ebp),%edx
-c01038c2:	3b 55 cc             	cmp    -0x34(%ebp),%edx
-c01038c5:	0f 87 a9 00 00 00    	ja     c0103974 <page_init+0x391>
-c01038cb:	3b 55 cc             	cmp    -0x34(%ebp),%edx
-c01038ce:	72 09                	jb     c01038d9 <page_init+0x2f6>
-c01038d0:	3b 45 c8             	cmp    -0x38(%ebp),%eax
-c01038d3:	0f 83 9b 00 00 00    	jae    c0103974 <page_init+0x391>
+c010373f:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c0103742:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c0103745:	3b 55 cc             	cmp    -0x34(%ebp),%edx
+c0103748:	0f 87 a2 00 00 00    	ja     c01037f0 <page_init+0x3ba>
+c010374e:	3b 55 cc             	cmp    -0x34(%ebp),%edx
+c0103751:	72 09                	jb     c010375c <page_init+0x326>
+c0103753:	3b 45 c8             	cmp    -0x38(%ebp),%eax
+c0103756:	0f 83 94 00 00 00    	jae    c01037f0 <page_init+0x3ba>
                 begin = ROUNDUP(begin, PGSIZE);
-c01038d9:	c7 45 9c 00 10 00 00 	movl   $0x1000,-0x64(%ebp)
-c01038e0:	8b 55 d0             	mov    -0x30(%ebp),%edx
-c01038e3:	8b 45 9c             	mov    -0x64(%ebp),%eax
-c01038e6:	01 d0                	add    %edx,%eax
-c01038e8:	83 e8 01             	sub    $0x1,%eax
-c01038eb:	89 45 98             	mov    %eax,-0x68(%ebp)
-c01038ee:	8b 45 98             	mov    -0x68(%ebp),%eax
-c01038f1:	ba 00 00 00 00       	mov    $0x0,%edx
-c01038f6:	f7 75 9c             	divl   -0x64(%ebp)
-c01038f9:	8b 45 98             	mov    -0x68(%ebp),%eax
-c01038fc:	29 d0                	sub    %edx,%eax
-c01038fe:	ba 00 00 00 00       	mov    $0x0,%edx
-c0103903:	89 45 d0             	mov    %eax,-0x30(%ebp)
-c0103906:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+c010375c:	c7 45 9c 00 10 00 00 	movl   $0x1000,-0x64(%ebp)
+c0103763:	8b 55 d0             	mov    -0x30(%ebp),%edx
+c0103766:	8b 45 9c             	mov    -0x64(%ebp),%eax
+c0103769:	01 d0                	add    %edx,%eax
+c010376b:	48                   	dec    %eax
+c010376c:	89 45 98             	mov    %eax,-0x68(%ebp)
+c010376f:	8b 45 98             	mov    -0x68(%ebp),%eax
+c0103772:	ba 00 00 00 00       	mov    $0x0,%edx
+c0103777:	f7 75 9c             	divl   -0x64(%ebp)
+c010377a:	8b 45 98             	mov    -0x68(%ebp),%eax
+c010377d:	29 d0                	sub    %edx,%eax
+c010377f:	ba 00 00 00 00       	mov    $0x0,%edx
+c0103784:	89 45 d0             	mov    %eax,-0x30(%ebp)
+c0103787:	89 55 d4             	mov    %edx,-0x2c(%ebp)
                 end = ROUNDDOWN(end, PGSIZE);
-c0103909:	8b 45 c8             	mov    -0x38(%ebp),%eax
-c010390c:	89 45 94             	mov    %eax,-0x6c(%ebp)
-c010390f:	8b 45 94             	mov    -0x6c(%ebp),%eax
-c0103912:	ba 00 00 00 00       	mov    $0x0,%edx
-c0103917:	89 c3                	mov    %eax,%ebx
-c0103919:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
-c010391f:	89 de                	mov    %ebx,%esi
-c0103921:	89 d0                	mov    %edx,%eax
-c0103923:	83 e0 00             	and    $0x0,%eax
-c0103926:	89 c7                	mov    %eax,%edi
-c0103928:	89 75 c8             	mov    %esi,-0x38(%ebp)
-c010392b:	89 7d cc             	mov    %edi,-0x34(%ebp)
+c010378a:	8b 45 c8             	mov    -0x38(%ebp),%eax
+c010378d:	89 45 94             	mov    %eax,-0x6c(%ebp)
+c0103790:	8b 45 94             	mov    -0x6c(%ebp),%eax
+c0103793:	ba 00 00 00 00       	mov    $0x0,%edx
+c0103798:	89 c3                	mov    %eax,%ebx
+c010379a:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
+c01037a0:	89 de                	mov    %ebx,%esi
+c01037a2:	89 d0                	mov    %edx,%eax
+c01037a4:	83 e0 00             	and    $0x0,%eax
+c01037a7:	89 c7                	mov    %eax,%edi
+c01037a9:	89 75 c8             	mov    %esi,-0x38(%ebp)
+c01037ac:	89 7d cc             	mov    %edi,-0x34(%ebp)
                 if (begin < end) {
-c010392e:	8b 45 d0             	mov    -0x30(%ebp),%eax
-c0103931:	8b 55 d4             	mov    -0x2c(%ebp),%edx
-c0103934:	3b 55 cc             	cmp    -0x34(%ebp),%edx
-c0103937:	77 3b                	ja     c0103974 <page_init+0x391>
-c0103939:	3b 55 cc             	cmp    -0x34(%ebp),%edx
-c010393c:	72 05                	jb     c0103943 <page_init+0x360>
-c010393e:	3b 45 c8             	cmp    -0x38(%ebp),%eax
-c0103941:	73 31                	jae    c0103974 <page_init+0x391>
+c01037af:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c01037b2:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c01037b5:	3b 55 cc             	cmp    -0x34(%ebp),%edx
+c01037b8:	77 36                	ja     c01037f0 <page_init+0x3ba>
+c01037ba:	3b 55 cc             	cmp    -0x34(%ebp),%edx
+c01037bd:	72 05                	jb     c01037c4 <page_init+0x38e>
+c01037bf:	3b 45 c8             	cmp    -0x38(%ebp),%eax
+c01037c2:	73 2c                	jae    c01037f0 <page_init+0x3ba>
                     init_memmap(pa2page(begin), (end - begin) / PGSIZE);
-c0103943:	8b 45 c8             	mov    -0x38(%ebp),%eax
-c0103946:	8b 55 cc             	mov    -0x34(%ebp),%edx
-c0103949:	2b 45 d0             	sub    -0x30(%ebp),%eax
-c010394c:	1b 55 d4             	sbb    -0x2c(%ebp),%edx
-c010394f:	0f ac d0 0c          	shrd   $0xc,%edx,%eax
-c0103953:	c1 ea 0c             	shr    $0xc,%edx
-c0103956:	89 c3                	mov    %eax,%ebx
-c0103958:	8b 45 d0             	mov    -0x30(%ebp),%eax
-c010395b:	83 ec 0c             	sub    $0xc,%esp
-c010395e:	50                   	push   %eax
-c010395f:	e8 8b f8 ff ff       	call   c01031ef <pa2page>
-c0103964:	83 c4 10             	add    $0x10,%esp
-c0103967:	83 ec 08             	sub    $0x8,%esp
-c010396a:	53                   	push   %ebx
-c010396b:	50                   	push   %eax
-c010396c:	e8 84 fb ff ff       	call   c01034f5 <init_memmap>
-c0103971:	83 c4 10             	add    $0x10,%esp
+c01037c4:	8b 45 c8             	mov    -0x38(%ebp),%eax
+c01037c7:	8b 55 cc             	mov    -0x34(%ebp),%edx
+c01037ca:	2b 45 d0             	sub    -0x30(%ebp),%eax
+c01037cd:	1b 55 d4             	sbb    -0x2c(%ebp),%edx
+c01037d0:	0f ac d0 0c          	shrd   $0xc,%edx,%eax
+c01037d4:	c1 ea 0c             	shr    $0xc,%edx
+c01037d7:	89 c3                	mov    %eax,%ebx
+c01037d9:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c01037dc:	89 04 24             	mov    %eax,(%esp)
+c01037df:	e8 4b f8 ff ff       	call   c010302f <pa2page>
+c01037e4:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+c01037e8:	89 04 24             	mov    %eax,(%esp)
+c01037eb:	e8 5d fb ff ff       	call   c010334d <init_memmap>
         SetPageReserved(pages + i);
     }
 
     uintptr_t freemem = PADDR((uintptr_t)pages + sizeof(struct Page) * npage);
 
     for (i = 0; i < memmap->nr_map; i ++) {
-c0103974:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
-c0103978:	8b 45 c4             	mov    -0x3c(%ebp),%eax
-c010397b:	8b 00                	mov    (%eax),%eax
-c010397d:	3b 45 dc             	cmp    -0x24(%ebp),%eax
-c0103980:	0f 8f 89 fe ff ff    	jg     c010380f <page_init+0x22c>
+c01037f0:	ff 45 dc             	incl   -0x24(%ebp)
+c01037f3:	8b 45 c4             	mov    -0x3c(%ebp),%eax
+c01037f6:	8b 00                	mov    (%eax),%eax
+c01037f8:	3b 45 dc             	cmp    -0x24(%ebp),%eax
+c01037fb:	0f 8f 91 fe ff ff    	jg     c0103692 <page_init+0x25c>
                     init_memmap(pa2page(begin), (end - begin) / PGSIZE);
                 }
             }
         }
     }
 }
-c0103986:	90                   	nop
-c0103987:	8d 65 f4             	lea    -0xc(%ebp),%esp
-c010398a:	5b                   	pop    %ebx
-c010398b:	5e                   	pop    %esi
-c010398c:	5f                   	pop    %edi
-c010398d:	5d                   	pop    %ebp
-c010398e:	c3                   	ret    
+c0103801:	90                   	nop
+c0103802:	81 c4 9c 00 00 00    	add    $0x9c,%esp
+c0103808:	5b                   	pop    %ebx
+c0103809:	5e                   	pop    %esi
+c010380a:	5f                   	pop    %edi
+c010380b:	5d                   	pop    %ebp
+c010380c:	c3                   	ret    
 
-c010398f <boot_map_segment>:
+c010380d <boot_map_segment>:
 //  la:   linear address of this memory need to map (after x86 segment map)
 //  size: memory size
 //  pa:   physical address of this memory
 //  perm: permission of this memory  
 static void
 boot_map_segment(pde_t *pgdir, uintptr_t la, size_t size, uintptr_t pa, uint32_t perm) {
-c010398f:	55                   	push   %ebp
-c0103990:	89 e5                	mov    %esp,%ebp
-c0103992:	83 ec 28             	sub    $0x28,%esp
+c010380d:	55                   	push   %ebp
+c010380e:	89 e5                	mov    %esp,%ebp
+c0103810:	83 ec 38             	sub    $0x38,%esp
     assert(PGOFF(la) == PGOFF(pa));
-c0103995:	8b 45 0c             	mov    0xc(%ebp),%eax
-c0103998:	33 45 14             	xor    0x14(%ebp),%eax
-c010399b:	25 ff 0f 00 00       	and    $0xfff,%eax
-c01039a0:	85 c0                	test   %eax,%eax
-c01039a2:	74 19                	je     c01039bd <boot_map_segment+0x2e>
-c01039a4:	68 36 8d 10 c0       	push   $0xc0108d36
-c01039a9:	68 4d 8d 10 c0       	push   $0xc0108d4d
-c01039ae:	68 07 01 00 00       	push   $0x107
-c01039b3:	68 28 8d 10 c0       	push   $0xc0108d28
-c01039b8:	e8 2b ca ff ff       	call   c01003e8 <__panic>
+c0103813:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0103816:	33 45 14             	xor    0x14(%ebp),%eax
+c0103819:	25 ff 0f 00 00       	and    $0xfff,%eax
+c010381e:	85 c0                	test   %eax,%eax
+c0103820:	74 24                	je     c0103846 <boot_map_segment+0x39>
+c0103822:	c7 44 24 0c 56 94 10 	movl   $0xc0109456,0xc(%esp)
+c0103829:	c0 
+c010382a:	c7 44 24 08 6d 94 10 	movl   $0xc010946d,0x8(%esp)
+c0103831:	c0 
+c0103832:	c7 44 24 04 07 01 00 	movl   $0x107,0x4(%esp)
+c0103839:	00 
+c010383a:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c0103841:	e8 b2 cb ff ff       	call   c01003f8 <__panic>
     size_t n = ROUNDUP(size + PGOFF(la), PGSIZE) / PGSIZE;
-c01039bd:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
-c01039c4:	8b 45 0c             	mov    0xc(%ebp),%eax
-c01039c7:	25 ff 0f 00 00       	and    $0xfff,%eax
-c01039cc:	89 c2                	mov    %eax,%edx
-c01039ce:	8b 45 10             	mov    0x10(%ebp),%eax
-c01039d1:	01 c2                	add    %eax,%edx
-c01039d3:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c01039d6:	01 d0                	add    %edx,%eax
-c01039d8:	83 e8 01             	sub    $0x1,%eax
-c01039db:	89 45 ec             	mov    %eax,-0x14(%ebp)
-c01039de:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c01039e1:	ba 00 00 00 00       	mov    $0x0,%edx
-c01039e6:	f7 75 f0             	divl   -0x10(%ebp)
-c01039e9:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c01039ec:	29 d0                	sub    %edx,%eax
-c01039ee:	c1 e8 0c             	shr    $0xc,%eax
-c01039f1:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0103846:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
+c010384d:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0103850:	25 ff 0f 00 00       	and    $0xfff,%eax
+c0103855:	89 c2                	mov    %eax,%edx
+c0103857:	8b 45 10             	mov    0x10(%ebp),%eax
+c010385a:	01 c2                	add    %eax,%edx
+c010385c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010385f:	01 d0                	add    %edx,%eax
+c0103861:	48                   	dec    %eax
+c0103862:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c0103865:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0103868:	ba 00 00 00 00       	mov    $0x0,%edx
+c010386d:	f7 75 f0             	divl   -0x10(%ebp)
+c0103870:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0103873:	29 d0                	sub    %edx,%eax
+c0103875:	c1 e8 0c             	shr    $0xc,%eax
+c0103878:	89 45 f4             	mov    %eax,-0xc(%ebp)
     la = ROUNDDOWN(la, PGSIZE);
-c01039f4:	8b 45 0c             	mov    0xc(%ebp),%eax
-c01039f7:	89 45 e8             	mov    %eax,-0x18(%ebp)
-c01039fa:	8b 45 e8             	mov    -0x18(%ebp),%eax
-c01039fd:	25 00 f0 ff ff       	and    $0xfffff000,%eax
-c0103a02:	89 45 0c             	mov    %eax,0xc(%ebp)
+c010387b:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010387e:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c0103881:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0103884:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+c0103889:	89 45 0c             	mov    %eax,0xc(%ebp)
     pa = ROUNDDOWN(pa, PGSIZE);
-c0103a05:	8b 45 14             	mov    0x14(%ebp),%eax
-c0103a08:	89 45 e4             	mov    %eax,-0x1c(%ebp)
-c0103a0b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-c0103a0e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
-c0103a13:	89 45 14             	mov    %eax,0x14(%ebp)
+c010388c:	8b 45 14             	mov    0x14(%ebp),%eax
+c010388f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+c0103892:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0103895:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+c010389a:	89 45 14             	mov    %eax,0x14(%ebp)
     for (; n > 0; n --, la += PGSIZE, pa += PGSIZE) {
-c0103a16:	eb 57                	jmp    c0103a6f <boot_map_segment+0xe0>
+c010389d:	eb 68                	jmp    c0103907 <boot_map_segment+0xfa>
         pte_t *ptep = get_pte(pgdir, la, 1);
-c0103a18:	83 ec 04             	sub    $0x4,%esp
-c0103a1b:	6a 01                	push   $0x1
-c0103a1d:	ff 75 0c             	pushl  0xc(%ebp)
-c0103a20:	ff 75 08             	pushl  0x8(%ebp)
-c0103a23:	e8 53 01 00 00       	call   c0103b7b <get_pte>
-c0103a28:	83 c4 10             	add    $0x10,%esp
-c0103a2b:	89 45 e0             	mov    %eax,-0x20(%ebp)
+c010389f:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+c01038a6:	00 
+c01038a7:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01038aa:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01038ae:	8b 45 08             	mov    0x8(%ebp),%eax
+c01038b1:	89 04 24             	mov    %eax,(%esp)
+c01038b4:	e8 81 01 00 00       	call   c0103a3a <get_pte>
+c01038b9:	89 45 e0             	mov    %eax,-0x20(%ebp)
         assert(ptep != NULL);
-c0103a2e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
-c0103a32:	75 19                	jne    c0103a4d <boot_map_segment+0xbe>
-c0103a34:	68 62 8d 10 c0       	push   $0xc0108d62
-c0103a39:	68 4d 8d 10 c0       	push   $0xc0108d4d
-c0103a3e:	68 0d 01 00 00       	push   $0x10d
-c0103a43:	68 28 8d 10 c0       	push   $0xc0108d28
-c0103a48:	e8 9b c9 ff ff       	call   c01003e8 <__panic>
+c01038bc:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+c01038c0:	75 24                	jne    c01038e6 <boot_map_segment+0xd9>
+c01038c2:	c7 44 24 0c 82 94 10 	movl   $0xc0109482,0xc(%esp)
+c01038c9:	c0 
+c01038ca:	c7 44 24 08 6d 94 10 	movl   $0xc010946d,0x8(%esp)
+c01038d1:	c0 
+c01038d2:	c7 44 24 04 0d 01 00 	movl   $0x10d,0x4(%esp)
+c01038d9:	00 
+c01038da:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c01038e1:	e8 12 cb ff ff       	call   c01003f8 <__panic>
         *ptep = pa | PTE_P | perm;
-c0103a4d:	8b 45 14             	mov    0x14(%ebp),%eax
-c0103a50:	0b 45 18             	or     0x18(%ebp),%eax
-c0103a53:	83 c8 01             	or     $0x1,%eax
-c0103a56:	89 c2                	mov    %eax,%edx
-c0103a58:	8b 45 e0             	mov    -0x20(%ebp),%eax
-c0103a5b:	89 10                	mov    %edx,(%eax)
+c01038e6:	8b 45 14             	mov    0x14(%ebp),%eax
+c01038e9:	0b 45 18             	or     0x18(%ebp),%eax
+c01038ec:	83 c8 01             	or     $0x1,%eax
+c01038ef:	89 c2                	mov    %eax,%edx
+c01038f1:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c01038f4:	89 10                	mov    %edx,(%eax)
 boot_map_segment(pde_t *pgdir, uintptr_t la, size_t size, uintptr_t pa, uint32_t perm) {
     assert(PGOFF(la) == PGOFF(pa));
     size_t n = ROUNDUP(size + PGOFF(la), PGSIZE) / PGSIZE;
     la = ROUNDDOWN(la, PGSIZE);
     pa = ROUNDDOWN(pa, PGSIZE);
     for (; n > 0; n --, la += PGSIZE, pa += PGSIZE) {
-c0103a5d:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
-c0103a61:	81 45 0c 00 10 00 00 	addl   $0x1000,0xc(%ebp)
-c0103a68:	81 45 14 00 10 00 00 	addl   $0x1000,0x14(%ebp)
-c0103a6f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
-c0103a73:	75 a3                	jne    c0103a18 <boot_map_segment+0x89>
+c01038f6:	ff 4d f4             	decl   -0xc(%ebp)
+c01038f9:	81 45 0c 00 10 00 00 	addl   $0x1000,0xc(%ebp)
+c0103900:	81 45 14 00 10 00 00 	addl   $0x1000,0x14(%ebp)
+c0103907:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c010390b:	75 92                	jne    c010389f <boot_map_segment+0x92>
         pte_t *ptep = get_pte(pgdir, la, 1);
         assert(ptep != NULL);
         *ptep = pa | PTE_P | perm;
     }
 }
-c0103a75:	90                   	nop
-c0103a76:	c9                   	leave  
-c0103a77:	c3                   	ret    
+c010390d:	90                   	nop
+c010390e:	c9                   	leave  
+c010390f:	c3                   	ret    
 
-c0103a78 <boot_alloc_page>:
+c0103910 <boot_alloc_page>:
 
 //boot_alloc_page - allocate one page using pmm->alloc_pages(1) 
 // return value: the kernel virtual address of this allocated page
 //note: this function is used to get the memory for PDT(Page Directory Table)&PT(Page Table)
 static void *
 boot_alloc_page(void) {
-c0103a78:	55                   	push   %ebp
-c0103a79:	89 e5                	mov    %esp,%ebp
-c0103a7b:	83 ec 18             	sub    $0x18,%esp
+c0103910:	55                   	push   %ebp
+c0103911:	89 e5                	mov    %esp,%ebp
+c0103913:	83 ec 28             	sub    $0x28,%esp
     struct Page *p = alloc_page();
-c0103a7e:	83 ec 0c             	sub    $0xc,%esp
-c0103a81:	6a 01                	push   $0x1
-c0103a83:	e8 8c fa ff ff       	call   c0103514 <alloc_pages>
-c0103a88:	83 c4 10             	add    $0x10,%esp
-c0103a8b:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0103916:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c010391d:	e8 4b fa ff ff       	call   c010336d <alloc_pages>
+c0103922:	89 45 f4             	mov    %eax,-0xc(%ebp)
     if (p == NULL) {
-c0103a8e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
-c0103a92:	75 17                	jne    c0103aab <boot_alloc_page+0x33>
+c0103925:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0103929:	75 1c                	jne    c0103947 <boot_alloc_page+0x37>
         panic("boot_alloc_page failed.\n");
-c0103a94:	83 ec 04             	sub    $0x4,%esp
-c0103a97:	68 6f 8d 10 c0       	push   $0xc0108d6f
-c0103a9c:	68 19 01 00 00       	push   $0x119
-c0103aa1:	68 28 8d 10 c0       	push   $0xc0108d28
-c0103aa6:	e8 3d c9 ff ff       	call   c01003e8 <__panic>
+c010392b:	c7 44 24 08 8f 94 10 	movl   $0xc010948f,0x8(%esp)
+c0103932:	c0 
+c0103933:	c7 44 24 04 19 01 00 	movl   $0x119,0x4(%esp)
+c010393a:	00 
+c010393b:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c0103942:	e8 b1 ca ff ff       	call   c01003f8 <__panic>
     }
     return page2kva(p);
-c0103aab:	83 ec 0c             	sub    $0xc,%esp
-c0103aae:	ff 75 f4             	pushl  -0xc(%ebp)
-c0103ab1:	e8 76 f7 ff ff       	call   c010322c <page2kva>
-c0103ab6:	83 c4 10             	add    $0x10,%esp
+c0103947:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010394a:	89 04 24             	mov    %eax,(%esp)
+c010394d:	e8 22 f7 ff ff       	call   c0103074 <page2kva>
 }
-c0103ab9:	c9                   	leave  
-c0103aba:	c3                   	ret    
+c0103952:	c9                   	leave  
+c0103953:	c3                   	ret    
 
-c0103abb <pmm_init>:
+c0103954 <pmm_init>:
 
 //pmm_init - setup a pmm to manage physical memory, build PDT&PT to setup paging mechanism 
 //         - check the correctness of pmm & paging mechanism, print PDT&PT
 void
 pmm_init(void) {
-c0103abb:	55                   	push   %ebp
-c0103abc:	89 e5                	mov    %esp,%ebp
-c0103abe:	83 ec 18             	sub    $0x18,%esp
+c0103954:	55                   	push   %ebp
+c0103955:	89 e5                	mov    %esp,%ebp
+c0103957:	83 ec 38             	sub    $0x38,%esp
     // We've already enabled paging
     boot_cr3 = PADDR(boot_pgdir);
-c0103ac1:	a1 e0 f9 11 c0       	mov    0xc011f9e0,%eax
-c0103ac6:	89 45 f4             	mov    %eax,-0xc(%ebp)
-c0103ac9:	81 7d f4 ff ff ff bf 	cmpl   $0xbfffffff,-0xc(%ebp)
-c0103ad0:	77 17                	ja     c0103ae9 <pmm_init+0x2e>
-c0103ad2:	ff 75 f4             	pushl  -0xc(%ebp)
-c0103ad5:	68 84 8c 10 c0       	push   $0xc0108c84
-c0103ada:	68 23 01 00 00       	push   $0x123
-c0103adf:	68 28 8d 10 c0       	push   $0xc0108d28
-c0103ae4:	e8 ff c8 ff ff       	call   c01003e8 <__panic>
-c0103ae9:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0103aec:	05 00 00 00 40       	add    $0x40000000,%eax
-c0103af1:	a3 24 30 12 c0       	mov    %eax,0xc0123024
+c010395a:	a1 e0 09 12 c0       	mov    0xc01209e0,%eax
+c010395f:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0103962:	81 7d f4 ff ff ff bf 	cmpl   $0xbfffffff,-0xc(%ebp)
+c0103969:	77 23                	ja     c010398e <pmm_init+0x3a>
+c010396b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010396e:	89 44 24 0c          	mov    %eax,0xc(%esp)
+c0103972:	c7 44 24 08 a4 93 10 	movl   $0xc01093a4,0x8(%esp)
+c0103979:	c0 
+c010397a:	c7 44 24 04 23 01 00 	movl   $0x123,0x4(%esp)
+c0103981:	00 
+c0103982:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c0103989:	e8 6a ca ff ff       	call   c01003f8 <__panic>
+c010398e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0103991:	05 00 00 00 40       	add    $0x40000000,%eax
+c0103996:	a3 24 40 12 c0       	mov    %eax,0xc0124024
     //We need to alloc/free the physical memory (granularity is 4KB or other size). 
     //So a framework of physical memory manager (struct pmm_manager)is defined in pmm.h
     //First we should init a physical memory manager(pmm) based on the framework.
     //Then pmm can alloc/free the physical memory. 
     //Now the first_fit/best_fit/worst_fit/buddy_system pmm are available.
     init_pmm_manager();
-c0103af6:	e8 c5 f9 ff ff       	call   c01034c0 <init_pmm_manager>
+c010399b:	e8 79 f9 ff ff       	call   c0103319 <init_pmm_manager>
 
     // detect physical memory space, reserve already used memory,
     // then use pmm->init_memmap to create free page list
     page_init();
-c0103afb:	e8 e3 fa ff ff       	call   c01035e3 <page_init>
+c01039a0:	e8 91 fa ff ff       	call   c0103436 <page_init>
 
     //use pmm->check to verify the correctness of the alloc/free function in a pmm
     check_alloc_page();
-c0103b00:	e8 38 04 00 00       	call   c0103f3d <check_alloc_page>
+c01039a5:	e8 cd 04 00 00       	call   c0103e77 <check_alloc_page>
 
     check_pgdir();
-c0103b05:	e8 56 04 00 00       	call   c0103f60 <check_pgdir>
+c01039aa:	e8 e7 04 00 00       	call   c0103e96 <check_pgdir>
 
     static_assert(KERNBASE % PTSIZE == 0 && KERNTOP % PTSIZE == 0);
 
     // recursively insert boot_pgdir in itself
     // to form a virtual page table at virtual address VPT
     boot_pgdir[PDX(VPT)] = PADDR(boot_pgdir) | PTE_P | PTE_W;
-c0103b0a:	a1 e0 f9 11 c0       	mov    0xc011f9e0,%eax
-c0103b0f:	8d 90 ac 0f 00 00    	lea    0xfac(%eax),%edx
-c0103b15:	a1 e0 f9 11 c0       	mov    0xc011f9e0,%eax
-c0103b1a:	89 45 f0             	mov    %eax,-0x10(%ebp)
-c0103b1d:	81 7d f0 ff ff ff bf 	cmpl   $0xbfffffff,-0x10(%ebp)
-c0103b24:	77 17                	ja     c0103b3d <pmm_init+0x82>
-c0103b26:	ff 75 f0             	pushl  -0x10(%ebp)
-c0103b29:	68 84 8c 10 c0       	push   $0xc0108c84
-c0103b2e:	68 39 01 00 00       	push   $0x139
-c0103b33:	68 28 8d 10 c0       	push   $0xc0108d28
-c0103b38:	e8 ab c8 ff ff       	call   c01003e8 <__panic>
-c0103b3d:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0103b40:	05 00 00 00 40       	add    $0x40000000,%eax
-c0103b45:	83 c8 03             	or     $0x3,%eax
-c0103b48:	89 02                	mov    %eax,(%edx)
+c01039af:	a1 e0 09 12 c0       	mov    0xc01209e0,%eax
+c01039b4:	8d 90 ac 0f 00 00    	lea    0xfac(%eax),%edx
+c01039ba:	a1 e0 09 12 c0       	mov    0xc01209e0,%eax
+c01039bf:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c01039c2:	81 7d f0 ff ff ff bf 	cmpl   $0xbfffffff,-0x10(%ebp)
+c01039c9:	77 23                	ja     c01039ee <pmm_init+0x9a>
+c01039cb:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01039ce:	89 44 24 0c          	mov    %eax,0xc(%esp)
+c01039d2:	c7 44 24 08 a4 93 10 	movl   $0xc01093a4,0x8(%esp)
+c01039d9:	c0 
+c01039da:	c7 44 24 04 39 01 00 	movl   $0x139,0x4(%esp)
+c01039e1:	00 
+c01039e2:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c01039e9:	e8 0a ca ff ff       	call   c01003f8 <__panic>
+c01039ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01039f1:	05 00 00 00 40       	add    $0x40000000,%eax
+c01039f6:	83 c8 03             	or     $0x3,%eax
+c01039f9:	89 02                	mov    %eax,(%edx)
 
     // map all physical memory to linear memory with base linear addr KERNBASE
     // linear_addr KERNBASE ~ KERNBASE + KMEMSIZE = phy_addr 0 ~ KMEMSIZE
     boot_map_segment(boot_pgdir, KERNBASE, KMEMSIZE, 0, PTE_W);
-c0103b4a:	a1 e0 f9 11 c0       	mov    0xc011f9e0,%eax
-c0103b4f:	83 ec 0c             	sub    $0xc,%esp
-c0103b52:	6a 02                	push   $0x2
-c0103b54:	6a 00                	push   $0x0
-c0103b56:	68 00 00 00 38       	push   $0x38000000
-c0103b5b:	68 00 00 00 c0       	push   $0xc0000000
-c0103b60:	50                   	push   %eax
-c0103b61:	e8 29 fe ff ff       	call   c010398f <boot_map_segment>
-c0103b66:	83 c4 20             	add    $0x20,%esp
+c01039fb:	a1 e0 09 12 c0       	mov    0xc01209e0,%eax
+c0103a00:	c7 44 24 10 02 00 00 	movl   $0x2,0x10(%esp)
+c0103a07:	00 
+c0103a08:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+c0103a0f:	00 
+c0103a10:	c7 44 24 08 00 00 00 	movl   $0x38000000,0x8(%esp)
+c0103a17:	38 
+c0103a18:	c7 44 24 04 00 00 00 	movl   $0xc0000000,0x4(%esp)
+c0103a1f:	c0 
+c0103a20:	89 04 24             	mov    %eax,(%esp)
+c0103a23:	e8 e5 fd ff ff       	call   c010380d <boot_map_segment>
 
     // Since we are using bootloader's GDT,
     // we should reload gdt (second time, the last time) to get user segments and the TSS
     // map virtual_addr 0 ~ 4G = linear_addr 0 ~ 4G
     // then set kernel stack (ss:esp) in TSS, setup TSS in gdt, load TSS
     gdt_init();
-c0103b69:	e8 60 f8 ff ff       	call   c01033ce <gdt_init>
+c0103a28:	e8 03 f8 ff ff       	call   c0103230 <gdt_init>
 
     //now the basic virtual memory map(see memalyout.h) is established.
     //check the correctness of the basic virtual memory map.
     check_boot_pgdir();
-c0103b6e:	e8 53 09 00 00       	call   c01044c6 <check_boot_pgdir>
+c0103a2d:	e8 00 0b 00 00       	call   c0104532 <check_boot_pgdir>
 
     print_pgdir();
-c0103b73:	e8 49 0d 00 00       	call   c01048c1 <print_pgdir>
+c0103a32:	e8 79 0f 00 00       	call   c01049b0 <print_pgdir>
 
 }
-c0103b78:	90                   	nop
-c0103b79:	c9                   	leave  
-c0103b7a:	c3                   	ret    
+c0103a37:	90                   	nop
+c0103a38:	c9                   	leave  
+c0103a39:	c3                   	ret    
 
-c0103b7b <get_pte>:
+c0103a3a <get_pte>:
 //  pgdir:  the kernel virtual base address of PDT
 //  la:     the linear address need to map
 //  create: a logical value to decide if alloc a page for PT
 // return vaule: the kernel virtual address of this pte
 pte_t *
 get_pte(pde_t *pgdir, uintptr_t la, bool create) {
-c0103b7b:	55                   	push   %ebp
-c0103b7c:	89 e5                	mov    %esp,%ebp
-c0103b7e:	83 ec 28             	sub    $0x28,%esp
+c0103a3a:	55                   	push   %ebp
+c0103a3b:	89 e5                	mov    %esp,%ebp
+c0103a3d:	83 ec 38             	sub    $0x38,%esp
                           // (6) clear page content using memset
                           // (7) set page directory entry's permission
     }
     return NULL;          // (8) return page table entry
 #endif
-    pde_t *pdep = &pgdir[PDX(la)];
-c0103b81:	8b 45 0c             	mov    0xc(%ebp),%eax
-c0103b84:	c1 e8 16             	shr    $0x16,%eax
-c0103b87:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
-c0103b8e:	8b 45 08             	mov    0x8(%ebp),%eax
-c0103b91:	01 d0                	add    %edx,%eax
-c0103b93:	89 45 f4             	mov    %eax,-0xc(%ebp)
-    if (!(*pdep & PTE_P)) {
-c0103b96:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0103b99:	8b 00                	mov    (%eax),%eax
-c0103b9b:	83 e0 01             	and    $0x1,%eax
-c0103b9e:	85 c0                	test   %eax,%eax
-c0103ba0:	0f 85 9f 00 00 00    	jne    c0103c45 <get_pte+0xca>
+    pde_t *pdep = &pgdir[PDX(la)];    //尝试获得页表
+c0103a40:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0103a43:	c1 e8 16             	shr    $0x16,%eax
+c0103a46:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+c0103a4d:	8b 45 08             	mov    0x8(%ebp),%eax
+c0103a50:	01 d0                	add    %edx,%eax
+c0103a52:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if (!(*pdep & PTE_P)) {             //如果获取不成功
+c0103a55:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0103a58:	8b 00                	mov    (%eax),%eax
+c0103a5a:	83 e0 01             	and    $0x1,%eax
+c0103a5d:	85 c0                	test   %eax,%eax
+c0103a5f:	0f 85 af 00 00 00    	jne    c0103b14 <get_pte+0xda>
         struct Page *page;
         if (!create || (page = alloc_page()) == NULL) {
-c0103ba6:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
-c0103baa:	74 16                	je     c0103bc2 <get_pte+0x47>
-c0103bac:	83 ec 0c             	sub    $0xc,%esp
-c0103baf:	6a 01                	push   $0x1
-c0103bb1:	e8 5e f9 ff ff       	call   c0103514 <alloc_pages>
-c0103bb6:	83 c4 10             	add    $0x10,%esp
-c0103bb9:	89 45 f0             	mov    %eax,-0x10(%ebp)
-c0103bbc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
-c0103bc0:	75 0a                	jne    c0103bcc <get_pte+0x51>
+c0103a65:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+c0103a69:	74 15                	je     c0103a80 <get_pte+0x46>
+c0103a6b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c0103a72:	e8 f6 f8 ff ff       	call   c010336d <alloc_pages>
+c0103a77:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0103a7a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c0103a7e:	75 0a                	jne    c0103a8a <get_pte+0x50>
             return NULL;
-c0103bc2:	b8 00 00 00 00       	mov    $0x0,%eax
-c0103bc7:	e9 ca 00 00 00       	jmp    c0103c96 <get_pte+0x11b>
+c0103a80:	b8 00 00 00 00       	mov    $0x0,%eax
+c0103a85:	e9 e7 00 00 00       	jmp    c0103b71 <get_pte+0x137>
         }
-        set_page_ref(page, 1);
-c0103bcc:	83 ec 08             	sub    $0x8,%esp
-c0103bcf:	6a 01                	push   $0x1
-c0103bd1:	ff 75 f0             	pushl  -0x10(%ebp)
-c0103bd4:	e8 37 f7 ff ff       	call   c0103310 <set_page_ref>
-c0103bd9:	83 c4 10             	add    $0x10,%esp
+        set_page_ref(page, 1);          //引用次数+1
+c0103a8a:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+c0103a91:	00 
+c0103a92:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0103a95:	89 04 24             	mov    %eax,(%esp)
+c0103a98:	e8 d5 f6 ff ff       	call   c0103172 <set_page_ref>
         uintptr_t pa = page2pa(page);
-c0103bdc:	83 ec 0c             	sub    $0xc,%esp
-c0103bdf:	ff 75 f0             	pushl  -0x10(%ebp)
-c0103be2:	e8 f5 f5 ff ff       	call   c01031dc <page2pa>
-c0103be7:	83 c4 10             	add    $0x10,%esp
-c0103bea:	89 45 ec             	mov    %eax,-0x14(%ebp)
-        memset(KADDR(pa), 0, PGSIZE);
-c0103bed:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c0103bf0:	89 45 e8             	mov    %eax,-0x18(%ebp)
-c0103bf3:	8b 45 e8             	mov    -0x18(%ebp),%eax
-c0103bf6:	c1 e8 0c             	shr    $0xc,%eax
-c0103bf9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
-c0103bfc:	a1 80 2f 12 c0       	mov    0xc0122f80,%eax
-c0103c01:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
-c0103c04:	72 17                	jb     c0103c1d <get_pte+0xa2>
-c0103c06:	ff 75 e8             	pushl  -0x18(%ebp)
-c0103c09:	68 60 8c 10 c0       	push   $0xc0108c60
-c0103c0e:	68 7f 01 00 00       	push   $0x17f
-c0103c13:	68 28 8d 10 c0       	push   $0xc0108d28
-c0103c18:	e8 cb c7 ff ff       	call   c01003e8 <__panic>
-c0103c1d:	8b 45 e8             	mov    -0x18(%ebp),%eax
-c0103c20:	2d 00 00 00 40       	sub    $0x40000000,%eax
-c0103c25:	83 ec 04             	sub    $0x4,%esp
-c0103c28:	68 00 10 00 00       	push   $0x1000
-c0103c2d:	6a 00                	push   $0x0
-c0103c2f:	50                   	push   %eax
-c0103c30:	e8 d3 3e 00 00       	call   c0107b08 <memset>
-c0103c35:	83 c4 10             	add    $0x10,%esp
-        *pdep = pa | PTE_U | PTE_W | PTE_P;
-c0103c38:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c0103c3b:	83 c8 07             	or     $0x7,%eax
-c0103c3e:	89 c2                	mov    %eax,%edx
-c0103c40:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0103c43:	89 10                	mov    %edx,(%eax)
+c0103a9d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0103aa0:	89 04 24             	mov    %eax,(%esp)
+c0103aa3:	e8 71 f5 ff ff       	call   c0103019 <page2pa>
+c0103aa8:	89 45 ec             	mov    %eax,-0x14(%ebp)
+        memset(KADDR(pa), 0, PGSIZE);   //初始化
+c0103aab:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0103aae:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c0103ab1:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0103ab4:	c1 e8 0c             	shr    $0xc,%eax
+c0103ab7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+c0103aba:	a1 80 3f 12 c0       	mov    0xc0123f80,%eax
+c0103abf:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
+c0103ac2:	72 23                	jb     c0103ae7 <get_pte+0xad>
+c0103ac4:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0103ac7:	89 44 24 0c          	mov    %eax,0xc(%esp)
+c0103acb:	c7 44 24 08 80 93 10 	movl   $0xc0109380,0x8(%esp)
+c0103ad2:	c0 
+c0103ad3:	c7 44 24 04 7f 01 00 	movl   $0x17f,0x4(%esp)
+c0103ada:	00 
+c0103adb:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c0103ae2:	e8 11 c9 ff ff       	call   c01003f8 <__panic>
+c0103ae7:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0103aea:	2d 00 00 00 40       	sub    $0x40000000,%eax
+c0103aef:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
+c0103af6:	00 
+c0103af7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+c0103afe:	00 
+c0103aff:	89 04 24             	mov    %eax,(%esp)
+c0103b02:	e8 d9 46 00 00       	call   c01081e0 <memset>
+        *pdep = pa | PTE_U | PTE_W | PTE_P;//设置控制位
+c0103b07:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0103b0a:	83 c8 07             	or     $0x7,%eax
+c0103b0d:	89 c2                	mov    %eax,%edx
+c0103b0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0103b12:	89 10                	mov    %edx,(%eax)
     }
     return &((pte_t *)KADDR(PDE_ADDR(*pdep)))[PTX(la)];
-c0103c45:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0103c48:	8b 00                	mov    (%eax),%eax
-c0103c4a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
-c0103c4f:	89 45 e0             	mov    %eax,-0x20(%ebp)
-c0103c52:	8b 45 e0             	mov    -0x20(%ebp),%eax
-c0103c55:	c1 e8 0c             	shr    $0xc,%eax
-c0103c58:	89 45 dc             	mov    %eax,-0x24(%ebp)
-c0103c5b:	a1 80 2f 12 c0       	mov    0xc0122f80,%eax
-c0103c60:	39 45 dc             	cmp    %eax,-0x24(%ebp)
-c0103c63:	72 17                	jb     c0103c7c <get_pte+0x101>
-c0103c65:	ff 75 e0             	pushl  -0x20(%ebp)
-c0103c68:	68 60 8c 10 c0       	push   $0xc0108c60
-c0103c6d:	68 82 01 00 00       	push   $0x182
-c0103c72:	68 28 8d 10 c0       	push   $0xc0108d28
-c0103c77:	e8 6c c7 ff ff       	call   c01003e8 <__panic>
-c0103c7c:	8b 45 e0             	mov    -0x20(%ebp),%eax
-c0103c7f:	2d 00 00 00 40       	sub    $0x40000000,%eax
-c0103c84:	89 c2                	mov    %eax,%edx
-c0103c86:	8b 45 0c             	mov    0xc(%ebp),%eax
-c0103c89:	c1 e8 0c             	shr    $0xc,%eax
-c0103c8c:	25 ff 03 00 00       	and    $0x3ff,%eax
-c0103c91:	c1 e0 02             	shl    $0x2,%eax
-c0103c94:	01 d0                	add    %edx,%eax
+c0103b14:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0103b17:	8b 00                	mov    (%eax),%eax
+c0103b19:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+c0103b1e:	89 45 e0             	mov    %eax,-0x20(%ebp)
+c0103b21:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0103b24:	c1 e8 0c             	shr    $0xc,%eax
+c0103b27:	89 45 dc             	mov    %eax,-0x24(%ebp)
+c0103b2a:	a1 80 3f 12 c0       	mov    0xc0123f80,%eax
+c0103b2f:	39 45 dc             	cmp    %eax,-0x24(%ebp)
+c0103b32:	72 23                	jb     c0103b57 <get_pte+0x11d>
+c0103b34:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0103b37:	89 44 24 0c          	mov    %eax,0xc(%esp)
+c0103b3b:	c7 44 24 08 80 93 10 	movl   $0xc0109380,0x8(%esp)
+c0103b42:	c0 
+c0103b43:	c7 44 24 04 82 01 00 	movl   $0x182,0x4(%esp)
+c0103b4a:	00 
+c0103b4b:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c0103b52:	e8 a1 c8 ff ff       	call   c01003f8 <__panic>
+c0103b57:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0103b5a:	2d 00 00 00 40       	sub    $0x40000000,%eax
+c0103b5f:	89 c2                	mov    %eax,%edx
+c0103b61:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0103b64:	c1 e8 0c             	shr    $0xc,%eax
+c0103b67:	25 ff 03 00 00       	and    $0x3ff,%eax
+c0103b6c:	c1 e0 02             	shl    $0x2,%eax
+c0103b6f:	01 d0                	add    %edx,%eax
 }
-c0103c96:	c9                   	leave  
-c0103c97:	c3                   	ret    
+c0103b71:	c9                   	leave  
+c0103b72:	c3                   	ret    
 
-c0103c98 <get_page>:
+c0103b73 <get_page>:
 
 //get_page - get related Page struct for linear address la using PDT pgdir
 struct Page *
 get_page(pde_t *pgdir, uintptr_t la, pte_t **ptep_store) {
-c0103c98:	55                   	push   %ebp
-c0103c99:	89 e5                	mov    %esp,%ebp
-c0103c9b:	83 ec 18             	sub    $0x18,%esp
+c0103b73:	55                   	push   %ebp
+c0103b74:	89 e5                	mov    %esp,%ebp
+c0103b76:	83 ec 28             	sub    $0x28,%esp
     pte_t *ptep = get_pte(pgdir, la, 0);
-c0103c9e:	83 ec 04             	sub    $0x4,%esp
-c0103ca1:	6a 00                	push   $0x0
-c0103ca3:	ff 75 0c             	pushl  0xc(%ebp)
-c0103ca6:	ff 75 08             	pushl  0x8(%ebp)
-c0103ca9:	e8 cd fe ff ff       	call   c0103b7b <get_pte>
-c0103cae:	83 c4 10             	add    $0x10,%esp
-c0103cb1:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0103b79:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+c0103b80:	00 
+c0103b81:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0103b84:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0103b88:	8b 45 08             	mov    0x8(%ebp),%eax
+c0103b8b:	89 04 24             	mov    %eax,(%esp)
+c0103b8e:	e8 a7 fe ff ff       	call   c0103a3a <get_pte>
+c0103b93:	89 45 f4             	mov    %eax,-0xc(%ebp)
     if (ptep_store != NULL) {
-c0103cb4:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
-c0103cb8:	74 08                	je     c0103cc2 <get_page+0x2a>
+c0103b96:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+c0103b9a:	74 08                	je     c0103ba4 <get_page+0x31>
         *ptep_store = ptep;
-c0103cba:	8b 45 10             	mov    0x10(%ebp),%eax
-c0103cbd:	8b 55 f4             	mov    -0xc(%ebp),%edx
-c0103cc0:	89 10                	mov    %edx,(%eax)
+c0103b9c:	8b 45 10             	mov    0x10(%ebp),%eax
+c0103b9f:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0103ba2:	89 10                	mov    %edx,(%eax)
     }
     if (ptep != NULL && *ptep & PTE_P) {
-c0103cc2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
-c0103cc6:	74 1f                	je     c0103ce7 <get_page+0x4f>
-c0103cc8:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0103ccb:	8b 00                	mov    (%eax),%eax
-c0103ccd:	83 e0 01             	and    $0x1,%eax
-c0103cd0:	85 c0                	test   %eax,%eax
-c0103cd2:	74 13                	je     c0103ce7 <get_page+0x4f>
+c0103ba4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0103ba8:	74 1b                	je     c0103bc5 <get_page+0x52>
+c0103baa:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0103bad:	8b 00                	mov    (%eax),%eax
+c0103baf:	83 e0 01             	and    $0x1,%eax
+c0103bb2:	85 c0                	test   %eax,%eax
+c0103bb4:	74 0f                	je     c0103bc5 <get_page+0x52>
         return pte2page(*ptep);
-c0103cd4:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0103cd7:	8b 00                	mov    (%eax),%eax
-c0103cd9:	83 ec 0c             	sub    $0xc,%esp
-c0103cdc:	50                   	push   %eax
-c0103cdd:	e8 ce f5 ff ff       	call   c01032b0 <pte2page>
-c0103ce2:	83 c4 10             	add    $0x10,%esp
-c0103ce5:	eb 05                	jmp    c0103cec <get_page+0x54>
+c0103bb6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0103bb9:	8b 00                	mov    (%eax),%eax
+c0103bbb:	89 04 24             	mov    %eax,(%esp)
+c0103bbe:	e8 4f f5 ff ff       	call   c0103112 <pte2page>
+c0103bc3:	eb 05                	jmp    c0103bca <get_page+0x57>
     }
     return NULL;
-c0103ce7:	b8 00 00 00 00       	mov    $0x0,%eax
+c0103bc5:	b8 00 00 00 00       	mov    $0x0,%eax
 }
-c0103cec:	c9                   	leave  
-c0103ced:	c3                   	ret    
+c0103bca:	c9                   	leave  
+c0103bcb:	c3                   	ret    
 
-c0103cee <page_remove_pte>:
+c0103bcc <page_remove_pte>:
 
 //page_remove_pte - free an Page sturct which is related linear address la
 //                - and clean(invalidate) pte which is related linear address la
 //note: PT is changed, so the TLB need to be invalidate 
 static inline void
 page_remove_pte(pde_t *pgdir, uintptr_t la, pte_t *ptep) {
-c0103cee:	55                   	push   %ebp
-c0103cef:	89 e5                	mov    %esp,%ebp
-c0103cf1:	83 ec 18             	sub    $0x18,%esp
+c0103bcc:	55                   	push   %ebp
+c0103bcd:	89 e5                	mov    %esp,%ebp
+c0103bcf:	83 ec 28             	sub    $0x28,%esp
                                   //(4) and free this page when page reference reachs 0
                                   //(5) clear second page table entry
                                   //(6) flush tlb
     }
 #endif
-    if (*ptep & PTE_P) {
-c0103cf4:	8b 45 10             	mov    0x10(%ebp),%eax
-c0103cf7:	8b 00                	mov    (%eax),%eax
-c0103cf9:	83 e0 01             	and    $0x1,%eax
-c0103cfc:	85 c0                	test   %eax,%eax
-c0103cfe:	74 50                	je     c0103d50 <page_remove_pte+0x62>
-        struct Page *page = pte2page(*ptep);
-c0103d00:	8b 45 10             	mov    0x10(%ebp),%eax
-c0103d03:	8b 00                	mov    (%eax),%eax
-c0103d05:	83 ec 0c             	sub    $0xc,%esp
-c0103d08:	50                   	push   %eax
-c0103d09:	e8 a2 f5 ff ff       	call   c01032b0 <pte2page>
-c0103d0e:	83 c4 10             	add    $0x10,%esp
-c0103d11:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    assert(*ptep & PTE_P);        //确保传入的二级页表项是存在的
+c0103bd2:	8b 45 10             	mov    0x10(%ebp),%eax
+c0103bd5:	8b 00                	mov    (%eax),%eax
+c0103bd7:	83 e0 01             	and    $0x1,%eax
+c0103bda:	85 c0                	test   %eax,%eax
+c0103bdc:	75 24                	jne    c0103c02 <page_remove_pte+0x36>
+c0103bde:	c7 44 24 0c a8 94 10 	movl   $0xc01094a8,0xc(%esp)
+c0103be5:	c0 
+c0103be6:	c7 44 24 08 6d 94 10 	movl   $0xc010946d,0x8(%esp)
+c0103bed:	c0 
+c0103bee:	c7 44 24 04 b0 01 00 	movl   $0x1b0,0x4(%esp)
+c0103bf5:	00 
+c0103bf6:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c0103bfd:	e8 f6 c7 ff ff       	call   c01003f8 <__panic>
+        struct Page *page = pte2page(*ptep);   //获取该页表项对应的物理页
+c0103c02:	8b 45 10             	mov    0x10(%ebp),%eax
+c0103c05:	8b 00                	mov    (%eax),%eax
+c0103c07:	89 04 24             	mov    %eax,(%esp)
+c0103c0a:	e8 03 f5 ff ff       	call   c0103112 <pte2page>
+c0103c0f:	89 45 f4             	mov    %eax,-0xc(%ebp)
         if (page_ref_dec(page) == 0) {
-c0103d14:	83 ec 0c             	sub    $0xc,%esp
-c0103d17:	ff 75 f4             	pushl  -0xc(%ebp)
-c0103d1a:	e8 16 f6 ff ff       	call   c0103335 <page_ref_dec>
-c0103d1f:	83 c4 10             	add    $0x10,%esp
-c0103d22:	85 c0                	test   %eax,%eax
-c0103d24:	75 10                	jne    c0103d36 <page_remove_pte+0x48>
+c0103c12:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0103c15:	89 04 24             	mov    %eax,(%esp)
+c0103c18:	e8 7a f5 ff ff       	call   c0103197 <page_ref_dec>
+c0103c1d:	85 c0                	test   %eax,%eax
+c0103c1f:	75 13                	jne    c0103c34 <page_remove_pte+0x68>
             free_page(page);
-c0103d26:	83 ec 08             	sub    $0x8,%esp
-c0103d29:	6a 01                	push   $0x1
-c0103d2b:	ff 75 f4             	pushl  -0xc(%ebp)
-c0103d2e:	e8 4d f8 ff ff       	call   c0103580 <free_pages>
-c0103d33:	83 c4 10             	add    $0x10,%esp
-        }
-        *ptep = 0;
-c0103d36:	8b 45 10             	mov    0x10(%ebp),%eax
-c0103d39:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
-        tlb_invalidate(pgdir, la);
-c0103d3f:	83 ec 08             	sub    $0x8,%esp
-c0103d42:	ff 75 0c             	pushl  0xc(%ebp)
-c0103d45:	ff 75 08             	pushl  0x8(%ebp)
-c0103d48:	e8 f8 00 00 00       	call   c0103e45 <tlb_invalidate>
-c0103d4d:	83 c4 10             	add    $0x10,%esp
-    }
-}
-c0103d50:	90                   	nop
-c0103d51:	c9                   	leave  
-c0103d52:	c3                   	ret    
+c0103c21:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+c0103c28:	00 
+c0103c29:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0103c2c:	89 04 24             	mov    %eax,(%esp)
+c0103c2f:	e8 a4 f7 ff ff       	call   c01033d8 <free_pages>
+        }
+        *ptep = 0;     //取消映射关系
+c0103c34:	8b 45 10             	mov    0x10(%ebp),%eax
+c0103c37:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+        tlb_invalidate(pgdir, la);  //更新TLB
+c0103c3d:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0103c40:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0103c44:	8b 45 08             	mov    0x8(%ebp),%eax
+c0103c47:	89 04 24             	mov    %eax,(%esp)
+c0103c4a:	e8 01 01 00 00       	call   c0103d50 <tlb_invalidate>
+}
+c0103c4f:	90                   	nop
+c0103c50:	c9                   	leave  
+c0103c51:	c3                   	ret    
 
-c0103d53 <page_remove>:
+c0103c52 <page_remove>:
 
 //page_remove - free an Page which is related linear address la and has an validated pte
 void
 page_remove(pde_t *pgdir, uintptr_t la) {
-c0103d53:	55                   	push   %ebp
-c0103d54:	89 e5                	mov    %esp,%ebp
-c0103d56:	83 ec 18             	sub    $0x18,%esp
+c0103c52:	55                   	push   %ebp
+c0103c53:	89 e5                	mov    %esp,%ebp
+c0103c55:	83 ec 28             	sub    $0x28,%esp
     pte_t *ptep = get_pte(pgdir, la, 0);
-c0103d59:	83 ec 04             	sub    $0x4,%esp
-c0103d5c:	6a 00                	push   $0x0
-c0103d5e:	ff 75 0c             	pushl  0xc(%ebp)
-c0103d61:	ff 75 08             	pushl  0x8(%ebp)
-c0103d64:	e8 12 fe ff ff       	call   c0103b7b <get_pte>
-c0103d69:	83 c4 10             	add    $0x10,%esp
-c0103d6c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0103c58:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+c0103c5f:	00 
+c0103c60:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0103c63:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0103c67:	8b 45 08             	mov    0x8(%ebp),%eax
+c0103c6a:	89 04 24             	mov    %eax,(%esp)
+c0103c6d:	e8 c8 fd ff ff       	call   c0103a3a <get_pte>
+c0103c72:	89 45 f4             	mov    %eax,-0xc(%ebp)
     if (ptep != NULL) {
-c0103d6f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
-c0103d73:	74 14                	je     c0103d89 <page_remove+0x36>
+c0103c75:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0103c79:	74 19                	je     c0103c94 <page_remove+0x42>
         page_remove_pte(pgdir, la, ptep);
-c0103d75:	83 ec 04             	sub    $0x4,%esp
-c0103d78:	ff 75 f4             	pushl  -0xc(%ebp)
-c0103d7b:	ff 75 0c             	pushl  0xc(%ebp)
-c0103d7e:	ff 75 08             	pushl  0x8(%ebp)
-c0103d81:	e8 68 ff ff ff       	call   c0103cee <page_remove_pte>
-c0103d86:	83 c4 10             	add    $0x10,%esp
+c0103c7b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0103c7e:	89 44 24 08          	mov    %eax,0x8(%esp)
+c0103c82:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0103c85:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0103c89:	8b 45 08             	mov    0x8(%ebp),%eax
+c0103c8c:	89 04 24             	mov    %eax,(%esp)
+c0103c8f:	e8 38 ff ff ff       	call   c0103bcc <page_remove_pte>
     }
 }
-c0103d89:	90                   	nop
-c0103d8a:	c9                   	leave  
-c0103d8b:	c3                   	ret    
+c0103c94:	90                   	nop
+c0103c95:	c9                   	leave  
+c0103c96:	c3                   	ret    
 
-c0103d8c <page_insert>:
+c0103c97 <page_insert>:
 //  la:    the linear address need to map
 //  perm:  the permission of this Page which is setted in related pte
 // return value: always 0
 //note: PT is changed, so the TLB need to be invalidate 
 int
 page_insert(pde_t *pgdir, struct Page *page, uintptr_t la, uint32_t perm) {
-c0103d8c:	55                   	push   %ebp
-c0103d8d:	89 e5                	mov    %esp,%ebp
-c0103d8f:	83 ec 18             	sub    $0x18,%esp
+c0103c97:	55                   	push   %ebp
+c0103c98:	89 e5                	mov    %esp,%ebp
+c0103c9a:	83 ec 28             	sub    $0x28,%esp
     pte_t *ptep = get_pte(pgdir, la, 1);
-c0103d92:	83 ec 04             	sub    $0x4,%esp
-c0103d95:	6a 01                	push   $0x1
-c0103d97:	ff 75 10             	pushl  0x10(%ebp)
-c0103d9a:	ff 75 08             	pushl  0x8(%ebp)
-c0103d9d:	e8 d9 fd ff ff       	call   c0103b7b <get_pte>
-c0103da2:	83 c4 10             	add    $0x10,%esp
-c0103da5:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0103c9d:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+c0103ca4:	00 
+c0103ca5:	8b 45 10             	mov    0x10(%ebp),%eax
+c0103ca8:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0103cac:	8b 45 08             	mov    0x8(%ebp),%eax
+c0103caf:	89 04 24             	mov    %eax,(%esp)
+c0103cb2:	e8 83 fd ff ff       	call   c0103a3a <get_pte>
+c0103cb7:	89 45 f4             	mov    %eax,-0xc(%ebp)
     if (ptep == NULL) {
-c0103da8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
-c0103dac:	75 0a                	jne    c0103db8 <page_insert+0x2c>
+c0103cba:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0103cbe:	75 0a                	jne    c0103cca <page_insert+0x33>
         return -E_NO_MEM;
-c0103dae:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
-c0103db3:	e9 8b 00 00 00       	jmp    c0103e43 <page_insert+0xb7>
+c0103cc0:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
+c0103cc5:	e9 84 00 00 00       	jmp    c0103d4e <page_insert+0xb7>
     }
     page_ref_inc(page);
-c0103db8:	83 ec 0c             	sub    $0xc,%esp
-c0103dbb:	ff 75 0c             	pushl  0xc(%ebp)
-c0103dbe:	e8 5b f5 ff ff       	call   c010331e <page_ref_inc>
-c0103dc3:	83 c4 10             	add    $0x10,%esp
+c0103cca:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0103ccd:	89 04 24             	mov    %eax,(%esp)
+c0103cd0:	e8 ab f4 ff ff       	call   c0103180 <page_ref_inc>
     if (*ptep & PTE_P) {
-c0103dc6:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0103dc9:	8b 00                	mov    (%eax),%eax
-c0103dcb:	83 e0 01             	and    $0x1,%eax
-c0103dce:	85 c0                	test   %eax,%eax
-c0103dd0:	74 40                	je     c0103e12 <page_insert+0x86>
+c0103cd5:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0103cd8:	8b 00                	mov    (%eax),%eax
+c0103cda:	83 e0 01             	and    $0x1,%eax
+c0103cdd:	85 c0                	test   %eax,%eax
+c0103cdf:	74 3e                	je     c0103d1f <page_insert+0x88>
         struct Page *p = pte2page(*ptep);
-c0103dd2:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0103dd5:	8b 00                	mov    (%eax),%eax
-c0103dd7:	83 ec 0c             	sub    $0xc,%esp
-c0103dda:	50                   	push   %eax
-c0103ddb:	e8 d0 f4 ff ff       	call   c01032b0 <pte2page>
-c0103de0:	83 c4 10             	add    $0x10,%esp
-c0103de3:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0103ce1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0103ce4:	8b 00                	mov    (%eax),%eax
+c0103ce6:	89 04 24             	mov    %eax,(%esp)
+c0103ce9:	e8 24 f4 ff ff       	call   c0103112 <pte2page>
+c0103cee:	89 45 f0             	mov    %eax,-0x10(%ebp)
         if (p == page) {
-c0103de6:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0103de9:	3b 45 0c             	cmp    0xc(%ebp),%eax
-c0103dec:	75 10                	jne    c0103dfe <page_insert+0x72>
+c0103cf1:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0103cf4:	3b 45 0c             	cmp    0xc(%ebp),%eax
+c0103cf7:	75 0d                	jne    c0103d06 <page_insert+0x6f>
             page_ref_dec(page);
-c0103dee:	83 ec 0c             	sub    $0xc,%esp
-c0103df1:	ff 75 0c             	pushl  0xc(%ebp)
-c0103df4:	e8 3c f5 ff ff       	call   c0103335 <page_ref_dec>
-c0103df9:	83 c4 10             	add    $0x10,%esp
-c0103dfc:	eb 14                	jmp    c0103e12 <page_insert+0x86>
+c0103cf9:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0103cfc:	89 04 24             	mov    %eax,(%esp)
+c0103cff:	e8 93 f4 ff ff       	call   c0103197 <page_ref_dec>
+c0103d04:	eb 19                	jmp    c0103d1f <page_insert+0x88>
         }
         else {
             page_remove_pte(pgdir, la, ptep);
-c0103dfe:	83 ec 04             	sub    $0x4,%esp
-c0103e01:	ff 75 f4             	pushl  -0xc(%ebp)
-c0103e04:	ff 75 10             	pushl  0x10(%ebp)
-c0103e07:	ff 75 08             	pushl  0x8(%ebp)
-c0103e0a:	e8 df fe ff ff       	call   c0103cee <page_remove_pte>
-c0103e0f:	83 c4 10             	add    $0x10,%esp
+c0103d06:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0103d09:	89 44 24 08          	mov    %eax,0x8(%esp)
+c0103d0d:	8b 45 10             	mov    0x10(%ebp),%eax
+c0103d10:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0103d14:	8b 45 08             	mov    0x8(%ebp),%eax
+c0103d17:	89 04 24             	mov    %eax,(%esp)
+c0103d1a:	e8 ad fe ff ff       	call   c0103bcc <page_remove_pte>
         }
     }
     *ptep = page2pa(page) | PTE_P | perm;
-c0103e12:	83 ec 0c             	sub    $0xc,%esp
-c0103e15:	ff 75 0c             	pushl  0xc(%ebp)
-c0103e18:	e8 bf f3 ff ff       	call   c01031dc <page2pa>
-c0103e1d:	83 c4 10             	add    $0x10,%esp
-c0103e20:	0b 45 14             	or     0x14(%ebp),%eax
-c0103e23:	83 c8 01             	or     $0x1,%eax
-c0103e26:	89 c2                	mov    %eax,%edx
-c0103e28:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0103e2b:	89 10                	mov    %edx,(%eax)
+c0103d1f:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0103d22:	89 04 24             	mov    %eax,(%esp)
+c0103d25:	e8 ef f2 ff ff       	call   c0103019 <page2pa>
+c0103d2a:	0b 45 14             	or     0x14(%ebp),%eax
+c0103d2d:	83 c8 01             	or     $0x1,%eax
+c0103d30:	89 c2                	mov    %eax,%edx
+c0103d32:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0103d35:	89 10                	mov    %edx,(%eax)
     tlb_invalidate(pgdir, la);
-c0103e2d:	83 ec 08             	sub    $0x8,%esp
-c0103e30:	ff 75 10             	pushl  0x10(%ebp)
-c0103e33:	ff 75 08             	pushl  0x8(%ebp)
-c0103e36:	e8 0a 00 00 00       	call   c0103e45 <tlb_invalidate>
-c0103e3b:	83 c4 10             	add    $0x10,%esp
+c0103d37:	8b 45 10             	mov    0x10(%ebp),%eax
+c0103d3a:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0103d3e:	8b 45 08             	mov    0x8(%ebp),%eax
+c0103d41:	89 04 24             	mov    %eax,(%esp)
+c0103d44:	e8 07 00 00 00       	call   c0103d50 <tlb_invalidate>
     return 0;
-c0103e3e:	b8 00 00 00 00       	mov    $0x0,%eax
+c0103d49:	b8 00 00 00 00       	mov    $0x0,%eax
 }
-c0103e43:	c9                   	leave  
-c0103e44:	c3                   	ret    
+c0103d4e:	c9                   	leave  
+c0103d4f:	c3                   	ret    
 
-c0103e45 <tlb_invalidate>:
+c0103d50 <tlb_invalidate>:
 
 // invalidate a TLB entry, but only if the page tables being
 // edited are the ones currently in use by the processor.
 void
 tlb_invalidate(pde_t *pgdir, uintptr_t la) {
-c0103e45:	55                   	push   %ebp
-c0103e46:	89 e5                	mov    %esp,%ebp
-c0103e48:	83 ec 18             	sub    $0x18,%esp
+c0103d50:	55                   	push   %ebp
+c0103d51:	89 e5                	mov    %esp,%ebp
+c0103d53:	83 ec 28             	sub    $0x28,%esp
 }
 
 static inline uintptr_t
 rcr3(void) {
     uintptr_t cr3;
     asm volatile ("mov %%cr3, %0" : "=r" (cr3) :: "memory");
-c0103e4b:	0f 20 d8             	mov    %cr3,%eax
-c0103e4e:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c0103d56:	0f 20 d8             	mov    %cr3,%eax
+c0103d59:	89 45 ec             	mov    %eax,-0x14(%ebp)
     return cr3;
-c0103e51:	8b 55 ec             	mov    -0x14(%ebp),%edx
+c0103d5c:	8b 55 ec             	mov    -0x14(%ebp),%edx
     if (rcr3() == PADDR(pgdir)) {
-c0103e54:	8b 45 08             	mov    0x8(%ebp),%eax
-c0103e57:	89 45 f0             	mov    %eax,-0x10(%ebp)
-c0103e5a:	81 7d f0 ff ff ff bf 	cmpl   $0xbfffffff,-0x10(%ebp)
-c0103e61:	77 17                	ja     c0103e7a <tlb_invalidate+0x35>
-c0103e63:	ff 75 f0             	pushl  -0x10(%ebp)
-c0103e66:	68 84 8c 10 c0       	push   $0xc0108c84
-c0103e6b:	68 e4 01 00 00       	push   $0x1e4
-c0103e70:	68 28 8d 10 c0       	push   $0xc0108d28
-c0103e75:	e8 6e c5 ff ff       	call   c01003e8 <__panic>
-c0103e7a:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0103e7d:	05 00 00 00 40       	add    $0x40000000,%eax
-c0103e82:	39 c2                	cmp    %eax,%edx
-c0103e84:	75 0c                	jne    c0103e92 <tlb_invalidate+0x4d>
+c0103d5f:	8b 45 08             	mov    0x8(%ebp),%eax
+c0103d62:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0103d65:	81 7d f0 ff ff ff bf 	cmpl   $0xbfffffff,-0x10(%ebp)
+c0103d6c:	77 23                	ja     c0103d91 <tlb_invalidate+0x41>
+c0103d6e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0103d71:	89 44 24 0c          	mov    %eax,0xc(%esp)
+c0103d75:	c7 44 24 08 a4 93 10 	movl   $0xc01093a4,0x8(%esp)
+c0103d7c:	c0 
+c0103d7d:	c7 44 24 04 e3 01 00 	movl   $0x1e3,0x4(%esp)
+c0103d84:	00 
+c0103d85:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c0103d8c:	e8 67 c6 ff ff       	call   c01003f8 <__panic>
+c0103d91:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0103d94:	05 00 00 00 40       	add    $0x40000000,%eax
+c0103d99:	39 c2                	cmp    %eax,%edx
+c0103d9b:	75 0c                	jne    c0103da9 <tlb_invalidate+0x59>
         invlpg((void *)la);
-c0103e86:	8b 45 0c             	mov    0xc(%ebp),%eax
-c0103e89:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0103d9d:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0103da0:	89 45 f4             	mov    %eax,-0xc(%ebp)
 }
 
 static inline void
 invlpg(void *addr) {
     asm volatile ("invlpg (%0)" :: "r" (addr) : "memory");
-c0103e8c:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0103e8f:	0f 01 38             	invlpg (%eax)
+c0103da3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0103da6:	0f 01 38             	invlpg (%eax)
     }
 }
-c0103e92:	90                   	nop
-c0103e93:	c9                   	leave  
-c0103e94:	c3                   	ret    
+c0103da9:	90                   	nop
+c0103daa:	c9                   	leave  
+c0103dab:	c3                   	ret    
 
-c0103e95 <pgdir_alloc_page>:
+c0103dac <pgdir_alloc_page>:
 
 // pgdir_alloc_page - call alloc_page & page_insert functions to 
 //                  - allocate a page size memory & setup an addr map
 //                  - pa<->la with linear address la and the PDT pgdir
 struct Page *
 pgdir_alloc_page(pde_t *pgdir, uintptr_t la, uint32_t perm) {
-c0103e95:	55                   	push   %ebp
-c0103e96:	89 e5                	mov    %esp,%ebp
-c0103e98:	83 ec 18             	sub    $0x18,%esp
+c0103dac:	55                   	push   %ebp
+c0103dad:	89 e5                	mov    %esp,%ebp
+c0103daf:	83 ec 28             	sub    $0x28,%esp
     struct Page *page = alloc_page();
-c0103e9b:	83 ec 0c             	sub    $0xc,%esp
-c0103e9e:	6a 01                	push   $0x1
-c0103ea0:	e8 6f f6 ff ff       	call   c0103514 <alloc_pages>
-c0103ea5:	83 c4 10             	add    $0x10,%esp
-c0103ea8:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0103db2:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c0103db9:	e8 af f5 ff ff       	call   c010336d <alloc_pages>
+c0103dbe:	89 45 f4             	mov    %eax,-0xc(%ebp)
     if (page != NULL) {
-c0103eab:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
-c0103eaf:	0f 84 83 00 00 00    	je     c0103f38 <pgdir_alloc_page+0xa3>
+c0103dc1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0103dc5:	0f 84 a7 00 00 00    	je     c0103e72 <pgdir_alloc_page+0xc6>
         if (page_insert(pgdir, page, la, perm) != 0) {
-c0103eb5:	ff 75 10             	pushl  0x10(%ebp)
-c0103eb8:	ff 75 0c             	pushl  0xc(%ebp)
-c0103ebb:	ff 75 f4             	pushl  -0xc(%ebp)
-c0103ebe:	ff 75 08             	pushl  0x8(%ebp)
-c0103ec1:	e8 c6 fe ff ff       	call   c0103d8c <page_insert>
-c0103ec6:	83 c4 10             	add    $0x10,%esp
-c0103ec9:	85 c0                	test   %eax,%eax
-c0103ecb:	74 17                	je     c0103ee4 <pgdir_alloc_page+0x4f>
+c0103dcb:	8b 45 10             	mov    0x10(%ebp),%eax
+c0103dce:	89 44 24 0c          	mov    %eax,0xc(%esp)
+c0103dd2:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0103dd5:	89 44 24 08          	mov    %eax,0x8(%esp)
+c0103dd9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0103ddc:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0103de0:	8b 45 08             	mov    0x8(%ebp),%eax
+c0103de3:	89 04 24             	mov    %eax,(%esp)
+c0103de6:	e8 ac fe ff ff       	call   c0103c97 <page_insert>
+c0103deb:	85 c0                	test   %eax,%eax
+c0103ded:	74 1a                	je     c0103e09 <pgdir_alloc_page+0x5d>
             free_page(page);
-c0103ecd:	83 ec 08             	sub    $0x8,%esp
-c0103ed0:	6a 01                	push   $0x1
-c0103ed2:	ff 75 f4             	pushl  -0xc(%ebp)
-c0103ed5:	e8 a6 f6 ff ff       	call   c0103580 <free_pages>
-c0103eda:	83 c4 10             	add    $0x10,%esp
+c0103def:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+c0103df6:	00 
+c0103df7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0103dfa:	89 04 24             	mov    %eax,(%esp)
+c0103dfd:	e8 d6 f5 ff ff       	call   c01033d8 <free_pages>
             return NULL;
-c0103edd:	b8 00 00 00 00       	mov    $0x0,%eax
-c0103ee2:	eb 57                	jmp    c0103f3b <pgdir_alloc_page+0xa6>
+c0103e02:	b8 00 00 00 00       	mov    $0x0,%eax
+c0103e07:	eb 6c                	jmp    c0103e75 <pgdir_alloc_page+0xc9>
         }
         if (swap_init_ok){
-c0103ee4:	a1 10 30 12 c0       	mov    0xc0123010,%eax
-c0103ee9:	85 c0                	test   %eax,%eax
-c0103eeb:	74 4b                	je     c0103f38 <pgdir_alloc_page+0xa3>
+c0103e09:	a1 10 40 12 c0       	mov    0xc0124010,%eax
+c0103e0e:	85 c0                	test   %eax,%eax
+c0103e10:	74 60                	je     c0103e72 <pgdir_alloc_page+0xc6>
             swap_map_swappable(check_mm_struct, la, page, 0);
-c0103eed:	a1 2c 30 12 c0       	mov    0xc012302c,%eax
-c0103ef2:	6a 00                	push   $0x0
-c0103ef4:	ff 75 f4             	pushl  -0xc(%ebp)
-c0103ef7:	ff 75 0c             	pushl  0xc(%ebp)
-c0103efa:	50                   	push   %eax
-c0103efb:	e8 be 19 00 00       	call   c01058be <swap_map_swappable>
-c0103f00:	83 c4 10             	add    $0x10,%esp
+c0103e12:	a1 2c 40 12 c0       	mov    0xc012402c,%eax
+c0103e17:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+c0103e1e:	00 
+c0103e1f:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0103e22:	89 54 24 08          	mov    %edx,0x8(%esp)
+c0103e26:	8b 55 0c             	mov    0xc(%ebp),%edx
+c0103e29:	89 54 24 04          	mov    %edx,0x4(%esp)
+c0103e2d:	89 04 24             	mov    %eax,(%esp)
+c0103e30:	e8 fc 1c 00 00       	call   c0105b31 <swap_map_swappable>
             page->pra_vaddr=la;
-c0103f03:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0103f06:	8b 55 0c             	mov    0xc(%ebp),%edx
-c0103f09:	89 50 1c             	mov    %edx,0x1c(%eax)
+c0103e35:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0103e38:	8b 55 0c             	mov    0xc(%ebp),%edx
+c0103e3b:	89 50 1c             	mov    %edx,0x1c(%eax)
             assert(page_ref(page) == 1);
-c0103f0c:	83 ec 0c             	sub    $0xc,%esp
-c0103f0f:	ff 75 f4             	pushl  -0xc(%ebp)
-c0103f12:	e8 ef f3 ff ff       	call   c0103306 <page_ref>
-c0103f17:	83 c4 10             	add    $0x10,%esp
-c0103f1a:	83 f8 01             	cmp    $0x1,%eax
-c0103f1d:	74 19                	je     c0103f38 <pgdir_alloc_page+0xa3>
-c0103f1f:	68 88 8d 10 c0       	push   $0xc0108d88
-c0103f24:	68 4d 8d 10 c0       	push   $0xc0108d4d
-c0103f29:	68 f7 01 00 00       	push   $0x1f7
-c0103f2e:	68 28 8d 10 c0       	push   $0xc0108d28
-c0103f33:	e8 b0 c4 ff ff       	call   c01003e8 <__panic>
+c0103e3e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0103e41:	89 04 24             	mov    %eax,(%esp)
+c0103e44:	e8 1f f3 ff ff       	call   c0103168 <page_ref>
+c0103e49:	83 f8 01             	cmp    $0x1,%eax
+c0103e4c:	74 24                	je     c0103e72 <pgdir_alloc_page+0xc6>
+c0103e4e:	c7 44 24 0c b6 94 10 	movl   $0xc01094b6,0xc(%esp)
+c0103e55:	c0 
+c0103e56:	c7 44 24 08 6d 94 10 	movl   $0xc010946d,0x8(%esp)
+c0103e5d:	c0 
+c0103e5e:	c7 44 24 04 f6 01 00 	movl   $0x1f6,0x4(%esp)
+c0103e65:	00 
+c0103e66:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c0103e6d:	e8 86 c5 ff ff       	call   c01003f8 <__panic>
             //cprintf("get No. %d  page: pra_vaddr %x, pra_link.prev %x, pra_link_next %x in pgdir_alloc_page\n", (page-pages), page->pra_vaddr,page->pra_page_link.prev, page->pra_page_link.next);
         }
 
     }
 
     return page;
-c0103f38:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0103e72:	8b 45 f4             	mov    -0xc(%ebp),%eax
 }
-c0103f3b:	c9                   	leave  
-c0103f3c:	c3                   	ret    
+c0103e75:	c9                   	leave  
+c0103e76:	c3                   	ret    
 
-c0103f3d <check_alloc_page>:
+c0103e77 <check_alloc_page>:
 
 static void
 check_alloc_page(void) {
-c0103f3d:	55                   	push   %ebp
-c0103f3e:	89 e5                	mov    %esp,%ebp
-c0103f40:	83 ec 08             	sub    $0x8,%esp
+c0103e77:	55                   	push   %ebp
+c0103e78:	89 e5                	mov    %esp,%ebp
+c0103e7a:	83 ec 18             	sub    $0x18,%esp
     pmm_manager->check();
-c0103f43:	a1 20 30 12 c0       	mov    0xc0123020,%eax
-c0103f48:	8b 40 18             	mov    0x18(%eax),%eax
-c0103f4b:	ff d0                	call   *%eax
+c0103e7d:	a1 20 40 12 c0       	mov    0xc0124020,%eax
+c0103e82:	8b 40 18             	mov    0x18(%eax),%eax
+c0103e85:	ff d0                	call   *%eax
     cprintf("check_alloc_page() succeeded!\n");
-c0103f4d:	83 ec 0c             	sub    $0xc,%esp
-c0103f50:	68 9c 8d 10 c0       	push   $0xc0108d9c
-c0103f55:	e8 28 c3 ff ff       	call   c0100282 <cprintf>
-c0103f5a:	83 c4 10             	add    $0x10,%esp
-}
-c0103f5d:	90                   	nop
-c0103f5e:	c9                   	leave  
-c0103f5f:	c3                   	ret    
+c0103e87:	c7 04 24 cc 94 10 c0 	movl   $0xc01094cc,(%esp)
+c0103e8e:	e8 0e c4 ff ff       	call   c01002a1 <cprintf>
+}
+c0103e93:	90                   	nop
+c0103e94:	c9                   	leave  
+c0103e95:	c3                   	ret    
 
-c0103f60 <check_pgdir>:
+c0103e96 <check_pgdir>:
 
 static void
 check_pgdir(void) {
-c0103f60:	55                   	push   %ebp
-c0103f61:	89 e5                	mov    %esp,%ebp
-c0103f63:	83 ec 28             	sub    $0x28,%esp
+c0103e96:	55                   	push   %ebp
+c0103e97:	89 e5                	mov    %esp,%ebp
+c0103e99:	83 ec 38             	sub    $0x38,%esp
     assert(npage <= KMEMSIZE / PGSIZE);
-c0103f66:	a1 80 2f 12 c0       	mov    0xc0122f80,%eax
-c0103f6b:	3d 00 80 03 00       	cmp    $0x38000,%eax
-c0103f70:	76 19                	jbe    c0103f8b <check_pgdir+0x2b>
-c0103f72:	68 bb 8d 10 c0       	push   $0xc0108dbb
-c0103f77:	68 4d 8d 10 c0       	push   $0xc0108d4d
-c0103f7c:	68 08 02 00 00       	push   $0x208
-c0103f81:	68 28 8d 10 c0       	push   $0xc0108d28
-c0103f86:	e8 5d c4 ff ff       	call   c01003e8 <__panic>
+c0103e9c:	a1 80 3f 12 c0       	mov    0xc0123f80,%eax
+c0103ea1:	3d 00 80 03 00       	cmp    $0x38000,%eax
+c0103ea6:	76 24                	jbe    c0103ecc <check_pgdir+0x36>
+c0103ea8:	c7 44 24 0c eb 94 10 	movl   $0xc01094eb,0xc(%esp)
+c0103eaf:	c0 
+c0103eb0:	c7 44 24 08 6d 94 10 	movl   $0xc010946d,0x8(%esp)
+c0103eb7:	c0 
+c0103eb8:	c7 44 24 04 07 02 00 	movl   $0x207,0x4(%esp)
+c0103ebf:	00 
+c0103ec0:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c0103ec7:	e8 2c c5 ff ff       	call   c01003f8 <__panic>
     assert(boot_pgdir != NULL && (uint32_t)PGOFF(boot_pgdir) == 0);
-c0103f8b:	a1 e0 f9 11 c0       	mov    0xc011f9e0,%eax
-c0103f90:	85 c0                	test   %eax,%eax
-c0103f92:	74 0e                	je     c0103fa2 <check_pgdir+0x42>
-c0103f94:	a1 e0 f9 11 c0       	mov    0xc011f9e0,%eax
-c0103f99:	25 ff 0f 00 00       	and    $0xfff,%eax
-c0103f9e:	85 c0                	test   %eax,%eax
-c0103fa0:	74 19                	je     c0103fbb <check_pgdir+0x5b>
-c0103fa2:	68 d8 8d 10 c0       	push   $0xc0108dd8
-c0103fa7:	68 4d 8d 10 c0       	push   $0xc0108d4d
-c0103fac:	68 09 02 00 00       	push   $0x209
-c0103fb1:	68 28 8d 10 c0       	push   $0xc0108d28
-c0103fb6:	e8 2d c4 ff ff       	call   c01003e8 <__panic>
+c0103ecc:	a1 e0 09 12 c0       	mov    0xc01209e0,%eax
+c0103ed1:	85 c0                	test   %eax,%eax
+c0103ed3:	74 0e                	je     c0103ee3 <check_pgdir+0x4d>
+c0103ed5:	a1 e0 09 12 c0       	mov    0xc01209e0,%eax
+c0103eda:	25 ff 0f 00 00       	and    $0xfff,%eax
+c0103edf:	85 c0                	test   %eax,%eax
+c0103ee1:	74 24                	je     c0103f07 <check_pgdir+0x71>
+c0103ee3:	c7 44 24 0c 08 95 10 	movl   $0xc0109508,0xc(%esp)
+c0103eea:	c0 
+c0103eeb:	c7 44 24 08 6d 94 10 	movl   $0xc010946d,0x8(%esp)
+c0103ef2:	c0 
+c0103ef3:	c7 44 24 04 08 02 00 	movl   $0x208,0x4(%esp)
+c0103efa:	00 
+c0103efb:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c0103f02:	e8 f1 c4 ff ff       	call   c01003f8 <__panic>
     assert(get_page(boot_pgdir, 0x0, NULL) == NULL);
-c0103fbb:	a1 e0 f9 11 c0       	mov    0xc011f9e0,%eax
-c0103fc0:	83 ec 04             	sub    $0x4,%esp
-c0103fc3:	6a 00                	push   $0x0
-c0103fc5:	6a 00                	push   $0x0
-c0103fc7:	50                   	push   %eax
-c0103fc8:	e8 cb fc ff ff       	call   c0103c98 <get_page>
-c0103fcd:	83 c4 10             	add    $0x10,%esp
-c0103fd0:	85 c0                	test   %eax,%eax
-c0103fd2:	74 19                	je     c0103fed <check_pgdir+0x8d>
-c0103fd4:	68 10 8e 10 c0       	push   $0xc0108e10
-c0103fd9:	68 4d 8d 10 c0       	push   $0xc0108d4d
-c0103fde:	68 0a 02 00 00       	push   $0x20a
-c0103fe3:	68 28 8d 10 c0       	push   $0xc0108d28
-c0103fe8:	e8 fb c3 ff ff       	call   c01003e8 <__panic>
+c0103f07:	a1 e0 09 12 c0       	mov    0xc01209e0,%eax
+c0103f0c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+c0103f13:	00 
+c0103f14:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+c0103f1b:	00 
+c0103f1c:	89 04 24             	mov    %eax,(%esp)
+c0103f1f:	e8 4f fc ff ff       	call   c0103b73 <get_page>
+c0103f24:	85 c0                	test   %eax,%eax
+c0103f26:	74 24                	je     c0103f4c <check_pgdir+0xb6>
+c0103f28:	c7 44 24 0c 40 95 10 	movl   $0xc0109540,0xc(%esp)
+c0103f2f:	c0 
+c0103f30:	c7 44 24 08 6d 94 10 	movl   $0xc010946d,0x8(%esp)
+c0103f37:	c0 
+c0103f38:	c7 44 24 04 09 02 00 	movl   $0x209,0x4(%esp)
+c0103f3f:	00 
+c0103f40:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c0103f47:	e8 ac c4 ff ff       	call   c01003f8 <__panic>
 
     struct Page *p1, *p2;
     p1 = alloc_page();
-c0103fed:	83 ec 0c             	sub    $0xc,%esp
-c0103ff0:	6a 01                	push   $0x1
-c0103ff2:	e8 1d f5 ff ff       	call   c0103514 <alloc_pages>
-c0103ff7:	83 c4 10             	add    $0x10,%esp
-c0103ffa:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0103f4c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c0103f53:	e8 15 f4 ff ff       	call   c010336d <alloc_pages>
+c0103f58:	89 45 f4             	mov    %eax,-0xc(%ebp)
     assert(page_insert(boot_pgdir, p1, 0x0, 0) == 0);
-c0103ffd:	a1 e0 f9 11 c0       	mov    0xc011f9e0,%eax
-c0104002:	6a 00                	push   $0x0
-c0104004:	6a 00                	push   $0x0
-c0104006:	ff 75 f4             	pushl  -0xc(%ebp)
-c0104009:	50                   	push   %eax
-c010400a:	e8 7d fd ff ff       	call   c0103d8c <page_insert>
-c010400f:	83 c4 10             	add    $0x10,%esp
-c0104012:	85 c0                	test   %eax,%eax
-c0104014:	74 19                	je     c010402f <check_pgdir+0xcf>
-c0104016:	68 38 8e 10 c0       	push   $0xc0108e38
-c010401b:	68 4d 8d 10 c0       	push   $0xc0108d4d
-c0104020:	68 0e 02 00 00       	push   $0x20e
-c0104025:	68 28 8d 10 c0       	push   $0xc0108d28
-c010402a:	e8 b9 c3 ff ff       	call   c01003e8 <__panic>
+c0103f5b:	a1 e0 09 12 c0       	mov    0xc01209e0,%eax
+c0103f60:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+c0103f67:	00 
+c0103f68:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+c0103f6f:	00 
+c0103f70:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0103f73:	89 54 24 04          	mov    %edx,0x4(%esp)
+c0103f77:	89 04 24             	mov    %eax,(%esp)
+c0103f7a:	e8 18 fd ff ff       	call   c0103c97 <page_insert>
+c0103f7f:	85 c0                	test   %eax,%eax
+c0103f81:	74 24                	je     c0103fa7 <check_pgdir+0x111>
+c0103f83:	c7 44 24 0c 68 95 10 	movl   $0xc0109568,0xc(%esp)
+c0103f8a:	c0 
+c0103f8b:	c7 44 24 08 6d 94 10 	movl   $0xc010946d,0x8(%esp)
+c0103f92:	c0 
+c0103f93:	c7 44 24 04 0d 02 00 	movl   $0x20d,0x4(%esp)
+c0103f9a:	00 
+c0103f9b:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c0103fa2:	e8 51 c4 ff ff       	call   c01003f8 <__panic>
 
     pte_t *ptep;
     assert((ptep = get_pte(boot_pgdir, 0x0, 0)) != NULL);
-c010402f:	a1 e0 f9 11 c0       	mov    0xc011f9e0,%eax
-c0104034:	83 ec 04             	sub    $0x4,%esp
-c0104037:	6a 00                	push   $0x0
-c0104039:	6a 00                	push   $0x0
-c010403b:	50                   	push   %eax
-c010403c:	e8 3a fb ff ff       	call   c0103b7b <get_pte>
-c0104041:	83 c4 10             	add    $0x10,%esp
-c0104044:	89 45 f0             	mov    %eax,-0x10(%ebp)
-c0104047:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
-c010404b:	75 19                	jne    c0104066 <check_pgdir+0x106>
-c010404d:	68 64 8e 10 c0       	push   $0xc0108e64
-c0104052:	68 4d 8d 10 c0       	push   $0xc0108d4d
-c0104057:	68 11 02 00 00       	push   $0x211
-c010405c:	68 28 8d 10 c0       	push   $0xc0108d28
-c0104061:	e8 82 c3 ff ff       	call   c01003e8 <__panic>
+c0103fa7:	a1 e0 09 12 c0       	mov    0xc01209e0,%eax
+c0103fac:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+c0103fb3:	00 
+c0103fb4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+c0103fbb:	00 
+c0103fbc:	89 04 24             	mov    %eax,(%esp)
+c0103fbf:	e8 76 fa ff ff       	call   c0103a3a <get_pte>
+c0103fc4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0103fc7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c0103fcb:	75 24                	jne    c0103ff1 <check_pgdir+0x15b>
+c0103fcd:	c7 44 24 0c 94 95 10 	movl   $0xc0109594,0xc(%esp)
+c0103fd4:	c0 
+c0103fd5:	c7 44 24 08 6d 94 10 	movl   $0xc010946d,0x8(%esp)
+c0103fdc:	c0 
+c0103fdd:	c7 44 24 04 10 02 00 	movl   $0x210,0x4(%esp)
+c0103fe4:	00 
+c0103fe5:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c0103fec:	e8 07 c4 ff ff       	call   c01003f8 <__panic>
     assert(pte2page(*ptep) == p1);
-c0104066:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0104069:	8b 00                	mov    (%eax),%eax
-c010406b:	83 ec 0c             	sub    $0xc,%esp
-c010406e:	50                   	push   %eax
-c010406f:	e8 3c f2 ff ff       	call   c01032b0 <pte2page>
-c0104074:	83 c4 10             	add    $0x10,%esp
-c0104077:	3b 45 f4             	cmp    -0xc(%ebp),%eax
-c010407a:	74 19                	je     c0104095 <check_pgdir+0x135>
-c010407c:	68 91 8e 10 c0       	push   $0xc0108e91
-c0104081:	68 4d 8d 10 c0       	push   $0xc0108d4d
-c0104086:	68 12 02 00 00       	push   $0x212
-c010408b:	68 28 8d 10 c0       	push   $0xc0108d28
-c0104090:	e8 53 c3 ff ff       	call   c01003e8 <__panic>
+c0103ff1:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0103ff4:	8b 00                	mov    (%eax),%eax
+c0103ff6:	89 04 24             	mov    %eax,(%esp)
+c0103ff9:	e8 14 f1 ff ff       	call   c0103112 <pte2page>
+c0103ffe:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+c0104001:	74 24                	je     c0104027 <check_pgdir+0x191>
+c0104003:	c7 44 24 0c c1 95 10 	movl   $0xc01095c1,0xc(%esp)
+c010400a:	c0 
+c010400b:	c7 44 24 08 6d 94 10 	movl   $0xc010946d,0x8(%esp)
+c0104012:	c0 
+c0104013:	c7 44 24 04 11 02 00 	movl   $0x211,0x4(%esp)
+c010401a:	00 
+c010401b:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c0104022:	e8 d1 c3 ff ff       	call   c01003f8 <__panic>
     assert(page_ref(p1) == 1);
-c0104095:	83 ec 0c             	sub    $0xc,%esp
-c0104098:	ff 75 f4             	pushl  -0xc(%ebp)
-c010409b:	e8 66 f2 ff ff       	call   c0103306 <page_ref>
-c01040a0:	83 c4 10             	add    $0x10,%esp
-c01040a3:	83 f8 01             	cmp    $0x1,%eax
-c01040a6:	74 19                	je     c01040c1 <check_pgdir+0x161>
-c01040a8:	68 a7 8e 10 c0       	push   $0xc0108ea7
-c01040ad:	68 4d 8d 10 c0       	push   $0xc0108d4d
-c01040b2:	68 13 02 00 00       	push   $0x213
-c01040b7:	68 28 8d 10 c0       	push   $0xc0108d28
-c01040bc:	e8 27 c3 ff ff       	call   c01003e8 <__panic>
+c0104027:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010402a:	89 04 24             	mov    %eax,(%esp)
+c010402d:	e8 36 f1 ff ff       	call   c0103168 <page_ref>
+c0104032:	83 f8 01             	cmp    $0x1,%eax
+c0104035:	74 24                	je     c010405b <check_pgdir+0x1c5>
+c0104037:	c7 44 24 0c d7 95 10 	movl   $0xc01095d7,0xc(%esp)
+c010403e:	c0 
+c010403f:	c7 44 24 08 6d 94 10 	movl   $0xc010946d,0x8(%esp)
+c0104046:	c0 
+c0104047:	c7 44 24 04 12 02 00 	movl   $0x212,0x4(%esp)
+c010404e:	00 
+c010404f:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c0104056:	e8 9d c3 ff ff       	call   c01003f8 <__panic>
 
     ptep = &((pte_t *)KADDR(PDE_ADDR(boot_pgdir[0])))[1];
-c01040c1:	a1 e0 f9 11 c0       	mov    0xc011f9e0,%eax
-c01040c6:	8b 00                	mov    (%eax),%eax
-c01040c8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
-c01040cd:	89 45 ec             	mov    %eax,-0x14(%ebp)
-c01040d0:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c01040d3:	c1 e8 0c             	shr    $0xc,%eax
-c01040d6:	89 45 e8             	mov    %eax,-0x18(%ebp)
-c01040d9:	a1 80 2f 12 c0       	mov    0xc0122f80,%eax
-c01040de:	39 45 e8             	cmp    %eax,-0x18(%ebp)
-c01040e1:	72 17                	jb     c01040fa <check_pgdir+0x19a>
-c01040e3:	ff 75 ec             	pushl  -0x14(%ebp)
-c01040e6:	68 60 8c 10 c0       	push   $0xc0108c60
-c01040eb:	68 15 02 00 00       	push   $0x215
-c01040f0:	68 28 8d 10 c0       	push   $0xc0108d28
-c01040f5:	e8 ee c2 ff ff       	call   c01003e8 <__panic>
-c01040fa:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c01040fd:	2d 00 00 00 40       	sub    $0x40000000,%eax
-c0104102:	83 c0 04             	add    $0x4,%eax
-c0104105:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c010405b:	a1 e0 09 12 c0       	mov    0xc01209e0,%eax
+c0104060:	8b 00                	mov    (%eax),%eax
+c0104062:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+c0104067:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c010406a:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c010406d:	c1 e8 0c             	shr    $0xc,%eax
+c0104070:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c0104073:	a1 80 3f 12 c0       	mov    0xc0123f80,%eax
+c0104078:	39 45 e8             	cmp    %eax,-0x18(%ebp)
+c010407b:	72 23                	jb     c01040a0 <check_pgdir+0x20a>
+c010407d:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0104080:	89 44 24 0c          	mov    %eax,0xc(%esp)
+c0104084:	c7 44 24 08 80 93 10 	movl   $0xc0109380,0x8(%esp)
+c010408b:	c0 
+c010408c:	c7 44 24 04 14 02 00 	movl   $0x214,0x4(%esp)
+c0104093:	00 
+c0104094:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c010409b:	e8 58 c3 ff ff       	call   c01003f8 <__panic>
+c01040a0:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c01040a3:	2d 00 00 00 40       	sub    $0x40000000,%eax
+c01040a8:	83 c0 04             	add    $0x4,%eax
+c01040ab:	89 45 f0             	mov    %eax,-0x10(%ebp)
     assert(get_pte(boot_pgdir, PGSIZE, 0) == ptep);
-c0104108:	a1 e0 f9 11 c0       	mov    0xc011f9e0,%eax
-c010410d:	83 ec 04             	sub    $0x4,%esp
-c0104110:	6a 00                	push   $0x0
-c0104112:	68 00 10 00 00       	push   $0x1000
-c0104117:	50                   	push   %eax
-c0104118:	e8 5e fa ff ff       	call   c0103b7b <get_pte>
-c010411d:	83 c4 10             	add    $0x10,%esp
-c0104120:	3b 45 f0             	cmp    -0x10(%ebp),%eax
-c0104123:	74 19                	je     c010413e <check_pgdir+0x1de>
-c0104125:	68 bc 8e 10 c0       	push   $0xc0108ebc
-c010412a:	68 4d 8d 10 c0       	push   $0xc0108d4d
-c010412f:	68 16 02 00 00       	push   $0x216
-c0104134:	68 28 8d 10 c0       	push   $0xc0108d28
-c0104139:	e8 aa c2 ff ff       	call   c01003e8 <__panic>
+c01040ae:	a1 e0 09 12 c0       	mov    0xc01209e0,%eax
+c01040b3:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+c01040ba:	00 
+c01040bb:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
+c01040c2:	00 
+c01040c3:	89 04 24             	mov    %eax,(%esp)
+c01040c6:	e8 6f f9 ff ff       	call   c0103a3a <get_pte>
+c01040cb:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+c01040ce:	74 24                	je     c01040f4 <check_pgdir+0x25e>
+c01040d0:	c7 44 24 0c ec 95 10 	movl   $0xc01095ec,0xc(%esp)
+c01040d7:	c0 
+c01040d8:	c7 44 24 08 6d 94 10 	movl   $0xc010946d,0x8(%esp)
+c01040df:	c0 
+c01040e0:	c7 44 24 04 15 02 00 	movl   $0x215,0x4(%esp)
+c01040e7:	00 
+c01040e8:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c01040ef:	e8 04 c3 ff ff       	call   c01003f8 <__panic>
 
     p2 = alloc_page();
-c010413e:	83 ec 0c             	sub    $0xc,%esp
-c0104141:	6a 01                	push   $0x1
-c0104143:	e8 cc f3 ff ff       	call   c0103514 <alloc_pages>
-c0104148:	83 c4 10             	add    $0x10,%esp
-c010414b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+c01040f4:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c01040fb:	e8 6d f2 ff ff       	call   c010336d <alloc_pages>
+c0104100:	89 45 e4             	mov    %eax,-0x1c(%ebp)
     assert(page_insert(boot_pgdir, p2, PGSIZE, PTE_U | PTE_W) == 0);
-c010414e:	a1 e0 f9 11 c0       	mov    0xc011f9e0,%eax
-c0104153:	6a 06                	push   $0x6
-c0104155:	68 00 10 00 00       	push   $0x1000
-c010415a:	ff 75 e4             	pushl  -0x1c(%ebp)
-c010415d:	50                   	push   %eax
-c010415e:	e8 29 fc ff ff       	call   c0103d8c <page_insert>
-c0104163:	83 c4 10             	add    $0x10,%esp
-c0104166:	85 c0                	test   %eax,%eax
-c0104168:	74 19                	je     c0104183 <check_pgdir+0x223>
-c010416a:	68 e4 8e 10 c0       	push   $0xc0108ee4
-c010416f:	68 4d 8d 10 c0       	push   $0xc0108d4d
-c0104174:	68 19 02 00 00       	push   $0x219
-c0104179:	68 28 8d 10 c0       	push   $0xc0108d28
-c010417e:	e8 65 c2 ff ff       	call   c01003e8 <__panic>
+c0104103:	a1 e0 09 12 c0       	mov    0xc01209e0,%eax
+c0104108:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
+c010410f:	00 
+c0104110:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
+c0104117:	00 
+c0104118:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c010411b:	89 54 24 04          	mov    %edx,0x4(%esp)
+c010411f:	89 04 24             	mov    %eax,(%esp)
+c0104122:	e8 70 fb ff ff       	call   c0103c97 <page_insert>
+c0104127:	85 c0                	test   %eax,%eax
+c0104129:	74 24                	je     c010414f <check_pgdir+0x2b9>
+c010412b:	c7 44 24 0c 14 96 10 	movl   $0xc0109614,0xc(%esp)
+c0104132:	c0 
+c0104133:	c7 44 24 08 6d 94 10 	movl   $0xc010946d,0x8(%esp)
+c010413a:	c0 
+c010413b:	c7 44 24 04 18 02 00 	movl   $0x218,0x4(%esp)
+c0104142:	00 
+c0104143:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c010414a:	e8 a9 c2 ff ff       	call   c01003f8 <__panic>
     assert((ptep = get_pte(boot_pgdir, PGSIZE, 0)) != NULL);
-c0104183:	a1 e0 f9 11 c0       	mov    0xc011f9e0,%eax
-c0104188:	83 ec 04             	sub    $0x4,%esp
-c010418b:	6a 00                	push   $0x0
-c010418d:	68 00 10 00 00       	push   $0x1000
-c0104192:	50                   	push   %eax
-c0104193:	e8 e3 f9 ff ff       	call   c0103b7b <get_pte>
-c0104198:	83 c4 10             	add    $0x10,%esp
-c010419b:	89 45 f0             	mov    %eax,-0x10(%ebp)
-c010419e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
-c01041a2:	75 19                	jne    c01041bd <check_pgdir+0x25d>
-c01041a4:	68 1c 8f 10 c0       	push   $0xc0108f1c
-c01041a9:	68 4d 8d 10 c0       	push   $0xc0108d4d
-c01041ae:	68 1a 02 00 00       	push   $0x21a
-c01041b3:	68 28 8d 10 c0       	push   $0xc0108d28
-c01041b8:	e8 2b c2 ff ff       	call   c01003e8 <__panic>
+c010414f:	a1 e0 09 12 c0       	mov    0xc01209e0,%eax
+c0104154:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+c010415b:	00 
+c010415c:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
+c0104163:	00 
+c0104164:	89 04 24             	mov    %eax,(%esp)
+c0104167:	e8 ce f8 ff ff       	call   c0103a3a <get_pte>
+c010416c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c010416f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c0104173:	75 24                	jne    c0104199 <check_pgdir+0x303>
+c0104175:	c7 44 24 0c 4c 96 10 	movl   $0xc010964c,0xc(%esp)
+c010417c:	c0 
+c010417d:	c7 44 24 08 6d 94 10 	movl   $0xc010946d,0x8(%esp)
+c0104184:	c0 
+c0104185:	c7 44 24 04 19 02 00 	movl   $0x219,0x4(%esp)
+c010418c:	00 
+c010418d:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c0104194:	e8 5f c2 ff ff       	call   c01003f8 <__panic>
     assert(*ptep & PTE_U);
-c01041bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c01041c0:	8b 00                	mov    (%eax),%eax
-c01041c2:	83 e0 04             	and    $0x4,%eax
-c01041c5:	85 c0                	test   %eax,%eax
-c01041c7:	75 19                	jne    c01041e2 <check_pgdir+0x282>
-c01041c9:	68 4c 8f 10 c0       	push   $0xc0108f4c
-c01041ce:	68 4d 8d 10 c0       	push   $0xc0108d4d
-c01041d3:	68 1b 02 00 00       	push   $0x21b
-c01041d8:	68 28 8d 10 c0       	push   $0xc0108d28
-c01041dd:	e8 06 c2 ff ff       	call   c01003e8 <__panic>
+c0104199:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010419c:	8b 00                	mov    (%eax),%eax
+c010419e:	83 e0 04             	and    $0x4,%eax
+c01041a1:	85 c0                	test   %eax,%eax
+c01041a3:	75 24                	jne    c01041c9 <check_pgdir+0x333>
+c01041a5:	c7 44 24 0c 7c 96 10 	movl   $0xc010967c,0xc(%esp)
+c01041ac:	c0 
+c01041ad:	c7 44 24 08 6d 94 10 	movl   $0xc010946d,0x8(%esp)
+c01041b4:	c0 
+c01041b5:	c7 44 24 04 1a 02 00 	movl   $0x21a,0x4(%esp)
+c01041bc:	00 
+c01041bd:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c01041c4:	e8 2f c2 ff ff       	call   c01003f8 <__panic>
     assert(*ptep & PTE_W);
-c01041e2:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c01041e5:	8b 00                	mov    (%eax),%eax
-c01041e7:	83 e0 02             	and    $0x2,%eax
-c01041ea:	85 c0                	test   %eax,%eax
-c01041ec:	75 19                	jne    c0104207 <check_pgdir+0x2a7>
-c01041ee:	68 5a 8f 10 c0       	push   $0xc0108f5a
-c01041f3:	68 4d 8d 10 c0       	push   $0xc0108d4d
-c01041f8:	68 1c 02 00 00       	push   $0x21c
-c01041fd:	68 28 8d 10 c0       	push   $0xc0108d28
-c0104202:	e8 e1 c1 ff ff       	call   c01003e8 <__panic>
+c01041c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01041cc:	8b 00                	mov    (%eax),%eax
+c01041ce:	83 e0 02             	and    $0x2,%eax
+c01041d1:	85 c0                	test   %eax,%eax
+c01041d3:	75 24                	jne    c01041f9 <check_pgdir+0x363>
+c01041d5:	c7 44 24 0c 8a 96 10 	movl   $0xc010968a,0xc(%esp)
+c01041dc:	c0 
+c01041dd:	c7 44 24 08 6d 94 10 	movl   $0xc010946d,0x8(%esp)
+c01041e4:	c0 
+c01041e5:	c7 44 24 04 1b 02 00 	movl   $0x21b,0x4(%esp)
+c01041ec:	00 
+c01041ed:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c01041f4:	e8 ff c1 ff ff       	call   c01003f8 <__panic>
     assert(boot_pgdir[0] & PTE_U);
-c0104207:	a1 e0 f9 11 c0       	mov    0xc011f9e0,%eax
-c010420c:	8b 00                	mov    (%eax),%eax
-c010420e:	83 e0 04             	and    $0x4,%eax
-c0104211:	85 c0                	test   %eax,%eax
-c0104213:	75 19                	jne    c010422e <check_pgdir+0x2ce>
-c0104215:	68 68 8f 10 c0       	push   $0xc0108f68
-c010421a:	68 4d 8d 10 c0       	push   $0xc0108d4d
-c010421f:	68 1d 02 00 00       	push   $0x21d
-c0104224:	68 28 8d 10 c0       	push   $0xc0108d28
-c0104229:	e8 ba c1 ff ff       	call   c01003e8 <__panic>
+c01041f9:	a1 e0 09 12 c0       	mov    0xc01209e0,%eax
+c01041fe:	8b 00                	mov    (%eax),%eax
+c0104200:	83 e0 04             	and    $0x4,%eax
+c0104203:	85 c0                	test   %eax,%eax
+c0104205:	75 24                	jne    c010422b <check_pgdir+0x395>
+c0104207:	c7 44 24 0c 98 96 10 	movl   $0xc0109698,0xc(%esp)
+c010420e:	c0 
+c010420f:	c7 44 24 08 6d 94 10 	movl   $0xc010946d,0x8(%esp)
+c0104216:	c0 
+c0104217:	c7 44 24 04 1c 02 00 	movl   $0x21c,0x4(%esp)
+c010421e:	00 
+c010421f:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c0104226:	e8 cd c1 ff ff       	call   c01003f8 <__panic>
     assert(page_ref(p2) == 1);
-c010422e:	83 ec 0c             	sub    $0xc,%esp
-c0104231:	ff 75 e4             	pushl  -0x1c(%ebp)
-c0104234:	e8 cd f0 ff ff       	call   c0103306 <page_ref>
-c0104239:	83 c4 10             	add    $0x10,%esp
-c010423c:	83 f8 01             	cmp    $0x1,%eax
-c010423f:	74 19                	je     c010425a <check_pgdir+0x2fa>
-c0104241:	68 7e 8f 10 c0       	push   $0xc0108f7e
-c0104246:	68 4d 8d 10 c0       	push   $0xc0108d4d
-c010424b:	68 1e 02 00 00       	push   $0x21e
-c0104250:	68 28 8d 10 c0       	push   $0xc0108d28
-c0104255:	e8 8e c1 ff ff       	call   c01003e8 <__panic>
+c010422b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c010422e:	89 04 24             	mov    %eax,(%esp)
+c0104231:	e8 32 ef ff ff       	call   c0103168 <page_ref>
+c0104236:	83 f8 01             	cmp    $0x1,%eax
+c0104239:	74 24                	je     c010425f <check_pgdir+0x3c9>
+c010423b:	c7 44 24 0c ae 96 10 	movl   $0xc01096ae,0xc(%esp)
+c0104242:	c0 
+c0104243:	c7 44 24 08 6d 94 10 	movl   $0xc010946d,0x8(%esp)
+c010424a:	c0 
+c010424b:	c7 44 24 04 1d 02 00 	movl   $0x21d,0x4(%esp)
+c0104252:	00 
+c0104253:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c010425a:	e8 99 c1 ff ff       	call   c01003f8 <__panic>
 
     assert(page_insert(boot_pgdir, p1, PGSIZE, 0) == 0);
-c010425a:	a1 e0 f9 11 c0       	mov    0xc011f9e0,%eax
-c010425f:	6a 00                	push   $0x0
-c0104261:	68 00 10 00 00       	push   $0x1000
-c0104266:	ff 75 f4             	pushl  -0xc(%ebp)
-c0104269:	50                   	push   %eax
-c010426a:	e8 1d fb ff ff       	call   c0103d8c <page_insert>
-c010426f:	83 c4 10             	add    $0x10,%esp
-c0104272:	85 c0                	test   %eax,%eax
-c0104274:	74 19                	je     c010428f <check_pgdir+0x32f>
-c0104276:	68 90 8f 10 c0       	push   $0xc0108f90
-c010427b:	68 4d 8d 10 c0       	push   $0xc0108d4d
-c0104280:	68 20 02 00 00       	push   $0x220
-c0104285:	68 28 8d 10 c0       	push   $0xc0108d28
-c010428a:	e8 59 c1 ff ff       	call   c01003e8 <__panic>
+c010425f:	a1 e0 09 12 c0       	mov    0xc01209e0,%eax
+c0104264:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+c010426b:	00 
+c010426c:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
+c0104273:	00 
+c0104274:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0104277:	89 54 24 04          	mov    %edx,0x4(%esp)
+c010427b:	89 04 24             	mov    %eax,(%esp)
+c010427e:	e8 14 fa ff ff       	call   c0103c97 <page_insert>
+c0104283:	85 c0                	test   %eax,%eax
+c0104285:	74 24                	je     c01042ab <check_pgdir+0x415>
+c0104287:	c7 44 24 0c c0 96 10 	movl   $0xc01096c0,0xc(%esp)
+c010428e:	c0 
+c010428f:	c7 44 24 08 6d 94 10 	movl   $0xc010946d,0x8(%esp)
+c0104296:	c0 
+c0104297:	c7 44 24 04 1f 02 00 	movl   $0x21f,0x4(%esp)
+c010429e:	00 
+c010429f:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c01042a6:	e8 4d c1 ff ff       	call   c01003f8 <__panic>
     assert(page_ref(p1) == 2);
-c010428f:	83 ec 0c             	sub    $0xc,%esp
-c0104292:	ff 75 f4             	pushl  -0xc(%ebp)
-c0104295:	e8 6c f0 ff ff       	call   c0103306 <page_ref>
-c010429a:	83 c4 10             	add    $0x10,%esp
-c010429d:	83 f8 02             	cmp    $0x2,%eax
-c01042a0:	74 19                	je     c01042bb <check_pgdir+0x35b>
-c01042a2:	68 bc 8f 10 c0       	push   $0xc0108fbc
-c01042a7:	68 4d 8d 10 c0       	push   $0xc0108d4d
-c01042ac:	68 21 02 00 00       	push   $0x221
-c01042b1:	68 28 8d 10 c0       	push   $0xc0108d28
-c01042b6:	e8 2d c1 ff ff       	call   c01003e8 <__panic>
+c01042ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01042ae:	89 04 24             	mov    %eax,(%esp)
+c01042b1:	e8 b2 ee ff ff       	call   c0103168 <page_ref>
+c01042b6:	83 f8 02             	cmp    $0x2,%eax
+c01042b9:	74 24                	je     c01042df <check_pgdir+0x449>
+c01042bb:	c7 44 24 0c ec 96 10 	movl   $0xc01096ec,0xc(%esp)
+c01042c2:	c0 
+c01042c3:	c7 44 24 08 6d 94 10 	movl   $0xc010946d,0x8(%esp)
+c01042ca:	c0 
+c01042cb:	c7 44 24 04 20 02 00 	movl   $0x220,0x4(%esp)
+c01042d2:	00 
+c01042d3:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c01042da:	e8 19 c1 ff ff       	call   c01003f8 <__panic>
     assert(page_ref(p2) == 0);
-c01042bb:	83 ec 0c             	sub    $0xc,%esp
-c01042be:	ff 75 e4             	pushl  -0x1c(%ebp)
-c01042c1:	e8 40 f0 ff ff       	call   c0103306 <page_ref>
-c01042c6:	83 c4 10             	add    $0x10,%esp
-c01042c9:	85 c0                	test   %eax,%eax
-c01042cb:	74 19                	je     c01042e6 <check_pgdir+0x386>
-c01042cd:	68 ce 8f 10 c0       	push   $0xc0108fce
-c01042d2:	68 4d 8d 10 c0       	push   $0xc0108d4d
-c01042d7:	68 22 02 00 00       	push   $0x222
-c01042dc:	68 28 8d 10 c0       	push   $0xc0108d28
-c01042e1:	e8 02 c1 ff ff       	call   c01003e8 <__panic>
+c01042df:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c01042e2:	89 04 24             	mov    %eax,(%esp)
+c01042e5:	e8 7e ee ff ff       	call   c0103168 <page_ref>
+c01042ea:	85 c0                	test   %eax,%eax
+c01042ec:	74 24                	je     c0104312 <check_pgdir+0x47c>
+c01042ee:	c7 44 24 0c fe 96 10 	movl   $0xc01096fe,0xc(%esp)
+c01042f5:	c0 
+c01042f6:	c7 44 24 08 6d 94 10 	movl   $0xc010946d,0x8(%esp)
+c01042fd:	c0 
+c01042fe:	c7 44 24 04 21 02 00 	movl   $0x221,0x4(%esp)
+c0104305:	00 
+c0104306:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c010430d:	e8 e6 c0 ff ff       	call   c01003f8 <__panic>
     assert((ptep = get_pte(boot_pgdir, PGSIZE, 0)) != NULL);
-c01042e6:	a1 e0 f9 11 c0       	mov    0xc011f9e0,%eax
-c01042eb:	83 ec 04             	sub    $0x4,%esp
-c01042ee:	6a 00                	push   $0x0
-c01042f0:	68 00 10 00 00       	push   $0x1000
-c01042f5:	50                   	push   %eax
-c01042f6:	e8 80 f8 ff ff       	call   c0103b7b <get_pte>
-c01042fb:	83 c4 10             	add    $0x10,%esp
-c01042fe:	89 45 f0             	mov    %eax,-0x10(%ebp)
-c0104301:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
-c0104305:	75 19                	jne    c0104320 <check_pgdir+0x3c0>
-c0104307:	68 1c 8f 10 c0       	push   $0xc0108f1c
-c010430c:	68 4d 8d 10 c0       	push   $0xc0108d4d
-c0104311:	68 23 02 00 00       	push   $0x223
-c0104316:	68 28 8d 10 c0       	push   $0xc0108d28
-c010431b:	e8 c8 c0 ff ff       	call   c01003e8 <__panic>
+c0104312:	a1 e0 09 12 c0       	mov    0xc01209e0,%eax
+c0104317:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+c010431e:	00 
+c010431f:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
+c0104326:	00 
+c0104327:	89 04 24             	mov    %eax,(%esp)
+c010432a:	e8 0b f7 ff ff       	call   c0103a3a <get_pte>
+c010432f:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0104332:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c0104336:	75 24                	jne    c010435c <check_pgdir+0x4c6>
+c0104338:	c7 44 24 0c 4c 96 10 	movl   $0xc010964c,0xc(%esp)
+c010433f:	c0 
+c0104340:	c7 44 24 08 6d 94 10 	movl   $0xc010946d,0x8(%esp)
+c0104347:	c0 
+c0104348:	c7 44 24 04 22 02 00 	movl   $0x222,0x4(%esp)
+c010434f:	00 
+c0104350:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c0104357:	e8 9c c0 ff ff       	call   c01003f8 <__panic>
     assert(pte2page(*ptep) == p1);
-c0104320:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0104323:	8b 00                	mov    (%eax),%eax
-c0104325:	83 ec 0c             	sub    $0xc,%esp
-c0104328:	50                   	push   %eax
-c0104329:	e8 82 ef ff ff       	call   c01032b0 <pte2page>
-c010432e:	83 c4 10             	add    $0x10,%esp
-c0104331:	3b 45 f4             	cmp    -0xc(%ebp),%eax
-c0104334:	74 19                	je     c010434f <check_pgdir+0x3ef>
-c0104336:	68 91 8e 10 c0       	push   $0xc0108e91
-c010433b:	68 4d 8d 10 c0       	push   $0xc0108d4d
-c0104340:	68 24 02 00 00       	push   $0x224
-c0104345:	68 28 8d 10 c0       	push   $0xc0108d28
-c010434a:	e8 99 c0 ff ff       	call   c01003e8 <__panic>
+c010435c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010435f:	8b 00                	mov    (%eax),%eax
+c0104361:	89 04 24             	mov    %eax,(%esp)
+c0104364:	e8 a9 ed ff ff       	call   c0103112 <pte2page>
+c0104369:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+c010436c:	74 24                	je     c0104392 <check_pgdir+0x4fc>
+c010436e:	c7 44 24 0c c1 95 10 	movl   $0xc01095c1,0xc(%esp)
+c0104375:	c0 
+c0104376:	c7 44 24 08 6d 94 10 	movl   $0xc010946d,0x8(%esp)
+c010437d:	c0 
+c010437e:	c7 44 24 04 23 02 00 	movl   $0x223,0x4(%esp)
+c0104385:	00 
+c0104386:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c010438d:	e8 66 c0 ff ff       	call   c01003f8 <__panic>
     assert((*ptep & PTE_U) == 0);
-c010434f:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0104352:	8b 00                	mov    (%eax),%eax
-c0104354:	83 e0 04             	and    $0x4,%eax
-c0104357:	85 c0                	test   %eax,%eax
-c0104359:	74 19                	je     c0104374 <check_pgdir+0x414>
-c010435b:	68 e0 8f 10 c0       	push   $0xc0108fe0
-c0104360:	68 4d 8d 10 c0       	push   $0xc0108d4d
-c0104365:	68 25 02 00 00       	push   $0x225
-c010436a:	68 28 8d 10 c0       	push   $0xc0108d28
-c010436f:	e8 74 c0 ff ff       	call   c01003e8 <__panic>
+c0104392:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0104395:	8b 00                	mov    (%eax),%eax
+c0104397:	83 e0 04             	and    $0x4,%eax
+c010439a:	85 c0                	test   %eax,%eax
+c010439c:	74 24                	je     c01043c2 <check_pgdir+0x52c>
+c010439e:	c7 44 24 0c 10 97 10 	movl   $0xc0109710,0xc(%esp)
+c01043a5:	c0 
+c01043a6:	c7 44 24 08 6d 94 10 	movl   $0xc010946d,0x8(%esp)
+c01043ad:	c0 
+c01043ae:	c7 44 24 04 24 02 00 	movl   $0x224,0x4(%esp)
+c01043b5:	00 
+c01043b6:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c01043bd:	e8 36 c0 ff ff       	call   c01003f8 <__panic>
 
     page_remove(boot_pgdir, 0x0);
-c0104374:	a1 e0 f9 11 c0       	mov    0xc011f9e0,%eax
-c0104379:	83 ec 08             	sub    $0x8,%esp
-c010437c:	6a 00                	push   $0x0
-c010437e:	50                   	push   %eax
-c010437f:	e8 cf f9 ff ff       	call   c0103d53 <page_remove>
-c0104384:	83 c4 10             	add    $0x10,%esp
+c01043c2:	a1 e0 09 12 c0       	mov    0xc01209e0,%eax
+c01043c7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+c01043ce:	00 
+c01043cf:	89 04 24             	mov    %eax,(%esp)
+c01043d2:	e8 7b f8 ff ff       	call   c0103c52 <page_remove>
     assert(page_ref(p1) == 1);
-c0104387:	83 ec 0c             	sub    $0xc,%esp
-c010438a:	ff 75 f4             	pushl  -0xc(%ebp)
-c010438d:	e8 74 ef ff ff       	call   c0103306 <page_ref>
-c0104392:	83 c4 10             	add    $0x10,%esp
-c0104395:	83 f8 01             	cmp    $0x1,%eax
-c0104398:	74 19                	je     c01043b3 <check_pgdir+0x453>
-c010439a:	68 a7 8e 10 c0       	push   $0xc0108ea7
-c010439f:	68 4d 8d 10 c0       	push   $0xc0108d4d
-c01043a4:	68 28 02 00 00       	push   $0x228
-c01043a9:	68 28 8d 10 c0       	push   $0xc0108d28
-c01043ae:	e8 35 c0 ff ff       	call   c01003e8 <__panic>
+c01043d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01043da:	89 04 24             	mov    %eax,(%esp)
+c01043dd:	e8 86 ed ff ff       	call   c0103168 <page_ref>
+c01043e2:	83 f8 01             	cmp    $0x1,%eax
+c01043e5:	74 24                	je     c010440b <check_pgdir+0x575>
+c01043e7:	c7 44 24 0c d7 95 10 	movl   $0xc01095d7,0xc(%esp)
+c01043ee:	c0 
+c01043ef:	c7 44 24 08 6d 94 10 	movl   $0xc010946d,0x8(%esp)
+c01043f6:	c0 
+c01043f7:	c7 44 24 04 27 02 00 	movl   $0x227,0x4(%esp)
+c01043fe:	00 
+c01043ff:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c0104406:	e8 ed bf ff ff       	call   c01003f8 <__panic>
     assert(page_ref(p2) == 0);
-c01043b3:	83 ec 0c             	sub    $0xc,%esp
-c01043b6:	ff 75 e4             	pushl  -0x1c(%ebp)
-c01043b9:	e8 48 ef ff ff       	call   c0103306 <page_ref>
-c01043be:	83 c4 10             	add    $0x10,%esp
-c01043c1:	85 c0                	test   %eax,%eax
-c01043c3:	74 19                	je     c01043de <check_pgdir+0x47e>
-c01043c5:	68 ce 8f 10 c0       	push   $0xc0108fce
-c01043ca:	68 4d 8d 10 c0       	push   $0xc0108d4d
-c01043cf:	68 29 02 00 00       	push   $0x229
-c01043d4:	68 28 8d 10 c0       	push   $0xc0108d28
-c01043d9:	e8 0a c0 ff ff       	call   c01003e8 <__panic>
+c010440b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c010440e:	89 04 24             	mov    %eax,(%esp)
+c0104411:	e8 52 ed ff ff       	call   c0103168 <page_ref>
+c0104416:	85 c0                	test   %eax,%eax
+c0104418:	74 24                	je     c010443e <check_pgdir+0x5a8>
+c010441a:	c7 44 24 0c fe 96 10 	movl   $0xc01096fe,0xc(%esp)
+c0104421:	c0 
+c0104422:	c7 44 24 08 6d 94 10 	movl   $0xc010946d,0x8(%esp)
+c0104429:	c0 
+c010442a:	c7 44 24 04 28 02 00 	movl   $0x228,0x4(%esp)
+c0104431:	00 
+c0104432:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c0104439:	e8 ba bf ff ff       	call   c01003f8 <__panic>
 
     page_remove(boot_pgdir, PGSIZE);
-c01043de:	a1 e0 f9 11 c0       	mov    0xc011f9e0,%eax
-c01043e3:	83 ec 08             	sub    $0x8,%esp
-c01043e6:	68 00 10 00 00       	push   $0x1000
-c01043eb:	50                   	push   %eax
-c01043ec:	e8 62 f9 ff ff       	call   c0103d53 <page_remove>
-c01043f1:	83 c4 10             	add    $0x10,%esp
+c010443e:	a1 e0 09 12 c0       	mov    0xc01209e0,%eax
+c0104443:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
+c010444a:	00 
+c010444b:	89 04 24             	mov    %eax,(%esp)
+c010444e:	e8 ff f7 ff ff       	call   c0103c52 <page_remove>
     assert(page_ref(p1) == 0);
-c01043f4:	83 ec 0c             	sub    $0xc,%esp
-c01043f7:	ff 75 f4             	pushl  -0xc(%ebp)
-c01043fa:	e8 07 ef ff ff       	call   c0103306 <page_ref>
-c01043ff:	83 c4 10             	add    $0x10,%esp
-c0104402:	85 c0                	test   %eax,%eax
-c0104404:	74 19                	je     c010441f <check_pgdir+0x4bf>
-c0104406:	68 f5 8f 10 c0       	push   $0xc0108ff5
-c010440b:	68 4d 8d 10 c0       	push   $0xc0108d4d
-c0104410:	68 2c 02 00 00       	push   $0x22c
-c0104415:	68 28 8d 10 c0       	push   $0xc0108d28
-c010441a:	e8 c9 bf ff ff       	call   c01003e8 <__panic>
+c0104453:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0104456:	89 04 24             	mov    %eax,(%esp)
+c0104459:	e8 0a ed ff ff       	call   c0103168 <page_ref>
+c010445e:	85 c0                	test   %eax,%eax
+c0104460:	74 24                	je     c0104486 <check_pgdir+0x5f0>
+c0104462:	c7 44 24 0c 25 97 10 	movl   $0xc0109725,0xc(%esp)
+c0104469:	c0 
+c010446a:	c7 44 24 08 6d 94 10 	movl   $0xc010946d,0x8(%esp)
+c0104471:	c0 
+c0104472:	c7 44 24 04 2b 02 00 	movl   $0x22b,0x4(%esp)
+c0104479:	00 
+c010447a:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c0104481:	e8 72 bf ff ff       	call   c01003f8 <__panic>
     assert(page_ref(p2) == 0);
-c010441f:	83 ec 0c             	sub    $0xc,%esp
-c0104422:	ff 75 e4             	pushl  -0x1c(%ebp)
-c0104425:	e8 dc ee ff ff       	call   c0103306 <page_ref>
-c010442a:	83 c4 10             	add    $0x10,%esp
-c010442d:	85 c0                	test   %eax,%eax
-c010442f:	74 19                	je     c010444a <check_pgdir+0x4ea>
-c0104431:	68 ce 8f 10 c0       	push   $0xc0108fce
-c0104436:	68 4d 8d 10 c0       	push   $0xc0108d4d
-c010443b:	68 2d 02 00 00       	push   $0x22d
-c0104440:	68 28 8d 10 c0       	push   $0xc0108d28
-c0104445:	e8 9e bf ff ff       	call   c01003e8 <__panic>
+c0104486:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0104489:	89 04 24             	mov    %eax,(%esp)
+c010448c:	e8 d7 ec ff ff       	call   c0103168 <page_ref>
+c0104491:	85 c0                	test   %eax,%eax
+c0104493:	74 24                	je     c01044b9 <check_pgdir+0x623>
+c0104495:	c7 44 24 0c fe 96 10 	movl   $0xc01096fe,0xc(%esp)
+c010449c:	c0 
+c010449d:	c7 44 24 08 6d 94 10 	movl   $0xc010946d,0x8(%esp)
+c01044a4:	c0 
+c01044a5:	c7 44 24 04 2c 02 00 	movl   $0x22c,0x4(%esp)
+c01044ac:	00 
+c01044ad:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c01044b4:	e8 3f bf ff ff       	call   c01003f8 <__panic>
 
     assert(page_ref(pde2page(boot_pgdir[0])) == 1);
-c010444a:	a1 e0 f9 11 c0       	mov    0xc011f9e0,%eax
-c010444f:	8b 00                	mov    (%eax),%eax
-c0104451:	83 ec 0c             	sub    $0xc,%esp
-c0104454:	50                   	push   %eax
-c0104455:	e8 90 ee ff ff       	call   c01032ea <pde2page>
-c010445a:	83 c4 10             	add    $0x10,%esp
-c010445d:	83 ec 0c             	sub    $0xc,%esp
-c0104460:	50                   	push   %eax
-c0104461:	e8 a0 ee ff ff       	call   c0103306 <page_ref>
-c0104466:	83 c4 10             	add    $0x10,%esp
-c0104469:	83 f8 01             	cmp    $0x1,%eax
-c010446c:	74 19                	je     c0104487 <check_pgdir+0x527>
-c010446e:	68 08 90 10 c0       	push   $0xc0109008
-c0104473:	68 4d 8d 10 c0       	push   $0xc0108d4d
-c0104478:	68 2f 02 00 00       	push   $0x22f
-c010447d:	68 28 8d 10 c0       	push   $0xc0108d28
-c0104482:	e8 61 bf ff ff       	call   c01003e8 <__panic>
+c01044b9:	a1 e0 09 12 c0       	mov    0xc01209e0,%eax
+c01044be:	8b 00                	mov    (%eax),%eax
+c01044c0:	89 04 24             	mov    %eax,(%esp)
+c01044c3:	e8 88 ec ff ff       	call   c0103150 <pde2page>
+c01044c8:	89 04 24             	mov    %eax,(%esp)
+c01044cb:	e8 98 ec ff ff       	call   c0103168 <page_ref>
+c01044d0:	83 f8 01             	cmp    $0x1,%eax
+c01044d3:	74 24                	je     c01044f9 <check_pgdir+0x663>
+c01044d5:	c7 44 24 0c 38 97 10 	movl   $0xc0109738,0xc(%esp)
+c01044dc:	c0 
+c01044dd:	c7 44 24 08 6d 94 10 	movl   $0xc010946d,0x8(%esp)
+c01044e4:	c0 
+c01044e5:	c7 44 24 04 2e 02 00 	movl   $0x22e,0x4(%esp)
+c01044ec:	00 
+c01044ed:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c01044f4:	e8 ff be ff ff       	call   c01003f8 <__panic>
     free_page(pde2page(boot_pgdir[0]));
-c0104487:	a1 e0 f9 11 c0       	mov    0xc011f9e0,%eax
-c010448c:	8b 00                	mov    (%eax),%eax
-c010448e:	83 ec 0c             	sub    $0xc,%esp
-c0104491:	50                   	push   %eax
-c0104492:	e8 53 ee ff ff       	call   c01032ea <pde2page>
-c0104497:	83 c4 10             	add    $0x10,%esp
-c010449a:	83 ec 08             	sub    $0x8,%esp
-c010449d:	6a 01                	push   $0x1
-c010449f:	50                   	push   %eax
-c01044a0:	e8 db f0 ff ff       	call   c0103580 <free_pages>
-c01044a5:	83 c4 10             	add    $0x10,%esp
+c01044f9:	a1 e0 09 12 c0       	mov    0xc01209e0,%eax
+c01044fe:	8b 00                	mov    (%eax),%eax
+c0104500:	89 04 24             	mov    %eax,(%esp)
+c0104503:	e8 48 ec ff ff       	call   c0103150 <pde2page>
+c0104508:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+c010450f:	00 
+c0104510:	89 04 24             	mov    %eax,(%esp)
+c0104513:	e8 c0 ee ff ff       	call   c01033d8 <free_pages>
     boot_pgdir[0] = 0;
-c01044a8:	a1 e0 f9 11 c0       	mov    0xc011f9e0,%eax
-c01044ad:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+c0104518:	a1 e0 09 12 c0       	mov    0xc01209e0,%eax
+c010451d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
 
     cprintf("check_pgdir() succeeded!\n");
-c01044b3:	83 ec 0c             	sub    $0xc,%esp
-c01044b6:	68 2f 90 10 c0       	push   $0xc010902f
-c01044bb:	e8 c2 bd ff ff       	call   c0100282 <cprintf>
-c01044c0:	83 c4 10             	add    $0x10,%esp
-}
-c01044c3:	90                   	nop
-c01044c4:	c9                   	leave  
-c01044c5:	c3                   	ret    
+c0104523:	c7 04 24 5f 97 10 c0 	movl   $0xc010975f,(%esp)
+c010452a:	e8 72 bd ff ff       	call   c01002a1 <cprintf>
+}
+c010452f:	90                   	nop
+c0104530:	c9                   	leave  
+c0104531:	c3                   	ret    
 
-c01044c6 <check_boot_pgdir>:
+c0104532 <check_boot_pgdir>:
 
 static void
 check_boot_pgdir(void) {
-c01044c6:	55                   	push   %ebp
-c01044c7:	89 e5                	mov    %esp,%ebp
-c01044c9:	83 ec 28             	sub    $0x28,%esp
+c0104532:	55                   	push   %ebp
+c0104533:	89 e5                	mov    %esp,%ebp
+c0104535:	83 ec 38             	sub    $0x38,%esp
     pte_t *ptep;
     int i;
     for (i = 0; i < npage; i += PGSIZE) {
-c01044cc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
-c01044d3:	e9 a3 00 00 00       	jmp    c010457b <check_boot_pgdir+0xb5>
+c0104538:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+c010453f:	e9 ca 00 00 00       	jmp    c010460e <check_boot_pgdir+0xdc>
         assert((ptep = get_pte(boot_pgdir, (uintptr_t)KADDR(i), 0)) != NULL);
-c01044d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c01044db:	89 45 f0             	mov    %eax,-0x10(%ebp)
-c01044de:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c01044e1:	c1 e8 0c             	shr    $0xc,%eax
-c01044e4:	89 45 ec             	mov    %eax,-0x14(%ebp)
-c01044e7:	a1 80 2f 12 c0       	mov    0xc0122f80,%eax
-c01044ec:	39 45 ec             	cmp    %eax,-0x14(%ebp)
-c01044ef:	72 17                	jb     c0104508 <check_boot_pgdir+0x42>
-c01044f1:	ff 75 f0             	pushl  -0x10(%ebp)
-c01044f4:	68 60 8c 10 c0       	push   $0xc0108c60
-c01044f9:	68 3b 02 00 00       	push   $0x23b
-c01044fe:	68 28 8d 10 c0       	push   $0xc0108d28
-c0104503:	e8 e0 be ff ff       	call   c01003e8 <__panic>
-c0104508:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c010450b:	2d 00 00 00 40       	sub    $0x40000000,%eax
-c0104510:	89 c2                	mov    %eax,%edx
-c0104512:	a1 e0 f9 11 c0       	mov    0xc011f9e0,%eax
-c0104517:	83 ec 04             	sub    $0x4,%esp
-c010451a:	6a 00                	push   $0x0
-c010451c:	52                   	push   %edx
-c010451d:	50                   	push   %eax
-c010451e:	e8 58 f6 ff ff       	call   c0103b7b <get_pte>
-c0104523:	83 c4 10             	add    $0x10,%esp
-c0104526:	89 45 e8             	mov    %eax,-0x18(%ebp)
-c0104529:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
-c010452d:	75 19                	jne    c0104548 <check_boot_pgdir+0x82>
-c010452f:	68 4c 90 10 c0       	push   $0xc010904c
-c0104534:	68 4d 8d 10 c0       	push   $0xc0108d4d
-c0104539:	68 3b 02 00 00       	push   $0x23b
-c010453e:	68 28 8d 10 c0       	push   $0xc0108d28
-c0104543:	e8 a0 be ff ff       	call   c01003e8 <__panic>
+c0104544:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0104547:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c010454a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010454d:	c1 e8 0c             	shr    $0xc,%eax
+c0104550:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c0104553:	a1 80 3f 12 c0       	mov    0xc0123f80,%eax
+c0104558:	39 45 ec             	cmp    %eax,-0x14(%ebp)
+c010455b:	72 23                	jb     c0104580 <check_boot_pgdir+0x4e>
+c010455d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0104560:	89 44 24 0c          	mov    %eax,0xc(%esp)
+c0104564:	c7 44 24 08 80 93 10 	movl   $0xc0109380,0x8(%esp)
+c010456b:	c0 
+c010456c:	c7 44 24 04 3a 02 00 	movl   $0x23a,0x4(%esp)
+c0104573:	00 
+c0104574:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c010457b:	e8 78 be ff ff       	call   c01003f8 <__panic>
+c0104580:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0104583:	2d 00 00 00 40       	sub    $0x40000000,%eax
+c0104588:	89 c2                	mov    %eax,%edx
+c010458a:	a1 e0 09 12 c0       	mov    0xc01209e0,%eax
+c010458f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+c0104596:	00 
+c0104597:	89 54 24 04          	mov    %edx,0x4(%esp)
+c010459b:	89 04 24             	mov    %eax,(%esp)
+c010459e:	e8 97 f4 ff ff       	call   c0103a3a <get_pte>
+c01045a3:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c01045a6:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+c01045aa:	75 24                	jne    c01045d0 <check_boot_pgdir+0x9e>
+c01045ac:	c7 44 24 0c 7c 97 10 	movl   $0xc010977c,0xc(%esp)
+c01045b3:	c0 
+c01045b4:	c7 44 24 08 6d 94 10 	movl   $0xc010946d,0x8(%esp)
+c01045bb:	c0 
+c01045bc:	c7 44 24 04 3a 02 00 	movl   $0x23a,0x4(%esp)
+c01045c3:	00 
+c01045c4:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c01045cb:	e8 28 be ff ff       	call   c01003f8 <__panic>
         assert(PTE_ADDR(*ptep) == i);
-c0104548:	8b 45 e8             	mov    -0x18(%ebp),%eax
-c010454b:	8b 00                	mov    (%eax),%eax
-c010454d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
-c0104552:	89 c2                	mov    %eax,%edx
-c0104554:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0104557:	39 c2                	cmp    %eax,%edx
-c0104559:	74 19                	je     c0104574 <check_boot_pgdir+0xae>
-c010455b:	68 89 90 10 c0       	push   $0xc0109089
-c0104560:	68 4d 8d 10 c0       	push   $0xc0108d4d
-c0104565:	68 3c 02 00 00       	push   $0x23c
-c010456a:	68 28 8d 10 c0       	push   $0xc0108d28
-c010456f:	e8 74 be ff ff       	call   c01003e8 <__panic>
+c01045d0:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c01045d3:	8b 00                	mov    (%eax),%eax
+c01045d5:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+c01045da:	89 c2                	mov    %eax,%edx
+c01045dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01045df:	39 c2                	cmp    %eax,%edx
+c01045e1:	74 24                	je     c0104607 <check_boot_pgdir+0xd5>
+c01045e3:	c7 44 24 0c b9 97 10 	movl   $0xc01097b9,0xc(%esp)
+c01045ea:	c0 
+c01045eb:	c7 44 24 08 6d 94 10 	movl   $0xc010946d,0x8(%esp)
+c01045f2:	c0 
+c01045f3:	c7 44 24 04 3b 02 00 	movl   $0x23b,0x4(%esp)
+c01045fa:	00 
+c01045fb:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c0104602:	e8 f1 bd ff ff       	call   c01003f8 <__panic>
 
 static void
 check_boot_pgdir(void) {
     pte_t *ptep;
     int i;
     for (i = 0; i < npage; i += PGSIZE) {
-c0104574:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
-c010457b:	8b 55 f4             	mov    -0xc(%ebp),%edx
-c010457e:	a1 80 2f 12 c0       	mov    0xc0122f80,%eax
-c0104583:	39 c2                	cmp    %eax,%edx
-c0104585:	0f 82 4d ff ff ff    	jb     c01044d8 <check_boot_pgdir+0x12>
+c0104607:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
+c010460e:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0104611:	a1 80 3f 12 c0       	mov    0xc0123f80,%eax
+c0104616:	39 c2                	cmp    %eax,%edx
+c0104618:	0f 82 26 ff ff ff    	jb     c0104544 <check_boot_pgdir+0x12>
         assert((ptep = get_pte(boot_pgdir, (uintptr_t)KADDR(i), 0)) != NULL);
         assert(PTE_ADDR(*ptep) == i);
     }
 
     assert(PDE_ADDR(boot_pgdir[PDX(VPT)]) == PADDR(boot_pgdir));
-c010458b:	a1 e0 f9 11 c0       	mov    0xc011f9e0,%eax
-c0104590:	05 ac 0f 00 00       	add    $0xfac,%eax
-c0104595:	8b 00                	mov    (%eax),%eax
-c0104597:	25 00 f0 ff ff       	and    $0xfffff000,%eax
-c010459c:	89 c2                	mov    %eax,%edx
-c010459e:	a1 e0 f9 11 c0       	mov    0xc011f9e0,%eax
-c01045a3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
-c01045a6:	81 7d e4 ff ff ff bf 	cmpl   $0xbfffffff,-0x1c(%ebp)
-c01045ad:	77 17                	ja     c01045c6 <check_boot_pgdir+0x100>
-c01045af:	ff 75 e4             	pushl  -0x1c(%ebp)
-c01045b2:	68 84 8c 10 c0       	push   $0xc0108c84
-c01045b7:	68 3f 02 00 00       	push   $0x23f
-c01045bc:	68 28 8d 10 c0       	push   $0xc0108d28
-c01045c1:	e8 22 be ff ff       	call   c01003e8 <__panic>
-c01045c6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-c01045c9:	05 00 00 00 40       	add    $0x40000000,%eax
-c01045ce:	39 c2                	cmp    %eax,%edx
-c01045d0:	74 19                	je     c01045eb <check_boot_pgdir+0x125>
-c01045d2:	68 a0 90 10 c0       	push   $0xc01090a0
-c01045d7:	68 4d 8d 10 c0       	push   $0xc0108d4d
-c01045dc:	68 3f 02 00 00       	push   $0x23f
-c01045e1:	68 28 8d 10 c0       	push   $0xc0108d28
-c01045e6:	e8 fd bd ff ff       	call   c01003e8 <__panic>
+c010461e:	a1 e0 09 12 c0       	mov    0xc01209e0,%eax
+c0104623:	05 ac 0f 00 00       	add    $0xfac,%eax
+c0104628:	8b 00                	mov    (%eax),%eax
+c010462a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+c010462f:	89 c2                	mov    %eax,%edx
+c0104631:	a1 e0 09 12 c0       	mov    0xc01209e0,%eax
+c0104636:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+c0104639:	81 7d e4 ff ff ff bf 	cmpl   $0xbfffffff,-0x1c(%ebp)
+c0104640:	77 23                	ja     c0104665 <check_boot_pgdir+0x133>
+c0104642:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0104645:	89 44 24 0c          	mov    %eax,0xc(%esp)
+c0104649:	c7 44 24 08 a4 93 10 	movl   $0xc01093a4,0x8(%esp)
+c0104650:	c0 
+c0104651:	c7 44 24 04 3e 02 00 	movl   $0x23e,0x4(%esp)
+c0104658:	00 
+c0104659:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c0104660:	e8 93 bd ff ff       	call   c01003f8 <__panic>
+c0104665:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0104668:	05 00 00 00 40       	add    $0x40000000,%eax
+c010466d:	39 c2                	cmp    %eax,%edx
+c010466f:	74 24                	je     c0104695 <check_boot_pgdir+0x163>
+c0104671:	c7 44 24 0c d0 97 10 	movl   $0xc01097d0,0xc(%esp)
+c0104678:	c0 
+c0104679:	c7 44 24 08 6d 94 10 	movl   $0xc010946d,0x8(%esp)
+c0104680:	c0 
+c0104681:	c7 44 24 04 3e 02 00 	movl   $0x23e,0x4(%esp)
+c0104688:	00 
+c0104689:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c0104690:	e8 63 bd ff ff       	call   c01003f8 <__panic>
 
     assert(boot_pgdir[0] == 0);
-c01045eb:	a1 e0 f9 11 c0       	mov    0xc011f9e0,%eax
-c01045f0:	8b 00                	mov    (%eax),%eax
-c01045f2:	85 c0                	test   %eax,%eax
-c01045f4:	74 19                	je     c010460f <check_boot_pgdir+0x149>
-c01045f6:	68 d4 90 10 c0       	push   $0xc01090d4
-c01045fb:	68 4d 8d 10 c0       	push   $0xc0108d4d
-c0104600:	68 41 02 00 00       	push   $0x241
-c0104605:	68 28 8d 10 c0       	push   $0xc0108d28
-c010460a:	e8 d9 bd ff ff       	call   c01003e8 <__panic>
+c0104695:	a1 e0 09 12 c0       	mov    0xc01209e0,%eax
+c010469a:	8b 00                	mov    (%eax),%eax
+c010469c:	85 c0                	test   %eax,%eax
+c010469e:	74 24                	je     c01046c4 <check_boot_pgdir+0x192>
+c01046a0:	c7 44 24 0c 04 98 10 	movl   $0xc0109804,0xc(%esp)
+c01046a7:	c0 
+c01046a8:	c7 44 24 08 6d 94 10 	movl   $0xc010946d,0x8(%esp)
+c01046af:	c0 
+c01046b0:	c7 44 24 04 40 02 00 	movl   $0x240,0x4(%esp)
+c01046b7:	00 
+c01046b8:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c01046bf:	e8 34 bd ff ff       	call   c01003f8 <__panic>
 
     struct Page *p;
     p = alloc_page();
-c010460f:	83 ec 0c             	sub    $0xc,%esp
-c0104612:	6a 01                	push   $0x1
-c0104614:	e8 fb ee ff ff       	call   c0103514 <alloc_pages>
-c0104619:	83 c4 10             	add    $0x10,%esp
-c010461c:	89 45 e0             	mov    %eax,-0x20(%ebp)
+c01046c4:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c01046cb:	e8 9d ec ff ff       	call   c010336d <alloc_pages>
+c01046d0:	89 45 e0             	mov    %eax,-0x20(%ebp)
     assert(page_insert(boot_pgdir, p, 0x100, PTE_W) == 0);
-c010461f:	a1 e0 f9 11 c0       	mov    0xc011f9e0,%eax
-c0104624:	6a 02                	push   $0x2
-c0104626:	68 00 01 00 00       	push   $0x100
-c010462b:	ff 75 e0             	pushl  -0x20(%ebp)
-c010462e:	50                   	push   %eax
-c010462f:	e8 58 f7 ff ff       	call   c0103d8c <page_insert>
-c0104634:	83 c4 10             	add    $0x10,%esp
-c0104637:	85 c0                	test   %eax,%eax
-c0104639:	74 19                	je     c0104654 <check_boot_pgdir+0x18e>
-c010463b:	68 e8 90 10 c0       	push   $0xc01090e8
-c0104640:	68 4d 8d 10 c0       	push   $0xc0108d4d
-c0104645:	68 45 02 00 00       	push   $0x245
-c010464a:	68 28 8d 10 c0       	push   $0xc0108d28
-c010464f:	e8 94 bd ff ff       	call   c01003e8 <__panic>
+c01046d3:	a1 e0 09 12 c0       	mov    0xc01209e0,%eax
+c01046d8:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
+c01046df:	00 
+c01046e0:	c7 44 24 08 00 01 00 	movl   $0x100,0x8(%esp)
+c01046e7:	00 
+c01046e8:	8b 55 e0             	mov    -0x20(%ebp),%edx
+c01046eb:	89 54 24 04          	mov    %edx,0x4(%esp)
+c01046ef:	89 04 24             	mov    %eax,(%esp)
+c01046f2:	e8 a0 f5 ff ff       	call   c0103c97 <page_insert>
+c01046f7:	85 c0                	test   %eax,%eax
+c01046f9:	74 24                	je     c010471f <check_boot_pgdir+0x1ed>
+c01046fb:	c7 44 24 0c 18 98 10 	movl   $0xc0109818,0xc(%esp)
+c0104702:	c0 
+c0104703:	c7 44 24 08 6d 94 10 	movl   $0xc010946d,0x8(%esp)
+c010470a:	c0 
+c010470b:	c7 44 24 04 44 02 00 	movl   $0x244,0x4(%esp)
+c0104712:	00 
+c0104713:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c010471a:	e8 d9 bc ff ff       	call   c01003f8 <__panic>
     assert(page_ref(p) == 1);
-c0104654:	83 ec 0c             	sub    $0xc,%esp
-c0104657:	ff 75 e0             	pushl  -0x20(%ebp)
-c010465a:	e8 a7 ec ff ff       	call   c0103306 <page_ref>
-c010465f:	83 c4 10             	add    $0x10,%esp
-c0104662:	83 f8 01             	cmp    $0x1,%eax
-c0104665:	74 19                	je     c0104680 <check_boot_pgdir+0x1ba>
-c0104667:	68 16 91 10 c0       	push   $0xc0109116
-c010466c:	68 4d 8d 10 c0       	push   $0xc0108d4d
-c0104671:	68 46 02 00 00       	push   $0x246
-c0104676:	68 28 8d 10 c0       	push   $0xc0108d28
-c010467b:	e8 68 bd ff ff       	call   c01003e8 <__panic>
+c010471f:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0104722:	89 04 24             	mov    %eax,(%esp)
+c0104725:	e8 3e ea ff ff       	call   c0103168 <page_ref>
+c010472a:	83 f8 01             	cmp    $0x1,%eax
+c010472d:	74 24                	je     c0104753 <check_boot_pgdir+0x221>
+c010472f:	c7 44 24 0c 46 98 10 	movl   $0xc0109846,0xc(%esp)
+c0104736:	c0 
+c0104737:	c7 44 24 08 6d 94 10 	movl   $0xc010946d,0x8(%esp)
+c010473e:	c0 
+c010473f:	c7 44 24 04 45 02 00 	movl   $0x245,0x4(%esp)
+c0104746:	00 
+c0104747:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c010474e:	e8 a5 bc ff ff       	call   c01003f8 <__panic>
     assert(page_insert(boot_pgdir, p, 0x100 + PGSIZE, PTE_W) == 0);
-c0104680:	a1 e0 f9 11 c0       	mov    0xc011f9e0,%eax
-c0104685:	6a 02                	push   $0x2
-c0104687:	68 00 11 00 00       	push   $0x1100
-c010468c:	ff 75 e0             	pushl  -0x20(%ebp)
-c010468f:	50                   	push   %eax
-c0104690:	e8 f7 f6 ff ff       	call   c0103d8c <page_insert>
-c0104695:	83 c4 10             	add    $0x10,%esp
-c0104698:	85 c0                	test   %eax,%eax
-c010469a:	74 19                	je     c01046b5 <check_boot_pgdir+0x1ef>
-c010469c:	68 28 91 10 c0       	push   $0xc0109128
-c01046a1:	68 4d 8d 10 c0       	push   $0xc0108d4d
-c01046a6:	68 47 02 00 00       	push   $0x247
-c01046ab:	68 28 8d 10 c0       	push   $0xc0108d28
-c01046b0:	e8 33 bd ff ff       	call   c01003e8 <__panic>
+c0104753:	a1 e0 09 12 c0       	mov    0xc01209e0,%eax
+c0104758:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
+c010475f:	00 
+c0104760:	c7 44 24 08 00 11 00 	movl   $0x1100,0x8(%esp)
+c0104767:	00 
+c0104768:	8b 55 e0             	mov    -0x20(%ebp),%edx
+c010476b:	89 54 24 04          	mov    %edx,0x4(%esp)
+c010476f:	89 04 24             	mov    %eax,(%esp)
+c0104772:	e8 20 f5 ff ff       	call   c0103c97 <page_insert>
+c0104777:	85 c0                	test   %eax,%eax
+c0104779:	74 24                	je     c010479f <check_boot_pgdir+0x26d>
+c010477b:	c7 44 24 0c 58 98 10 	movl   $0xc0109858,0xc(%esp)
+c0104782:	c0 
+c0104783:	c7 44 24 08 6d 94 10 	movl   $0xc010946d,0x8(%esp)
+c010478a:	c0 
+c010478b:	c7 44 24 04 46 02 00 	movl   $0x246,0x4(%esp)
+c0104792:	00 
+c0104793:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c010479a:	e8 59 bc ff ff       	call   c01003f8 <__panic>
     assert(page_ref(p) == 2);
-c01046b5:	83 ec 0c             	sub    $0xc,%esp
-c01046b8:	ff 75 e0             	pushl  -0x20(%ebp)
-c01046bb:	e8 46 ec ff ff       	call   c0103306 <page_ref>
-c01046c0:	83 c4 10             	add    $0x10,%esp
-c01046c3:	83 f8 02             	cmp    $0x2,%eax
-c01046c6:	74 19                	je     c01046e1 <check_boot_pgdir+0x21b>
-c01046c8:	68 5f 91 10 c0       	push   $0xc010915f
-c01046cd:	68 4d 8d 10 c0       	push   $0xc0108d4d
-c01046d2:	68 48 02 00 00       	push   $0x248
-c01046d7:	68 28 8d 10 c0       	push   $0xc0108d28
-c01046dc:	e8 07 bd ff ff       	call   c01003e8 <__panic>
+c010479f:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c01047a2:	89 04 24             	mov    %eax,(%esp)
+c01047a5:	e8 be e9 ff ff       	call   c0103168 <page_ref>
+c01047aa:	83 f8 02             	cmp    $0x2,%eax
+c01047ad:	74 24                	je     c01047d3 <check_boot_pgdir+0x2a1>
+c01047af:	c7 44 24 0c 8f 98 10 	movl   $0xc010988f,0xc(%esp)
+c01047b6:	c0 
+c01047b7:	c7 44 24 08 6d 94 10 	movl   $0xc010946d,0x8(%esp)
+c01047be:	c0 
+c01047bf:	c7 44 24 04 47 02 00 	movl   $0x247,0x4(%esp)
+c01047c6:	00 
+c01047c7:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c01047ce:	e8 25 bc ff ff       	call   c01003f8 <__panic>
 
     const char *str = "ucore: Hello world!!";
-c01046e1:	c7 45 dc 70 91 10 c0 	movl   $0xc0109170,-0x24(%ebp)
+c01047d3:	c7 45 dc a0 98 10 c0 	movl   $0xc01098a0,-0x24(%ebp)
     strcpy((void *)0x100, str);
-c01046e8:	83 ec 08             	sub    $0x8,%esp
-c01046eb:	ff 75 dc             	pushl  -0x24(%ebp)
-c01046ee:	68 00 01 00 00       	push   $0x100
-c01046f3:	e8 37 31 00 00       	call   c010782f <strcpy>
-c01046f8:	83 c4 10             	add    $0x10,%esp
+c01047da:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c01047dd:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01047e1:	c7 04 24 00 01 00 00 	movl   $0x100,(%esp)
+c01047e8:	e8 29 37 00 00       	call   c0107f16 <strcpy>
     assert(strcmp((void *)0x100, (void *)(0x100 + PGSIZE)) == 0);
-c01046fb:	83 ec 08             	sub    $0x8,%esp
-c01046fe:	68 00 11 00 00       	push   $0x1100
-c0104703:	68 00 01 00 00       	push   $0x100
-c0104708:	e8 9c 31 00 00       	call   c01078a9 <strcmp>
-c010470d:	83 c4 10             	add    $0x10,%esp
-c0104710:	85 c0                	test   %eax,%eax
-c0104712:	74 19                	je     c010472d <check_boot_pgdir+0x267>
-c0104714:	68 88 91 10 c0       	push   $0xc0109188
-c0104719:	68 4d 8d 10 c0       	push   $0xc0108d4d
-c010471e:	68 4c 02 00 00       	push   $0x24c
-c0104723:	68 28 8d 10 c0       	push   $0xc0108d28
-c0104728:	e8 bb bc ff ff       	call   c01003e8 <__panic>
+c01047ed:	c7 44 24 04 00 11 00 	movl   $0x1100,0x4(%esp)
+c01047f4:	00 
+c01047f5:	c7 04 24 00 01 00 00 	movl   $0x100,(%esp)
+c01047fc:	e8 8c 37 00 00       	call   c0107f8d <strcmp>
+c0104801:	85 c0                	test   %eax,%eax
+c0104803:	74 24                	je     c0104829 <check_boot_pgdir+0x2f7>
+c0104805:	c7 44 24 0c b8 98 10 	movl   $0xc01098b8,0xc(%esp)
+c010480c:	c0 
+c010480d:	c7 44 24 08 6d 94 10 	movl   $0xc010946d,0x8(%esp)
+c0104814:	c0 
+c0104815:	c7 44 24 04 4b 02 00 	movl   $0x24b,0x4(%esp)
+c010481c:	00 
+c010481d:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c0104824:	e8 cf bb ff ff       	call   c01003f8 <__panic>
 
     *(char *)(page2kva(p) + 0x100) = '\0';
-c010472d:	83 ec 0c             	sub    $0xc,%esp
-c0104730:	ff 75 e0             	pushl  -0x20(%ebp)
-c0104733:	e8 f4 ea ff ff       	call   c010322c <page2kva>
-c0104738:	83 c4 10             	add    $0x10,%esp
-c010473b:	05 00 01 00 00       	add    $0x100,%eax
-c0104740:	c6 00 00             	movb   $0x0,(%eax)
+c0104829:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c010482c:	89 04 24             	mov    %eax,(%esp)
+c010482f:	e8 40 e8 ff ff       	call   c0103074 <page2kva>
+c0104834:	05 00 01 00 00       	add    $0x100,%eax
+c0104839:	c6 00 00             	movb   $0x0,(%eax)
     assert(strlen((const char *)0x100) == 0);
-c0104743:	83 ec 0c             	sub    $0xc,%esp
-c0104746:	68 00 01 00 00       	push   $0x100
-c010474b:	e8 87 30 00 00       	call   c01077d7 <strlen>
-c0104750:	83 c4 10             	add    $0x10,%esp
-c0104753:	85 c0                	test   %eax,%eax
-c0104755:	74 19                	je     c0104770 <check_boot_pgdir+0x2aa>
-c0104757:	68 c0 91 10 c0       	push   $0xc01091c0
-c010475c:	68 4d 8d 10 c0       	push   $0xc0108d4d
-c0104761:	68 4f 02 00 00       	push   $0x24f
-c0104766:	68 28 8d 10 c0       	push   $0xc0108d28
-c010476b:	e8 78 bc ff ff       	call   c01003e8 <__panic>
+c010483c:	c7 04 24 00 01 00 00 	movl   $0x100,(%esp)
+c0104843:	e8 78 36 00 00       	call   c0107ec0 <strlen>
+c0104848:	85 c0                	test   %eax,%eax
+c010484a:	74 24                	je     c0104870 <check_boot_pgdir+0x33e>
+c010484c:	c7 44 24 0c f0 98 10 	movl   $0xc01098f0,0xc(%esp)
+c0104853:	c0 
+c0104854:	c7 44 24 08 6d 94 10 	movl   $0xc010946d,0x8(%esp)
+c010485b:	c0 
+c010485c:	c7 44 24 04 4e 02 00 	movl   $0x24e,0x4(%esp)
+c0104863:	00 
+c0104864:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c010486b:	e8 88 bb ff ff       	call   c01003f8 <__panic>
 
     free_page(p);
-c0104770:	83 ec 08             	sub    $0x8,%esp
-c0104773:	6a 01                	push   $0x1
-c0104775:	ff 75 e0             	pushl  -0x20(%ebp)
-c0104778:	e8 03 ee ff ff       	call   c0103580 <free_pages>
-c010477d:	83 c4 10             	add    $0x10,%esp
+c0104870:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+c0104877:	00 
+c0104878:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c010487b:	89 04 24             	mov    %eax,(%esp)
+c010487e:	e8 55 eb ff ff       	call   c01033d8 <free_pages>
     free_page(pde2page(boot_pgdir[0]));
-c0104780:	a1 e0 f9 11 c0       	mov    0xc011f9e0,%eax
-c0104785:	8b 00                	mov    (%eax),%eax
-c0104787:	83 ec 0c             	sub    $0xc,%esp
-c010478a:	50                   	push   %eax
-c010478b:	e8 5a eb ff ff       	call   c01032ea <pde2page>
-c0104790:	83 c4 10             	add    $0x10,%esp
-c0104793:	83 ec 08             	sub    $0x8,%esp
-c0104796:	6a 01                	push   $0x1
-c0104798:	50                   	push   %eax
-c0104799:	e8 e2 ed ff ff       	call   c0103580 <free_pages>
-c010479e:	83 c4 10             	add    $0x10,%esp
+c0104883:	a1 e0 09 12 c0       	mov    0xc01209e0,%eax
+c0104888:	8b 00                	mov    (%eax),%eax
+c010488a:	89 04 24             	mov    %eax,(%esp)
+c010488d:	e8 be e8 ff ff       	call   c0103150 <pde2page>
+c0104892:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+c0104899:	00 
+c010489a:	89 04 24             	mov    %eax,(%esp)
+c010489d:	e8 36 eb ff ff       	call   c01033d8 <free_pages>
     boot_pgdir[0] = 0;
-c01047a1:	a1 e0 f9 11 c0       	mov    0xc011f9e0,%eax
-c01047a6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+c01048a2:	a1 e0 09 12 c0       	mov    0xc01209e0,%eax
+c01048a7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
 
     cprintf("check_boot_pgdir() succeeded!\n");
-c01047ac:	83 ec 0c             	sub    $0xc,%esp
-c01047af:	68 e4 91 10 c0       	push   $0xc01091e4
-c01047b4:	e8 c9 ba ff ff       	call   c0100282 <cprintf>
-c01047b9:	83 c4 10             	add    $0x10,%esp
-}
-c01047bc:	90                   	nop
-c01047bd:	c9                   	leave  
-c01047be:	c3                   	ret    
+c01048ad:	c7 04 24 14 99 10 c0 	movl   $0xc0109914,(%esp)
+c01048b4:	e8 e8 b9 ff ff       	call   c01002a1 <cprintf>
+}
+c01048b9:	90                   	nop
+c01048ba:	c9                   	leave  
+c01048bb:	c3                   	ret    
 
-c01047bf <perm2str>:
+c01048bc <perm2str>:
 
 //perm2str - use string 'u,r,w,-' to present the permission
 static const char *
 perm2str(int perm) {
-c01047bf:	55                   	push   %ebp
-c01047c0:	89 e5                	mov    %esp,%ebp
+c01048bc:	55                   	push   %ebp
+c01048bd:	89 e5                	mov    %esp,%ebp
     static char str[4];
     str[0] = (perm & PTE_U) ? 'u' : '-';
-c01047c2:	8b 45 08             	mov    0x8(%ebp),%eax
-c01047c5:	83 e0 04             	and    $0x4,%eax
-c01047c8:	85 c0                	test   %eax,%eax
-c01047ca:	74 07                	je     c01047d3 <perm2str+0x14>
-c01047cc:	b8 75 00 00 00       	mov    $0x75,%eax
-c01047d1:	eb 05                	jmp    c01047d8 <perm2str+0x19>
-c01047d3:	b8 2d 00 00 00       	mov    $0x2d,%eax
-c01047d8:	a2 08 30 12 c0       	mov    %al,0xc0123008
+c01048bf:	8b 45 08             	mov    0x8(%ebp),%eax
+c01048c2:	83 e0 04             	and    $0x4,%eax
+c01048c5:	85 c0                	test   %eax,%eax
+c01048c7:	74 04                	je     c01048cd <perm2str+0x11>
+c01048c9:	b0 75                	mov    $0x75,%al
+c01048cb:	eb 02                	jmp    c01048cf <perm2str+0x13>
+c01048cd:	b0 2d                	mov    $0x2d,%al
+c01048cf:	a2 08 40 12 c0       	mov    %al,0xc0124008
     str[1] = 'r';
-c01047dd:	c6 05 09 30 12 c0 72 	movb   $0x72,0xc0123009
+c01048d4:	c6 05 09 40 12 c0 72 	movb   $0x72,0xc0124009
     str[2] = (perm & PTE_W) ? 'w' : '-';
-c01047e4:	8b 45 08             	mov    0x8(%ebp),%eax
-c01047e7:	83 e0 02             	and    $0x2,%eax
-c01047ea:	85 c0                	test   %eax,%eax
-c01047ec:	74 07                	je     c01047f5 <perm2str+0x36>
-c01047ee:	b8 77 00 00 00       	mov    $0x77,%eax
-c01047f3:	eb 05                	jmp    c01047fa <perm2str+0x3b>
-c01047f5:	b8 2d 00 00 00       	mov    $0x2d,%eax
-c01047fa:	a2 0a 30 12 c0       	mov    %al,0xc012300a
+c01048db:	8b 45 08             	mov    0x8(%ebp),%eax
+c01048de:	83 e0 02             	and    $0x2,%eax
+c01048e1:	85 c0                	test   %eax,%eax
+c01048e3:	74 04                	je     c01048e9 <perm2str+0x2d>
+c01048e5:	b0 77                	mov    $0x77,%al
+c01048e7:	eb 02                	jmp    c01048eb <perm2str+0x2f>
+c01048e9:	b0 2d                	mov    $0x2d,%al
+c01048eb:	a2 0a 40 12 c0       	mov    %al,0xc012400a
     str[3] = '\0';
-c01047ff:	c6 05 0b 30 12 c0 00 	movb   $0x0,0xc012300b
+c01048f0:	c6 05 0b 40 12 c0 00 	movb   $0x0,0xc012400b
     return str;
-c0104806:	b8 08 30 12 c0       	mov    $0xc0123008,%eax
+c01048f7:	b8 08 40 12 c0       	mov    $0xc0124008,%eax
 }
-c010480b:	5d                   	pop    %ebp
-c010480c:	c3                   	ret    
+c01048fc:	5d                   	pop    %ebp
+c01048fd:	c3                   	ret    
 
-c010480d <get_pgtable_items>:
+c01048fe <get_pgtable_items>:
 //  table:       the beginning addr of table
 //  left_store:  the pointer of the high side of table's next range
 //  right_store: the pointer of the low side of table's next range
 // return value: 0 - not a invalid item range, perm - a valid item range with perm permission 
 static int
 get_pgtable_items(size_t left, size_t right, size_t start, uintptr_t *table, size_t *left_store, size_t *right_store) {
-c010480d:	55                   	push   %ebp
-c010480e:	89 e5                	mov    %esp,%ebp
-c0104810:	83 ec 10             	sub    $0x10,%esp
+c01048fe:	55                   	push   %ebp
+c01048ff:	89 e5                	mov    %esp,%ebp
+c0104901:	83 ec 10             	sub    $0x10,%esp
     if (start >= right) {
-c0104813:	8b 45 10             	mov    0x10(%ebp),%eax
-c0104816:	3b 45 0c             	cmp    0xc(%ebp),%eax
-c0104819:	72 0e                	jb     c0104829 <get_pgtable_items+0x1c>
+c0104904:	8b 45 10             	mov    0x10(%ebp),%eax
+c0104907:	3b 45 0c             	cmp    0xc(%ebp),%eax
+c010490a:	72 0d                	jb     c0104919 <get_pgtable_items+0x1b>
         return 0;
-c010481b:	b8 00 00 00 00       	mov    $0x0,%eax
-c0104820:	e9 9a 00 00 00       	jmp    c01048bf <get_pgtable_items+0xb2>
+c010490c:	b8 00 00 00 00       	mov    $0x0,%eax
+c0104911:	e9 98 00 00 00       	jmp    c01049ae <get_pgtable_items+0xb0>
     }
     while (start < right && !(table[start] & PTE_P)) {
         start ++;
-c0104825:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+c0104916:	ff 45 10             	incl   0x10(%ebp)
 static int
 get_pgtable_items(size_t left, size_t right, size_t start, uintptr_t *table, size_t *left_store, size_t *right_store) {
     if (start >= right) {
         return 0;
     }
     while (start < right && !(table[start] & PTE_P)) {
-c0104829:	8b 45 10             	mov    0x10(%ebp),%eax
-c010482c:	3b 45 0c             	cmp    0xc(%ebp),%eax
-c010482f:	73 18                	jae    c0104849 <get_pgtable_items+0x3c>
-c0104831:	8b 45 10             	mov    0x10(%ebp),%eax
-c0104834:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
-c010483b:	8b 45 14             	mov    0x14(%ebp),%eax
-c010483e:	01 d0                	add    %edx,%eax
-c0104840:	8b 00                	mov    (%eax),%eax
-c0104842:	83 e0 01             	and    $0x1,%eax
-c0104845:	85 c0                	test   %eax,%eax
-c0104847:	74 dc                	je     c0104825 <get_pgtable_items+0x18>
+c0104919:	8b 45 10             	mov    0x10(%ebp),%eax
+c010491c:	3b 45 0c             	cmp    0xc(%ebp),%eax
+c010491f:	73 18                	jae    c0104939 <get_pgtable_items+0x3b>
+c0104921:	8b 45 10             	mov    0x10(%ebp),%eax
+c0104924:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+c010492b:	8b 45 14             	mov    0x14(%ebp),%eax
+c010492e:	01 d0                	add    %edx,%eax
+c0104930:	8b 00                	mov    (%eax),%eax
+c0104932:	83 e0 01             	and    $0x1,%eax
+c0104935:	85 c0                	test   %eax,%eax
+c0104937:	74 dd                	je     c0104916 <get_pgtable_items+0x18>
         start ++;
     }
     if (start < right) {
-c0104849:	8b 45 10             	mov    0x10(%ebp),%eax
-c010484c:	3b 45 0c             	cmp    0xc(%ebp),%eax
-c010484f:	73 69                	jae    c01048ba <get_pgtable_items+0xad>
+c0104939:	8b 45 10             	mov    0x10(%ebp),%eax
+c010493c:	3b 45 0c             	cmp    0xc(%ebp),%eax
+c010493f:	73 68                	jae    c01049a9 <get_pgtable_items+0xab>
         if (left_store != NULL) {
-c0104851:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
-c0104855:	74 08                	je     c010485f <get_pgtable_items+0x52>
+c0104941:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
+c0104945:	74 08                	je     c010494f <get_pgtable_items+0x51>
             *left_store = start;
-c0104857:	8b 45 18             	mov    0x18(%ebp),%eax
-c010485a:	8b 55 10             	mov    0x10(%ebp),%edx
-c010485d:	89 10                	mov    %edx,(%eax)
+c0104947:	8b 45 18             	mov    0x18(%ebp),%eax
+c010494a:	8b 55 10             	mov    0x10(%ebp),%edx
+c010494d:	89 10                	mov    %edx,(%eax)
         }
         int perm = (table[start ++] & PTE_USER);
-c010485f:	8b 45 10             	mov    0x10(%ebp),%eax
-c0104862:	8d 50 01             	lea    0x1(%eax),%edx
-c0104865:	89 55 10             	mov    %edx,0x10(%ebp)
-c0104868:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
-c010486f:	8b 45 14             	mov    0x14(%ebp),%eax
-c0104872:	01 d0                	add    %edx,%eax
-c0104874:	8b 00                	mov    (%eax),%eax
-c0104876:	83 e0 07             	and    $0x7,%eax
-c0104879:	89 45 fc             	mov    %eax,-0x4(%ebp)
+c010494f:	8b 45 10             	mov    0x10(%ebp),%eax
+c0104952:	8d 50 01             	lea    0x1(%eax),%edx
+c0104955:	89 55 10             	mov    %edx,0x10(%ebp)
+c0104958:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+c010495f:	8b 45 14             	mov    0x14(%ebp),%eax
+c0104962:	01 d0                	add    %edx,%eax
+c0104964:	8b 00                	mov    (%eax),%eax
+c0104966:	83 e0 07             	and    $0x7,%eax
+c0104969:	89 45 fc             	mov    %eax,-0x4(%ebp)
         while (start < right && (table[start] & PTE_USER) == perm) {
-c010487c:	eb 04                	jmp    c0104882 <get_pgtable_items+0x75>
+c010496c:	eb 03                	jmp    c0104971 <get_pgtable_items+0x73>
             start ++;
-c010487e:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+c010496e:	ff 45 10             	incl   0x10(%ebp)
     if (start < right) {
         if (left_store != NULL) {
             *left_store = start;
         }
         int perm = (table[start ++] & PTE_USER);
         while (start < right && (table[start] & PTE_USER) == perm) {
-c0104882:	8b 45 10             	mov    0x10(%ebp),%eax
-c0104885:	3b 45 0c             	cmp    0xc(%ebp),%eax
-c0104888:	73 1d                	jae    c01048a7 <get_pgtable_items+0x9a>
-c010488a:	8b 45 10             	mov    0x10(%ebp),%eax
-c010488d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
-c0104894:	8b 45 14             	mov    0x14(%ebp),%eax
-c0104897:	01 d0                	add    %edx,%eax
-c0104899:	8b 00                	mov    (%eax),%eax
-c010489b:	83 e0 07             	and    $0x7,%eax
-c010489e:	89 c2                	mov    %eax,%edx
-c01048a0:	8b 45 fc             	mov    -0x4(%ebp),%eax
-c01048a3:	39 c2                	cmp    %eax,%edx
-c01048a5:	74 d7                	je     c010487e <get_pgtable_items+0x71>
+c0104971:	8b 45 10             	mov    0x10(%ebp),%eax
+c0104974:	3b 45 0c             	cmp    0xc(%ebp),%eax
+c0104977:	73 1d                	jae    c0104996 <get_pgtable_items+0x98>
+c0104979:	8b 45 10             	mov    0x10(%ebp),%eax
+c010497c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+c0104983:	8b 45 14             	mov    0x14(%ebp),%eax
+c0104986:	01 d0                	add    %edx,%eax
+c0104988:	8b 00                	mov    (%eax),%eax
+c010498a:	83 e0 07             	and    $0x7,%eax
+c010498d:	89 c2                	mov    %eax,%edx
+c010498f:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0104992:	39 c2                	cmp    %eax,%edx
+c0104994:	74 d8                	je     c010496e <get_pgtable_items+0x70>
             start ++;
         }
         if (right_store != NULL) {
-c01048a7:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
-c01048ab:	74 08                	je     c01048b5 <get_pgtable_items+0xa8>
+c0104996:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
+c010499a:	74 08                	je     c01049a4 <get_pgtable_items+0xa6>
             *right_store = start;
-c01048ad:	8b 45 1c             	mov    0x1c(%ebp),%eax
-c01048b0:	8b 55 10             	mov    0x10(%ebp),%edx
-c01048b3:	89 10                	mov    %edx,(%eax)
+c010499c:	8b 45 1c             	mov    0x1c(%ebp),%eax
+c010499f:	8b 55 10             	mov    0x10(%ebp),%edx
+c01049a2:	89 10                	mov    %edx,(%eax)
         }
         return perm;
-c01048b5:	8b 45 fc             	mov    -0x4(%ebp),%eax
-c01048b8:	eb 05                	jmp    c01048bf <get_pgtable_items+0xb2>
+c01049a4:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c01049a7:	eb 05                	jmp    c01049ae <get_pgtable_items+0xb0>
     }
     return 0;
-c01048ba:	b8 00 00 00 00       	mov    $0x0,%eax
+c01049a9:	b8 00 00 00 00       	mov    $0x0,%eax
 }
-c01048bf:	c9                   	leave  
-c01048c0:	c3                   	ret    
+c01049ae:	c9                   	leave  
+c01049af:	c3                   	ret    
 
-c01048c1 <print_pgdir>:
+c01049b0 <print_pgdir>:
 
 //print_pgdir - print the PDT&PT
 void
 print_pgdir(void) {
-c01048c1:	55                   	push   %ebp
-c01048c2:	89 e5                	mov    %esp,%ebp
-c01048c4:	57                   	push   %edi
-c01048c5:	56                   	push   %esi
-c01048c6:	53                   	push   %ebx
-c01048c7:	83 ec 2c             	sub    $0x2c,%esp
+c01049b0:	55                   	push   %ebp
+c01049b1:	89 e5                	mov    %esp,%ebp
+c01049b3:	57                   	push   %edi
+c01049b4:	56                   	push   %esi
+c01049b5:	53                   	push   %ebx
+c01049b6:	83 ec 4c             	sub    $0x4c,%esp
     cprintf("-------------------- BEGIN --------------------\n");
-c01048ca:	83 ec 0c             	sub    $0xc,%esp
-c01048cd:	68 04 92 10 c0       	push   $0xc0109204
-c01048d2:	e8 ab b9 ff ff       	call   c0100282 <cprintf>
-c01048d7:	83 c4 10             	add    $0x10,%esp
+c01049b9:	c7 04 24 34 99 10 c0 	movl   $0xc0109934,(%esp)
+c01049c0:	e8 dc b8 ff ff       	call   c01002a1 <cprintf>
     size_t left, right = 0, perm;
-c01048da:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+c01049c5:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
     while ((perm = get_pgtable_items(0, NPDEENTRY, right, vpd, &left, &right)) != 0) {
-c01048e1:	e9 e5 00 00 00       	jmp    c01049cb <print_pgdir+0x10a>
+c01049cc:	e9 fa 00 00 00       	jmp    c0104acb <print_pgdir+0x11b>
         cprintf("PDE(%03x) %08x-%08x %08x %s\n", right - left,
-c01048e6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-c01048e9:	83 ec 0c             	sub    $0xc,%esp
-c01048ec:	50                   	push   %eax
-c01048ed:	e8 cd fe ff ff       	call   c01047bf <perm2str>
-c01048f2:	83 c4 10             	add    $0x10,%esp
-c01048f5:	89 c7                	mov    %eax,%edi
+c01049d1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c01049d4:	89 04 24             	mov    %eax,(%esp)
+c01049d7:	e8 e0 fe ff ff       	call   c01048bc <perm2str>
                 left * PTSIZE, right * PTSIZE, (right - left) * PTSIZE, perm2str(perm));
-c01048f7:	8b 55 dc             	mov    -0x24(%ebp),%edx
-c01048fa:	8b 45 e0             	mov    -0x20(%ebp),%eax
-c01048fd:	29 c2                	sub    %eax,%edx
-c01048ff:	89 d0                	mov    %edx,%eax
+c01049dc:	8b 4d dc             	mov    -0x24(%ebp),%ecx
+c01049df:	8b 55 e0             	mov    -0x20(%ebp),%edx
+c01049e2:	29 d1                	sub    %edx,%ecx
+c01049e4:	89 ca                	mov    %ecx,%edx
 void
 print_pgdir(void) {
     cprintf("-------------------- BEGIN --------------------\n");
     size_t left, right = 0, perm;
     while ((perm = get_pgtable_items(0, NPDEENTRY, right, vpd, &left, &right)) != 0) {
         cprintf("PDE(%03x) %08x-%08x %08x %s\n", right - left,
-c0104901:	c1 e0 16             	shl    $0x16,%eax
-c0104904:	89 c3                	mov    %eax,%ebx
-c0104906:	8b 45 dc             	mov    -0x24(%ebp),%eax
-c0104909:	c1 e0 16             	shl    $0x16,%eax
-c010490c:	89 c1                	mov    %eax,%ecx
-c010490e:	8b 45 e0             	mov    -0x20(%ebp),%eax
-c0104911:	c1 e0 16             	shl    $0x16,%eax
-c0104914:	89 c2                	mov    %eax,%edx
-c0104916:	8b 75 dc             	mov    -0x24(%ebp),%esi
-c0104919:	8b 45 e0             	mov    -0x20(%ebp),%eax
-c010491c:	29 c6                	sub    %eax,%esi
-c010491e:	89 f0                	mov    %esi,%eax
-c0104920:	83 ec 08             	sub    $0x8,%esp
-c0104923:	57                   	push   %edi
-c0104924:	53                   	push   %ebx
-c0104925:	51                   	push   %ecx
-c0104926:	52                   	push   %edx
-c0104927:	50                   	push   %eax
-c0104928:	68 35 92 10 c0       	push   $0xc0109235
-c010492d:	e8 50 b9 ff ff       	call   c0100282 <cprintf>
-c0104932:	83 c4 20             	add    $0x20,%esp
+c01049e6:	89 d6                	mov    %edx,%esi
+c01049e8:	c1 e6 16             	shl    $0x16,%esi
+c01049eb:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c01049ee:	89 d3                	mov    %edx,%ebx
+c01049f0:	c1 e3 16             	shl    $0x16,%ebx
+c01049f3:	8b 55 e0             	mov    -0x20(%ebp),%edx
+c01049f6:	89 d1                	mov    %edx,%ecx
+c01049f8:	c1 e1 16             	shl    $0x16,%ecx
+c01049fb:	8b 7d dc             	mov    -0x24(%ebp),%edi
+c01049fe:	8b 55 e0             	mov    -0x20(%ebp),%edx
+c0104a01:	29 d7                	sub    %edx,%edi
+c0104a03:	89 fa                	mov    %edi,%edx
+c0104a05:	89 44 24 14          	mov    %eax,0x14(%esp)
+c0104a09:	89 74 24 10          	mov    %esi,0x10(%esp)
+c0104a0d:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+c0104a11:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+c0104a15:	89 54 24 04          	mov    %edx,0x4(%esp)
+c0104a19:	c7 04 24 65 99 10 c0 	movl   $0xc0109965,(%esp)
+c0104a20:	e8 7c b8 ff ff       	call   c01002a1 <cprintf>
                 left * PTSIZE, right * PTSIZE, (right - left) * PTSIZE, perm2str(perm));
         size_t l, r = left * NPTEENTRY;
-c0104935:	8b 45 e0             	mov    -0x20(%ebp),%eax
-c0104938:	c1 e0 0a             	shl    $0xa,%eax
-c010493b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+c0104a25:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0104a28:	c1 e0 0a             	shl    $0xa,%eax
+c0104a2b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
         while ((perm = get_pgtable_items(left * NPTEENTRY, right * NPTEENTRY, r, vpt, &l, &r)) != 0) {
-c010493e:	eb 4f                	jmp    c010498f <print_pgdir+0xce>
+c0104a2e:	eb 54                	jmp    c0104a84 <print_pgdir+0xd4>
             cprintf("  |-- PTE(%05x) %08x-%08x %08x %s\n", r - l,
-c0104940:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-c0104943:	83 ec 0c             	sub    $0xc,%esp
-c0104946:	50                   	push   %eax
-c0104947:	e8 73 fe ff ff       	call   c01047bf <perm2str>
-c010494c:	83 c4 10             	add    $0x10,%esp
-c010494f:	89 c7                	mov    %eax,%edi
+c0104a30:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0104a33:	89 04 24             	mov    %eax,(%esp)
+c0104a36:	e8 81 fe ff ff       	call   c01048bc <perm2str>
                     l * PGSIZE, r * PGSIZE, (r - l) * PGSIZE, perm2str(perm));
-c0104951:	8b 55 d4             	mov    -0x2c(%ebp),%edx
-c0104954:	8b 45 d8             	mov    -0x28(%ebp),%eax
-c0104957:	29 c2                	sub    %eax,%edx
-c0104959:	89 d0                	mov    %edx,%eax
+c0104a3b:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
+c0104a3e:	8b 55 d8             	mov    -0x28(%ebp),%edx
+c0104a41:	29 d1                	sub    %edx,%ecx
+c0104a43:	89 ca                	mov    %ecx,%edx
     while ((perm = get_pgtable_items(0, NPDEENTRY, right, vpd, &left, &right)) != 0) {
         cprintf("PDE(%03x) %08x-%08x %08x %s\n", right - left,
                 left * PTSIZE, right * PTSIZE, (right - left) * PTSIZE, perm2str(perm));
         size_t l, r = left * NPTEENTRY;
         while ((perm = get_pgtable_items(left * NPTEENTRY, right * NPTEENTRY, r, vpt, &l, &r)) != 0) {
             cprintf("  |-- PTE(%05x) %08x-%08x %08x %s\n", r - l,
-c010495b:	c1 e0 0c             	shl    $0xc,%eax
-c010495e:	89 c3                	mov    %eax,%ebx
-c0104960:	8b 45 d4             	mov    -0x2c(%ebp),%eax
-c0104963:	c1 e0 0c             	shl    $0xc,%eax
-c0104966:	89 c1                	mov    %eax,%ecx
-c0104968:	8b 45 d8             	mov    -0x28(%ebp),%eax
-c010496b:	c1 e0 0c             	shl    $0xc,%eax
-c010496e:	89 c2                	mov    %eax,%edx
-c0104970:	8b 75 d4             	mov    -0x2c(%ebp),%esi
-c0104973:	8b 45 d8             	mov    -0x28(%ebp),%eax
-c0104976:	29 c6                	sub    %eax,%esi
-c0104978:	89 f0                	mov    %esi,%eax
-c010497a:	83 ec 08             	sub    $0x8,%esp
-c010497d:	57                   	push   %edi
-c010497e:	53                   	push   %ebx
-c010497f:	51                   	push   %ecx
-c0104980:	52                   	push   %edx
-c0104981:	50                   	push   %eax
-c0104982:	68 54 92 10 c0       	push   $0xc0109254
-c0104987:	e8 f6 b8 ff ff       	call   c0100282 <cprintf>
-c010498c:	83 c4 20             	add    $0x20,%esp
+c0104a45:	89 d6                	mov    %edx,%esi
+c0104a47:	c1 e6 0c             	shl    $0xc,%esi
+c0104a4a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c0104a4d:	89 d3                	mov    %edx,%ebx
+c0104a4f:	c1 e3 0c             	shl    $0xc,%ebx
+c0104a52:	8b 55 d8             	mov    -0x28(%ebp),%edx
+c0104a55:	89 d1                	mov    %edx,%ecx
+c0104a57:	c1 e1 0c             	shl    $0xc,%ecx
+c0104a5a:	8b 7d d4             	mov    -0x2c(%ebp),%edi
+c0104a5d:	8b 55 d8             	mov    -0x28(%ebp),%edx
+c0104a60:	29 d7                	sub    %edx,%edi
+c0104a62:	89 fa                	mov    %edi,%edx
+c0104a64:	89 44 24 14          	mov    %eax,0x14(%esp)
+c0104a68:	89 74 24 10          	mov    %esi,0x10(%esp)
+c0104a6c:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+c0104a70:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+c0104a74:	89 54 24 04          	mov    %edx,0x4(%esp)
+c0104a78:	c7 04 24 84 99 10 c0 	movl   $0xc0109984,(%esp)
+c0104a7f:	e8 1d b8 ff ff       	call   c01002a1 <cprintf>
     size_t left, right = 0, perm;
     while ((perm = get_pgtable_items(0, NPDEENTRY, right, vpd, &left, &right)) != 0) {
         cprintf("PDE(%03x) %08x-%08x %08x %s\n", right - left,
                 left * PTSIZE, right * PTSIZE, (right - left) * PTSIZE, perm2str(perm));
         size_t l, r = left * NPTEENTRY;
         while ((perm = get_pgtable_items(left * NPTEENTRY, right * NPTEENTRY, r, vpt, &l, &r)) != 0) {
-c010498f:	be 00 00 c0 fa       	mov    $0xfac00000,%esi
-c0104994:	8b 45 d4             	mov    -0x2c(%ebp),%eax
-c0104997:	8b 55 dc             	mov    -0x24(%ebp),%edx
-c010499a:	89 d3                	mov    %edx,%ebx
-c010499c:	c1 e3 0a             	shl    $0xa,%ebx
-c010499f:	8b 55 e0             	mov    -0x20(%ebp),%edx
-c01049a2:	89 d1                	mov    %edx,%ecx
-c01049a4:	c1 e1 0a             	shl    $0xa,%ecx
-c01049a7:	83 ec 08             	sub    $0x8,%esp
-c01049aa:	8d 55 d4             	lea    -0x2c(%ebp),%edx
-c01049ad:	52                   	push   %edx
-c01049ae:	8d 55 d8             	lea    -0x28(%ebp),%edx
-c01049b1:	52                   	push   %edx
-c01049b2:	56                   	push   %esi
-c01049b3:	50                   	push   %eax
-c01049b4:	53                   	push   %ebx
-c01049b5:	51                   	push   %ecx
-c01049b6:	e8 52 fe ff ff       	call   c010480d <get_pgtable_items>
-c01049bb:	83 c4 20             	add    $0x20,%esp
-c01049be:	89 45 e4             	mov    %eax,-0x1c(%ebp)
-c01049c1:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
-c01049c5:	0f 85 75 ff ff ff    	jne    c0104940 <print_pgdir+0x7f>
+c0104a84:	be 00 00 c0 fa       	mov    $0xfac00000,%esi
+c0104a89:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+c0104a8c:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c0104a8f:	89 d3                	mov    %edx,%ebx
+c0104a91:	c1 e3 0a             	shl    $0xa,%ebx
+c0104a94:	8b 55 e0             	mov    -0x20(%ebp),%edx
+c0104a97:	89 d1                	mov    %edx,%ecx
+c0104a99:	c1 e1 0a             	shl    $0xa,%ecx
+c0104a9c:	8d 55 d4             	lea    -0x2c(%ebp),%edx
+c0104a9f:	89 54 24 14          	mov    %edx,0x14(%esp)
+c0104aa3:	8d 55 d8             	lea    -0x28(%ebp),%edx
+c0104aa6:	89 54 24 10          	mov    %edx,0x10(%esp)
+c0104aaa:	89 74 24 0c          	mov    %esi,0xc(%esp)
+c0104aae:	89 44 24 08          	mov    %eax,0x8(%esp)
+c0104ab2:	89 5c 24 04          	mov    %ebx,0x4(%esp)
+c0104ab6:	89 0c 24             	mov    %ecx,(%esp)
+c0104ab9:	e8 40 fe ff ff       	call   c01048fe <get_pgtable_items>
+c0104abe:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+c0104ac1:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+c0104ac5:	0f 85 65 ff ff ff    	jne    c0104a30 <print_pgdir+0x80>
 //print_pgdir - print the PDT&PT
 void
 print_pgdir(void) {
     cprintf("-------------------- BEGIN --------------------\n");
     size_t left, right = 0, perm;
     while ((perm = get_pgtable_items(0, NPDEENTRY, right, vpd, &left, &right)) != 0) {
-c01049cb:	b9 00 b0 fe fa       	mov    $0xfafeb000,%ecx
-c01049d0:	8b 45 dc             	mov    -0x24(%ebp),%eax
-c01049d3:	83 ec 08             	sub    $0x8,%esp
-c01049d6:	8d 55 dc             	lea    -0x24(%ebp),%edx
-c01049d9:	52                   	push   %edx
-c01049da:	8d 55 e0             	lea    -0x20(%ebp),%edx
-c01049dd:	52                   	push   %edx
-c01049de:	51                   	push   %ecx
-c01049df:	50                   	push   %eax
-c01049e0:	68 00 04 00 00       	push   $0x400
-c01049e5:	6a 00                	push   $0x0
-c01049e7:	e8 21 fe ff ff       	call   c010480d <get_pgtable_items>
-c01049ec:	83 c4 20             	add    $0x20,%esp
-c01049ef:	89 45 e4             	mov    %eax,-0x1c(%ebp)
-c01049f2:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
-c01049f6:	0f 85 ea fe ff ff    	jne    c01048e6 <print_pgdir+0x25>
+c0104acb:	b9 00 b0 fe fa       	mov    $0xfafeb000,%ecx
+c0104ad0:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0104ad3:	8d 55 dc             	lea    -0x24(%ebp),%edx
+c0104ad6:	89 54 24 14          	mov    %edx,0x14(%esp)
+c0104ada:	8d 55 e0             	lea    -0x20(%ebp),%edx
+c0104add:	89 54 24 10          	mov    %edx,0x10(%esp)
+c0104ae1:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
+c0104ae5:	89 44 24 08          	mov    %eax,0x8(%esp)
+c0104ae9:	c7 44 24 04 00 04 00 	movl   $0x400,0x4(%esp)
+c0104af0:	00 
+c0104af1:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+c0104af8:	e8 01 fe ff ff       	call   c01048fe <get_pgtable_items>
+c0104afd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+c0104b00:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+c0104b04:	0f 85 c7 fe ff ff    	jne    c01049d1 <print_pgdir+0x21>
         while ((perm = get_pgtable_items(left * NPTEENTRY, right * NPTEENTRY, r, vpt, &l, &r)) != 0) {
             cprintf("  |-- PTE(%05x) %08x-%08x %08x %s\n", r - l,
                     l * PGSIZE, r * PGSIZE, (r - l) * PGSIZE, perm2str(perm));
         }
     }
     cprintf("--------------------- END ---------------------\n");
-c01049fc:	83 ec 0c             	sub    $0xc,%esp
-c01049ff:	68 78 92 10 c0       	push   $0xc0109278
-c0104a04:	e8 79 b8 ff ff       	call   c0100282 <cprintf>
-c0104a09:	83 c4 10             	add    $0x10,%esp
-}
-c0104a0c:	90                   	nop
-c0104a0d:	8d 65 f4             	lea    -0xc(%ebp),%esp
-c0104a10:	5b                   	pop    %ebx
-c0104a11:	5e                   	pop    %esi
-c0104a12:	5f                   	pop    %edi
-c0104a13:	5d                   	pop    %ebp
-c0104a14:	c3                   	ret    
+c0104b0a:	c7 04 24 a8 99 10 c0 	movl   $0xc01099a8,(%esp)
+c0104b11:	e8 8b b7 ff ff       	call   c01002a1 <cprintf>
+}
+c0104b16:	90                   	nop
+c0104b17:	83 c4 4c             	add    $0x4c,%esp
+c0104b1a:	5b                   	pop    %ebx
+c0104b1b:	5e                   	pop    %esi
+c0104b1c:	5f                   	pop    %edi
+c0104b1d:	5d                   	pop    %ebp
+c0104b1e:	c3                   	ret    
 
-c0104a15 <kmalloc>:
+c0104b1f <kmalloc>:
 
 void *
 kmalloc(size_t n) {
-c0104a15:	55                   	push   %ebp
-c0104a16:	89 e5                	mov    %esp,%ebp
-c0104a18:	83 ec 18             	sub    $0x18,%esp
+c0104b1f:	55                   	push   %ebp
+c0104b20:	89 e5                	mov    %esp,%ebp
+c0104b22:	83 ec 28             	sub    $0x28,%esp
     void * ptr=NULL;
-c0104a1b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+c0104b25:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     struct Page *base=NULL;
-c0104a22:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+c0104b2c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
     assert(n > 0 && n < 1024*0124);
-c0104a29:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
-c0104a2d:	74 09                	je     c0104a38 <kmalloc+0x23>
-c0104a2f:	81 7d 08 ff 4f 01 00 	cmpl   $0x14fff,0x8(%ebp)
-c0104a36:	76 19                	jbe    c0104a51 <kmalloc+0x3c>
-c0104a38:	68 a9 92 10 c0       	push   $0xc01092a9
-c0104a3d:	68 4d 8d 10 c0       	push   $0xc0108d4d
-c0104a42:	68 9b 02 00 00       	push   $0x29b
-c0104a47:	68 28 8d 10 c0       	push   $0xc0108d28
-c0104a4c:	e8 97 b9 ff ff       	call   c01003e8 <__panic>
+c0104b33:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+c0104b37:	74 09                	je     c0104b42 <kmalloc+0x23>
+c0104b39:	81 7d 08 ff 4f 01 00 	cmpl   $0x14fff,0x8(%ebp)
+c0104b40:	76 24                	jbe    c0104b66 <kmalloc+0x47>
+c0104b42:	c7 44 24 0c d9 99 10 	movl   $0xc01099d9,0xc(%esp)
+c0104b49:	c0 
+c0104b4a:	c7 44 24 08 6d 94 10 	movl   $0xc010946d,0x8(%esp)
+c0104b51:	c0 
+c0104b52:	c7 44 24 04 9a 02 00 	movl   $0x29a,0x4(%esp)
+c0104b59:	00 
+c0104b5a:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c0104b61:	e8 92 b8 ff ff       	call   c01003f8 <__panic>
     int num_pages=(n+PGSIZE-1)/PGSIZE;
-c0104a51:	8b 45 08             	mov    0x8(%ebp),%eax
-c0104a54:	05 ff 0f 00 00       	add    $0xfff,%eax
-c0104a59:	c1 e8 0c             	shr    $0xc,%eax
-c0104a5c:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c0104b66:	8b 45 08             	mov    0x8(%ebp),%eax
+c0104b69:	05 ff 0f 00 00       	add    $0xfff,%eax
+c0104b6e:	c1 e8 0c             	shr    $0xc,%eax
+c0104b71:	89 45 ec             	mov    %eax,-0x14(%ebp)
     base = alloc_pages(num_pages);
-c0104a5f:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c0104a62:	83 ec 0c             	sub    $0xc,%esp
-c0104a65:	50                   	push   %eax
-c0104a66:	e8 a9 ea ff ff       	call   c0103514 <alloc_pages>
-c0104a6b:	83 c4 10             	add    $0x10,%esp
-c0104a6e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0104b74:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0104b77:	89 04 24             	mov    %eax,(%esp)
+c0104b7a:	e8 ee e7 ff ff       	call   c010336d <alloc_pages>
+c0104b7f:	89 45 f0             	mov    %eax,-0x10(%ebp)
     assert(base != NULL);
-c0104a71:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
-c0104a75:	75 19                	jne    c0104a90 <kmalloc+0x7b>
-c0104a77:	68 c0 92 10 c0       	push   $0xc01092c0
-c0104a7c:	68 4d 8d 10 c0       	push   $0xc0108d4d
-c0104a81:	68 9e 02 00 00       	push   $0x29e
-c0104a86:	68 28 8d 10 c0       	push   $0xc0108d28
-c0104a8b:	e8 58 b9 ff ff       	call   c01003e8 <__panic>
+c0104b82:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c0104b86:	75 24                	jne    c0104bac <kmalloc+0x8d>
+c0104b88:	c7 44 24 0c f0 99 10 	movl   $0xc01099f0,0xc(%esp)
+c0104b8f:	c0 
+c0104b90:	c7 44 24 08 6d 94 10 	movl   $0xc010946d,0x8(%esp)
+c0104b97:	c0 
+c0104b98:	c7 44 24 04 9d 02 00 	movl   $0x29d,0x4(%esp)
+c0104b9f:	00 
+c0104ba0:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c0104ba7:	e8 4c b8 ff ff       	call   c01003f8 <__panic>
     ptr=page2kva(base);
-c0104a90:	83 ec 0c             	sub    $0xc,%esp
-c0104a93:	ff 75 f0             	pushl  -0x10(%ebp)
-c0104a96:	e8 91 e7 ff ff       	call   c010322c <page2kva>
-c0104a9b:	83 c4 10             	add    $0x10,%esp
-c0104a9e:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0104bac:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0104baf:	89 04 24             	mov    %eax,(%esp)
+c0104bb2:	e8 bd e4 ff ff       	call   c0103074 <page2kva>
+c0104bb7:	89 45 f4             	mov    %eax,-0xc(%ebp)
     return ptr;
-c0104aa1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0104bba:	8b 45 f4             	mov    -0xc(%ebp),%eax
 }
-c0104aa4:	c9                   	leave  
-c0104aa5:	c3                   	ret    
+c0104bbd:	c9                   	leave  
+c0104bbe:	c3                   	ret    
 
-c0104aa6 <kfree>:
+c0104bbf <kfree>:
 
 void 
 kfree(void *ptr, size_t n) {
-c0104aa6:	55                   	push   %ebp
-c0104aa7:	89 e5                	mov    %esp,%ebp
-c0104aa9:	83 ec 18             	sub    $0x18,%esp
+c0104bbf:	55                   	push   %ebp
+c0104bc0:	89 e5                	mov    %esp,%ebp
+c0104bc2:	83 ec 28             	sub    $0x28,%esp
     assert(n > 0 && n < 1024*0124);
-c0104aac:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
-c0104ab0:	74 09                	je     c0104abb <kfree+0x15>
-c0104ab2:	81 7d 0c ff 4f 01 00 	cmpl   $0x14fff,0xc(%ebp)
-c0104ab9:	76 19                	jbe    c0104ad4 <kfree+0x2e>
-c0104abb:	68 a9 92 10 c0       	push   $0xc01092a9
-c0104ac0:	68 4d 8d 10 c0       	push   $0xc0108d4d
-c0104ac5:	68 a5 02 00 00       	push   $0x2a5
-c0104aca:	68 28 8d 10 c0       	push   $0xc0108d28
-c0104acf:	e8 14 b9 ff ff       	call   c01003e8 <__panic>
+c0104bc5:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+c0104bc9:	74 09                	je     c0104bd4 <kfree+0x15>
+c0104bcb:	81 7d 0c ff 4f 01 00 	cmpl   $0x14fff,0xc(%ebp)
+c0104bd2:	76 24                	jbe    c0104bf8 <kfree+0x39>
+c0104bd4:	c7 44 24 0c d9 99 10 	movl   $0xc01099d9,0xc(%esp)
+c0104bdb:	c0 
+c0104bdc:	c7 44 24 08 6d 94 10 	movl   $0xc010946d,0x8(%esp)
+c0104be3:	c0 
+c0104be4:	c7 44 24 04 a4 02 00 	movl   $0x2a4,0x4(%esp)
+c0104beb:	00 
+c0104bec:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c0104bf3:	e8 00 b8 ff ff       	call   c01003f8 <__panic>
     assert(ptr != NULL);
-c0104ad4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
-c0104ad8:	75 19                	jne    c0104af3 <kfree+0x4d>
-c0104ada:	68 cd 92 10 c0       	push   $0xc01092cd
-c0104adf:	68 4d 8d 10 c0       	push   $0xc0108d4d
-c0104ae4:	68 a6 02 00 00       	push   $0x2a6
-c0104ae9:	68 28 8d 10 c0       	push   $0xc0108d28
-c0104aee:	e8 f5 b8 ff ff       	call   c01003e8 <__panic>
+c0104bf8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+c0104bfc:	75 24                	jne    c0104c22 <kfree+0x63>
+c0104bfe:	c7 44 24 0c fd 99 10 	movl   $0xc01099fd,0xc(%esp)
+c0104c05:	c0 
+c0104c06:	c7 44 24 08 6d 94 10 	movl   $0xc010946d,0x8(%esp)
+c0104c0d:	c0 
+c0104c0e:	c7 44 24 04 a5 02 00 	movl   $0x2a5,0x4(%esp)
+c0104c15:	00 
+c0104c16:	c7 04 24 48 94 10 c0 	movl   $0xc0109448,(%esp)
+c0104c1d:	e8 d6 b7 ff ff       	call   c01003f8 <__panic>
     struct Page *base=NULL;
-c0104af3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+c0104c22:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     int num_pages=(n+PGSIZE-1)/PGSIZE;
-c0104afa:	8b 45 0c             	mov    0xc(%ebp),%eax
-c0104afd:	05 ff 0f 00 00       	add    $0xfff,%eax
-c0104b02:	c1 e8 0c             	shr    $0xc,%eax
-c0104b05:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0104c29:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0104c2c:	05 ff 0f 00 00       	add    $0xfff,%eax
+c0104c31:	c1 e8 0c             	shr    $0xc,%eax
+c0104c34:	89 45 f0             	mov    %eax,-0x10(%ebp)
     base = kva2page(ptr);
-c0104b08:	83 ec 0c             	sub    $0xc,%esp
-c0104b0b:	ff 75 08             	pushl  0x8(%ebp)
-c0104b0e:	e8 5e e7 ff ff       	call   c0103271 <kva2page>
-c0104b13:	83 c4 10             	add    $0x10,%esp
-c0104b16:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0104c37:	8b 45 08             	mov    0x8(%ebp),%eax
+c0104c3a:	89 04 24             	mov    %eax,(%esp)
+c0104c3d:	e8 86 e4 ff ff       	call   c01030c8 <kva2page>
+c0104c42:	89 45 f4             	mov    %eax,-0xc(%ebp)
     free_pages(base, num_pages);
-c0104b19:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0104b1c:	83 ec 08             	sub    $0x8,%esp
-c0104b1f:	50                   	push   %eax
-c0104b20:	ff 75 f4             	pushl  -0xc(%ebp)
-c0104b23:	e8 58 ea ff ff       	call   c0103580 <free_pages>
-c0104b28:	83 c4 10             	add    $0x10,%esp
-}
-c0104b2b:	90                   	nop
-c0104b2c:	c9                   	leave  
-c0104b2d:	c3                   	ret    
+c0104c45:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0104c48:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0104c4c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0104c4f:	89 04 24             	mov    %eax,(%esp)
+c0104c52:	e8 81 e7 ff ff       	call   c01033d8 <free_pages>
+}
+c0104c57:	90                   	nop
+c0104c58:	c9                   	leave  
+c0104c59:	c3                   	ret    
 
-c0104b2e <pa2page>:
+c0104c5a <pa2page>:
 page2pa(struct Page *page) {
     return page2ppn(page) << PGSHIFT;
 }
 
 static inline struct Page *
 pa2page(uintptr_t pa) {
-c0104b2e:	55                   	push   %ebp
-c0104b2f:	89 e5                	mov    %esp,%ebp
-c0104b31:	83 ec 08             	sub    $0x8,%esp
+c0104c5a:	55                   	push   %ebp
+c0104c5b:	89 e5                	mov    %esp,%ebp
+c0104c5d:	83 ec 18             	sub    $0x18,%esp
     if (PPN(pa) >= npage) {
-c0104b34:	8b 45 08             	mov    0x8(%ebp),%eax
-c0104b37:	c1 e8 0c             	shr    $0xc,%eax
-c0104b3a:	89 c2                	mov    %eax,%edx
-c0104b3c:	a1 80 2f 12 c0       	mov    0xc0122f80,%eax
-c0104b41:	39 c2                	cmp    %eax,%edx
-c0104b43:	72 14                	jb     c0104b59 <pa2page+0x2b>
+c0104c60:	8b 45 08             	mov    0x8(%ebp),%eax
+c0104c63:	c1 e8 0c             	shr    $0xc,%eax
+c0104c66:	89 c2                	mov    %eax,%edx
+c0104c68:	a1 80 3f 12 c0       	mov    0xc0123f80,%eax
+c0104c6d:	39 c2                	cmp    %eax,%edx
+c0104c6f:	72 1c                	jb     c0104c8d <pa2page+0x33>
         panic("pa2page called with invalid pa");
-c0104b45:	83 ec 04             	sub    $0x4,%esp
-c0104b48:	68 dc 92 10 c0       	push   $0xc01092dc
-c0104b4d:	6a 5b                	push   $0x5b
-c0104b4f:	68 fb 92 10 c0       	push   $0xc01092fb
-c0104b54:	e8 8f b8 ff ff       	call   c01003e8 <__panic>
+c0104c71:	c7 44 24 08 0c 9a 10 	movl   $0xc0109a0c,0x8(%esp)
+c0104c78:	c0 
+c0104c79:	c7 44 24 04 5b 00 00 	movl   $0x5b,0x4(%esp)
+c0104c80:	00 
+c0104c81:	c7 04 24 2b 9a 10 c0 	movl   $0xc0109a2b,(%esp)
+c0104c88:	e8 6b b7 ff ff       	call   c01003f8 <__panic>
     }
     return &pages[PPN(pa)];
-c0104b59:	a1 28 30 12 c0       	mov    0xc0123028,%eax
-c0104b5e:	8b 55 08             	mov    0x8(%ebp),%edx
-c0104b61:	c1 ea 0c             	shr    $0xc,%edx
-c0104b64:	c1 e2 05             	shl    $0x5,%edx
-c0104b67:	01 d0                	add    %edx,%eax
+c0104c8d:	a1 28 40 12 c0       	mov    0xc0124028,%eax
+c0104c92:	8b 55 08             	mov    0x8(%ebp),%edx
+c0104c95:	c1 ea 0c             	shr    $0xc,%edx
+c0104c98:	c1 e2 05             	shl    $0x5,%edx
+c0104c9b:	01 d0                	add    %edx,%eax
 }
-c0104b69:	c9                   	leave  
-c0104b6a:	c3                   	ret    
+c0104c9d:	c9                   	leave  
+c0104c9e:	c3                   	ret    
 
-c0104b6b <pde2page>:
+c0104c9f <pde2page>:
     }
     return pa2page(PTE_ADDR(pte));
 }
 
 static inline struct Page *
 pde2page(pde_t pde) {
-c0104b6b:	55                   	push   %ebp
-c0104b6c:	89 e5                	mov    %esp,%ebp
-c0104b6e:	83 ec 08             	sub    $0x8,%esp
+c0104c9f:	55                   	push   %ebp
+c0104ca0:	89 e5                	mov    %esp,%ebp
+c0104ca2:	83 ec 18             	sub    $0x18,%esp
     return pa2page(PDE_ADDR(pde));
-c0104b71:	8b 45 08             	mov    0x8(%ebp),%eax
-c0104b74:	25 00 f0 ff ff       	and    $0xfffff000,%eax
-c0104b79:	83 ec 0c             	sub    $0xc,%esp
-c0104b7c:	50                   	push   %eax
-c0104b7d:	e8 ac ff ff ff       	call   c0104b2e <pa2page>
-c0104b82:	83 c4 10             	add    $0x10,%esp
+c0104ca5:	8b 45 08             	mov    0x8(%ebp),%eax
+c0104ca8:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+c0104cad:	89 04 24             	mov    %eax,(%esp)
+c0104cb0:	e8 a5 ff ff ff       	call   c0104c5a <pa2page>
 }
-c0104b85:	c9                   	leave  
-c0104b86:	c3                   	ret    
+c0104cb5:	c9                   	leave  
+c0104cb6:	c3                   	ret    
 
-c0104b87 <mm_create>:
+c0104cb7 <mm_create>:
 static void check_vma_struct(void);
 static void check_pgfault(void);
 
 // mm_create -  alloc a mm_struct & initialize it.
 struct mm_struct *
 mm_create(void) {
-c0104b87:	55                   	push   %ebp
-c0104b88:	89 e5                	mov    %esp,%ebp
-c0104b8a:	83 ec 18             	sub    $0x18,%esp
+c0104cb7:	55                   	push   %ebp
+c0104cb8:	89 e5                	mov    %esp,%ebp
+c0104cba:	83 ec 28             	sub    $0x28,%esp
     struct mm_struct *mm = kmalloc(sizeof(struct mm_struct));
-c0104b8d:	83 ec 0c             	sub    $0xc,%esp
-c0104b90:	6a 18                	push   $0x18
-c0104b92:	e8 7e fe ff ff       	call   c0104a15 <kmalloc>
-c0104b97:	83 c4 10             	add    $0x10,%esp
-c0104b9a:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0104cbd:	c7 04 24 18 00 00 00 	movl   $0x18,(%esp)
+c0104cc4:	e8 56 fe ff ff       	call   c0104b1f <kmalloc>
+c0104cc9:	89 45 f4             	mov    %eax,-0xc(%ebp)
 
     if (mm != NULL) {
-c0104b9d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
-c0104ba1:	74 5b                	je     c0104bfe <mm_create+0x77>
+c0104ccc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0104cd0:	74 58                	je     c0104d2a <mm_create+0x73>
         list_init(&(mm->mmap_list));
-c0104ba3:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0104ba6:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0104cd2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0104cd5:	89 45 f0             	mov    %eax,-0x10(%ebp)
  * list_init - initialize a new entry
  * @elm:        new entry to be initialized
  * */
 static inline void
 list_init(list_entry_t *elm) {
     elm->prev = elm->next = elm;
-c0104ba9:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0104bac:	8b 55 f0             	mov    -0x10(%ebp),%edx
-c0104baf:	89 50 04             	mov    %edx,0x4(%eax)
-c0104bb2:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0104bb5:	8b 50 04             	mov    0x4(%eax),%edx
-c0104bb8:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0104bbb:	89 10                	mov    %edx,(%eax)
+c0104cd8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0104cdb:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c0104cde:	89 50 04             	mov    %edx,0x4(%eax)
+c0104ce1:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0104ce4:	8b 50 04             	mov    0x4(%eax),%edx
+c0104ce7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0104cea:	89 10                	mov    %edx,(%eax)
         mm->mmap_cache = NULL;
-c0104bbd:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0104bc0:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
+c0104cec:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0104cef:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
         mm->pgdir = NULL;
-c0104bc7:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0104bca:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
+c0104cf6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0104cf9:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
         mm->map_count = 0;
-c0104bd1:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0104bd4:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
+c0104d00:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0104d03:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
 
         if (swap_init_ok) swap_init_mm(mm);
-c0104bdb:	a1 10 30 12 c0       	mov    0xc0123010,%eax
-c0104be0:	85 c0                	test   %eax,%eax
-c0104be2:	74 10                	je     c0104bf4 <mm_create+0x6d>
-c0104be4:	83 ec 0c             	sub    $0xc,%esp
-c0104be7:	ff 75 f4             	pushl  -0xc(%ebp)
-c0104bea:	e8 99 0c 00 00       	call   c0105888 <swap_init_mm>
-c0104bef:	83 c4 10             	add    $0x10,%esp
-c0104bf2:	eb 0a                	jmp    c0104bfe <mm_create+0x77>
+c0104d0a:	a1 10 40 12 c0       	mov    0xc0124010,%eax
+c0104d0f:	85 c0                	test   %eax,%eax
+c0104d11:	74 0d                	je     c0104d20 <mm_create+0x69>
+c0104d13:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0104d16:	89 04 24             	mov    %eax,(%esp)
+c0104d19:	e8 e3 0d 00 00       	call   c0105b01 <swap_init_mm>
+c0104d1e:	eb 0a                	jmp    c0104d2a <mm_create+0x73>
         else mm->sm_priv = NULL;
-c0104bf4:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0104bf7:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
+c0104d20:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0104d23:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
     }
     return mm;
-c0104bfe:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0104d2a:	8b 45 f4             	mov    -0xc(%ebp),%eax
 }
-c0104c01:	c9                   	leave  
-c0104c02:	c3                   	ret    
+c0104d2d:	c9                   	leave  
+c0104d2e:	c3                   	ret    
 
-c0104c03 <vma_create>:
+c0104d2f <vma_create>:
 
 // vma_create - alloc a vma_struct & initialize it. (addr range: vm_start~vm_end)
 struct vma_struct *
 vma_create(uintptr_t vm_start, uintptr_t vm_end, uint32_t vm_flags) {
-c0104c03:	55                   	push   %ebp
-c0104c04:	89 e5                	mov    %esp,%ebp
-c0104c06:	83 ec 18             	sub    $0x18,%esp
+c0104d2f:	55                   	push   %ebp
+c0104d30:	89 e5                	mov    %esp,%ebp
+c0104d32:	83 ec 28             	sub    $0x28,%esp
     struct vma_struct *vma = kmalloc(sizeof(struct vma_struct));
-c0104c09:	83 ec 0c             	sub    $0xc,%esp
-c0104c0c:	6a 18                	push   $0x18
-c0104c0e:	e8 02 fe ff ff       	call   c0104a15 <kmalloc>
-c0104c13:	83 c4 10             	add    $0x10,%esp
-c0104c16:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0104d35:	c7 04 24 18 00 00 00 	movl   $0x18,(%esp)
+c0104d3c:	e8 de fd ff ff       	call   c0104b1f <kmalloc>
+c0104d41:	89 45 f4             	mov    %eax,-0xc(%ebp)
 
     if (vma != NULL) {
-c0104c19:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
-c0104c1d:	74 1b                	je     c0104c3a <vma_create+0x37>
+c0104d44:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0104d48:	74 1b                	je     c0104d65 <vma_create+0x36>
         vma->vm_start = vm_start;
-c0104c1f:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0104c22:	8b 55 08             	mov    0x8(%ebp),%edx
-c0104c25:	89 50 04             	mov    %edx,0x4(%eax)
+c0104d4a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0104d4d:	8b 55 08             	mov    0x8(%ebp),%edx
+c0104d50:	89 50 04             	mov    %edx,0x4(%eax)
         vma->vm_end = vm_end;
-c0104c28:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0104c2b:	8b 55 0c             	mov    0xc(%ebp),%edx
-c0104c2e:	89 50 08             	mov    %edx,0x8(%eax)
+c0104d53:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0104d56:	8b 55 0c             	mov    0xc(%ebp),%edx
+c0104d59:	89 50 08             	mov    %edx,0x8(%eax)
         vma->vm_flags = vm_flags;
-c0104c31:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0104c34:	8b 55 10             	mov    0x10(%ebp),%edx
-c0104c37:	89 50 0c             	mov    %edx,0xc(%eax)
+c0104d5c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0104d5f:	8b 55 10             	mov    0x10(%ebp),%edx
+c0104d62:	89 50 0c             	mov    %edx,0xc(%eax)
     }
     return vma;
-c0104c3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0104d65:	8b 45 f4             	mov    -0xc(%ebp),%eax
 }
-c0104c3d:	c9                   	leave  
-c0104c3e:	c3                   	ret    
+c0104d68:	c9                   	leave  
+c0104d69:	c3                   	ret    
 
-c0104c3f <find_vma>:
+c0104d6a <find_vma>:
 
 
 // find_vma - find a vma  (vma->vm_start <= addr <= vma_vm_end)
 struct vma_struct *
 find_vma(struct mm_struct *mm, uintptr_t addr) {
-c0104c3f:	55                   	push   %ebp
-c0104c40:	89 e5                	mov    %esp,%ebp
-c0104c42:	83 ec 20             	sub    $0x20,%esp
+c0104d6a:	55                   	push   %ebp
+c0104d6b:	89 e5                	mov    %esp,%ebp
+c0104d6d:	83 ec 20             	sub    $0x20,%esp
     struct vma_struct *vma = NULL;
-c0104c45:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+c0104d70:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
     if (mm != NULL) {
-c0104c4c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
-c0104c50:	0f 84 95 00 00 00    	je     c0104ceb <find_vma+0xac>
+c0104d77:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+c0104d7b:	0f 84 95 00 00 00    	je     c0104e16 <find_vma+0xac>
         vma = mm->mmap_cache;
-c0104c56:	8b 45 08             	mov    0x8(%ebp),%eax
-c0104c59:	8b 40 08             	mov    0x8(%eax),%eax
-c0104c5c:	89 45 fc             	mov    %eax,-0x4(%ebp)
+c0104d81:	8b 45 08             	mov    0x8(%ebp),%eax
+c0104d84:	8b 40 08             	mov    0x8(%eax),%eax
+c0104d87:	89 45 fc             	mov    %eax,-0x4(%ebp)
         if (!(vma != NULL && vma->vm_start <= addr && vma->vm_end > addr)) {
-c0104c5f:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
-c0104c63:	74 16                	je     c0104c7b <find_vma+0x3c>
-c0104c65:	8b 45 fc             	mov    -0x4(%ebp),%eax
-c0104c68:	8b 40 04             	mov    0x4(%eax),%eax
-c0104c6b:	3b 45 0c             	cmp    0xc(%ebp),%eax
-c0104c6e:	77 0b                	ja     c0104c7b <find_vma+0x3c>
-c0104c70:	8b 45 fc             	mov    -0x4(%ebp),%eax
-c0104c73:	8b 40 08             	mov    0x8(%eax),%eax
-c0104c76:	3b 45 0c             	cmp    0xc(%ebp),%eax
-c0104c79:	77 61                	ja     c0104cdc <find_vma+0x9d>
+c0104d8a:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
+c0104d8e:	74 16                	je     c0104da6 <find_vma+0x3c>
+c0104d90:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0104d93:	8b 40 04             	mov    0x4(%eax),%eax
+c0104d96:	3b 45 0c             	cmp    0xc(%ebp),%eax
+c0104d99:	77 0b                	ja     c0104da6 <find_vma+0x3c>
+c0104d9b:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0104d9e:	8b 40 08             	mov    0x8(%eax),%eax
+c0104da1:	3b 45 0c             	cmp    0xc(%ebp),%eax
+c0104da4:	77 61                	ja     c0104e07 <find_vma+0x9d>
                 bool found = 0;
-c0104c7b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+c0104da6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
                 list_entry_t *list = &(mm->mmap_list), *le = list;
-c0104c82:	8b 45 08             	mov    0x8(%ebp),%eax
-c0104c85:	89 45 f0             	mov    %eax,-0x10(%ebp)
-c0104c88:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0104c8b:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0104dad:	8b 45 08             	mov    0x8(%ebp),%eax
+c0104db0:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0104db3:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0104db6:	89 45 f4             	mov    %eax,-0xc(%ebp)
                 while ((le = list_next(le)) != list) {
-c0104c8e:	eb 28                	jmp    c0104cb8 <find_vma+0x79>
+c0104db9:	eb 28                	jmp    c0104de3 <find_vma+0x79>
                     vma = le2vma(le, list_link);
-c0104c90:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0104c93:	83 e8 10             	sub    $0x10,%eax
-c0104c96:	89 45 fc             	mov    %eax,-0x4(%ebp)
+c0104dbb:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0104dbe:	83 e8 10             	sub    $0x10,%eax
+c0104dc1:	89 45 fc             	mov    %eax,-0x4(%ebp)
                     if (vma->vm_start<=addr && addr < vma->vm_end) {
-c0104c99:	8b 45 fc             	mov    -0x4(%ebp),%eax
-c0104c9c:	8b 40 04             	mov    0x4(%eax),%eax
-c0104c9f:	3b 45 0c             	cmp    0xc(%ebp),%eax
-c0104ca2:	77 14                	ja     c0104cb8 <find_vma+0x79>
-c0104ca4:	8b 45 fc             	mov    -0x4(%ebp),%eax
-c0104ca7:	8b 40 08             	mov    0x8(%eax),%eax
-c0104caa:	3b 45 0c             	cmp    0xc(%ebp),%eax
-c0104cad:	76 09                	jbe    c0104cb8 <find_vma+0x79>
+c0104dc4:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0104dc7:	8b 40 04             	mov    0x4(%eax),%eax
+c0104dca:	3b 45 0c             	cmp    0xc(%ebp),%eax
+c0104dcd:	77 14                	ja     c0104de3 <find_vma+0x79>
+c0104dcf:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0104dd2:	8b 40 08             	mov    0x8(%eax),%eax
+c0104dd5:	3b 45 0c             	cmp    0xc(%ebp),%eax
+c0104dd8:	76 09                	jbe    c0104de3 <find_vma+0x79>
                         found = 1;
-c0104caf:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
+c0104dda:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
                         break;
-c0104cb6:	eb 17                	jmp    c0104ccf <find_vma+0x90>
-c0104cb8:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0104cbb:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c0104de1:	eb 17                	jmp    c0104dfa <find_vma+0x90>
+c0104de3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0104de6:	89 45 ec             	mov    %eax,-0x14(%ebp)
  * list_next - get the next entry
  * @listelm:    the list head
  **/
 static inline list_entry_t *
 list_next(list_entry_t *listelm) {
     return listelm->next;
-c0104cbe:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c0104cc1:	8b 40 04             	mov    0x4(%eax),%eax
+c0104de9:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0104dec:	8b 40 04             	mov    0x4(%eax),%eax
     if (mm != NULL) {
         vma = mm->mmap_cache;
         if (!(vma != NULL && vma->vm_start <= addr && vma->vm_end > addr)) {
                 bool found = 0;
                 list_entry_t *list = &(mm->mmap_list), *le = list;
                 while ((le = list_next(le)) != list) {
-c0104cc4:	89 45 f4             	mov    %eax,-0xc(%ebp)
-c0104cc7:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0104cca:	3b 45 f0             	cmp    -0x10(%ebp),%eax
-c0104ccd:	75 c1                	jne    c0104c90 <find_vma+0x51>
+c0104def:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0104df2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0104df5:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+c0104df8:	75 c1                	jne    c0104dbb <find_vma+0x51>
                     if (vma->vm_start<=addr && addr < vma->vm_end) {
                         found = 1;
                         break;
                     }
                 }
                 if (!found) {
-c0104ccf:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
-c0104cd3:	75 07                	jne    c0104cdc <find_vma+0x9d>
+c0104dfa:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
+c0104dfe:	75 07                	jne    c0104e07 <find_vma+0x9d>
                     vma = NULL;
-c0104cd5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+c0104e00:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
                 }
         }
         if (vma != NULL) {
-c0104cdc:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
-c0104ce0:	74 09                	je     c0104ceb <find_vma+0xac>
+c0104e07:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
+c0104e0b:	74 09                	je     c0104e16 <find_vma+0xac>
             mm->mmap_cache = vma;
-c0104ce2:	8b 45 08             	mov    0x8(%ebp),%eax
-c0104ce5:	8b 55 fc             	mov    -0x4(%ebp),%edx
-c0104ce8:	89 50 08             	mov    %edx,0x8(%eax)
+c0104e0d:	8b 45 08             	mov    0x8(%ebp),%eax
+c0104e10:	8b 55 fc             	mov    -0x4(%ebp),%edx
+c0104e13:	89 50 08             	mov    %edx,0x8(%eax)
         }
     }
     return vma;
-c0104ceb:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0104e16:	8b 45 fc             	mov    -0x4(%ebp),%eax
 }
-c0104cee:	c9                   	leave  
-c0104cef:	c3                   	ret    
+c0104e19:	c9                   	leave  
+c0104e1a:	c3                   	ret    
 
-c0104cf0 <check_vma_overlap>:
+c0104e1b <check_vma_overlap>:
 
 
 // check_vma_overlap - check if vma1 overlaps vma2 ?
 static inline void
 check_vma_overlap(struct vma_struct *prev, struct vma_struct *next) {
-c0104cf0:	55                   	push   %ebp
-c0104cf1:	89 e5                	mov    %esp,%ebp
-c0104cf3:	83 ec 08             	sub    $0x8,%esp
+c0104e1b:	55                   	push   %ebp
+c0104e1c:	89 e5                	mov    %esp,%ebp
+c0104e1e:	83 ec 18             	sub    $0x18,%esp
     assert(prev->vm_start < prev->vm_end);
-c0104cf6:	8b 45 08             	mov    0x8(%ebp),%eax
-c0104cf9:	8b 50 04             	mov    0x4(%eax),%edx
-c0104cfc:	8b 45 08             	mov    0x8(%ebp),%eax
-c0104cff:	8b 40 08             	mov    0x8(%eax),%eax
-c0104d02:	39 c2                	cmp    %eax,%edx
-c0104d04:	72 16                	jb     c0104d1c <check_vma_overlap+0x2c>
-c0104d06:	68 09 93 10 c0       	push   $0xc0109309
-c0104d0b:	68 27 93 10 c0       	push   $0xc0109327
-c0104d10:	6a 67                	push   $0x67
-c0104d12:	68 3c 93 10 c0       	push   $0xc010933c
-c0104d17:	e8 cc b6 ff ff       	call   c01003e8 <__panic>
+c0104e21:	8b 45 08             	mov    0x8(%ebp),%eax
+c0104e24:	8b 50 04             	mov    0x4(%eax),%edx
+c0104e27:	8b 45 08             	mov    0x8(%ebp),%eax
+c0104e2a:	8b 40 08             	mov    0x8(%eax),%eax
+c0104e2d:	39 c2                	cmp    %eax,%edx
+c0104e2f:	72 24                	jb     c0104e55 <check_vma_overlap+0x3a>
+c0104e31:	c7 44 24 0c 39 9a 10 	movl   $0xc0109a39,0xc(%esp)
+c0104e38:	c0 
+c0104e39:	c7 44 24 08 57 9a 10 	movl   $0xc0109a57,0x8(%esp)
+c0104e40:	c0 
+c0104e41:	c7 44 24 04 67 00 00 	movl   $0x67,0x4(%esp)
+c0104e48:	00 
+c0104e49:	c7 04 24 6c 9a 10 c0 	movl   $0xc0109a6c,(%esp)
+c0104e50:	e8 a3 b5 ff ff       	call   c01003f8 <__panic>
     assert(prev->vm_end <= next->vm_start);
-c0104d1c:	8b 45 08             	mov    0x8(%ebp),%eax
-c0104d1f:	8b 50 08             	mov    0x8(%eax),%edx
-c0104d22:	8b 45 0c             	mov    0xc(%ebp),%eax
-c0104d25:	8b 40 04             	mov    0x4(%eax),%eax
-c0104d28:	39 c2                	cmp    %eax,%edx
-c0104d2a:	76 16                	jbe    c0104d42 <check_vma_overlap+0x52>
-c0104d2c:	68 4c 93 10 c0       	push   $0xc010934c
-c0104d31:	68 27 93 10 c0       	push   $0xc0109327
-c0104d36:	6a 68                	push   $0x68
-c0104d38:	68 3c 93 10 c0       	push   $0xc010933c
-c0104d3d:	e8 a6 b6 ff ff       	call   c01003e8 <__panic>
+c0104e55:	8b 45 08             	mov    0x8(%ebp),%eax
+c0104e58:	8b 50 08             	mov    0x8(%eax),%edx
+c0104e5b:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0104e5e:	8b 40 04             	mov    0x4(%eax),%eax
+c0104e61:	39 c2                	cmp    %eax,%edx
+c0104e63:	76 24                	jbe    c0104e89 <check_vma_overlap+0x6e>
+c0104e65:	c7 44 24 0c 7c 9a 10 	movl   $0xc0109a7c,0xc(%esp)
+c0104e6c:	c0 
+c0104e6d:	c7 44 24 08 57 9a 10 	movl   $0xc0109a57,0x8(%esp)
+c0104e74:	c0 
+c0104e75:	c7 44 24 04 68 00 00 	movl   $0x68,0x4(%esp)
+c0104e7c:	00 
+c0104e7d:	c7 04 24 6c 9a 10 c0 	movl   $0xc0109a6c,(%esp)
+c0104e84:	e8 6f b5 ff ff       	call   c01003f8 <__panic>
     assert(next->vm_start < next->vm_end);
-c0104d42:	8b 45 0c             	mov    0xc(%ebp),%eax
-c0104d45:	8b 50 04             	mov    0x4(%eax),%edx
-c0104d48:	8b 45 0c             	mov    0xc(%ebp),%eax
-c0104d4b:	8b 40 08             	mov    0x8(%eax),%eax
-c0104d4e:	39 c2                	cmp    %eax,%edx
-c0104d50:	72 16                	jb     c0104d68 <check_vma_overlap+0x78>
-c0104d52:	68 6b 93 10 c0       	push   $0xc010936b
-c0104d57:	68 27 93 10 c0       	push   $0xc0109327
-c0104d5c:	6a 69                	push   $0x69
-c0104d5e:	68 3c 93 10 c0       	push   $0xc010933c
-c0104d63:	e8 80 b6 ff ff       	call   c01003e8 <__panic>
-}
-c0104d68:	90                   	nop
-c0104d69:	c9                   	leave  
-c0104d6a:	c3                   	ret    
+c0104e89:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0104e8c:	8b 50 04             	mov    0x4(%eax),%edx
+c0104e8f:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0104e92:	8b 40 08             	mov    0x8(%eax),%eax
+c0104e95:	39 c2                	cmp    %eax,%edx
+c0104e97:	72 24                	jb     c0104ebd <check_vma_overlap+0xa2>
+c0104e99:	c7 44 24 0c 9b 9a 10 	movl   $0xc0109a9b,0xc(%esp)
+c0104ea0:	c0 
+c0104ea1:	c7 44 24 08 57 9a 10 	movl   $0xc0109a57,0x8(%esp)
+c0104ea8:	c0 
+c0104ea9:	c7 44 24 04 69 00 00 	movl   $0x69,0x4(%esp)
+c0104eb0:	00 
+c0104eb1:	c7 04 24 6c 9a 10 c0 	movl   $0xc0109a6c,(%esp)
+c0104eb8:	e8 3b b5 ff ff       	call   c01003f8 <__panic>
+}
+c0104ebd:	90                   	nop
+c0104ebe:	c9                   	leave  
+c0104ebf:	c3                   	ret    
 
-c0104d6b <insert_vma_struct>:
+c0104ec0 <insert_vma_struct>:
 
 
 // insert_vma_struct -insert vma in mm's list link
 void
 insert_vma_struct(struct mm_struct *mm, struct vma_struct *vma) {
-c0104d6b:	55                   	push   %ebp
-c0104d6c:	89 e5                	mov    %esp,%ebp
-c0104d6e:	83 ec 38             	sub    $0x38,%esp
+c0104ec0:	55                   	push   %ebp
+c0104ec1:	89 e5                	mov    %esp,%ebp
+c0104ec3:	83 ec 48             	sub    $0x48,%esp
     assert(vma->vm_start < vma->vm_end);
-c0104d71:	8b 45 0c             	mov    0xc(%ebp),%eax
-c0104d74:	8b 50 04             	mov    0x4(%eax),%edx
-c0104d77:	8b 45 0c             	mov    0xc(%ebp),%eax
-c0104d7a:	8b 40 08             	mov    0x8(%eax),%eax
-c0104d7d:	39 c2                	cmp    %eax,%edx
-c0104d7f:	72 16                	jb     c0104d97 <insert_vma_struct+0x2c>
-c0104d81:	68 89 93 10 c0       	push   $0xc0109389
-c0104d86:	68 27 93 10 c0       	push   $0xc0109327
-c0104d8b:	6a 70                	push   $0x70
-c0104d8d:	68 3c 93 10 c0       	push   $0xc010933c
-c0104d92:	e8 51 b6 ff ff       	call   c01003e8 <__panic>
+c0104ec6:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0104ec9:	8b 50 04             	mov    0x4(%eax),%edx
+c0104ecc:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0104ecf:	8b 40 08             	mov    0x8(%eax),%eax
+c0104ed2:	39 c2                	cmp    %eax,%edx
+c0104ed4:	72 24                	jb     c0104efa <insert_vma_struct+0x3a>
+c0104ed6:	c7 44 24 0c b9 9a 10 	movl   $0xc0109ab9,0xc(%esp)
+c0104edd:	c0 
+c0104ede:	c7 44 24 08 57 9a 10 	movl   $0xc0109a57,0x8(%esp)
+c0104ee5:	c0 
+c0104ee6:	c7 44 24 04 70 00 00 	movl   $0x70,0x4(%esp)
+c0104eed:	00 
+c0104eee:	c7 04 24 6c 9a 10 c0 	movl   $0xc0109a6c,(%esp)
+c0104ef5:	e8 fe b4 ff ff       	call   c01003f8 <__panic>
     list_entry_t *list = &(mm->mmap_list);
-c0104d97:	8b 45 08             	mov    0x8(%ebp),%eax
-c0104d9a:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c0104efa:	8b 45 08             	mov    0x8(%ebp),%eax
+c0104efd:	89 45 ec             	mov    %eax,-0x14(%ebp)
     list_entry_t *le_prev = list, *le_next;
-c0104d9d:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c0104da0:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0104f00:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0104f03:	89 45 f4             	mov    %eax,-0xc(%ebp)
 
         list_entry_t *le = list;
-c0104da3:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c0104da6:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0104f06:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0104f09:	89 45 f0             	mov    %eax,-0x10(%ebp)
         while ((le = list_next(le)) != list) {
-c0104da9:	eb 1f                	jmp    c0104dca <insert_vma_struct+0x5f>
+c0104f0c:	eb 1f                	jmp    c0104f2d <insert_vma_struct+0x6d>
             struct vma_struct *mmap_prev = le2vma(le, list_link);
-c0104dab:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0104dae:	83 e8 10             	sub    $0x10,%eax
-c0104db1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+c0104f0e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0104f11:	83 e8 10             	sub    $0x10,%eax
+c0104f14:	89 45 e4             	mov    %eax,-0x1c(%ebp)
             if (mmap_prev->vm_start > vma->vm_start) {
-c0104db4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-c0104db7:	8b 50 04             	mov    0x4(%eax),%edx
-c0104dba:	8b 45 0c             	mov    0xc(%ebp),%eax
-c0104dbd:	8b 40 04             	mov    0x4(%eax),%eax
-c0104dc0:	39 c2                	cmp    %eax,%edx
-c0104dc2:	77 1f                	ja     c0104de3 <insert_vma_struct+0x78>
+c0104f17:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0104f1a:	8b 50 04             	mov    0x4(%eax),%edx
+c0104f1d:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0104f20:	8b 40 04             	mov    0x4(%eax),%eax
+c0104f23:	39 c2                	cmp    %eax,%edx
+c0104f25:	77 1f                	ja     c0104f46 <insert_vma_struct+0x86>
                 break;
             }
             le_prev = le;
-c0104dc4:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0104dc7:	89 45 f4             	mov    %eax,-0xc(%ebp)
-c0104dca:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0104dcd:	89 45 d8             	mov    %eax,-0x28(%ebp)
-c0104dd0:	8b 45 d8             	mov    -0x28(%ebp),%eax
-c0104dd3:	8b 40 04             	mov    0x4(%eax),%eax
+c0104f27:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0104f2a:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0104f2d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0104f30:	89 45 d8             	mov    %eax,-0x28(%ebp)
+c0104f33:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c0104f36:	8b 40 04             	mov    0x4(%eax),%eax
     assert(vma->vm_start < vma->vm_end);
     list_entry_t *list = &(mm->mmap_list);
     list_entry_t *le_prev = list, *le_next;
 
         list_entry_t *le = list;
         while ((le = list_next(le)) != list) {
-c0104dd6:	89 45 f0             	mov    %eax,-0x10(%ebp)
-c0104dd9:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0104ddc:	3b 45 ec             	cmp    -0x14(%ebp),%eax
-c0104ddf:	75 ca                	jne    c0104dab <insert_vma_struct+0x40>
-c0104de1:	eb 01                	jmp    c0104de4 <insert_vma_struct+0x79>
+c0104f39:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0104f3c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0104f3f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+c0104f42:	75 ca                	jne    c0104f0e <insert_vma_struct+0x4e>
+c0104f44:	eb 01                	jmp    c0104f47 <insert_vma_struct+0x87>
             struct vma_struct *mmap_prev = le2vma(le, list_link);
             if (mmap_prev->vm_start > vma->vm_start) {
                 break;
-c0104de3:	90                   	nop
-c0104de4:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0104de7:	89 45 e8             	mov    %eax,-0x18(%ebp)
-c0104dea:	8b 45 e8             	mov    -0x18(%ebp),%eax
-c0104ded:	8b 40 04             	mov    0x4(%eax),%eax
+c0104f46:	90                   	nop
+c0104f47:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0104f4a:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c0104f4d:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0104f50:	8b 40 04             	mov    0x4(%eax),%eax
             }
             le_prev = le;
         }
 
     le_next = list_next(le_prev);
-c0104df0:	89 45 dc             	mov    %eax,-0x24(%ebp)
+c0104f53:	89 45 dc             	mov    %eax,-0x24(%ebp)
 
     /* check overlap */
     if (le_prev != list) {
-c0104df3:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0104df6:	3b 45 ec             	cmp    -0x14(%ebp),%eax
-c0104df9:	74 15                	je     c0104e10 <insert_vma_struct+0xa5>
+c0104f56:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0104f59:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+c0104f5c:	74 15                	je     c0104f73 <insert_vma_struct+0xb3>
         check_vma_overlap(le2vma(le_prev, list_link), vma);
-c0104dfb:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0104dfe:	83 e8 10             	sub    $0x10,%eax
-c0104e01:	83 ec 08             	sub    $0x8,%esp
-c0104e04:	ff 75 0c             	pushl  0xc(%ebp)
-c0104e07:	50                   	push   %eax
-c0104e08:	e8 e3 fe ff ff       	call   c0104cf0 <check_vma_overlap>
-c0104e0d:	83 c4 10             	add    $0x10,%esp
+c0104f5e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0104f61:	8d 50 f0             	lea    -0x10(%eax),%edx
+c0104f64:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0104f67:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0104f6b:	89 14 24             	mov    %edx,(%esp)
+c0104f6e:	e8 a8 fe ff ff       	call   c0104e1b <check_vma_overlap>
     }
     if (le_next != list) {
-c0104e10:	8b 45 dc             	mov    -0x24(%ebp),%eax
-c0104e13:	3b 45 ec             	cmp    -0x14(%ebp),%eax
-c0104e16:	74 15                	je     c0104e2d <insert_vma_struct+0xc2>
+c0104f73:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0104f76:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+c0104f79:	74 15                	je     c0104f90 <insert_vma_struct+0xd0>
         check_vma_overlap(vma, le2vma(le_next, list_link));
-c0104e18:	8b 45 dc             	mov    -0x24(%ebp),%eax
-c0104e1b:	83 e8 10             	sub    $0x10,%eax
-c0104e1e:	83 ec 08             	sub    $0x8,%esp
-c0104e21:	50                   	push   %eax
-c0104e22:	ff 75 0c             	pushl  0xc(%ebp)
-c0104e25:	e8 c6 fe ff ff       	call   c0104cf0 <check_vma_overlap>
-c0104e2a:	83 c4 10             	add    $0x10,%esp
+c0104f7b:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0104f7e:	83 e8 10             	sub    $0x10,%eax
+c0104f81:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0104f85:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0104f88:	89 04 24             	mov    %eax,(%esp)
+c0104f8b:	e8 8b fe ff ff       	call   c0104e1b <check_vma_overlap>
     }
 
     vma->vm_mm = mm;
-c0104e2d:	8b 45 0c             	mov    0xc(%ebp),%eax
-c0104e30:	8b 55 08             	mov    0x8(%ebp),%edx
-c0104e33:	89 10                	mov    %edx,(%eax)
+c0104f90:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0104f93:	8b 55 08             	mov    0x8(%ebp),%edx
+c0104f96:	89 10                	mov    %edx,(%eax)
     list_add_after(le_prev, &(vma->list_link));
-c0104e35:	8b 45 0c             	mov    0xc(%ebp),%eax
-c0104e38:	8d 50 10             	lea    0x10(%eax),%edx
-c0104e3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0104e3e:	89 45 e0             	mov    %eax,-0x20(%ebp)
-c0104e41:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+c0104f98:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0104f9b:	8d 50 10             	lea    0x10(%eax),%edx
+c0104f9e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0104fa1:	89 45 e0             	mov    %eax,-0x20(%ebp)
+c0104fa4:	89 55 d4             	mov    %edx,-0x2c(%ebp)
  * Insert the new element @elm *after* the element @listelm which
  * is already in the list.
  * */
 static inline void
 list_add_after(list_entry_t *listelm, list_entry_t *elm) {
     __list_add(elm, listelm, listelm->next);
-c0104e44:	8b 45 e0             	mov    -0x20(%ebp),%eax
-c0104e47:	8b 40 04             	mov    0x4(%eax),%eax
-c0104e4a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
-c0104e4d:	89 55 d0             	mov    %edx,-0x30(%ebp)
-c0104e50:	8b 55 e0             	mov    -0x20(%ebp),%edx
-c0104e53:	89 55 cc             	mov    %edx,-0x34(%ebp)
-c0104e56:	89 45 c8             	mov    %eax,-0x38(%ebp)
+c0104fa7:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0104faa:	8b 40 04             	mov    0x4(%eax),%eax
+c0104fad:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c0104fb0:	89 55 d0             	mov    %edx,-0x30(%ebp)
+c0104fb3:	8b 55 e0             	mov    -0x20(%ebp),%edx
+c0104fb6:	89 55 cc             	mov    %edx,-0x34(%ebp)
+c0104fb9:	89 45 c8             	mov    %eax,-0x38(%ebp)
  * This is only for internal list manipulation where we know
  * the prev/next entries already!
  * */
 static inline void
 __list_add(list_entry_t *elm, list_entry_t *prev, list_entry_t *next) {
     prev->next = next->prev = elm;
-c0104e59:	8b 45 c8             	mov    -0x38(%ebp),%eax
-c0104e5c:	8b 55 d0             	mov    -0x30(%ebp),%edx
-c0104e5f:	89 10                	mov    %edx,(%eax)
-c0104e61:	8b 45 c8             	mov    -0x38(%ebp),%eax
-c0104e64:	8b 10                	mov    (%eax),%edx
-c0104e66:	8b 45 cc             	mov    -0x34(%ebp),%eax
-c0104e69:	89 50 04             	mov    %edx,0x4(%eax)
+c0104fbc:	8b 45 c8             	mov    -0x38(%ebp),%eax
+c0104fbf:	8b 55 d0             	mov    -0x30(%ebp),%edx
+c0104fc2:	89 10                	mov    %edx,(%eax)
+c0104fc4:	8b 45 c8             	mov    -0x38(%ebp),%eax
+c0104fc7:	8b 10                	mov    (%eax),%edx
+c0104fc9:	8b 45 cc             	mov    -0x34(%ebp),%eax
+c0104fcc:	89 50 04             	mov    %edx,0x4(%eax)
     elm->next = next;
-c0104e6c:	8b 45 d0             	mov    -0x30(%ebp),%eax
-c0104e6f:	8b 55 c8             	mov    -0x38(%ebp),%edx
-c0104e72:	89 50 04             	mov    %edx,0x4(%eax)
+c0104fcf:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c0104fd2:	8b 55 c8             	mov    -0x38(%ebp),%edx
+c0104fd5:	89 50 04             	mov    %edx,0x4(%eax)
     elm->prev = prev;
-c0104e75:	8b 45 d0             	mov    -0x30(%ebp),%eax
-c0104e78:	8b 55 cc             	mov    -0x34(%ebp),%edx
-c0104e7b:	89 10                	mov    %edx,(%eax)
+c0104fd8:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c0104fdb:	8b 55 cc             	mov    -0x34(%ebp),%edx
+c0104fde:	89 10                	mov    %edx,(%eax)
 
     mm->map_count ++;
-c0104e7d:	8b 45 08             	mov    0x8(%ebp),%eax
-c0104e80:	8b 40 10             	mov    0x10(%eax),%eax
-c0104e83:	8d 50 01             	lea    0x1(%eax),%edx
-c0104e86:	8b 45 08             	mov    0x8(%ebp),%eax
-c0104e89:	89 50 10             	mov    %edx,0x10(%eax)
-}
-c0104e8c:	90                   	nop
-c0104e8d:	c9                   	leave  
-c0104e8e:	c3                   	ret    
+c0104fe0:	8b 45 08             	mov    0x8(%ebp),%eax
+c0104fe3:	8b 40 10             	mov    0x10(%eax),%eax
+c0104fe6:	8d 50 01             	lea    0x1(%eax),%edx
+c0104fe9:	8b 45 08             	mov    0x8(%ebp),%eax
+c0104fec:	89 50 10             	mov    %edx,0x10(%eax)
+}
+c0104fef:	90                   	nop
+c0104ff0:	c9                   	leave  
+c0104ff1:	c3                   	ret    
 
-c0104e8f <mm_destroy>:
+c0104ff2 <mm_destroy>:
 
 // mm_destroy - free mm and mm internal fields
 void
 mm_destroy(struct mm_struct *mm) {
-c0104e8f:	55                   	push   %ebp
-c0104e90:	89 e5                	mov    %esp,%ebp
-c0104e92:	83 ec 28             	sub    $0x28,%esp
+c0104ff2:	55                   	push   %ebp
+c0104ff3:	89 e5                	mov    %esp,%ebp
+c0104ff5:	83 ec 38             	sub    $0x38,%esp
 
     list_entry_t *list = &(mm->mmap_list), *le;
-c0104e95:	8b 45 08             	mov    0x8(%ebp),%eax
-c0104e98:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0104ff8:	8b 45 08             	mov    0x8(%ebp),%eax
+c0104ffb:	89 45 f4             	mov    %eax,-0xc(%ebp)
     while ((le = list_next(list)) != list) {
-c0104e9b:	eb 3c                	jmp    c0104ed9 <mm_destroy+0x4a>
-c0104e9d:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0104ea0:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c0104ffe:	eb 3e                	jmp    c010503e <mm_destroy+0x4c>
+c0105000:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0105003:	89 45 e8             	mov    %eax,-0x18(%ebp)
  * Note: list_empty() on @listelm does not return true after this, the entry is
  * in an undefined state.
  * */
 static inline void
 list_del(list_entry_t *listelm) {
     __list_del(listelm->prev, listelm->next);
-c0104ea3:	8b 45 e8             	mov    -0x18(%ebp),%eax
-c0104ea6:	8b 40 04             	mov    0x4(%eax),%eax
-c0104ea9:	8b 55 e8             	mov    -0x18(%ebp),%edx
-c0104eac:	8b 12                	mov    (%edx),%edx
-c0104eae:	89 55 e4             	mov    %edx,-0x1c(%ebp)
-c0104eb1:	89 45 e0             	mov    %eax,-0x20(%ebp)
+c0105006:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0105009:	8b 40 04             	mov    0x4(%eax),%eax
+c010500c:	8b 55 e8             	mov    -0x18(%ebp),%edx
+c010500f:	8b 12                	mov    (%edx),%edx
+c0105011:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+c0105014:	89 45 e0             	mov    %eax,-0x20(%ebp)
  * This is only for internal list manipulation where we know
  * the prev/next entries already!
  * */
 static inline void
 __list_del(list_entry_t *prev, list_entry_t *next) {
     prev->next = next;
-c0104eb4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-c0104eb7:	8b 55 e0             	mov    -0x20(%ebp),%edx
-c0104eba:	89 50 04             	mov    %edx,0x4(%eax)
+c0105017:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c010501a:	8b 55 e0             	mov    -0x20(%ebp),%edx
+c010501d:	89 50 04             	mov    %edx,0x4(%eax)
     next->prev = prev;
-c0104ebd:	8b 45 e0             	mov    -0x20(%ebp),%eax
-c0104ec0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
-c0104ec3:	89 10                	mov    %edx,(%eax)
+c0105020:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0105023:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c0105026:	89 10                	mov    %edx,(%eax)
         list_del(le);
         kfree(le2vma(le, list_link),sizeof(struct vma_struct));  //kfree vma        
-c0104ec5:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0104ec8:	83 e8 10             	sub    $0x10,%eax
-c0104ecb:	83 ec 08             	sub    $0x8,%esp
-c0104ece:	6a 18                	push   $0x18
-c0104ed0:	50                   	push   %eax
-c0104ed1:	e8 d0 fb ff ff       	call   c0104aa6 <kfree>
-c0104ed6:	83 c4 10             	add    $0x10,%esp
-c0104ed9:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0104edc:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c0105028:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010502b:	83 e8 10             	sub    $0x10,%eax
+c010502e:	c7 44 24 04 18 00 00 	movl   $0x18,0x4(%esp)
+c0105035:	00 
+c0105036:	89 04 24             	mov    %eax,(%esp)
+c0105039:	e8 81 fb ff ff       	call   c0104bbf <kfree>
+c010503e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0105041:	89 45 ec             	mov    %eax,-0x14(%ebp)
  * list_next - get the next entry
  * @listelm:    the list head
  **/
 static inline list_entry_t *
 list_next(list_entry_t *listelm) {
     return listelm->next;
-c0104edf:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c0104ee2:	8b 40 04             	mov    0x4(%eax),%eax
+c0105044:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0105047:	8b 40 04             	mov    0x4(%eax),%eax
 // mm_destroy - free mm and mm internal fields
 void
 mm_destroy(struct mm_struct *mm) {
 
     list_entry_t *list = &(mm->mmap_list), *le;
     while ((le = list_next(list)) != list) {
-c0104ee5:	89 45 f0             	mov    %eax,-0x10(%ebp)
-c0104ee8:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0104eeb:	3b 45 f4             	cmp    -0xc(%ebp),%eax
-c0104eee:	75 ad                	jne    c0104e9d <mm_destroy+0xe>
+c010504a:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c010504d:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0105050:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+c0105053:	75 ab                	jne    c0105000 <mm_destroy+0xe>
         list_del(le);
         kfree(le2vma(le, list_link),sizeof(struct vma_struct));  //kfree vma        
     }
     kfree(mm, sizeof(struct mm_struct)); //kfree mm
-c0104ef0:	83 ec 08             	sub    $0x8,%esp
-c0104ef3:	6a 18                	push   $0x18
-c0104ef5:	ff 75 08             	pushl  0x8(%ebp)
-c0104ef8:	e8 a9 fb ff ff       	call   c0104aa6 <kfree>
-c0104efd:	83 c4 10             	add    $0x10,%esp
+c0105055:	c7 44 24 04 18 00 00 	movl   $0x18,0x4(%esp)
+c010505c:	00 
+c010505d:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105060:	89 04 24             	mov    %eax,(%esp)
+c0105063:	e8 57 fb ff ff       	call   c0104bbf <kfree>
     mm=NULL;
-c0104f00:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
+c0105068:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
 }
-c0104f07:	90                   	nop
-c0104f08:	c9                   	leave  
-c0104f09:	c3                   	ret    
+c010506f:	90                   	nop
+c0105070:	c9                   	leave  
+c0105071:	c3                   	ret    
 
-c0104f0a <vmm_init>:
+c0105072 <vmm_init>:
 
 // vmm_init - initialize virtual memory management
 //          - now just call check_vmm to check correctness of vmm
 void
 vmm_init(void) {
-c0104f0a:	55                   	push   %ebp
-c0104f0b:	89 e5                	mov    %esp,%ebp
-c0104f0d:	83 ec 08             	sub    $0x8,%esp
+c0105072:	55                   	push   %ebp
+c0105073:	89 e5                	mov    %esp,%ebp
+c0105075:	83 ec 08             	sub    $0x8,%esp
     check_vmm();
-c0104f10:	e8 03 00 00 00       	call   c0104f18 <check_vmm>
+c0105078:	e8 03 00 00 00       	call   c0105080 <check_vmm>
 }
-c0104f15:	90                   	nop
-c0104f16:	c9                   	leave  
-c0104f17:	c3                   	ret    
+c010507d:	90                   	nop
+c010507e:	c9                   	leave  
+c010507f:	c3                   	ret    
 
-c0104f18 <check_vmm>:
+c0105080 <check_vmm>:
 
 // check_vmm - check correctness of vmm
 static void
 check_vmm(void) {
-c0104f18:	55                   	push   %ebp
-c0104f19:	89 e5                	mov    %esp,%ebp
-c0104f1b:	83 ec 18             	sub    $0x18,%esp
+c0105080:	55                   	push   %ebp
+c0105081:	89 e5                	mov    %esp,%ebp
+c0105083:	83 ec 28             	sub    $0x28,%esp
     size_t nr_free_pages_store = nr_free_pages();
-c0104f1e:	e8 92 e6 ff ff       	call   c01035b5 <nr_free_pages>
-c0104f23:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0105086:	e8 80 e3 ff ff       	call   c010340b <nr_free_pages>
+c010508b:	89 45 f4             	mov    %eax,-0xc(%ebp)
     
     check_vma_struct();
-c0104f26:	e8 3b 00 00 00       	call   c0104f66 <check_vma_struct>
+c010508e:	e8 42 00 00 00       	call   c01050d5 <check_vma_struct>
     check_pgfault();
-c0104f2b:	e8 56 04 00 00       	call   c0105386 <check_pgfault>
+c0105093:	e8 fd 04 00 00       	call   c0105595 <check_pgfault>
 
     assert(nr_free_pages_store == nr_free_pages());
-c0104f30:	e8 80 e6 ff ff       	call   c01035b5 <nr_free_pages>
-c0104f35:	3b 45 f4             	cmp    -0xc(%ebp),%eax
-c0104f38:	74 19                	je     c0104f53 <check_vmm+0x3b>
-c0104f3a:	68 a8 93 10 c0       	push   $0xc01093a8
-c0104f3f:	68 27 93 10 c0       	push   $0xc0109327
-c0104f44:	68 a9 00 00 00       	push   $0xa9
-c0104f49:	68 3c 93 10 c0       	push   $0xc010933c
-c0104f4e:	e8 95 b4 ff ff       	call   c01003e8 <__panic>
+c0105098:	e8 6e e3 ff ff       	call   c010340b <nr_free_pages>
+c010509d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+c01050a0:	74 24                	je     c01050c6 <check_vmm+0x46>
+c01050a2:	c7 44 24 0c d8 9a 10 	movl   $0xc0109ad8,0xc(%esp)
+c01050a9:	c0 
+c01050aa:	c7 44 24 08 57 9a 10 	movl   $0xc0109a57,0x8(%esp)
+c01050b1:	c0 
+c01050b2:	c7 44 24 04 a9 00 00 	movl   $0xa9,0x4(%esp)
+c01050b9:	00 
+c01050ba:	c7 04 24 6c 9a 10 c0 	movl   $0xc0109a6c,(%esp)
+c01050c1:	e8 32 b3 ff ff       	call   c01003f8 <__panic>
 
     cprintf("check_vmm() succeeded.\n");
-c0104f53:	83 ec 0c             	sub    $0xc,%esp
-c0104f56:	68 cf 93 10 c0       	push   $0xc01093cf
-c0104f5b:	e8 22 b3 ff ff       	call   c0100282 <cprintf>
-c0104f60:	83 c4 10             	add    $0x10,%esp
-}
-c0104f63:	90                   	nop
-c0104f64:	c9                   	leave  
-c0104f65:	c3                   	ret    
+c01050c6:	c7 04 24 ff 9a 10 c0 	movl   $0xc0109aff,(%esp)
+c01050cd:	e8 cf b1 ff ff       	call   c01002a1 <cprintf>
+}
+c01050d2:	90                   	nop
+c01050d3:	c9                   	leave  
+c01050d4:	c3                   	ret    
 
-c0104f66 <check_vma_struct>:
+c01050d5 <check_vma_struct>:
 
 static void
 check_vma_struct(void) {
-c0104f66:	55                   	push   %ebp
-c0104f67:	89 e5                	mov    %esp,%ebp
-c0104f69:	83 ec 58             	sub    $0x58,%esp
+c01050d5:	55                   	push   %ebp
+c01050d6:	89 e5                	mov    %esp,%ebp
+c01050d8:	83 ec 68             	sub    $0x68,%esp
     size_t nr_free_pages_store = nr_free_pages();
-c0104f6c:	e8 44 e6 ff ff       	call   c01035b5 <nr_free_pages>
-c0104f71:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c01050db:	e8 2b e3 ff ff       	call   c010340b <nr_free_pages>
+c01050e0:	89 45 ec             	mov    %eax,-0x14(%ebp)
 
     struct mm_struct *mm = mm_create();
-c0104f74:	e8 0e fc ff ff       	call   c0104b87 <mm_create>
-c0104f79:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c01050e3:	e8 cf fb ff ff       	call   c0104cb7 <mm_create>
+c01050e8:	89 45 e8             	mov    %eax,-0x18(%ebp)
     assert(mm != NULL);
-c0104f7c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
-c0104f80:	75 19                	jne    c0104f9b <check_vma_struct+0x35>
-c0104f82:	68 e7 93 10 c0       	push   $0xc01093e7
-c0104f87:	68 27 93 10 c0       	push   $0xc0109327
-c0104f8c:	68 b3 00 00 00       	push   $0xb3
-c0104f91:	68 3c 93 10 c0       	push   $0xc010933c
-c0104f96:	e8 4d b4 ff ff       	call   c01003e8 <__panic>
+c01050eb:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+c01050ef:	75 24                	jne    c0105115 <check_vma_struct+0x40>
+c01050f1:	c7 44 24 0c 17 9b 10 	movl   $0xc0109b17,0xc(%esp)
+c01050f8:	c0 
+c01050f9:	c7 44 24 08 57 9a 10 	movl   $0xc0109a57,0x8(%esp)
+c0105100:	c0 
+c0105101:	c7 44 24 04 b3 00 00 	movl   $0xb3,0x4(%esp)
+c0105108:	00 
+c0105109:	c7 04 24 6c 9a 10 c0 	movl   $0xc0109a6c,(%esp)
+c0105110:	e8 e3 b2 ff ff       	call   c01003f8 <__panic>
 
     int step1 = 10, step2 = step1 * 10;
-c0104f9b:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%ebp)
-c0104fa2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
-c0104fa5:	89 d0                	mov    %edx,%eax
-c0104fa7:	c1 e0 02             	shl    $0x2,%eax
-c0104faa:	01 d0                	add    %edx,%eax
-c0104fac:	01 c0                	add    %eax,%eax
-c0104fae:	89 45 e0             	mov    %eax,-0x20(%ebp)
+c0105115:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%ebp)
+c010511c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c010511f:	89 d0                	mov    %edx,%eax
+c0105121:	c1 e0 02             	shl    $0x2,%eax
+c0105124:	01 d0                	add    %edx,%eax
+c0105126:	01 c0                	add    %eax,%eax
+c0105128:	89 45 e0             	mov    %eax,-0x20(%ebp)
 
     int i;
     for (i = step1; i >= 1; i --) {
-c0104fb1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-c0104fb4:	89 45 f4             	mov    %eax,-0xc(%ebp)
-c0104fb7:	eb 5f                	jmp    c0105018 <check_vma_struct+0xb2>
+c010512b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c010512e:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0105131:	eb 6f                	jmp    c01051a2 <check_vma_struct+0xcd>
         struct vma_struct *vma = vma_create(i * 5, i * 5 + 2, 0);
-c0104fb9:	8b 55 f4             	mov    -0xc(%ebp),%edx
-c0104fbc:	89 d0                	mov    %edx,%eax
-c0104fbe:	c1 e0 02             	shl    $0x2,%eax
-c0104fc1:	01 d0                	add    %edx,%eax
-c0104fc3:	83 c0 02             	add    $0x2,%eax
-c0104fc6:	89 c1                	mov    %eax,%ecx
-c0104fc8:	8b 55 f4             	mov    -0xc(%ebp),%edx
-c0104fcb:	89 d0                	mov    %edx,%eax
-c0104fcd:	c1 e0 02             	shl    $0x2,%eax
-c0104fd0:	01 d0                	add    %edx,%eax
-c0104fd2:	83 ec 04             	sub    $0x4,%esp
-c0104fd5:	6a 00                	push   $0x0
-c0104fd7:	51                   	push   %ecx
-c0104fd8:	50                   	push   %eax
-c0104fd9:	e8 25 fc ff ff       	call   c0104c03 <vma_create>
-c0104fde:	83 c4 10             	add    $0x10,%esp
-c0104fe1:	89 45 dc             	mov    %eax,-0x24(%ebp)
+c0105133:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0105136:	89 d0                	mov    %edx,%eax
+c0105138:	c1 e0 02             	shl    $0x2,%eax
+c010513b:	01 d0                	add    %edx,%eax
+c010513d:	83 c0 02             	add    $0x2,%eax
+c0105140:	89 c1                	mov    %eax,%ecx
+c0105142:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0105145:	89 d0                	mov    %edx,%eax
+c0105147:	c1 e0 02             	shl    $0x2,%eax
+c010514a:	01 d0                	add    %edx,%eax
+c010514c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+c0105153:	00 
+c0105154:	89 4c 24 04          	mov    %ecx,0x4(%esp)
+c0105158:	89 04 24             	mov    %eax,(%esp)
+c010515b:	e8 cf fb ff ff       	call   c0104d2f <vma_create>
+c0105160:	89 45 dc             	mov    %eax,-0x24(%ebp)
         assert(vma != NULL);
-c0104fe4:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
-c0104fe8:	75 19                	jne    c0105003 <check_vma_struct+0x9d>
-c0104fea:	68 f2 93 10 c0       	push   $0xc01093f2
-c0104fef:	68 27 93 10 c0       	push   $0xc0109327
-c0104ff4:	68 ba 00 00 00       	push   $0xba
-c0104ff9:	68 3c 93 10 c0       	push   $0xc010933c
-c0104ffe:	e8 e5 b3 ff ff       	call   c01003e8 <__panic>
+c0105163:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+c0105167:	75 24                	jne    c010518d <check_vma_struct+0xb8>
+c0105169:	c7 44 24 0c 22 9b 10 	movl   $0xc0109b22,0xc(%esp)
+c0105170:	c0 
+c0105171:	c7 44 24 08 57 9a 10 	movl   $0xc0109a57,0x8(%esp)
+c0105178:	c0 
+c0105179:	c7 44 24 04 ba 00 00 	movl   $0xba,0x4(%esp)
+c0105180:	00 
+c0105181:	c7 04 24 6c 9a 10 c0 	movl   $0xc0109a6c,(%esp)
+c0105188:	e8 6b b2 ff ff       	call   c01003f8 <__panic>
         insert_vma_struct(mm, vma);
-c0105003:	83 ec 08             	sub    $0x8,%esp
-c0105006:	ff 75 dc             	pushl  -0x24(%ebp)
-c0105009:	ff 75 e8             	pushl  -0x18(%ebp)
-c010500c:	e8 5a fd ff ff       	call   c0104d6b <insert_vma_struct>
-c0105011:	83 c4 10             	add    $0x10,%esp
+c010518d:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0105190:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0105194:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0105197:	89 04 24             	mov    %eax,(%esp)
+c010519a:	e8 21 fd ff ff       	call   c0104ec0 <insert_vma_struct>
     assert(mm != NULL);
 
     int step1 = 10, step2 = step1 * 10;
 
     int i;
     for (i = step1; i >= 1; i --) {
-c0105014:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
-c0105018:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
-c010501c:	7f 9b                	jg     c0104fb9 <check_vma_struct+0x53>
+c010519f:	ff 4d f4             	decl   -0xc(%ebp)
+c01051a2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c01051a6:	7f 8b                	jg     c0105133 <check_vma_struct+0x5e>
         struct vma_struct *vma = vma_create(i * 5, i * 5 + 2, 0);
         assert(vma != NULL);
         insert_vma_struct(mm, vma);
     }
 
     for (i = step1 + 1; i <= step2; i ++) {
-c010501e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-c0105021:	83 c0 01             	add    $0x1,%eax
-c0105024:	89 45 f4             	mov    %eax,-0xc(%ebp)
-c0105027:	eb 5f                	jmp    c0105088 <check_vma_struct+0x122>
+c01051a8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c01051ab:	40                   	inc    %eax
+c01051ac:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c01051af:	eb 6f                	jmp    c0105220 <check_vma_struct+0x14b>
         struct vma_struct *vma = vma_create(i * 5, i * 5 + 2, 0);
-c0105029:	8b 55 f4             	mov    -0xc(%ebp),%edx
-c010502c:	89 d0                	mov    %edx,%eax
-c010502e:	c1 e0 02             	shl    $0x2,%eax
-c0105031:	01 d0                	add    %edx,%eax
-c0105033:	83 c0 02             	add    $0x2,%eax
-c0105036:	89 c1                	mov    %eax,%ecx
-c0105038:	8b 55 f4             	mov    -0xc(%ebp),%edx
-c010503b:	89 d0                	mov    %edx,%eax
-c010503d:	c1 e0 02             	shl    $0x2,%eax
-c0105040:	01 d0                	add    %edx,%eax
-c0105042:	83 ec 04             	sub    $0x4,%esp
-c0105045:	6a 00                	push   $0x0
-c0105047:	51                   	push   %ecx
-c0105048:	50                   	push   %eax
-c0105049:	e8 b5 fb ff ff       	call   c0104c03 <vma_create>
-c010504e:	83 c4 10             	add    $0x10,%esp
-c0105051:	89 45 d8             	mov    %eax,-0x28(%ebp)
+c01051b1:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c01051b4:	89 d0                	mov    %edx,%eax
+c01051b6:	c1 e0 02             	shl    $0x2,%eax
+c01051b9:	01 d0                	add    %edx,%eax
+c01051bb:	83 c0 02             	add    $0x2,%eax
+c01051be:	89 c1                	mov    %eax,%ecx
+c01051c0:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c01051c3:	89 d0                	mov    %edx,%eax
+c01051c5:	c1 e0 02             	shl    $0x2,%eax
+c01051c8:	01 d0                	add    %edx,%eax
+c01051ca:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+c01051d1:	00 
+c01051d2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
+c01051d6:	89 04 24             	mov    %eax,(%esp)
+c01051d9:	e8 51 fb ff ff       	call   c0104d2f <vma_create>
+c01051de:	89 45 d8             	mov    %eax,-0x28(%ebp)
         assert(vma != NULL);
-c0105054:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
-c0105058:	75 19                	jne    c0105073 <check_vma_struct+0x10d>
-c010505a:	68 f2 93 10 c0       	push   $0xc01093f2
-c010505f:	68 27 93 10 c0       	push   $0xc0109327
-c0105064:	68 c0 00 00 00       	push   $0xc0
-c0105069:	68 3c 93 10 c0       	push   $0xc010933c
-c010506e:	e8 75 b3 ff ff       	call   c01003e8 <__panic>
+c01051e1:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
+c01051e5:	75 24                	jne    c010520b <check_vma_struct+0x136>
+c01051e7:	c7 44 24 0c 22 9b 10 	movl   $0xc0109b22,0xc(%esp)
+c01051ee:	c0 
+c01051ef:	c7 44 24 08 57 9a 10 	movl   $0xc0109a57,0x8(%esp)
+c01051f6:	c0 
+c01051f7:	c7 44 24 04 c0 00 00 	movl   $0xc0,0x4(%esp)
+c01051fe:	00 
+c01051ff:	c7 04 24 6c 9a 10 c0 	movl   $0xc0109a6c,(%esp)
+c0105206:	e8 ed b1 ff ff       	call   c01003f8 <__panic>
         insert_vma_struct(mm, vma);
-c0105073:	83 ec 08             	sub    $0x8,%esp
-c0105076:	ff 75 d8             	pushl  -0x28(%ebp)
-c0105079:	ff 75 e8             	pushl  -0x18(%ebp)
-c010507c:	e8 ea fc ff ff       	call   c0104d6b <insert_vma_struct>
-c0105081:	83 c4 10             	add    $0x10,%esp
+c010520b:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c010520e:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0105212:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0105215:	89 04 24             	mov    %eax,(%esp)
+c0105218:	e8 a3 fc ff ff       	call   c0104ec0 <insert_vma_struct>
         struct vma_struct *vma = vma_create(i * 5, i * 5 + 2, 0);
         assert(vma != NULL);
         insert_vma_struct(mm, vma);
     }
 
     for (i = step1 + 1; i <= step2; i ++) {
-c0105084:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
-c0105088:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c010508b:	3b 45 e0             	cmp    -0x20(%ebp),%eax
-c010508e:	7e 99                	jle    c0105029 <check_vma_struct+0xc3>
+c010521d:	ff 45 f4             	incl   -0xc(%ebp)
+c0105220:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0105223:	3b 45 e0             	cmp    -0x20(%ebp),%eax
+c0105226:	7e 89                	jle    c01051b1 <check_vma_struct+0xdc>
         struct vma_struct *vma = vma_create(i * 5, i * 5 + 2, 0);
         assert(vma != NULL);
         insert_vma_struct(mm, vma);
     }
 
     list_entry_t *le = list_next(&(mm->mmap_list));
-c0105090:	8b 45 e8             	mov    -0x18(%ebp),%eax
-c0105093:	89 45 b4             	mov    %eax,-0x4c(%ebp)
-c0105096:	8b 45 b4             	mov    -0x4c(%ebp),%eax
-c0105099:	8b 40 04             	mov    0x4(%eax),%eax
-c010509c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0105228:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c010522b:	89 45 b4             	mov    %eax,-0x4c(%ebp)
+c010522e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
+c0105231:	8b 40 04             	mov    0x4(%eax),%eax
+c0105234:	89 45 f0             	mov    %eax,-0x10(%ebp)
 
     for (i = 1; i <= step2; i ++) {
-c010509f:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
-c01050a6:	e9 81 00 00 00       	jmp    c010512c <check_vma_struct+0x1c6>
+c0105237:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
+c010523e:	e9 96 00 00 00       	jmp    c01052d9 <check_vma_struct+0x204>
         assert(le != &(mm->mmap_list));
-c01050ab:	8b 45 e8             	mov    -0x18(%ebp),%eax
-c01050ae:	3b 45 f0             	cmp    -0x10(%ebp),%eax
-c01050b1:	75 19                	jne    c01050cc <check_vma_struct+0x166>
-c01050b3:	68 fe 93 10 c0       	push   $0xc01093fe
-c01050b8:	68 27 93 10 c0       	push   $0xc0109327
-c01050bd:	68 c7 00 00 00       	push   $0xc7
-c01050c2:	68 3c 93 10 c0       	push   $0xc010933c
-c01050c7:	e8 1c b3 ff ff       	call   c01003e8 <__panic>
+c0105243:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0105246:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+c0105249:	75 24                	jne    c010526f <check_vma_struct+0x19a>
+c010524b:	c7 44 24 0c 2e 9b 10 	movl   $0xc0109b2e,0xc(%esp)
+c0105252:	c0 
+c0105253:	c7 44 24 08 57 9a 10 	movl   $0xc0109a57,0x8(%esp)
+c010525a:	c0 
+c010525b:	c7 44 24 04 c7 00 00 	movl   $0xc7,0x4(%esp)
+c0105262:	00 
+c0105263:	c7 04 24 6c 9a 10 c0 	movl   $0xc0109a6c,(%esp)
+c010526a:	e8 89 b1 ff ff       	call   c01003f8 <__panic>
         struct vma_struct *mmap = le2vma(le, list_link);
-c01050cc:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c01050cf:	83 e8 10             	sub    $0x10,%eax
-c01050d2:	89 45 d0             	mov    %eax,-0x30(%ebp)
+c010526f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0105272:	83 e8 10             	sub    $0x10,%eax
+c0105275:	89 45 d0             	mov    %eax,-0x30(%ebp)
         assert(mmap->vm_start == i * 5 && mmap->vm_end == i * 5 + 2);
-c01050d5:	8b 45 d0             	mov    -0x30(%ebp),%eax
-c01050d8:	8b 48 04             	mov    0x4(%eax),%ecx
-c01050db:	8b 55 f4             	mov    -0xc(%ebp),%edx
-c01050de:	89 d0                	mov    %edx,%eax
-c01050e0:	c1 e0 02             	shl    $0x2,%eax
-c01050e3:	01 d0                	add    %edx,%eax
-c01050e5:	39 c1                	cmp    %eax,%ecx
-c01050e7:	75 17                	jne    c0105100 <check_vma_struct+0x19a>
-c01050e9:	8b 45 d0             	mov    -0x30(%ebp),%eax
-c01050ec:	8b 48 08             	mov    0x8(%eax),%ecx
-c01050ef:	8b 55 f4             	mov    -0xc(%ebp),%edx
-c01050f2:	89 d0                	mov    %edx,%eax
-c01050f4:	c1 e0 02             	shl    $0x2,%eax
-c01050f7:	01 d0                	add    %edx,%eax
-c01050f9:	83 c0 02             	add    $0x2,%eax
-c01050fc:	39 c1                	cmp    %eax,%ecx
-c01050fe:	74 19                	je     c0105119 <check_vma_struct+0x1b3>
-c0105100:	68 18 94 10 c0       	push   $0xc0109418
-c0105105:	68 27 93 10 c0       	push   $0xc0109327
-c010510a:	68 c9 00 00 00       	push   $0xc9
-c010510f:	68 3c 93 10 c0       	push   $0xc010933c
-c0105114:	e8 cf b2 ff ff       	call   c01003e8 <__panic>
-c0105119:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c010511c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
-c010511f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
-c0105122:	8b 40 04             	mov    0x4(%eax),%eax
+c0105278:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c010527b:	8b 48 04             	mov    0x4(%eax),%ecx
+c010527e:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0105281:	89 d0                	mov    %edx,%eax
+c0105283:	c1 e0 02             	shl    $0x2,%eax
+c0105286:	01 d0                	add    %edx,%eax
+c0105288:	39 c1                	cmp    %eax,%ecx
+c010528a:	75 17                	jne    c01052a3 <check_vma_struct+0x1ce>
+c010528c:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c010528f:	8b 48 08             	mov    0x8(%eax),%ecx
+c0105292:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0105295:	89 d0                	mov    %edx,%eax
+c0105297:	c1 e0 02             	shl    $0x2,%eax
+c010529a:	01 d0                	add    %edx,%eax
+c010529c:	83 c0 02             	add    $0x2,%eax
+c010529f:	39 c1                	cmp    %eax,%ecx
+c01052a1:	74 24                	je     c01052c7 <check_vma_struct+0x1f2>
+c01052a3:	c7 44 24 0c 48 9b 10 	movl   $0xc0109b48,0xc(%esp)
+c01052aa:	c0 
+c01052ab:	c7 44 24 08 57 9a 10 	movl   $0xc0109a57,0x8(%esp)
+c01052b2:	c0 
+c01052b3:	c7 44 24 04 c9 00 00 	movl   $0xc9,0x4(%esp)
+c01052ba:	00 
+c01052bb:	c7 04 24 6c 9a 10 c0 	movl   $0xc0109a6c,(%esp)
+c01052c2:	e8 31 b1 ff ff       	call   c01003f8 <__panic>
+c01052c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01052ca:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+c01052cd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+c01052d0:	8b 40 04             	mov    0x4(%eax),%eax
         le = list_next(le);
-c0105125:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c01052d3:	89 45 f0             	mov    %eax,-0x10(%ebp)
         insert_vma_struct(mm, vma);
     }
 
     list_entry_t *le = list_next(&(mm->mmap_list));
 
     for (i = 1; i <= step2; i ++) {
-c0105128:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
-c010512c:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c010512f:	3b 45 e0             	cmp    -0x20(%ebp),%eax
-c0105132:	0f 8e 73 ff ff ff    	jle    c01050ab <check_vma_struct+0x145>
+c01052d6:	ff 45 f4             	incl   -0xc(%ebp)
+c01052d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01052dc:	3b 45 e0             	cmp    -0x20(%ebp),%eax
+c01052df:	0f 8e 5e ff ff ff    	jle    c0105243 <check_vma_struct+0x16e>
         struct vma_struct *mmap = le2vma(le, list_link);
         assert(mmap->vm_start == i * 5 && mmap->vm_end == i * 5 + 2);
         le = list_next(le);
     }
 
     for (i = 5; i <= 5 * step2; i +=5) {
-c0105138:	c7 45 f4 05 00 00 00 	movl   $0x5,-0xc(%ebp)
-c010513f:	e9 80 01 00 00       	jmp    c01052c4 <check_vma_struct+0x35e>
+c01052e5:	c7 45 f4 05 00 00 00 	movl   $0x5,-0xc(%ebp)
+c01052ec:	e9 cb 01 00 00       	jmp    c01054bc <check_vma_struct+0x3e7>
         struct vma_struct *vma1 = find_vma(mm, i);
-c0105144:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0105147:	83 ec 08             	sub    $0x8,%esp
-c010514a:	50                   	push   %eax
-c010514b:	ff 75 e8             	pushl  -0x18(%ebp)
-c010514e:	e8 ec fa ff ff       	call   c0104c3f <find_vma>
-c0105153:	83 c4 10             	add    $0x10,%esp
-c0105156:	89 45 cc             	mov    %eax,-0x34(%ebp)
+c01052f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01052f4:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01052f8:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c01052fb:	89 04 24             	mov    %eax,(%esp)
+c01052fe:	e8 67 fa ff ff       	call   c0104d6a <find_vma>
+c0105303:	89 45 cc             	mov    %eax,-0x34(%ebp)
         assert(vma1 != NULL);
-c0105159:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
-c010515d:	75 19                	jne    c0105178 <check_vma_struct+0x212>
-c010515f:	68 4d 94 10 c0       	push   $0xc010944d
-c0105164:	68 27 93 10 c0       	push   $0xc0109327
-c0105169:	68 cf 00 00 00       	push   $0xcf
-c010516e:	68 3c 93 10 c0       	push   $0xc010933c
-c0105173:	e8 70 b2 ff ff       	call   c01003e8 <__panic>
+c0105306:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
+c010530a:	75 24                	jne    c0105330 <check_vma_struct+0x25b>
+c010530c:	c7 44 24 0c 7d 9b 10 	movl   $0xc0109b7d,0xc(%esp)
+c0105313:	c0 
+c0105314:	c7 44 24 08 57 9a 10 	movl   $0xc0109a57,0x8(%esp)
+c010531b:	c0 
+c010531c:	c7 44 24 04 cf 00 00 	movl   $0xcf,0x4(%esp)
+c0105323:	00 
+c0105324:	c7 04 24 6c 9a 10 c0 	movl   $0xc0109a6c,(%esp)
+c010532b:	e8 c8 b0 ff ff       	call   c01003f8 <__panic>
         struct vma_struct *vma2 = find_vma(mm, i+1);
-c0105178:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c010517b:	83 c0 01             	add    $0x1,%eax
-c010517e:	83 ec 08             	sub    $0x8,%esp
-c0105181:	50                   	push   %eax
-c0105182:	ff 75 e8             	pushl  -0x18(%ebp)
-c0105185:	e8 b5 fa ff ff       	call   c0104c3f <find_vma>
-c010518a:	83 c4 10             	add    $0x10,%esp
-c010518d:	89 45 c8             	mov    %eax,-0x38(%ebp)
+c0105330:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0105333:	40                   	inc    %eax
+c0105334:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0105338:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c010533b:	89 04 24             	mov    %eax,(%esp)
+c010533e:	e8 27 fa ff ff       	call   c0104d6a <find_vma>
+c0105343:	89 45 c8             	mov    %eax,-0x38(%ebp)
         assert(vma2 != NULL);
-c0105190:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
-c0105194:	75 19                	jne    c01051af <check_vma_struct+0x249>
-c0105196:	68 5a 94 10 c0       	push   $0xc010945a
-c010519b:	68 27 93 10 c0       	push   $0xc0109327
-c01051a0:	68 d1 00 00 00       	push   $0xd1
-c01051a5:	68 3c 93 10 c0       	push   $0xc010933c
-c01051aa:	e8 39 b2 ff ff       	call   c01003e8 <__panic>
+c0105346:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
+c010534a:	75 24                	jne    c0105370 <check_vma_struct+0x29b>
+c010534c:	c7 44 24 0c 8a 9b 10 	movl   $0xc0109b8a,0xc(%esp)
+c0105353:	c0 
+c0105354:	c7 44 24 08 57 9a 10 	movl   $0xc0109a57,0x8(%esp)
+c010535b:	c0 
+c010535c:	c7 44 24 04 d1 00 00 	movl   $0xd1,0x4(%esp)
+c0105363:	00 
+c0105364:	c7 04 24 6c 9a 10 c0 	movl   $0xc0109a6c,(%esp)
+c010536b:	e8 88 b0 ff ff       	call   c01003f8 <__panic>
         struct vma_struct *vma3 = find_vma(mm, i+2);
-c01051af:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c01051b2:	83 c0 02             	add    $0x2,%eax
-c01051b5:	83 ec 08             	sub    $0x8,%esp
-c01051b8:	50                   	push   %eax
-c01051b9:	ff 75 e8             	pushl  -0x18(%ebp)
-c01051bc:	e8 7e fa ff ff       	call   c0104c3f <find_vma>
-c01051c1:	83 c4 10             	add    $0x10,%esp
-c01051c4:	89 45 c4             	mov    %eax,-0x3c(%ebp)
+c0105370:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0105373:	83 c0 02             	add    $0x2,%eax
+c0105376:	89 44 24 04          	mov    %eax,0x4(%esp)
+c010537a:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c010537d:	89 04 24             	mov    %eax,(%esp)
+c0105380:	e8 e5 f9 ff ff       	call   c0104d6a <find_vma>
+c0105385:	89 45 c4             	mov    %eax,-0x3c(%ebp)
         assert(vma3 == NULL);
-c01051c7:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
-c01051cb:	74 19                	je     c01051e6 <check_vma_struct+0x280>
-c01051cd:	68 67 94 10 c0       	push   $0xc0109467
-c01051d2:	68 27 93 10 c0       	push   $0xc0109327
-c01051d7:	68 d3 00 00 00       	push   $0xd3
-c01051dc:	68 3c 93 10 c0       	push   $0xc010933c
-c01051e1:	e8 02 b2 ff ff       	call   c01003e8 <__panic>
+c0105388:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
+c010538c:	74 24                	je     c01053b2 <check_vma_struct+0x2dd>
+c010538e:	c7 44 24 0c 97 9b 10 	movl   $0xc0109b97,0xc(%esp)
+c0105395:	c0 
+c0105396:	c7 44 24 08 57 9a 10 	movl   $0xc0109a57,0x8(%esp)
+c010539d:	c0 
+c010539e:	c7 44 24 04 d3 00 00 	movl   $0xd3,0x4(%esp)
+c01053a5:	00 
+c01053a6:	c7 04 24 6c 9a 10 c0 	movl   $0xc0109a6c,(%esp)
+c01053ad:	e8 46 b0 ff ff       	call   c01003f8 <__panic>
         struct vma_struct *vma4 = find_vma(mm, i+3);
-c01051e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c01051e9:	83 c0 03             	add    $0x3,%eax
-c01051ec:	83 ec 08             	sub    $0x8,%esp
-c01051ef:	50                   	push   %eax
-c01051f0:	ff 75 e8             	pushl  -0x18(%ebp)
-c01051f3:	e8 47 fa ff ff       	call   c0104c3f <find_vma>
-c01051f8:	83 c4 10             	add    $0x10,%esp
-c01051fb:	89 45 c0             	mov    %eax,-0x40(%ebp)
+c01053b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01053b5:	83 c0 03             	add    $0x3,%eax
+c01053b8:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01053bc:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c01053bf:	89 04 24             	mov    %eax,(%esp)
+c01053c2:	e8 a3 f9 ff ff       	call   c0104d6a <find_vma>
+c01053c7:	89 45 c0             	mov    %eax,-0x40(%ebp)
         assert(vma4 == NULL);
-c01051fe:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
-c0105202:	74 19                	je     c010521d <check_vma_struct+0x2b7>
-c0105204:	68 74 94 10 c0       	push   $0xc0109474
-c0105209:	68 27 93 10 c0       	push   $0xc0109327
-c010520e:	68 d5 00 00 00       	push   $0xd5
-c0105213:	68 3c 93 10 c0       	push   $0xc010933c
-c0105218:	e8 cb b1 ff ff       	call   c01003e8 <__panic>
+c01053ca:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
+c01053ce:	74 24                	je     c01053f4 <check_vma_struct+0x31f>
+c01053d0:	c7 44 24 0c a4 9b 10 	movl   $0xc0109ba4,0xc(%esp)
+c01053d7:	c0 
+c01053d8:	c7 44 24 08 57 9a 10 	movl   $0xc0109a57,0x8(%esp)
+c01053df:	c0 
+c01053e0:	c7 44 24 04 d5 00 00 	movl   $0xd5,0x4(%esp)
+c01053e7:	00 
+c01053e8:	c7 04 24 6c 9a 10 c0 	movl   $0xc0109a6c,(%esp)
+c01053ef:	e8 04 b0 ff ff       	call   c01003f8 <__panic>
         struct vma_struct *vma5 = find_vma(mm, i+4);
-c010521d:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0105220:	83 c0 04             	add    $0x4,%eax
-c0105223:	83 ec 08             	sub    $0x8,%esp
-c0105226:	50                   	push   %eax
-c0105227:	ff 75 e8             	pushl  -0x18(%ebp)
-c010522a:	e8 10 fa ff ff       	call   c0104c3f <find_vma>
-c010522f:	83 c4 10             	add    $0x10,%esp
-c0105232:	89 45 bc             	mov    %eax,-0x44(%ebp)
+c01053f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01053f7:	83 c0 04             	add    $0x4,%eax
+c01053fa:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01053fe:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0105401:	89 04 24             	mov    %eax,(%esp)
+c0105404:	e8 61 f9 ff ff       	call   c0104d6a <find_vma>
+c0105409:	89 45 bc             	mov    %eax,-0x44(%ebp)
         assert(vma5 == NULL);
-c0105235:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
-c0105239:	74 19                	je     c0105254 <check_vma_struct+0x2ee>
-c010523b:	68 81 94 10 c0       	push   $0xc0109481
-c0105240:	68 27 93 10 c0       	push   $0xc0109327
-c0105245:	68 d7 00 00 00       	push   $0xd7
-c010524a:	68 3c 93 10 c0       	push   $0xc010933c
-c010524f:	e8 94 b1 ff ff       	call   c01003e8 <__panic>
+c010540c:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
+c0105410:	74 24                	je     c0105436 <check_vma_struct+0x361>
+c0105412:	c7 44 24 0c b1 9b 10 	movl   $0xc0109bb1,0xc(%esp)
+c0105419:	c0 
+c010541a:	c7 44 24 08 57 9a 10 	movl   $0xc0109a57,0x8(%esp)
+c0105421:	c0 
+c0105422:	c7 44 24 04 d7 00 00 	movl   $0xd7,0x4(%esp)
+c0105429:	00 
+c010542a:	c7 04 24 6c 9a 10 c0 	movl   $0xc0109a6c,(%esp)
+c0105431:	e8 c2 af ff ff       	call   c01003f8 <__panic>
 
         assert(vma1->vm_start == i  && vma1->vm_end == i  + 2);
-c0105254:	8b 45 cc             	mov    -0x34(%ebp),%eax
-c0105257:	8b 50 04             	mov    0x4(%eax),%edx
-c010525a:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c010525d:	39 c2                	cmp    %eax,%edx
-c010525f:	75 10                	jne    c0105271 <check_vma_struct+0x30b>
-c0105261:	8b 45 cc             	mov    -0x34(%ebp),%eax
-c0105264:	8b 40 08             	mov    0x8(%eax),%eax
-c0105267:	8b 55 f4             	mov    -0xc(%ebp),%edx
-c010526a:	83 c2 02             	add    $0x2,%edx
-c010526d:	39 d0                	cmp    %edx,%eax
-c010526f:	74 19                	je     c010528a <check_vma_struct+0x324>
-c0105271:	68 90 94 10 c0       	push   $0xc0109490
-c0105276:	68 27 93 10 c0       	push   $0xc0109327
-c010527b:	68 d9 00 00 00       	push   $0xd9
-c0105280:	68 3c 93 10 c0       	push   $0xc010933c
-c0105285:	e8 5e b1 ff ff       	call   c01003e8 <__panic>
+c0105436:	8b 45 cc             	mov    -0x34(%ebp),%eax
+c0105439:	8b 50 04             	mov    0x4(%eax),%edx
+c010543c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010543f:	39 c2                	cmp    %eax,%edx
+c0105441:	75 10                	jne    c0105453 <check_vma_struct+0x37e>
+c0105443:	8b 45 cc             	mov    -0x34(%ebp),%eax
+c0105446:	8b 40 08             	mov    0x8(%eax),%eax
+c0105449:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c010544c:	83 c2 02             	add    $0x2,%edx
+c010544f:	39 d0                	cmp    %edx,%eax
+c0105451:	74 24                	je     c0105477 <check_vma_struct+0x3a2>
+c0105453:	c7 44 24 0c c0 9b 10 	movl   $0xc0109bc0,0xc(%esp)
+c010545a:	c0 
+c010545b:	c7 44 24 08 57 9a 10 	movl   $0xc0109a57,0x8(%esp)
+c0105462:	c0 
+c0105463:	c7 44 24 04 d9 00 00 	movl   $0xd9,0x4(%esp)
+c010546a:	00 
+c010546b:	c7 04 24 6c 9a 10 c0 	movl   $0xc0109a6c,(%esp)
+c0105472:	e8 81 af ff ff       	call   c01003f8 <__panic>
         assert(vma2->vm_start == i  && vma2->vm_end == i  + 2);
-c010528a:	8b 45 c8             	mov    -0x38(%ebp),%eax
-c010528d:	8b 50 04             	mov    0x4(%eax),%edx
-c0105290:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0105293:	39 c2                	cmp    %eax,%edx
-c0105295:	75 10                	jne    c01052a7 <check_vma_struct+0x341>
-c0105297:	8b 45 c8             	mov    -0x38(%ebp),%eax
-c010529a:	8b 40 08             	mov    0x8(%eax),%eax
-c010529d:	8b 55 f4             	mov    -0xc(%ebp),%edx
-c01052a0:	83 c2 02             	add    $0x2,%edx
-c01052a3:	39 d0                	cmp    %edx,%eax
-c01052a5:	74 19                	je     c01052c0 <check_vma_struct+0x35a>
-c01052a7:	68 c0 94 10 c0       	push   $0xc01094c0
-c01052ac:	68 27 93 10 c0       	push   $0xc0109327
-c01052b1:	68 da 00 00 00       	push   $0xda
-c01052b6:	68 3c 93 10 c0       	push   $0xc010933c
-c01052bb:	e8 28 b1 ff ff       	call   c01003e8 <__panic>
+c0105477:	8b 45 c8             	mov    -0x38(%ebp),%eax
+c010547a:	8b 50 04             	mov    0x4(%eax),%edx
+c010547d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0105480:	39 c2                	cmp    %eax,%edx
+c0105482:	75 10                	jne    c0105494 <check_vma_struct+0x3bf>
+c0105484:	8b 45 c8             	mov    -0x38(%ebp),%eax
+c0105487:	8b 40 08             	mov    0x8(%eax),%eax
+c010548a:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c010548d:	83 c2 02             	add    $0x2,%edx
+c0105490:	39 d0                	cmp    %edx,%eax
+c0105492:	74 24                	je     c01054b8 <check_vma_struct+0x3e3>
+c0105494:	c7 44 24 0c f0 9b 10 	movl   $0xc0109bf0,0xc(%esp)
+c010549b:	c0 
+c010549c:	c7 44 24 08 57 9a 10 	movl   $0xc0109a57,0x8(%esp)
+c01054a3:	c0 
+c01054a4:	c7 44 24 04 da 00 00 	movl   $0xda,0x4(%esp)
+c01054ab:	00 
+c01054ac:	c7 04 24 6c 9a 10 c0 	movl   $0xc0109a6c,(%esp)
+c01054b3:	e8 40 af ff ff       	call   c01003f8 <__panic>
         struct vma_struct *mmap = le2vma(le, list_link);
         assert(mmap->vm_start == i * 5 && mmap->vm_end == i * 5 + 2);
         le = list_next(le);
     }
 
     for (i = 5; i <= 5 * step2; i +=5) {
-c01052c0:	83 45 f4 05          	addl   $0x5,-0xc(%ebp)
-c01052c4:	8b 55 e0             	mov    -0x20(%ebp),%edx
-c01052c7:	89 d0                	mov    %edx,%eax
-c01052c9:	c1 e0 02             	shl    $0x2,%eax
-c01052cc:	01 d0                	add    %edx,%eax
-c01052ce:	3b 45 f4             	cmp    -0xc(%ebp),%eax
-c01052d1:	0f 8d 6d fe ff ff    	jge    c0105144 <check_vma_struct+0x1de>
+c01054b8:	83 45 f4 05          	addl   $0x5,-0xc(%ebp)
+c01054bc:	8b 55 e0             	mov    -0x20(%ebp),%edx
+c01054bf:	89 d0                	mov    %edx,%eax
+c01054c1:	c1 e0 02             	shl    $0x2,%eax
+c01054c4:	01 d0                	add    %edx,%eax
+c01054c6:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+c01054c9:	0f 8d 22 fe ff ff    	jge    c01052f1 <check_vma_struct+0x21c>
 
         assert(vma1->vm_start == i  && vma1->vm_end == i  + 2);
         assert(vma2->vm_start == i  && vma2->vm_end == i  + 2);
     }
 
     for (i =4; i>=0; i--) {
-c01052d7:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%ebp)
-c01052de:	eb 5c                	jmp    c010533c <check_vma_struct+0x3d6>
+c01054cf:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%ebp)
+c01054d6:	eb 6f                	jmp    c0105547 <check_vma_struct+0x472>
         struct vma_struct *vma_below_5= find_vma(mm,i);
-c01052e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c01052e3:	83 ec 08             	sub    $0x8,%esp
-c01052e6:	50                   	push   %eax
-c01052e7:	ff 75 e8             	pushl  -0x18(%ebp)
-c01052ea:	e8 50 f9 ff ff       	call   c0104c3f <find_vma>
-c01052ef:	83 c4 10             	add    $0x10,%esp
-c01052f2:	89 45 b8             	mov    %eax,-0x48(%ebp)
+c01054d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01054db:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01054df:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c01054e2:	89 04 24             	mov    %eax,(%esp)
+c01054e5:	e8 80 f8 ff ff       	call   c0104d6a <find_vma>
+c01054ea:	89 45 b8             	mov    %eax,-0x48(%ebp)
         if (vma_below_5 != NULL ) {
-c01052f5:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
-c01052f9:	74 1e                	je     c0105319 <check_vma_struct+0x3b3>
+c01054ed:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
+c01054f1:	74 27                	je     c010551a <check_vma_struct+0x445>
            cprintf("vma_below_5: i %x, start %x, end %x\n",i, vma_below_5->vm_start, vma_below_5->vm_end); 
-c01052fb:	8b 45 b8             	mov    -0x48(%ebp),%eax
-c01052fe:	8b 50 08             	mov    0x8(%eax),%edx
-c0105301:	8b 45 b8             	mov    -0x48(%ebp),%eax
-c0105304:	8b 40 04             	mov    0x4(%eax),%eax
-c0105307:	52                   	push   %edx
-c0105308:	50                   	push   %eax
-c0105309:	ff 75 f4             	pushl  -0xc(%ebp)
-c010530c:	68 f0 94 10 c0       	push   $0xc01094f0
-c0105311:	e8 6c af ff ff       	call   c0100282 <cprintf>
-c0105316:	83 c4 10             	add    $0x10,%esp
+c01054f3:	8b 45 b8             	mov    -0x48(%ebp),%eax
+c01054f6:	8b 50 08             	mov    0x8(%eax),%edx
+c01054f9:	8b 45 b8             	mov    -0x48(%ebp),%eax
+c01054fc:	8b 40 04             	mov    0x4(%eax),%eax
+c01054ff:	89 54 24 0c          	mov    %edx,0xc(%esp)
+c0105503:	89 44 24 08          	mov    %eax,0x8(%esp)
+c0105507:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010550a:	89 44 24 04          	mov    %eax,0x4(%esp)
+c010550e:	c7 04 24 20 9c 10 c0 	movl   $0xc0109c20,(%esp)
+c0105515:	e8 87 ad ff ff       	call   c01002a1 <cprintf>
         }
         assert(vma_below_5 == NULL);
-c0105319:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
-c010531d:	74 19                	je     c0105338 <check_vma_struct+0x3d2>
-c010531f:	68 15 95 10 c0       	push   $0xc0109515
-c0105324:	68 27 93 10 c0       	push   $0xc0109327
-c0105329:	68 e2 00 00 00       	push   $0xe2
-c010532e:	68 3c 93 10 c0       	push   $0xc010933c
-c0105333:	e8 b0 b0 ff ff       	call   c01003e8 <__panic>
+c010551a:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
+c010551e:	74 24                	je     c0105544 <check_vma_struct+0x46f>
+c0105520:	c7 44 24 0c 45 9c 10 	movl   $0xc0109c45,0xc(%esp)
+c0105527:	c0 
+c0105528:	c7 44 24 08 57 9a 10 	movl   $0xc0109a57,0x8(%esp)
+c010552f:	c0 
+c0105530:	c7 44 24 04 e2 00 00 	movl   $0xe2,0x4(%esp)
+c0105537:	00 
+c0105538:	c7 04 24 6c 9a 10 c0 	movl   $0xc0109a6c,(%esp)
+c010553f:	e8 b4 ae ff ff       	call   c01003f8 <__panic>
 
         assert(vma1->vm_start == i  && vma1->vm_end == i  + 2);
         assert(vma2->vm_start == i  && vma2->vm_end == i  + 2);
     }
 
     for (i =4; i>=0; i--) {
-c0105338:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
-c010533c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
-c0105340:	79 9e                	jns    c01052e0 <check_vma_struct+0x37a>
+c0105544:	ff 4d f4             	decl   -0xc(%ebp)
+c0105547:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c010554b:	79 8b                	jns    c01054d8 <check_vma_struct+0x403>
            cprintf("vma_below_5: i %x, start %x, end %x\n",i, vma_below_5->vm_start, vma_below_5->vm_end); 
         }
         assert(vma_below_5 == NULL);
     }
 
     mm_destroy(mm);
-c0105342:	83 ec 0c             	sub    $0xc,%esp
-c0105345:	ff 75 e8             	pushl  -0x18(%ebp)
-c0105348:	e8 42 fb ff ff       	call   c0104e8f <mm_destroy>
-c010534d:	83 c4 10             	add    $0x10,%esp
+c010554d:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0105550:	89 04 24             	mov    %eax,(%esp)
+c0105553:	e8 9a fa ff ff       	call   c0104ff2 <mm_destroy>
 
     assert(nr_free_pages_store == nr_free_pages());
-c0105350:	e8 60 e2 ff ff       	call   c01035b5 <nr_free_pages>
-c0105355:	3b 45 ec             	cmp    -0x14(%ebp),%eax
-c0105358:	74 19                	je     c0105373 <check_vma_struct+0x40d>
-c010535a:	68 a8 93 10 c0       	push   $0xc01093a8
-c010535f:	68 27 93 10 c0       	push   $0xc0109327
-c0105364:	68 e7 00 00 00       	push   $0xe7
-c0105369:	68 3c 93 10 c0       	push   $0xc010933c
-c010536e:	e8 75 b0 ff ff       	call   c01003e8 <__panic>
+c0105558:	e8 ae de ff ff       	call   c010340b <nr_free_pages>
+c010555d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+c0105560:	74 24                	je     c0105586 <check_vma_struct+0x4b1>
+c0105562:	c7 44 24 0c d8 9a 10 	movl   $0xc0109ad8,0xc(%esp)
+c0105569:	c0 
+c010556a:	c7 44 24 08 57 9a 10 	movl   $0xc0109a57,0x8(%esp)
+c0105571:	c0 
+c0105572:	c7 44 24 04 e7 00 00 	movl   $0xe7,0x4(%esp)
+c0105579:	00 
+c010557a:	c7 04 24 6c 9a 10 c0 	movl   $0xc0109a6c,(%esp)
+c0105581:	e8 72 ae ff ff       	call   c01003f8 <__panic>
 
     cprintf("check_vma_struct() succeeded!\n");
-c0105373:	83 ec 0c             	sub    $0xc,%esp
-c0105376:	68 2c 95 10 c0       	push   $0xc010952c
-c010537b:	e8 02 af ff ff       	call   c0100282 <cprintf>
-c0105380:	83 c4 10             	add    $0x10,%esp
-}
-c0105383:	90                   	nop
-c0105384:	c9                   	leave  
-c0105385:	c3                   	ret    
+c0105586:	c7 04 24 5c 9c 10 c0 	movl   $0xc0109c5c,(%esp)
+c010558d:	e8 0f ad ff ff       	call   c01002a1 <cprintf>
+}
+c0105592:	90                   	nop
+c0105593:	c9                   	leave  
+c0105594:	c3                   	ret    
 
-c0105386 <check_pgfault>:
+c0105595 <check_pgfault>:
 
 struct mm_struct *check_mm_struct;
 
 // check_pgfault - check correctness of pgfault handler
 static void
 check_pgfault(void) {
-c0105386:	55                   	push   %ebp
-c0105387:	89 e5                	mov    %esp,%ebp
-c0105389:	83 ec 28             	sub    $0x28,%esp
+c0105595:	55                   	push   %ebp
+c0105596:	89 e5                	mov    %esp,%ebp
+c0105598:	83 ec 38             	sub    $0x38,%esp
     size_t nr_free_pages_store = nr_free_pages();
-c010538c:	e8 24 e2 ff ff       	call   c01035b5 <nr_free_pages>
-c0105391:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c010559b:	e8 6b de ff ff       	call   c010340b <nr_free_pages>
+c01055a0:	89 45 ec             	mov    %eax,-0x14(%ebp)
 
     check_mm_struct = mm_create();
-c0105394:	e8 ee f7 ff ff       	call   c0104b87 <mm_create>
-c0105399:	a3 2c 30 12 c0       	mov    %eax,0xc012302c
+c01055a3:	e8 0f f7 ff ff       	call   c0104cb7 <mm_create>
+c01055a8:	a3 2c 40 12 c0       	mov    %eax,0xc012402c
     assert(check_mm_struct != NULL);
-c010539e:	a1 2c 30 12 c0       	mov    0xc012302c,%eax
-c01053a3:	85 c0                	test   %eax,%eax
-c01053a5:	75 19                	jne    c01053c0 <check_pgfault+0x3a>
-c01053a7:	68 4b 95 10 c0       	push   $0xc010954b
-c01053ac:	68 27 93 10 c0       	push   $0xc0109327
-c01053b1:	68 f4 00 00 00       	push   $0xf4
-c01053b6:	68 3c 93 10 c0       	push   $0xc010933c
-c01053bb:	e8 28 b0 ff ff       	call   c01003e8 <__panic>
+c01055ad:	a1 2c 40 12 c0       	mov    0xc012402c,%eax
+c01055b2:	85 c0                	test   %eax,%eax
+c01055b4:	75 24                	jne    c01055da <check_pgfault+0x45>
+c01055b6:	c7 44 24 0c 7b 9c 10 	movl   $0xc0109c7b,0xc(%esp)
+c01055bd:	c0 
+c01055be:	c7 44 24 08 57 9a 10 	movl   $0xc0109a57,0x8(%esp)
+c01055c5:	c0 
+c01055c6:	c7 44 24 04 f4 00 00 	movl   $0xf4,0x4(%esp)
+c01055cd:	00 
+c01055ce:	c7 04 24 6c 9a 10 c0 	movl   $0xc0109a6c,(%esp)
+c01055d5:	e8 1e ae ff ff       	call   c01003f8 <__panic>
 
     struct mm_struct *mm = check_mm_struct;
-c01053c0:	a1 2c 30 12 c0       	mov    0xc012302c,%eax
-c01053c5:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c01055da:	a1 2c 40 12 c0       	mov    0xc012402c,%eax
+c01055df:	89 45 e8             	mov    %eax,-0x18(%ebp)
     pde_t *pgdir = mm->pgdir = boot_pgdir;
-c01053c8:	8b 15 e0 f9 11 c0    	mov    0xc011f9e0,%edx
-c01053ce:	8b 45 e8             	mov    -0x18(%ebp),%eax
-c01053d1:	89 50 0c             	mov    %edx,0xc(%eax)
-c01053d4:	8b 45 e8             	mov    -0x18(%ebp),%eax
-c01053d7:	8b 40 0c             	mov    0xc(%eax),%eax
-c01053da:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+c01055e2:	8b 15 e0 09 12 c0    	mov    0xc01209e0,%edx
+c01055e8:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c01055eb:	89 50 0c             	mov    %edx,0xc(%eax)
+c01055ee:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c01055f1:	8b 40 0c             	mov    0xc(%eax),%eax
+c01055f4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
     assert(pgdir[0] == 0);
-c01053dd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-c01053e0:	8b 00                	mov    (%eax),%eax
-c01053e2:	85 c0                	test   %eax,%eax
-c01053e4:	74 19                	je     c01053ff <check_pgfault+0x79>
-c01053e6:	68 63 95 10 c0       	push   $0xc0109563
-c01053eb:	68 27 93 10 c0       	push   $0xc0109327
-c01053f0:	68 f8 00 00 00       	push   $0xf8
-c01053f5:	68 3c 93 10 c0       	push   $0xc010933c
-c01053fa:	e8 e9 af ff ff       	call   c01003e8 <__panic>
+c01055f7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c01055fa:	8b 00                	mov    (%eax),%eax
+c01055fc:	85 c0                	test   %eax,%eax
+c01055fe:	74 24                	je     c0105624 <check_pgfault+0x8f>
+c0105600:	c7 44 24 0c 93 9c 10 	movl   $0xc0109c93,0xc(%esp)
+c0105607:	c0 
+c0105608:	c7 44 24 08 57 9a 10 	movl   $0xc0109a57,0x8(%esp)
+c010560f:	c0 
+c0105610:	c7 44 24 04 f8 00 00 	movl   $0xf8,0x4(%esp)
+c0105617:	00 
+c0105618:	c7 04 24 6c 9a 10 c0 	movl   $0xc0109a6c,(%esp)
+c010561f:	e8 d4 ad ff ff       	call   c01003f8 <__panic>
 
     struct vma_struct *vma = vma_create(0, PTSIZE, VM_WRITE);
-c01053ff:	83 ec 04             	sub    $0x4,%esp
-c0105402:	6a 02                	push   $0x2
-c0105404:	68 00 00 40 00       	push   $0x400000
-c0105409:	6a 00                	push   $0x0
-c010540b:	e8 f3 f7 ff ff       	call   c0104c03 <vma_create>
-c0105410:	83 c4 10             	add    $0x10,%esp
-c0105413:	89 45 e0             	mov    %eax,-0x20(%ebp)
+c0105624:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
+c010562b:	00 
+c010562c:	c7 44 24 04 00 00 40 	movl   $0x400000,0x4(%esp)
+c0105633:	00 
+c0105634:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+c010563b:	e8 ef f6 ff ff       	call   c0104d2f <vma_create>
+c0105640:	89 45 e0             	mov    %eax,-0x20(%ebp)
     assert(vma != NULL);
-c0105416:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
-c010541a:	75 19                	jne    c0105435 <check_pgfault+0xaf>
-c010541c:	68 f2 93 10 c0       	push   $0xc01093f2
-c0105421:	68 27 93 10 c0       	push   $0xc0109327
-c0105426:	68 fb 00 00 00       	push   $0xfb
-c010542b:	68 3c 93 10 c0       	push   $0xc010933c
-c0105430:	e8 b3 af ff ff       	call   c01003e8 <__panic>
+c0105643:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+c0105647:	75 24                	jne    c010566d <check_pgfault+0xd8>
+c0105649:	c7 44 24 0c 22 9b 10 	movl   $0xc0109b22,0xc(%esp)
+c0105650:	c0 
+c0105651:	c7 44 24 08 57 9a 10 	movl   $0xc0109a57,0x8(%esp)
+c0105658:	c0 
+c0105659:	c7 44 24 04 fb 00 00 	movl   $0xfb,0x4(%esp)
+c0105660:	00 
+c0105661:	c7 04 24 6c 9a 10 c0 	movl   $0xc0109a6c,(%esp)
+c0105668:	e8 8b ad ff ff       	call   c01003f8 <__panic>
 
     insert_vma_struct(mm, vma);
-c0105435:	83 ec 08             	sub    $0x8,%esp
-c0105438:	ff 75 e0             	pushl  -0x20(%ebp)
-c010543b:	ff 75 e8             	pushl  -0x18(%ebp)
-c010543e:	e8 28 f9 ff ff       	call   c0104d6b <insert_vma_struct>
-c0105443:	83 c4 10             	add    $0x10,%esp
+c010566d:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0105670:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0105674:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0105677:	89 04 24             	mov    %eax,(%esp)
+c010567a:	e8 41 f8 ff ff       	call   c0104ec0 <insert_vma_struct>
 
     uintptr_t addr = 0x100;
-c0105446:	c7 45 dc 00 01 00 00 	movl   $0x100,-0x24(%ebp)
+c010567f:	c7 45 dc 00 01 00 00 	movl   $0x100,-0x24(%ebp)
     assert(find_vma(mm, addr) == vma);
-c010544d:	83 ec 08             	sub    $0x8,%esp
-c0105450:	ff 75 dc             	pushl  -0x24(%ebp)
-c0105453:	ff 75 e8             	pushl  -0x18(%ebp)
-c0105456:	e8 e4 f7 ff ff       	call   c0104c3f <find_vma>
-c010545b:	83 c4 10             	add    $0x10,%esp
-c010545e:	3b 45 e0             	cmp    -0x20(%ebp),%eax
-c0105461:	74 19                	je     c010547c <check_pgfault+0xf6>
-c0105463:	68 71 95 10 c0       	push   $0xc0109571
-c0105468:	68 27 93 10 c0       	push   $0xc0109327
-c010546d:	68 00 01 00 00       	push   $0x100
-c0105472:	68 3c 93 10 c0       	push   $0xc010933c
-c0105477:	e8 6c af ff ff       	call   c01003e8 <__panic>
+c0105686:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0105689:	89 44 24 04          	mov    %eax,0x4(%esp)
+c010568d:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0105690:	89 04 24             	mov    %eax,(%esp)
+c0105693:	e8 d2 f6 ff ff       	call   c0104d6a <find_vma>
+c0105698:	3b 45 e0             	cmp    -0x20(%ebp),%eax
+c010569b:	74 24                	je     c01056c1 <check_pgfault+0x12c>
+c010569d:	c7 44 24 0c a1 9c 10 	movl   $0xc0109ca1,0xc(%esp)
+c01056a4:	c0 
+c01056a5:	c7 44 24 08 57 9a 10 	movl   $0xc0109a57,0x8(%esp)
+c01056ac:	c0 
+c01056ad:	c7 44 24 04 00 01 00 	movl   $0x100,0x4(%esp)
+c01056b4:	00 
+c01056b5:	c7 04 24 6c 9a 10 c0 	movl   $0xc0109a6c,(%esp)
+c01056bc:	e8 37 ad ff ff       	call   c01003f8 <__panic>
 
     int i, sum = 0;
-c010547c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+c01056c1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
     for (i = 0; i < 100; i ++) {
-c0105483:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
-c010548a:	eb 19                	jmp    c01054a5 <check_pgfault+0x11f>
+c01056c8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+c01056cf:	eb 16                	jmp    c01056e7 <check_pgfault+0x152>
         *(char *)(addr + i) = i;
-c010548c:	8b 55 f4             	mov    -0xc(%ebp),%edx
-c010548f:	8b 45 dc             	mov    -0x24(%ebp),%eax
-c0105492:	01 d0                	add    %edx,%eax
-c0105494:	89 c2                	mov    %eax,%edx
-c0105496:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0105499:	88 02                	mov    %al,(%edx)
+c01056d1:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c01056d4:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c01056d7:	01 d0                	add    %edx,%eax
+c01056d9:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c01056dc:	88 10                	mov    %dl,(%eax)
         sum += i;
-c010549b:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c010549e:	01 45 f0             	add    %eax,-0x10(%ebp)
+c01056de:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01056e1:	01 45 f0             	add    %eax,-0x10(%ebp)
 
     uintptr_t addr = 0x100;
     assert(find_vma(mm, addr) == vma);
 
     int i, sum = 0;
     for (i = 0; i < 100; i ++) {
-c01054a1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
-c01054a5:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
-c01054a9:	7e e1                	jle    c010548c <check_pgfault+0x106>
+c01056e4:	ff 45 f4             	incl   -0xc(%ebp)
+c01056e7:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
+c01056eb:	7e e4                	jle    c01056d1 <check_pgfault+0x13c>
         *(char *)(addr + i) = i;
         sum += i;
     }
     for (i = 0; i < 100; i ++) {
-c01054ab:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
-c01054b2:	eb 15                	jmp    c01054c9 <check_pgfault+0x143>
+c01056ed:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+c01056f4:	eb 14                	jmp    c010570a <check_pgfault+0x175>
         sum -= *(char *)(addr + i);
-c01054b4:	8b 55 f4             	mov    -0xc(%ebp),%edx
-c01054b7:	8b 45 dc             	mov    -0x24(%ebp),%eax
-c01054ba:	01 d0                	add    %edx,%eax
-c01054bc:	0f b6 00             	movzbl (%eax),%eax
-c01054bf:	0f be c0             	movsbl %al,%eax
-c01054c2:	29 45 f0             	sub    %eax,-0x10(%ebp)
+c01056f6:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c01056f9:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c01056fc:	01 d0                	add    %edx,%eax
+c01056fe:	0f b6 00             	movzbl (%eax),%eax
+c0105701:	0f be c0             	movsbl %al,%eax
+c0105704:	29 45 f0             	sub    %eax,-0x10(%ebp)
     int i, sum = 0;
     for (i = 0; i < 100; i ++) {
         *(char *)(addr + i) = i;
         sum += i;
     }
     for (i = 0; i < 100; i ++) {
-c01054c5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
-c01054c9:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
-c01054cd:	7e e5                	jle    c01054b4 <check_pgfault+0x12e>
+c0105707:	ff 45 f4             	incl   -0xc(%ebp)
+c010570a:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
+c010570e:	7e e6                	jle    c01056f6 <check_pgfault+0x161>
         sum -= *(char *)(addr + i);
     }
     assert(sum == 0);
-c01054cf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
-c01054d3:	74 19                	je     c01054ee <check_pgfault+0x168>
-c01054d5:	68 8b 95 10 c0       	push   $0xc010958b
-c01054da:	68 27 93 10 c0       	push   $0xc0109327
-c01054df:	68 0a 01 00 00       	push   $0x10a
-c01054e4:	68 3c 93 10 c0       	push   $0xc010933c
-c01054e9:	e8 fa ae ff ff       	call   c01003e8 <__panic>
+c0105710:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c0105714:	74 24                	je     c010573a <check_pgfault+0x1a5>
+c0105716:	c7 44 24 0c bb 9c 10 	movl   $0xc0109cbb,0xc(%esp)
+c010571d:	c0 
+c010571e:	c7 44 24 08 57 9a 10 	movl   $0xc0109a57,0x8(%esp)
+c0105725:	c0 
+c0105726:	c7 44 24 04 0a 01 00 	movl   $0x10a,0x4(%esp)
+c010572d:	00 
+c010572e:	c7 04 24 6c 9a 10 c0 	movl   $0xc0109a6c,(%esp)
+c0105735:	e8 be ac ff ff       	call   c01003f8 <__panic>
 
     page_remove(pgdir, ROUNDDOWN(addr, PGSIZE));
-c01054ee:	8b 45 dc             	mov    -0x24(%ebp),%eax
-c01054f1:	89 45 d8             	mov    %eax,-0x28(%ebp)
-c01054f4:	8b 45 d8             	mov    -0x28(%ebp),%eax
-c01054f7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
-c01054fc:	83 ec 08             	sub    $0x8,%esp
-c01054ff:	50                   	push   %eax
-c0105500:	ff 75 e4             	pushl  -0x1c(%ebp)
-c0105503:	e8 4b e8 ff ff       	call   c0103d53 <page_remove>
-c0105508:	83 c4 10             	add    $0x10,%esp
+c010573a:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c010573d:	89 45 d8             	mov    %eax,-0x28(%ebp)
+c0105740:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c0105743:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+c0105748:	89 44 24 04          	mov    %eax,0x4(%esp)
+c010574c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c010574f:	89 04 24             	mov    %eax,(%esp)
+c0105752:	e8 fb e4 ff ff       	call   c0103c52 <page_remove>
     free_page(pde2page(pgdir[0]));
-c010550b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-c010550e:	8b 00                	mov    (%eax),%eax
-c0105510:	83 ec 0c             	sub    $0xc,%esp
-c0105513:	50                   	push   %eax
-c0105514:	e8 52 f6 ff ff       	call   c0104b6b <pde2page>
-c0105519:	83 c4 10             	add    $0x10,%esp
-c010551c:	83 ec 08             	sub    $0x8,%esp
-c010551f:	6a 01                	push   $0x1
-c0105521:	50                   	push   %eax
-c0105522:	e8 59 e0 ff ff       	call   c0103580 <free_pages>
-c0105527:	83 c4 10             	add    $0x10,%esp
+c0105757:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c010575a:	8b 00                	mov    (%eax),%eax
+c010575c:	89 04 24             	mov    %eax,(%esp)
+c010575f:	e8 3b f5 ff ff       	call   c0104c9f <pde2page>
+c0105764:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+c010576b:	00 
+c010576c:	89 04 24             	mov    %eax,(%esp)
+c010576f:	e8 64 dc ff ff       	call   c01033d8 <free_pages>
     pgdir[0] = 0;
-c010552a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-c010552d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
+c0105774:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0105777:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
 
     mm->pgdir = NULL;
-c0105533:	8b 45 e8             	mov    -0x18(%ebp),%eax
-c0105536:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
+c010577d:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0105780:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
     mm_destroy(mm);
-c010553d:	83 ec 0c             	sub    $0xc,%esp
-c0105540:	ff 75 e8             	pushl  -0x18(%ebp)
-c0105543:	e8 47 f9 ff ff       	call   c0104e8f <mm_destroy>
-c0105548:	83 c4 10             	add    $0x10,%esp
+c0105787:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c010578a:	89 04 24             	mov    %eax,(%esp)
+c010578d:	e8 60 f8 ff ff       	call   c0104ff2 <mm_destroy>
     check_mm_struct = NULL;
-c010554b:	c7 05 2c 30 12 c0 00 	movl   $0x0,0xc012302c
-c0105552:	00 00 00 
+c0105792:	c7 05 2c 40 12 c0 00 	movl   $0x0,0xc012402c
+c0105799:	00 00 00 
 
     assert(nr_free_pages_store == nr_free_pages());
-c0105555:	e8 5b e0 ff ff       	call   c01035b5 <nr_free_pages>
-c010555a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
-c010555d:	74 19                	je     c0105578 <check_pgfault+0x1f2>
-c010555f:	68 a8 93 10 c0       	push   $0xc01093a8
-c0105564:	68 27 93 10 c0       	push   $0xc0109327
-c0105569:	68 14 01 00 00       	push   $0x114
-c010556e:	68 3c 93 10 c0       	push   $0xc010933c
-c0105573:	e8 70 ae ff ff       	call   c01003e8 <__panic>
+c010579c:	e8 6a dc ff ff       	call   c010340b <nr_free_pages>
+c01057a1:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+c01057a4:	74 24                	je     c01057ca <check_pgfault+0x235>
+c01057a6:	c7 44 24 0c d8 9a 10 	movl   $0xc0109ad8,0xc(%esp)
+c01057ad:	c0 
+c01057ae:	c7 44 24 08 57 9a 10 	movl   $0xc0109a57,0x8(%esp)
+c01057b5:	c0 
+c01057b6:	c7 44 24 04 14 01 00 	movl   $0x114,0x4(%esp)
+c01057bd:	00 
+c01057be:	c7 04 24 6c 9a 10 c0 	movl   $0xc0109a6c,(%esp)
+c01057c5:	e8 2e ac ff ff       	call   c01003f8 <__panic>
 
     cprintf("check_pgfault() succeeded!\n");
-c0105578:	83 ec 0c             	sub    $0xc,%esp
-c010557b:	68 94 95 10 c0       	push   $0xc0109594
-c0105580:	e8 fd ac ff ff       	call   c0100282 <cprintf>
-c0105585:	83 c4 10             	add    $0x10,%esp
-}
-c0105588:	90                   	nop
-c0105589:	c9                   	leave  
-c010558a:	c3                   	ret    
+c01057ca:	c7 04 24 c4 9c 10 c0 	movl   $0xc0109cc4,(%esp)
+c01057d1:	e8 cb aa ff ff       	call   c01002a1 <cprintf>
+}
+c01057d6:	90                   	nop
+c01057d7:	c9                   	leave  
+c01057d8:	c3                   	ret    
 
-c010558b <do_pgfault>:
+c01057d9 <do_pgfault>:
  *            was a read (0) or write (1).
  *         -- The U/S flag (bit 2) indicates whether the processor was executing at user mode (1)
  *            or supervisor mode (0) at the time of the exception.
  */
 int
 do_pgfault(struct mm_struct *mm, uint32_t error_code, uintptr_t addr) {
-c010558b:	55                   	push   %ebp
-c010558c:	89 e5                	mov    %esp,%ebp
-c010558e:	83 ec 28             	sub    $0x28,%esp
+c01057d9:	55                   	push   %ebp
+c01057da:	89 e5                	mov    %esp,%ebp
+c01057dc:	83 ec 38             	sub    $0x38,%esp
     int ret = -E_INVAL;
-c0105591:	c7 45 f4 fd ff ff ff 	movl   $0xfffffffd,-0xc(%ebp)
+c01057df:	c7 45 f4 fd ff ff ff 	movl   $0xfffffffd,-0xc(%ebp)
     //try to find a vma which include addr
     struct vma_struct *vma = find_vma(mm, addr);
-c0105598:	ff 75 10             	pushl  0x10(%ebp)
-c010559b:	ff 75 08             	pushl  0x8(%ebp)
-c010559e:	e8 9c f6 ff ff       	call   c0104c3f <find_vma>
-c01055a3:	83 c4 08             	add    $0x8,%esp
-c01055a6:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c01057e6:	8b 45 10             	mov    0x10(%ebp),%eax
+c01057e9:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01057ed:	8b 45 08             	mov    0x8(%ebp),%eax
+c01057f0:	89 04 24             	mov    %eax,(%esp)
+c01057f3:	e8 72 f5 ff ff       	call   c0104d6a <find_vma>
+c01057f8:	89 45 ec             	mov    %eax,-0x14(%ebp)
 
     pgfault_num++;
-c01055a9:	a1 0c 30 12 c0       	mov    0xc012300c,%eax
-c01055ae:	83 c0 01             	add    $0x1,%eax
-c01055b1:	a3 0c 30 12 c0       	mov    %eax,0xc012300c
+c01057fb:	a1 0c 40 12 c0       	mov    0xc012400c,%eax
+c0105800:	40                   	inc    %eax
+c0105801:	a3 0c 40 12 c0       	mov    %eax,0xc012400c
     //If the addr is in the range of a mm's vma?
     if (vma == NULL || vma->vm_start > addr) {
-c01055b6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
-c01055ba:	74 0b                	je     c01055c7 <do_pgfault+0x3c>
-c01055bc:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c01055bf:	8b 40 04             	mov    0x4(%eax),%eax
-c01055c2:	3b 45 10             	cmp    0x10(%ebp),%eax
-c01055c5:	76 18                	jbe    c01055df <do_pgfault+0x54>
+c0105806:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+c010580a:	74 0b                	je     c0105817 <do_pgfault+0x3e>
+c010580c:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c010580f:	8b 40 04             	mov    0x4(%eax),%eax
+c0105812:	3b 45 10             	cmp    0x10(%ebp),%eax
+c0105815:	76 18                	jbe    c010582f <do_pgfault+0x56>
         cprintf("not valid addr %x, and  can not find it in vma\n", addr);
-c01055c7:	83 ec 08             	sub    $0x8,%esp
-c01055ca:	ff 75 10             	pushl  0x10(%ebp)
-c01055cd:	68 b0 95 10 c0       	push   $0xc01095b0
-c01055d2:	e8 ab ac ff ff       	call   c0100282 <cprintf>
-c01055d7:	83 c4 10             	add    $0x10,%esp
+c0105817:	8b 45 10             	mov    0x10(%ebp),%eax
+c010581a:	89 44 24 04          	mov    %eax,0x4(%esp)
+c010581e:	c7 04 24 e0 9c 10 c0 	movl   $0xc0109ce0,(%esp)
+c0105825:	e8 77 aa ff ff       	call   c01002a1 <cprintf>
         goto failed;
-c01055da:	e9 aa 01 00 00       	jmp    c0105789 <do_pgfault+0x1fe>
+c010582a:	e9 ba 01 00 00       	jmp    c01059e9 <do_pgfault+0x210>
     }
     //check the error_code
     switch (error_code & 3) {
-c01055df:	8b 45 0c             	mov    0xc(%ebp),%eax
-c01055e2:	83 e0 03             	and    $0x3,%eax
-c01055e5:	85 c0                	test   %eax,%eax
-c01055e7:	74 3c                	je     c0105625 <do_pgfault+0x9a>
-c01055e9:	83 f8 01             	cmp    $0x1,%eax
-c01055ec:	74 22                	je     c0105610 <do_pgfault+0x85>
+c010582f:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0105832:	83 e0 03             	and    $0x3,%eax
+c0105835:	85 c0                	test   %eax,%eax
+c0105837:	74 34                	je     c010586d <do_pgfault+0x94>
+c0105839:	83 f8 01             	cmp    $0x1,%eax
+c010583c:	74 1e                	je     c010585c <do_pgfault+0x83>
     default:
             /* error code flag : default is 3 ( W/R=1, P=1): write, present */
     case 2: /* error code flag : (W/R=1, P=0): write, not present */
         if (!(vma->vm_flags & VM_WRITE)) {
-c01055ee:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c01055f1:	8b 40 0c             	mov    0xc(%eax),%eax
-c01055f4:	83 e0 02             	and    $0x2,%eax
-c01055f7:	85 c0                	test   %eax,%eax
-c01055f9:	75 4c                	jne    c0105647 <do_pgfault+0xbc>
+c010583e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0105841:	8b 40 0c             	mov    0xc(%eax),%eax
+c0105844:	83 e0 02             	and    $0x2,%eax
+c0105847:	85 c0                	test   %eax,%eax
+c0105849:	75 40                	jne    c010588b <do_pgfault+0xb2>
             cprintf("do_pgfault failed: error code flag = write AND not present, but the addr's vma cannot write\n");
-c01055fb:	83 ec 0c             	sub    $0xc,%esp
-c01055fe:	68 e0 95 10 c0       	push   $0xc01095e0
-c0105603:	e8 7a ac ff ff       	call   c0100282 <cprintf>
-c0105608:	83 c4 10             	add    $0x10,%esp
+c010584b:	c7 04 24 10 9d 10 c0 	movl   $0xc0109d10,(%esp)
+c0105852:	e8 4a aa ff ff       	call   c01002a1 <cprintf>
             goto failed;
-c010560b:	e9 79 01 00 00       	jmp    c0105789 <do_pgfault+0x1fe>
+c0105857:	e9 8d 01 00 00       	jmp    c01059e9 <do_pgfault+0x210>
         }
         break;
     case 1: /* error code flag : (W/R=0, P=1): read, present */
         cprintf("do_pgfault failed: error code flag = read AND present\n");
-c0105610:	83 ec 0c             	sub    $0xc,%esp
-c0105613:	68 40 96 10 c0       	push   $0xc0109640
-c0105618:	e8 65 ac ff ff       	call   c0100282 <cprintf>
-c010561d:	83 c4 10             	add    $0x10,%esp
+c010585c:	c7 04 24 70 9d 10 c0 	movl   $0xc0109d70,(%esp)
+c0105863:	e8 39 aa ff ff       	call   c01002a1 <cprintf>
         goto failed;
-c0105620:	e9 64 01 00 00       	jmp    c0105789 <do_pgfault+0x1fe>
+c0105868:	e9 7c 01 00 00       	jmp    c01059e9 <do_pgfault+0x210>
     case 0: /* error code flag : (W/R=0, P=0): read, not present */
         if (!(vma->vm_flags & (VM_READ | VM_EXEC))) {
-c0105625:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c0105628:	8b 40 0c             	mov    0xc(%eax),%eax
-c010562b:	83 e0 05             	and    $0x5,%eax
-c010562e:	85 c0                	test   %eax,%eax
-c0105630:	75 16                	jne    c0105648 <do_pgfault+0xbd>
+c010586d:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0105870:	8b 40 0c             	mov    0xc(%eax),%eax
+c0105873:	83 e0 05             	and    $0x5,%eax
+c0105876:	85 c0                	test   %eax,%eax
+c0105878:	75 12                	jne    c010588c <do_pgfault+0xb3>
             cprintf("do_pgfault failed: error code flag = read AND not present, but the addr's vma cannot read or exec\n");
-c0105632:	83 ec 0c             	sub    $0xc,%esp
-c0105635:	68 78 96 10 c0       	push   $0xc0109678
-c010563a:	e8 43 ac ff ff       	call   c0100282 <cprintf>
-c010563f:	83 c4 10             	add    $0x10,%esp
+c010587a:	c7 04 24 a8 9d 10 c0 	movl   $0xc0109da8,(%esp)
+c0105881:	e8 1b aa ff ff       	call   c01002a1 <cprintf>
             goto failed;
-c0105642:	e9 42 01 00 00       	jmp    c0105789 <do_pgfault+0x1fe>
+c0105886:	e9 5e 01 00 00       	jmp    c01059e9 <do_pgfault+0x210>
     case 2: /* error code flag : (W/R=1, P=0): write, not present */
         if (!(vma->vm_flags & VM_WRITE)) {
             cprintf("do_pgfault failed: error code flag = write AND not present, but the addr's vma cannot write\n");
             goto failed;
         }
         break;
-c0105647:	90                   	nop
+c010588b:	90                   	nop
      *    (write an non_existed addr && addr is writable) OR
      *    (read  an non_existed addr && addr is readable)
      * THEN
      *    continue process
      */
     uint32_t perm = PTE_U;
-c0105648:	c7 45 f0 04 00 00 00 	movl   $0x4,-0x10(%ebp)
+c010588c:	c7 45 f0 04 00 00 00 	movl   $0x4,-0x10(%ebp)
     if (vma->vm_flags & VM_WRITE) {
-c010564f:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c0105652:	8b 40 0c             	mov    0xc(%eax),%eax
-c0105655:	83 e0 02             	and    $0x2,%eax
-c0105658:	85 c0                	test   %eax,%eax
-c010565a:	74 04                	je     c0105660 <do_pgfault+0xd5>
+c0105893:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0105896:	8b 40 0c             	mov    0xc(%eax),%eax
+c0105899:	83 e0 02             	and    $0x2,%eax
+c010589c:	85 c0                	test   %eax,%eax
+c010589e:	74 04                	je     c01058a4 <do_pgfault+0xcb>
         perm |= PTE_W;
-c010565c:	83 4d f0 02          	orl    $0x2,-0x10(%ebp)
+c01058a0:	83 4d f0 02          	orl    $0x2,-0x10(%ebp)
     }
     addr = ROUNDDOWN(addr, PGSIZE);
-c0105660:	8b 45 10             	mov    0x10(%ebp),%eax
-c0105663:	89 45 e8             	mov    %eax,-0x18(%ebp)
-c0105666:	8b 45 e8             	mov    -0x18(%ebp),%eax
-c0105669:	25 00 f0 ff ff       	and    $0xfffff000,%eax
-c010566e:	89 45 10             	mov    %eax,0x10(%ebp)
+c01058a4:	8b 45 10             	mov    0x10(%ebp),%eax
+c01058a7:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c01058aa:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c01058ad:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+c01058b2:	89 45 10             	mov    %eax,0x10(%ebp)
 
     ret = -E_NO_MEM;
-c0105671:	c7 45 f4 fc ff ff ff 	movl   $0xfffffffc,-0xc(%ebp)
+c01058b5:	c7 45 f4 fc ff ff ff 	movl   $0xfffffffc,-0xc(%ebp)
 
     pte_t *ptep=NULL;
-c0105678:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+c01058bc:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
         }
    }
 #endif
     // try to find a pte, if pte's PT(Page Table) isn't existed, then create a PT.
     // (notice the 3th parameter '1')
     if ((ptep = get_pte(mm->pgdir, addr, 1)) == NULL) {
-c010567f:	8b 45 08             	mov    0x8(%ebp),%eax
-c0105682:	8b 40 0c             	mov    0xc(%eax),%eax
-c0105685:	83 ec 04             	sub    $0x4,%esp
-c0105688:	6a 01                	push   $0x1
-c010568a:	ff 75 10             	pushl  0x10(%ebp)
-c010568d:	50                   	push   %eax
-c010568e:	e8 e8 e4 ff ff       	call   c0103b7b <get_pte>
-c0105693:	83 c4 10             	add    $0x10,%esp
-c0105696:	89 45 e4             	mov    %eax,-0x1c(%ebp)
-c0105699:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
-c010569d:	75 15                	jne    c01056b4 <do_pgfault+0x129>
+c01058c3:	8b 45 08             	mov    0x8(%ebp),%eax
+c01058c6:	8b 40 0c             	mov    0xc(%eax),%eax
+c01058c9:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+c01058d0:	00 
+c01058d1:	8b 55 10             	mov    0x10(%ebp),%edx
+c01058d4:	89 54 24 04          	mov    %edx,0x4(%esp)
+c01058d8:	89 04 24             	mov    %eax,(%esp)
+c01058db:	e8 5a e1 ff ff       	call   c0103a3a <get_pte>
+c01058e0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+c01058e3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+c01058e7:	75 11                	jne    c01058fa <do_pgfault+0x121>
         cprintf("get_pte in do_pgfault failed\n");
-c010569f:	83 ec 0c             	sub    $0xc,%esp
-c01056a2:	68 db 96 10 c0       	push   $0xc01096db
-c01056a7:	e8 d6 ab ff ff       	call   c0100282 <cprintf>
-c01056ac:	83 c4 10             	add    $0x10,%esp
+c01058e9:	c7 04 24 0b 9e 10 c0 	movl   $0xc0109e0b,(%esp)
+c01058f0:	e8 ac a9 ff ff       	call   c01002a1 <cprintf>
         goto failed;
-c01056af:	e9 d5 00 00 00       	jmp    c0105789 <do_pgfault+0x1fe>
+c01058f5:	e9 ef 00 00 00       	jmp    c01059e9 <do_pgfault+0x210>
     }
     
     if (*ptep == 0) { // if the phy addr isn't exist, then alloc a page & map the phy addr with logical addr
-c01056b4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-c01056b7:	8b 00                	mov    (%eax),%eax
-c01056b9:	85 c0                	test   %eax,%eax
-c01056bb:	75 35                	jne    c01056f2 <do_pgfault+0x167>
+c01058fa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c01058fd:	8b 00                	mov    (%eax),%eax
+c01058ff:	85 c0                	test   %eax,%eax
+c0105901:	75 35                	jne    c0105938 <do_pgfault+0x15f>
         if (pgdir_alloc_page(mm->pgdir, addr, perm) == NULL) {
-c01056bd:	8b 45 08             	mov    0x8(%ebp),%eax
-c01056c0:	8b 40 0c             	mov    0xc(%eax),%eax
-c01056c3:	83 ec 04             	sub    $0x4,%esp
-c01056c6:	ff 75 f0             	pushl  -0x10(%ebp)
-c01056c9:	ff 75 10             	pushl  0x10(%ebp)
-c01056cc:	50                   	push   %eax
-c01056cd:	e8 c3 e7 ff ff       	call   c0103e95 <pgdir_alloc_page>
-c01056d2:	83 c4 10             	add    $0x10,%esp
-c01056d5:	85 c0                	test   %eax,%eax
-c01056d7:	0f 85 a5 00 00 00    	jne    c0105782 <do_pgfault+0x1f7>
+c0105903:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105906:	8b 40 0c             	mov    0xc(%eax),%eax
+c0105909:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c010590c:	89 54 24 08          	mov    %edx,0x8(%esp)
+c0105910:	8b 55 10             	mov    0x10(%ebp),%edx
+c0105913:	89 54 24 04          	mov    %edx,0x4(%esp)
+c0105917:	89 04 24             	mov    %eax,(%esp)
+c010591a:	e8 8d e4 ff ff       	call   c0103dac <pgdir_alloc_page>
+c010591f:	85 c0                	test   %eax,%eax
+c0105921:	0f 85 bb 00 00 00    	jne    c01059e2 <do_pgfault+0x209>
             cprintf("pgdir_alloc_page in do_pgfault failed\n");
-c01056dd:	83 ec 0c             	sub    $0xc,%esp
-c01056e0:	68 fc 96 10 c0       	push   $0xc01096fc
-c01056e5:	e8 98 ab ff ff       	call   c0100282 <cprintf>
-c01056ea:	83 c4 10             	add    $0x10,%esp
+c0105927:	c7 04 24 2c 9e 10 c0 	movl   $0xc0109e2c,(%esp)
+c010592e:	e8 6e a9 ff ff       	call   c01002a1 <cprintf>
             goto failed;
-c01056ed:	e9 97 00 00 00       	jmp    c0105789 <do_pgfault+0x1fe>
+c0105933:	e9 b1 00 00 00       	jmp    c01059e9 <do_pgfault+0x210>
         }
     }
     else { // if this pte is a swap entry, then load data from disk to a page with phy addr
            // and call page_insert to map the phy addr with logical addr
         if(swap_init_ok) {
-c01056f2:	a1 10 30 12 c0       	mov    0xc0123010,%eax
-c01056f7:	85 c0                	test   %eax,%eax
-c01056f9:	74 6f                	je     c010576a <do_pgfault+0x1df>
+c0105938:	a1 10 40 12 c0       	mov    0xc0124010,%eax
+c010593d:	85 c0                	test   %eax,%eax
+c010593f:	0f 84 86 00 00 00    	je     c01059cb <do_pgfault+0x1f2>
             struct Page *page=NULL;
-c01056fb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
+c0105945:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
             if ((ret = swap_in(mm, addr, &page)) != 0) {
-c0105702:	83 ec 04             	sub    $0x4,%esp
-c0105705:	8d 45 e0             	lea    -0x20(%ebp),%eax
-c0105708:	50                   	push   %eax
-c0105709:	ff 75 10             	pushl  0x10(%ebp)
-c010570c:	ff 75 08             	pushl  0x8(%ebp)
-c010570f:	e8 3a 03 00 00       	call   c0105a4e <swap_in>
-c0105714:	83 c4 10             	add    $0x10,%esp
-c0105717:	89 45 f4             	mov    %eax,-0xc(%ebp)
-c010571a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
-c010571e:	74 12                	je     c0105732 <do_pgfault+0x1a7>
+c010594c:	8d 45 e0             	lea    -0x20(%ebp),%eax
+c010594f:	89 44 24 08          	mov    %eax,0x8(%esp)
+c0105953:	8b 45 10             	mov    0x10(%ebp),%eax
+c0105956:	89 44 24 04          	mov    %eax,0x4(%esp)
+c010595a:	8b 45 08             	mov    0x8(%ebp),%eax
+c010595d:	89 04 24             	mov    %eax,(%esp)
+c0105960:	e8 8e 03 00 00       	call   c0105cf3 <swap_in>
+c0105965:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0105968:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c010596c:	74 0e                	je     c010597c <do_pgfault+0x1a3>
                 cprintf("swap_in in do_pgfault failed\n");
-c0105720:	83 ec 0c             	sub    $0xc,%esp
-c0105723:	68 23 97 10 c0       	push   $0xc0109723
-c0105728:	e8 55 ab ff ff       	call   c0100282 <cprintf>
-c010572d:	83 c4 10             	add    $0x10,%esp
-c0105730:	eb 57                	jmp    c0105789 <do_pgfault+0x1fe>
+c010596e:	c7 04 24 53 9e 10 c0 	movl   $0xc0109e53,(%esp)
+c0105975:	e8 27 a9 ff ff       	call   c01002a1 <cprintf>
+c010597a:	eb 6d                	jmp    c01059e9 <do_pgfault+0x210>
                 goto failed;
             }    
             page_insert(mm->pgdir, page, addr, perm);
-c0105732:	8b 55 e0             	mov    -0x20(%ebp),%edx
-c0105735:	8b 45 08             	mov    0x8(%ebp),%eax
-c0105738:	8b 40 0c             	mov    0xc(%eax),%eax
-c010573b:	ff 75 f0             	pushl  -0x10(%ebp)
-c010573e:	ff 75 10             	pushl  0x10(%ebp)
-c0105741:	52                   	push   %edx
-c0105742:	50                   	push   %eax
-c0105743:	e8 44 e6 ff ff       	call   c0103d8c <page_insert>
-c0105748:	83 c4 10             	add    $0x10,%esp
+c010597c:	8b 55 e0             	mov    -0x20(%ebp),%edx
+c010597f:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105982:	8b 40 0c             	mov    0xc(%eax),%eax
+c0105985:	8b 4d f0             	mov    -0x10(%ebp),%ecx
+c0105988:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
+c010598c:	8b 4d 10             	mov    0x10(%ebp),%ecx
+c010598f:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+c0105993:	89 54 24 04          	mov    %edx,0x4(%esp)
+c0105997:	89 04 24             	mov    %eax,(%esp)
+c010599a:	e8 f8 e2 ff ff       	call   c0103c97 <page_insert>
             swap_map_swappable(mm, addr, page, 1);
-c010574b:	8b 45 e0             	mov    -0x20(%ebp),%eax
-c010574e:	6a 01                	push   $0x1
-c0105750:	50                   	push   %eax
-c0105751:	ff 75 10             	pushl  0x10(%ebp)
-c0105754:	ff 75 08             	pushl  0x8(%ebp)
-c0105757:	e8 62 01 00 00       	call   c01058be <swap_map_swappable>
-c010575c:	83 c4 10             	add    $0x10,%esp
+c010599f:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c01059a2:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
+c01059a9:	00 
+c01059aa:	89 44 24 08          	mov    %eax,0x8(%esp)
+c01059ae:	8b 45 10             	mov    0x10(%ebp),%eax
+c01059b1:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01059b5:	8b 45 08             	mov    0x8(%ebp),%eax
+c01059b8:	89 04 24             	mov    %eax,(%esp)
+c01059bb:	e8 71 01 00 00       	call   c0105b31 <swap_map_swappable>
             page->pra_vaddr = addr;
-c010575f:	8b 45 e0             	mov    -0x20(%ebp),%eax
-c0105762:	8b 55 10             	mov    0x10(%ebp),%edx
-c0105765:	89 50 1c             	mov    %edx,0x1c(%eax)
-c0105768:	eb 18                	jmp    c0105782 <do_pgfault+0x1f7>
+c01059c0:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c01059c3:	8b 55 10             	mov    0x10(%ebp),%edx
+c01059c6:	89 50 1c             	mov    %edx,0x1c(%eax)
+c01059c9:	eb 17                	jmp    c01059e2 <do_pgfault+0x209>
         }
         else {
             cprintf("no swap_init_ok but ptep is %x, failed\n",*ptep);
-c010576a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-c010576d:	8b 00                	mov    (%eax),%eax
-c010576f:	83 ec 08             	sub    $0x8,%esp
-c0105772:	50                   	push   %eax
-c0105773:	68 44 97 10 c0       	push   $0xc0109744
-c0105778:	e8 05 ab ff ff       	call   c0100282 <cprintf>
-c010577d:	83 c4 10             	add    $0x10,%esp
+c01059cb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c01059ce:	8b 00                	mov    (%eax),%eax
+c01059d0:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01059d4:	c7 04 24 74 9e 10 c0 	movl   $0xc0109e74,(%esp)
+c01059db:	e8 c1 a8 ff ff       	call   c01002a1 <cprintf>
             goto failed;
-c0105780:	eb 07                	jmp    c0105789 <do_pgfault+0x1fe>
+c01059e0:	eb 07                	jmp    c01059e9 <do_pgfault+0x210>
         }
    }
    ret = 0;
-c0105782:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+c01059e2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 failed:
     return ret;
-c0105789:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01059e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
 }
-c010578c:	c9                   	leave  
-c010578d:	c3                   	ret    
+c01059ec:	c9                   	leave  
+c01059ed:	c3                   	ret    
 
-c010578e <pa2page>:
+c01059ee <pa2page>:
 page2pa(struct Page *page) {
     return page2ppn(page) << PGSHIFT;
 }
 
 static inline struct Page *
 pa2page(uintptr_t pa) {
-c010578e:	55                   	push   %ebp
-c010578f:	89 e5                	mov    %esp,%ebp
-c0105791:	83 ec 08             	sub    $0x8,%esp
+c01059ee:	55                   	push   %ebp
+c01059ef:	89 e5                	mov    %esp,%ebp
+c01059f1:	83 ec 18             	sub    $0x18,%esp
     if (PPN(pa) >= npage) {
-c0105794:	8b 45 08             	mov    0x8(%ebp),%eax
-c0105797:	c1 e8 0c             	shr    $0xc,%eax
-c010579a:	89 c2                	mov    %eax,%edx
-c010579c:	a1 80 2f 12 c0       	mov    0xc0122f80,%eax
-c01057a1:	39 c2                	cmp    %eax,%edx
-c01057a3:	72 14                	jb     c01057b9 <pa2page+0x2b>
+c01059f4:	8b 45 08             	mov    0x8(%ebp),%eax
+c01059f7:	c1 e8 0c             	shr    $0xc,%eax
+c01059fa:	89 c2                	mov    %eax,%edx
+c01059fc:	a1 80 3f 12 c0       	mov    0xc0123f80,%eax
+c0105a01:	39 c2                	cmp    %eax,%edx
+c0105a03:	72 1c                	jb     c0105a21 <pa2page+0x33>
         panic("pa2page called with invalid pa");
-c01057a5:	83 ec 04             	sub    $0x4,%esp
-c01057a8:	68 6c 97 10 c0       	push   $0xc010976c
-c01057ad:	6a 5b                	push   $0x5b
-c01057af:	68 8b 97 10 c0       	push   $0xc010978b
-c01057b4:	e8 2f ac ff ff       	call   c01003e8 <__panic>
+c0105a05:	c7 44 24 08 9c 9e 10 	movl   $0xc0109e9c,0x8(%esp)
+c0105a0c:	c0 
+c0105a0d:	c7 44 24 04 5b 00 00 	movl   $0x5b,0x4(%esp)
+c0105a14:	00 
+c0105a15:	c7 04 24 bb 9e 10 c0 	movl   $0xc0109ebb,(%esp)
+c0105a1c:	e8 d7 a9 ff ff       	call   c01003f8 <__panic>
     }
     return &pages[PPN(pa)];
-c01057b9:	a1 28 30 12 c0       	mov    0xc0123028,%eax
-c01057be:	8b 55 08             	mov    0x8(%ebp),%edx
-c01057c1:	c1 ea 0c             	shr    $0xc,%edx
-c01057c4:	c1 e2 05             	shl    $0x5,%edx
-c01057c7:	01 d0                	add    %edx,%eax
+c0105a21:	a1 28 40 12 c0       	mov    0xc0124028,%eax
+c0105a26:	8b 55 08             	mov    0x8(%ebp),%edx
+c0105a29:	c1 ea 0c             	shr    $0xc,%edx
+c0105a2c:	c1 e2 05             	shl    $0x5,%edx
+c0105a2f:	01 d0                	add    %edx,%eax
 }
-c01057c9:	c9                   	leave  
-c01057ca:	c3                   	ret    
+c0105a31:	c9                   	leave  
+c0105a32:	c3                   	ret    
 
-c01057cb <pte2page>:
+c0105a33 <pte2page>:
 kva2page(void *kva) {
     return pa2page(PADDR(kva));
 }
 
 static inline struct Page *
 pte2page(pte_t pte) {
-c01057cb:	55                   	push   %ebp
-c01057cc:	89 e5                	mov    %esp,%ebp
-c01057ce:	83 ec 08             	sub    $0x8,%esp
+c0105a33:	55                   	push   %ebp
+c0105a34:	89 e5                	mov    %esp,%ebp
+c0105a36:	83 ec 18             	sub    $0x18,%esp
     if (!(pte & PTE_P)) {
-c01057d1:	8b 45 08             	mov    0x8(%ebp),%eax
-c01057d4:	83 e0 01             	and    $0x1,%eax
-c01057d7:	85 c0                	test   %eax,%eax
-c01057d9:	75 14                	jne    c01057ef <pte2page+0x24>
+c0105a39:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105a3c:	83 e0 01             	and    $0x1,%eax
+c0105a3f:	85 c0                	test   %eax,%eax
+c0105a41:	75 1c                	jne    c0105a5f <pte2page+0x2c>
         panic("pte2page called with invalid pte");
-c01057db:	83 ec 04             	sub    $0x4,%esp
-c01057de:	68 9c 97 10 c0       	push   $0xc010979c
-c01057e3:	6a 6d                	push   $0x6d
-c01057e5:	68 8b 97 10 c0       	push   $0xc010978b
-c01057ea:	e8 f9 ab ff ff       	call   c01003e8 <__panic>
+c0105a43:	c7 44 24 08 cc 9e 10 	movl   $0xc0109ecc,0x8(%esp)
+c0105a4a:	c0 
+c0105a4b:	c7 44 24 04 6d 00 00 	movl   $0x6d,0x4(%esp)
+c0105a52:	00 
+c0105a53:	c7 04 24 bb 9e 10 c0 	movl   $0xc0109ebb,(%esp)
+c0105a5a:	e8 99 a9 ff ff       	call   c01003f8 <__panic>
     }
     return pa2page(PTE_ADDR(pte));
-c01057ef:	8b 45 08             	mov    0x8(%ebp),%eax
-c01057f2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
-c01057f7:	83 ec 0c             	sub    $0xc,%esp
-c01057fa:	50                   	push   %eax
-c01057fb:	e8 8e ff ff ff       	call   c010578e <pa2page>
-c0105800:	83 c4 10             	add    $0x10,%esp
+c0105a5f:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105a62:	25 00 f0 ff ff       	and    $0xfffff000,%eax
+c0105a67:	89 04 24             	mov    %eax,(%esp)
+c0105a6a:	e8 7f ff ff ff       	call   c01059ee <pa2page>
 }
-c0105803:	c9                   	leave  
-c0105804:	c3                   	ret    
+c0105a6f:	c9                   	leave  
+c0105a70:	c3                   	ret    
 
-c0105805 <swap_init>:
+c0105a71 <swap_init>:
 
 static void check_swap(void);
 
 int
 swap_init(void)
 {
-c0105805:	55                   	push   %ebp
-c0105806:	89 e5                	mov    %esp,%ebp
-c0105808:	83 ec 18             	sub    $0x18,%esp
+c0105a71:	55                   	push   %ebp
+c0105a72:	89 e5                	mov    %esp,%ebp
+c0105a74:	83 ec 28             	sub    $0x28,%esp
      swapfs_init();
-c010580b:	e8 d2 1e 00 00       	call   c01076e2 <swapfs_init>
+c0105a77:	e8 17 23 00 00       	call   c0107d93 <swapfs_init>
 
      if (!(1024 <= max_swap_offset && max_swap_offset < MAX_SWAP_OFFSET_LIMIT))
-c0105810:	a1 dc 30 12 c0       	mov    0xc01230dc,%eax
-c0105815:	3d ff 03 00 00       	cmp    $0x3ff,%eax
-c010581a:	76 0c                	jbe    c0105828 <swap_init+0x23>
-c010581c:	a1 dc 30 12 c0       	mov    0xc01230dc,%eax
-c0105821:	3d ff ff ff 00       	cmp    $0xffffff,%eax
-c0105826:	76 17                	jbe    c010583f <swap_init+0x3a>
+c0105a7c:	a1 dc 40 12 c0       	mov    0xc01240dc,%eax
+c0105a81:	3d ff 03 00 00       	cmp    $0x3ff,%eax
+c0105a86:	76 0c                	jbe    c0105a94 <swap_init+0x23>
+c0105a88:	a1 dc 40 12 c0       	mov    0xc01240dc,%eax
+c0105a8d:	3d ff ff ff 00       	cmp    $0xffffff,%eax
+c0105a92:	76 25                	jbe    c0105ab9 <swap_init+0x48>
      {
           panic("bad max_swap_offset %08x.\n", max_swap_offset);
-c0105828:	a1 dc 30 12 c0       	mov    0xc01230dc,%eax
-c010582d:	50                   	push   %eax
-c010582e:	68 bd 97 10 c0       	push   $0xc01097bd
-c0105833:	6a 25                	push   $0x25
-c0105835:	68 d8 97 10 c0       	push   $0xc01097d8
-c010583a:	e8 a9 ab ff ff       	call   c01003e8 <__panic>
+c0105a94:	a1 dc 40 12 c0       	mov    0xc01240dc,%eax
+c0105a99:	89 44 24 0c          	mov    %eax,0xc(%esp)
+c0105a9d:	c7 44 24 08 ed 9e 10 	movl   $0xc0109eed,0x8(%esp)
+c0105aa4:	c0 
+c0105aa5:	c7 44 24 04 25 00 00 	movl   $0x25,0x4(%esp)
+c0105aac:	00 
+c0105aad:	c7 04 24 08 9f 10 c0 	movl   $0xc0109f08,(%esp)
+c0105ab4:	e8 3f a9 ff ff       	call   c01003f8 <__panic>
      }
      
 
      sm = &swap_manager_fifo;
-c010583f:	c7 05 18 30 12 c0 40 	movl   $0xc011fa40,0xc0123018
-c0105846:	fa 11 c0 
+c0105ab9:	c7 05 18 40 12 c0 40 	movl   $0xc0120a40,0xc0124018
+c0105ac0:	0a 12 c0 
      int r = sm->init();
-c0105849:	a1 18 30 12 c0       	mov    0xc0123018,%eax
-c010584e:	8b 40 04             	mov    0x4(%eax),%eax
-c0105851:	ff d0                	call   *%eax
-c0105853:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0105ac3:	a1 18 40 12 c0       	mov    0xc0124018,%eax
+c0105ac8:	8b 40 04             	mov    0x4(%eax),%eax
+c0105acb:	ff d0                	call   *%eax
+c0105acd:	89 45 f4             	mov    %eax,-0xc(%ebp)
      
      if (r == 0)
-c0105856:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
-c010585a:	75 27                	jne    c0105883 <swap_init+0x7e>
+c0105ad0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0105ad4:	75 26                	jne    c0105afc <swap_init+0x8b>
      {
           swap_init_ok = 1;
-c010585c:	c7 05 10 30 12 c0 01 	movl   $0x1,0xc0123010
-c0105863:	00 00 00 
+c0105ad6:	c7 05 10 40 12 c0 01 	movl   $0x1,0xc0124010
+c0105add:	00 00 00 
           cprintf("SWAP: manager = %s\n", sm->name);
-c0105866:	a1 18 30 12 c0       	mov    0xc0123018,%eax
-c010586b:	8b 00                	mov    (%eax),%eax
-c010586d:	83 ec 08             	sub    $0x8,%esp
-c0105870:	50                   	push   %eax
-c0105871:	68 e7 97 10 c0       	push   $0xc01097e7
-c0105876:	e8 07 aa ff ff       	call   c0100282 <cprintf>
-c010587b:	83 c4 10             	add    $0x10,%esp
+c0105ae0:	a1 18 40 12 c0       	mov    0xc0124018,%eax
+c0105ae5:	8b 00                	mov    (%eax),%eax
+c0105ae7:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0105aeb:	c7 04 24 17 9f 10 c0 	movl   $0xc0109f17,(%esp)
+c0105af2:	e8 aa a7 ff ff       	call   c01002a1 <cprintf>
           check_swap();
-c010587e:	e8 f7 03 00 00       	call   c0105c7a <check_swap>
+c0105af7:	e8 9e 04 00 00       	call   c0105f9a <check_swap>
      }
 
      return r;
-c0105883:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0105afc:	8b 45 f4             	mov    -0xc(%ebp),%eax
 }
-c0105886:	c9                   	leave  
-c0105887:	c3                   	ret    
+c0105aff:	c9                   	leave  
+c0105b00:	c3                   	ret    
 
-c0105888 <swap_init_mm>:
+c0105b01 <swap_init_mm>:
 
 int
 swap_init_mm(struct mm_struct *mm)
 {
-c0105888:	55                   	push   %ebp
-c0105889:	89 e5                	mov    %esp,%ebp
-c010588b:	83 ec 08             	sub    $0x8,%esp
+c0105b01:	55                   	push   %ebp
+c0105b02:	89 e5                	mov    %esp,%ebp
+c0105b04:	83 ec 18             	sub    $0x18,%esp
      return sm->init_mm(mm);
-c010588e:	a1 18 30 12 c0       	mov    0xc0123018,%eax
-c0105893:	8b 40 08             	mov    0x8(%eax),%eax
-c0105896:	83 ec 0c             	sub    $0xc,%esp
-c0105899:	ff 75 08             	pushl  0x8(%ebp)
-c010589c:	ff d0                	call   *%eax
-c010589e:	83 c4 10             	add    $0x10,%esp
+c0105b07:	a1 18 40 12 c0       	mov    0xc0124018,%eax
+c0105b0c:	8b 40 08             	mov    0x8(%eax),%eax
+c0105b0f:	8b 55 08             	mov    0x8(%ebp),%edx
+c0105b12:	89 14 24             	mov    %edx,(%esp)
+c0105b15:	ff d0                	call   *%eax
 }
-c01058a1:	c9                   	leave  
-c01058a2:	c3                   	ret    
+c0105b17:	c9                   	leave  
+c0105b18:	c3                   	ret    
 
-c01058a3 <swap_tick_event>:
+c0105b19 <swap_tick_event>:
 
 int
 swap_tick_event(struct mm_struct *mm)
 {
-c01058a3:	55                   	push   %ebp
-c01058a4:	89 e5                	mov    %esp,%ebp
-c01058a6:	83 ec 08             	sub    $0x8,%esp
+c0105b19:	55                   	push   %ebp
+c0105b1a:	89 e5                	mov    %esp,%ebp
+c0105b1c:	83 ec 18             	sub    $0x18,%esp
      return sm->tick_event(mm);
-c01058a9:	a1 18 30 12 c0       	mov    0xc0123018,%eax
-c01058ae:	8b 40 0c             	mov    0xc(%eax),%eax
-c01058b1:	83 ec 0c             	sub    $0xc,%esp
-c01058b4:	ff 75 08             	pushl  0x8(%ebp)
-c01058b7:	ff d0                	call   *%eax
-c01058b9:	83 c4 10             	add    $0x10,%esp
+c0105b1f:	a1 18 40 12 c0       	mov    0xc0124018,%eax
+c0105b24:	8b 40 0c             	mov    0xc(%eax),%eax
+c0105b27:	8b 55 08             	mov    0x8(%ebp),%edx
+c0105b2a:	89 14 24             	mov    %edx,(%esp)
+c0105b2d:	ff d0                	call   *%eax
 }
-c01058bc:	c9                   	leave  
-c01058bd:	c3                   	ret    
+c0105b2f:	c9                   	leave  
+c0105b30:	c3                   	ret    
 
-c01058be <swap_map_swappable>:
+c0105b31 <swap_map_swappable>:
 
 int
 swap_map_swappable(struct mm_struct *mm, uintptr_t addr, struct Page *page, int swap_in)
 {
-c01058be:	55                   	push   %ebp
-c01058bf:	89 e5                	mov    %esp,%ebp
-c01058c1:	83 ec 08             	sub    $0x8,%esp
+c0105b31:	55                   	push   %ebp
+c0105b32:	89 e5                	mov    %esp,%ebp
+c0105b34:	83 ec 18             	sub    $0x18,%esp
      return sm->map_swappable(mm, addr, page, swap_in);
-c01058c4:	a1 18 30 12 c0       	mov    0xc0123018,%eax
-c01058c9:	8b 40 10             	mov    0x10(%eax),%eax
-c01058cc:	ff 75 14             	pushl  0x14(%ebp)
-c01058cf:	ff 75 10             	pushl  0x10(%ebp)
-c01058d2:	ff 75 0c             	pushl  0xc(%ebp)
-c01058d5:	ff 75 08             	pushl  0x8(%ebp)
-c01058d8:	ff d0                	call   *%eax
-c01058da:	83 c4 10             	add    $0x10,%esp
+c0105b37:	a1 18 40 12 c0       	mov    0xc0124018,%eax
+c0105b3c:	8b 40 10             	mov    0x10(%eax),%eax
+c0105b3f:	8b 55 14             	mov    0x14(%ebp),%edx
+c0105b42:	89 54 24 0c          	mov    %edx,0xc(%esp)
+c0105b46:	8b 55 10             	mov    0x10(%ebp),%edx
+c0105b49:	89 54 24 08          	mov    %edx,0x8(%esp)
+c0105b4d:	8b 55 0c             	mov    0xc(%ebp),%edx
+c0105b50:	89 54 24 04          	mov    %edx,0x4(%esp)
+c0105b54:	8b 55 08             	mov    0x8(%ebp),%edx
+c0105b57:	89 14 24             	mov    %edx,(%esp)
+c0105b5a:	ff d0                	call   *%eax
 }
-c01058dd:	c9                   	leave  
-c01058de:	c3                   	ret    
+c0105b5c:	c9                   	leave  
+c0105b5d:	c3                   	ret    
 
-c01058df <swap_set_unswappable>:
+c0105b5e <swap_set_unswappable>:
 
 int
 swap_set_unswappable(struct mm_struct *mm, uintptr_t addr)
 {
-c01058df:	55                   	push   %ebp
-c01058e0:	89 e5                	mov    %esp,%ebp
-c01058e2:	83 ec 08             	sub    $0x8,%esp
+c0105b5e:	55                   	push   %ebp
+c0105b5f:	89 e5                	mov    %esp,%ebp
+c0105b61:	83 ec 18             	sub    $0x18,%esp
      return sm->set_unswappable(mm, addr);
-c01058e5:	a1 18 30 12 c0       	mov    0xc0123018,%eax
-c01058ea:	8b 40 14             	mov    0x14(%eax),%eax
-c01058ed:	83 ec 08             	sub    $0x8,%esp
-c01058f0:	ff 75 0c             	pushl  0xc(%ebp)
-c01058f3:	ff 75 08             	pushl  0x8(%ebp)
-c01058f6:	ff d0                	call   *%eax
-c01058f8:	83 c4 10             	add    $0x10,%esp
+c0105b64:	a1 18 40 12 c0       	mov    0xc0124018,%eax
+c0105b69:	8b 40 14             	mov    0x14(%eax),%eax
+c0105b6c:	8b 55 0c             	mov    0xc(%ebp),%edx
+c0105b6f:	89 54 24 04          	mov    %edx,0x4(%esp)
+c0105b73:	8b 55 08             	mov    0x8(%ebp),%edx
+c0105b76:	89 14 24             	mov    %edx,(%esp)
+c0105b79:	ff d0                	call   *%eax
 }
-c01058fb:	c9                   	leave  
-c01058fc:	c3                   	ret    
+c0105b7b:	c9                   	leave  
+c0105b7c:	c3                   	ret    
 
-c01058fd <swap_out>:
+c0105b7d <swap_out>:
 
 volatile unsigned int swap_out_num=0;
 
 int
 swap_out(struct mm_struct *mm, int n, int in_tick)
 {
-c01058fd:	55                   	push   %ebp
-c01058fe:	89 e5                	mov    %esp,%ebp
-c0105900:	83 ec 28             	sub    $0x28,%esp
+c0105b7d:	55                   	push   %ebp
+c0105b7e:	89 e5                	mov    %esp,%ebp
+c0105b80:	83 ec 38             	sub    $0x38,%esp
      int i;
      for (i = 0; i != n; ++ i)
-c0105903:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
-c010590a:	e9 2e 01 00 00       	jmp    c0105a3d <swap_out+0x140>
+c0105b83:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+c0105b8a:	e9 53 01 00 00       	jmp    c0105ce2 <swap_out+0x165>
      {
           uintptr_t v;
           //struct Page **ptr_page=NULL;
           struct Page *page;
           // cprintf("i %d, SWAP: call swap_out_victim\n",i);
           int r = sm->swap_out_victim(mm, &page, in_tick);
-c010590f:	a1 18 30 12 c0       	mov    0xc0123018,%eax
-c0105914:	8b 40 18             	mov    0x18(%eax),%eax
-c0105917:	83 ec 04             	sub    $0x4,%esp
-c010591a:	ff 75 10             	pushl  0x10(%ebp)
-c010591d:	8d 55 e4             	lea    -0x1c(%ebp),%edx
-c0105920:	52                   	push   %edx
-c0105921:	ff 75 08             	pushl  0x8(%ebp)
-c0105924:	ff d0                	call   *%eax
-c0105926:	83 c4 10             	add    $0x10,%esp
-c0105929:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0105b8f:	a1 18 40 12 c0       	mov    0xc0124018,%eax
+c0105b94:	8b 40 18             	mov    0x18(%eax),%eax
+c0105b97:	8b 55 10             	mov    0x10(%ebp),%edx
+c0105b9a:	89 54 24 08          	mov    %edx,0x8(%esp)
+c0105b9e:	8d 55 e4             	lea    -0x1c(%ebp),%edx
+c0105ba1:	89 54 24 04          	mov    %edx,0x4(%esp)
+c0105ba5:	8b 55 08             	mov    0x8(%ebp),%edx
+c0105ba8:	89 14 24             	mov    %edx,(%esp)
+c0105bab:	ff d0                	call   *%eax
+c0105bad:	89 45 f0             	mov    %eax,-0x10(%ebp)
           if (r != 0) {
-c010592c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
-c0105930:	74 18                	je     c010594a <swap_out+0x4d>
+c0105bb0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c0105bb4:	74 18                	je     c0105bce <swap_out+0x51>
                     cprintf("i %d, swap_out: call swap_out_victim failed\n",i);
-c0105932:	83 ec 08             	sub    $0x8,%esp
-c0105935:	ff 75 f4             	pushl  -0xc(%ebp)
-c0105938:	68 fc 97 10 c0       	push   $0xc01097fc
-c010593d:	e8 40 a9 ff ff       	call   c0100282 <cprintf>
-c0105942:	83 c4 10             	add    $0x10,%esp
-c0105945:	e9 ff 00 00 00       	jmp    c0105a49 <swap_out+0x14c>
+c0105bb6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0105bb9:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0105bbd:	c7 04 24 2c 9f 10 c0 	movl   $0xc0109f2c,(%esp)
+c0105bc4:	e8 d8 a6 ff ff       	call   c01002a1 <cprintf>
+c0105bc9:	e9 20 01 00 00       	jmp    c0105cee <swap_out+0x171>
           }          
           //assert(!PageReserved(page));
 
           //cprintf("SWAP: choose victim page 0x%08x\n", page);
           
           v=page->pra_vaddr; 
-c010594a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-c010594d:	8b 40 1c             	mov    0x1c(%eax),%eax
-c0105950:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c0105bce:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0105bd1:	8b 40 1c             	mov    0x1c(%eax),%eax
+c0105bd4:	89 45 ec             	mov    %eax,-0x14(%ebp)
           pte_t *ptep = get_pte(mm->pgdir, v, 0);
-c0105953:	8b 45 08             	mov    0x8(%ebp),%eax
-c0105956:	8b 40 0c             	mov    0xc(%eax),%eax
-c0105959:	83 ec 04             	sub    $0x4,%esp
-c010595c:	6a 00                	push   $0x0
-c010595e:	ff 75 ec             	pushl  -0x14(%ebp)
-c0105961:	50                   	push   %eax
-c0105962:	e8 14 e2 ff ff       	call   c0103b7b <get_pte>
-c0105967:	83 c4 10             	add    $0x10,%esp
-c010596a:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c0105bd7:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105bda:	8b 40 0c             	mov    0xc(%eax),%eax
+c0105bdd:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+c0105be4:	00 
+c0105be5:	8b 55 ec             	mov    -0x14(%ebp),%edx
+c0105be8:	89 54 24 04          	mov    %edx,0x4(%esp)
+c0105bec:	89 04 24             	mov    %eax,(%esp)
+c0105bef:	e8 46 de ff ff       	call   c0103a3a <get_pte>
+c0105bf4:	89 45 e8             	mov    %eax,-0x18(%ebp)
           assert((*ptep & PTE_P) != 0);
-c010596d:	8b 45 e8             	mov    -0x18(%ebp),%eax
-c0105970:	8b 00                	mov    (%eax),%eax
-c0105972:	83 e0 01             	and    $0x1,%eax
-c0105975:	85 c0                	test   %eax,%eax
-c0105977:	75 16                	jne    c010598f <swap_out+0x92>
-c0105979:	68 29 98 10 c0       	push   $0xc0109829
-c010597e:	68 3e 98 10 c0       	push   $0xc010983e
-c0105983:	6a 65                	push   $0x65
-c0105985:	68 d8 97 10 c0       	push   $0xc01097d8
-c010598a:	e8 59 aa ff ff       	call   c01003e8 <__panic>
+c0105bf7:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0105bfa:	8b 00                	mov    (%eax),%eax
+c0105bfc:	83 e0 01             	and    $0x1,%eax
+c0105bff:	85 c0                	test   %eax,%eax
+c0105c01:	75 24                	jne    c0105c27 <swap_out+0xaa>
+c0105c03:	c7 44 24 0c 59 9f 10 	movl   $0xc0109f59,0xc(%esp)
+c0105c0a:	c0 
+c0105c0b:	c7 44 24 08 6e 9f 10 	movl   $0xc0109f6e,0x8(%esp)
+c0105c12:	c0 
+c0105c13:	c7 44 24 04 65 00 00 	movl   $0x65,0x4(%esp)
+c0105c1a:	00 
+c0105c1b:	c7 04 24 08 9f 10 c0 	movl   $0xc0109f08,(%esp)
+c0105c22:	e8 d1 a7 ff ff       	call   c01003f8 <__panic>
 
           if (swapfs_write( (page->pra_vaddr/PGSIZE+1)<<8, page) != 0) {
-c010598f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-c0105992:	8b 55 e4             	mov    -0x1c(%ebp),%edx
-c0105995:	8b 52 1c             	mov    0x1c(%edx),%edx
-c0105998:	c1 ea 0c             	shr    $0xc,%edx
-c010599b:	83 c2 01             	add    $0x1,%edx
-c010599e:	c1 e2 08             	shl    $0x8,%edx
-c01059a1:	83 ec 08             	sub    $0x8,%esp
-c01059a4:	50                   	push   %eax
-c01059a5:	52                   	push   %edx
-c01059a6:	e8 d3 1d 00 00       	call   c010777e <swapfs_write>
-c01059ab:	83 c4 10             	add    $0x10,%esp
-c01059ae:	85 c0                	test   %eax,%eax
-c01059b0:	74 2b                	je     c01059dd <swap_out+0xe0>
+c0105c27:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0105c2a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c0105c2d:	8b 52 1c             	mov    0x1c(%edx),%edx
+c0105c30:	c1 ea 0c             	shr    $0xc,%edx
+c0105c33:	42                   	inc    %edx
+c0105c34:	c1 e2 08             	shl    $0x8,%edx
+c0105c37:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0105c3b:	89 14 24             	mov    %edx,(%esp)
+c0105c3e:	e8 0b 22 00 00       	call   c0107e4e <swapfs_write>
+c0105c43:	85 c0                	test   %eax,%eax
+c0105c45:	74 34                	je     c0105c7b <swap_out+0xfe>
                     cprintf("SWAP: failed to save\n");
-c01059b2:	83 ec 0c             	sub    $0xc,%esp
-c01059b5:	68 53 98 10 c0       	push   $0xc0109853
-c01059ba:	e8 c3 a8 ff ff       	call   c0100282 <cprintf>
-c01059bf:	83 c4 10             	add    $0x10,%esp
+c0105c47:	c7 04 24 83 9f 10 c0 	movl   $0xc0109f83,(%esp)
+c0105c4e:	e8 4e a6 ff ff       	call   c01002a1 <cprintf>
                     sm->map_swappable(mm, v, page, 0);
-c01059c2:	a1 18 30 12 c0       	mov    0xc0123018,%eax
-c01059c7:	8b 40 10             	mov    0x10(%eax),%eax
-c01059ca:	8b 55 e4             	mov    -0x1c(%ebp),%edx
-c01059cd:	6a 00                	push   $0x0
-c01059cf:	52                   	push   %edx
-c01059d0:	ff 75 ec             	pushl  -0x14(%ebp)
-c01059d3:	ff 75 08             	pushl  0x8(%ebp)
-c01059d6:	ff d0                	call   *%eax
-c01059d8:	83 c4 10             	add    $0x10,%esp
-c01059db:	eb 5c                	jmp    c0105a39 <swap_out+0x13c>
+c0105c53:	a1 18 40 12 c0       	mov    0xc0124018,%eax
+c0105c58:	8b 40 10             	mov    0x10(%eax),%eax
+c0105c5b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c0105c5e:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
+c0105c65:	00 
+c0105c66:	89 54 24 08          	mov    %edx,0x8(%esp)
+c0105c6a:	8b 55 ec             	mov    -0x14(%ebp),%edx
+c0105c6d:	89 54 24 04          	mov    %edx,0x4(%esp)
+c0105c71:	8b 55 08             	mov    0x8(%ebp),%edx
+c0105c74:	89 14 24             	mov    %edx,(%esp)
+c0105c77:	ff d0                	call   *%eax
+c0105c79:	eb 64                	jmp    c0105cdf <swap_out+0x162>
                     continue;
           }
           else {
                     cprintf("swap_out: i %d, store page in vaddr 0x%x to disk swap entry %d\n", i, v, page->pra_vaddr/PGSIZE+1);
-c01059dd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-c01059e0:	8b 40 1c             	mov    0x1c(%eax),%eax
-c01059e3:	c1 e8 0c             	shr    $0xc,%eax
-c01059e6:	83 c0 01             	add    $0x1,%eax
-c01059e9:	50                   	push   %eax
-c01059ea:	ff 75 ec             	pushl  -0x14(%ebp)
-c01059ed:	ff 75 f4             	pushl  -0xc(%ebp)
-c01059f0:	68 6c 98 10 c0       	push   $0xc010986c
-c01059f5:	e8 88 a8 ff ff       	call   c0100282 <cprintf>
-c01059fa:	83 c4 10             	add    $0x10,%esp
+c0105c7b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0105c7e:	8b 40 1c             	mov    0x1c(%eax),%eax
+c0105c81:	c1 e8 0c             	shr    $0xc,%eax
+c0105c84:	40                   	inc    %eax
+c0105c85:	89 44 24 0c          	mov    %eax,0xc(%esp)
+c0105c89:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0105c8c:	89 44 24 08          	mov    %eax,0x8(%esp)
+c0105c90:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0105c93:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0105c97:	c7 04 24 9c 9f 10 c0 	movl   $0xc0109f9c,(%esp)
+c0105c9e:	e8 fe a5 ff ff       	call   c01002a1 <cprintf>
                     *ptep = (page->pra_vaddr/PGSIZE+1)<<8;
-c01059fd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-c0105a00:	8b 40 1c             	mov    0x1c(%eax),%eax
-c0105a03:	c1 e8 0c             	shr    $0xc,%eax
-c0105a06:	83 c0 01             	add    $0x1,%eax
-c0105a09:	c1 e0 08             	shl    $0x8,%eax
-c0105a0c:	89 c2                	mov    %eax,%edx
-c0105a0e:	8b 45 e8             	mov    -0x18(%ebp),%eax
-c0105a11:	89 10                	mov    %edx,(%eax)
+c0105ca3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0105ca6:	8b 40 1c             	mov    0x1c(%eax),%eax
+c0105ca9:	c1 e8 0c             	shr    $0xc,%eax
+c0105cac:	40                   	inc    %eax
+c0105cad:	c1 e0 08             	shl    $0x8,%eax
+c0105cb0:	89 c2                	mov    %eax,%edx
+c0105cb2:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0105cb5:	89 10                	mov    %edx,(%eax)
                     free_page(page);
-c0105a13:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-c0105a16:	83 ec 08             	sub    $0x8,%esp
-c0105a19:	6a 01                	push   $0x1
-c0105a1b:	50                   	push   %eax
-c0105a1c:	e8 5f db ff ff       	call   c0103580 <free_pages>
-c0105a21:	83 c4 10             	add    $0x10,%esp
+c0105cb7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0105cba:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+c0105cc1:	00 
+c0105cc2:	89 04 24             	mov    %eax,(%esp)
+c0105cc5:	e8 0e d7 ff ff       	call   c01033d8 <free_pages>
           }
           
           tlb_invalidate(mm->pgdir, v);
-c0105a24:	8b 45 08             	mov    0x8(%ebp),%eax
-c0105a27:	8b 40 0c             	mov    0xc(%eax),%eax
-c0105a2a:	83 ec 08             	sub    $0x8,%esp
-c0105a2d:	ff 75 ec             	pushl  -0x14(%ebp)
-c0105a30:	50                   	push   %eax
-c0105a31:	e8 0f e4 ff ff       	call   c0103e45 <tlb_invalidate>
-c0105a36:	83 c4 10             	add    $0x10,%esp
+c0105cca:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105ccd:	8b 40 0c             	mov    0xc(%eax),%eax
+c0105cd0:	8b 55 ec             	mov    -0x14(%ebp),%edx
+c0105cd3:	89 54 24 04          	mov    %edx,0x4(%esp)
+c0105cd7:	89 04 24             	mov    %eax,(%esp)
+c0105cda:	e8 71 e0 ff ff       	call   c0103d50 <tlb_invalidate>
 
 int
 swap_out(struct mm_struct *mm, int n, int in_tick)
 {
      int i;
      for (i = 0; i != n; ++ i)
-c0105a39:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
-c0105a3d:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0105a40:	3b 45 0c             	cmp    0xc(%ebp),%eax
-c0105a43:	0f 85 c6 fe ff ff    	jne    c010590f <swap_out+0x12>
+c0105cdf:	ff 45 f4             	incl   -0xc(%ebp)
+c0105ce2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0105ce5:	3b 45 0c             	cmp    0xc(%ebp),%eax
+c0105ce8:	0f 85 a1 fe ff ff    	jne    c0105b8f <swap_out+0x12>
                     free_page(page);
           }
           
           tlb_invalidate(mm->pgdir, v);
      }
      return i;
-c0105a49:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0105cee:	8b 45 f4             	mov    -0xc(%ebp),%eax
 }
-c0105a4c:	c9                   	leave  
-c0105a4d:	c3                   	ret    
+c0105cf1:	c9                   	leave  
+c0105cf2:	c3                   	ret    
 
-c0105a4e <swap_in>:
+c0105cf3 <swap_in>:
 
 int
 swap_in(struct mm_struct *mm, uintptr_t addr, struct Page **ptr_result)
 {
-c0105a4e:	55                   	push   %ebp
-c0105a4f:	89 e5                	mov    %esp,%ebp
-c0105a51:	83 ec 18             	sub    $0x18,%esp
+c0105cf3:	55                   	push   %ebp
+c0105cf4:	89 e5                	mov    %esp,%ebp
+c0105cf6:	83 ec 28             	sub    $0x28,%esp
      struct Page *result = alloc_page();
-c0105a54:	83 ec 0c             	sub    $0xc,%esp
-c0105a57:	6a 01                	push   $0x1
-c0105a59:	e8 b6 da ff ff       	call   c0103514 <alloc_pages>
-c0105a5e:	83 c4 10             	add    $0x10,%esp
-c0105a61:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0105cf9:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c0105d00:	e8 68 d6 ff ff       	call   c010336d <alloc_pages>
+c0105d05:	89 45 f4             	mov    %eax,-0xc(%ebp)
      assert(result!=NULL);
-c0105a64:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
-c0105a68:	75 16                	jne    c0105a80 <swap_in+0x32>
-c0105a6a:	68 ac 98 10 c0       	push   $0xc01098ac
-c0105a6f:	68 3e 98 10 c0       	push   $0xc010983e
-c0105a74:	6a 7b                	push   $0x7b
-c0105a76:	68 d8 97 10 c0       	push   $0xc01097d8
-c0105a7b:	e8 68 a9 ff ff       	call   c01003e8 <__panic>
+c0105d08:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0105d0c:	75 24                	jne    c0105d32 <swap_in+0x3f>
+c0105d0e:	c7 44 24 0c dc 9f 10 	movl   $0xc0109fdc,0xc(%esp)
+c0105d15:	c0 
+c0105d16:	c7 44 24 08 6e 9f 10 	movl   $0xc0109f6e,0x8(%esp)
+c0105d1d:	c0 
+c0105d1e:	c7 44 24 04 7b 00 00 	movl   $0x7b,0x4(%esp)
+c0105d25:	00 
+c0105d26:	c7 04 24 08 9f 10 c0 	movl   $0xc0109f08,(%esp)
+c0105d2d:	e8 c6 a6 ff ff       	call   c01003f8 <__panic>
 
      pte_t *ptep = get_pte(mm->pgdir, addr, 0);
-c0105a80:	8b 45 08             	mov    0x8(%ebp),%eax
-c0105a83:	8b 40 0c             	mov    0xc(%eax),%eax
-c0105a86:	83 ec 04             	sub    $0x4,%esp
-c0105a89:	6a 00                	push   $0x0
-c0105a8b:	ff 75 0c             	pushl  0xc(%ebp)
-c0105a8e:	50                   	push   %eax
-c0105a8f:	e8 e7 e0 ff ff       	call   c0103b7b <get_pte>
-c0105a94:	83 c4 10             	add    $0x10,%esp
-c0105a97:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0105d32:	8b 45 08             	mov    0x8(%ebp),%eax
+c0105d35:	8b 40 0c             	mov    0xc(%eax),%eax
+c0105d38:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+c0105d3f:	00 
+c0105d40:	8b 55 0c             	mov    0xc(%ebp),%edx
+c0105d43:	89 54 24 04          	mov    %edx,0x4(%esp)
+c0105d47:	89 04 24             	mov    %eax,(%esp)
+c0105d4a:	e8 eb dc ff ff       	call   c0103a3a <get_pte>
+c0105d4f:	89 45 f0             	mov    %eax,-0x10(%ebp)
      // cprintf("SWAP: load ptep %x swap entry %d to vaddr 0x%08x, page %x, No %d\n", ptep, (*ptep)>>8, addr, result, (result-pages));
     
      int r;
      if ((r = swapfs_read((*ptep), result)) != 0)
-c0105a9a:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0105a9d:	8b 00                	mov    (%eax),%eax
-c0105a9f:	83 ec 08             	sub    $0x8,%esp
-c0105aa2:	ff 75 f4             	pushl  -0xc(%ebp)
-c0105aa5:	50                   	push   %eax
-c0105aa6:	e8 7a 1c 00 00       	call   c0107725 <swapfs_read>
-c0105aab:	83 c4 10             	add    $0x10,%esp
-c0105aae:	89 45 ec             	mov    %eax,-0x14(%ebp)
-c0105ab1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
-c0105ab5:	74 1f                	je     c0105ad6 <swap_in+0x88>
+c0105d52:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0105d55:	8b 00                	mov    (%eax),%eax
+c0105d57:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0105d5a:	89 54 24 04          	mov    %edx,0x4(%esp)
+c0105d5e:	89 04 24             	mov    %eax,(%esp)
+c0105d61:	e8 76 20 00 00       	call   c0107ddc <swapfs_read>
+c0105d66:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c0105d69:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+c0105d6d:	74 2a                	je     c0105d99 <swap_in+0xa6>
      {
         assert(r!=0);
-c0105ab7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
-c0105abb:	75 19                	jne    c0105ad6 <swap_in+0x88>
-c0105abd:	68 b9 98 10 c0       	push   $0xc01098b9
-c0105ac2:	68 3e 98 10 c0       	push   $0xc010983e
-c0105ac7:	68 83 00 00 00       	push   $0x83
-c0105acc:	68 d8 97 10 c0       	push   $0xc01097d8
-c0105ad1:	e8 12 a9 ff ff       	call   c01003e8 <__panic>
+c0105d6f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+c0105d73:	75 24                	jne    c0105d99 <swap_in+0xa6>
+c0105d75:	c7 44 24 0c e9 9f 10 	movl   $0xc0109fe9,0xc(%esp)
+c0105d7c:	c0 
+c0105d7d:	c7 44 24 08 6e 9f 10 	movl   $0xc0109f6e,0x8(%esp)
+c0105d84:	c0 
+c0105d85:	c7 44 24 04 83 00 00 	movl   $0x83,0x4(%esp)
+c0105d8c:	00 
+c0105d8d:	c7 04 24 08 9f 10 c0 	movl   $0xc0109f08,(%esp)
+c0105d94:	e8 5f a6 ff ff       	call   c01003f8 <__panic>
      }
      cprintf("swap_in: load disk swap entry %d with swap_page in vadr 0x%x\n", (*ptep)>>8, addr);
-c0105ad6:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0105ad9:	8b 00                	mov    (%eax),%eax
-c0105adb:	c1 e8 08             	shr    $0x8,%eax
-c0105ade:	83 ec 04             	sub    $0x4,%esp
-c0105ae1:	ff 75 0c             	pushl  0xc(%ebp)
-c0105ae4:	50                   	push   %eax
-c0105ae5:	68 c0 98 10 c0       	push   $0xc01098c0
-c0105aea:	e8 93 a7 ff ff       	call   c0100282 <cprintf>
-c0105aef:	83 c4 10             	add    $0x10,%esp
+c0105d99:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0105d9c:	8b 00                	mov    (%eax),%eax
+c0105d9e:	c1 e8 08             	shr    $0x8,%eax
+c0105da1:	89 c2                	mov    %eax,%edx
+c0105da3:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0105da6:	89 44 24 08          	mov    %eax,0x8(%esp)
+c0105daa:	89 54 24 04          	mov    %edx,0x4(%esp)
+c0105dae:	c7 04 24 f0 9f 10 c0 	movl   $0xc0109ff0,(%esp)
+c0105db5:	e8 e7 a4 ff ff       	call   c01002a1 <cprintf>
      *ptr_result=result;
-c0105af2:	8b 45 10             	mov    0x10(%ebp),%eax
-c0105af5:	8b 55 f4             	mov    -0xc(%ebp),%edx
-c0105af8:	89 10                	mov    %edx,(%eax)
+c0105dba:	8b 45 10             	mov    0x10(%ebp),%eax
+c0105dbd:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0105dc0:	89 10                	mov    %edx,(%eax)
      return 0;
-c0105afa:	b8 00 00 00 00       	mov    $0x0,%eax
+c0105dc2:	b8 00 00 00 00       	mov    $0x0,%eax
 }
-c0105aff:	c9                   	leave  
-c0105b00:	c3                   	ret    
+c0105dc7:	c9                   	leave  
+c0105dc8:	c3                   	ret    
 
-c0105b01 <check_content_set>:
+c0105dc9 <check_content_set>:
 
 
 
 static inline void
 check_content_set(void)
 {
-c0105b01:	55                   	push   %ebp
-c0105b02:	89 e5                	mov    %esp,%ebp
-c0105b04:	83 ec 08             	sub    $0x8,%esp
+c0105dc9:	55                   	push   %ebp
+c0105dca:	89 e5                	mov    %esp,%ebp
+c0105dcc:	83 ec 18             	sub    $0x18,%esp
      *(unsigned char *)0x1000 = 0x0a;
-c0105b07:	b8 00 10 00 00       	mov    $0x1000,%eax
-c0105b0c:	c6 00 0a             	movb   $0xa,(%eax)
+c0105dcf:	b8 00 10 00 00       	mov    $0x1000,%eax
+c0105dd4:	c6 00 0a             	movb   $0xa,(%eax)
      assert(pgfault_num==1);
-c0105b0f:	a1 0c 30 12 c0       	mov    0xc012300c,%eax
-c0105b14:	83 f8 01             	cmp    $0x1,%eax
-c0105b17:	74 19                	je     c0105b32 <check_content_set+0x31>
-c0105b19:	68 fe 98 10 c0       	push   $0xc01098fe
-c0105b1e:	68 3e 98 10 c0       	push   $0xc010983e
-c0105b23:	68 90 00 00 00       	push   $0x90
-c0105b28:	68 d8 97 10 c0       	push   $0xc01097d8
-c0105b2d:	e8 b6 a8 ff ff       	call   c01003e8 <__panic>
+c0105dd7:	a1 0c 40 12 c0       	mov    0xc012400c,%eax
+c0105ddc:	83 f8 01             	cmp    $0x1,%eax
+c0105ddf:	74 24                	je     c0105e05 <check_content_set+0x3c>
+c0105de1:	c7 44 24 0c 2e a0 10 	movl   $0xc010a02e,0xc(%esp)
+c0105de8:	c0 
+c0105de9:	c7 44 24 08 6e 9f 10 	movl   $0xc0109f6e,0x8(%esp)
+c0105df0:	c0 
+c0105df1:	c7 44 24 04 90 00 00 	movl   $0x90,0x4(%esp)
+c0105df8:	00 
+c0105df9:	c7 04 24 08 9f 10 c0 	movl   $0xc0109f08,(%esp)
+c0105e00:	e8 f3 a5 ff ff       	call   c01003f8 <__panic>
      *(unsigned char *)0x1010 = 0x0a;
-c0105b32:	b8 10 10 00 00       	mov    $0x1010,%eax
-c0105b37:	c6 00 0a             	movb   $0xa,(%eax)
+c0105e05:	b8 10 10 00 00       	mov    $0x1010,%eax
+c0105e0a:	c6 00 0a             	movb   $0xa,(%eax)
      assert(pgfault_num==1);
-c0105b3a:	a1 0c 30 12 c0       	mov    0xc012300c,%eax
-c0105b3f:	83 f8 01             	cmp    $0x1,%eax
-c0105b42:	74 19                	je     c0105b5d <check_content_set+0x5c>
-c0105b44:	68 fe 98 10 c0       	push   $0xc01098fe
-c0105b49:	68 3e 98 10 c0       	push   $0xc010983e
-c0105b4e:	68 92 00 00 00       	push   $0x92
-c0105b53:	68 d8 97 10 c0       	push   $0xc01097d8
-c0105b58:	e8 8b a8 ff ff       	call   c01003e8 <__panic>
+c0105e0d:	a1 0c 40 12 c0       	mov    0xc012400c,%eax
+c0105e12:	83 f8 01             	cmp    $0x1,%eax
+c0105e15:	74 24                	je     c0105e3b <check_content_set+0x72>
+c0105e17:	c7 44 24 0c 2e a0 10 	movl   $0xc010a02e,0xc(%esp)
+c0105e1e:	c0 
+c0105e1f:	c7 44 24 08 6e 9f 10 	movl   $0xc0109f6e,0x8(%esp)
+c0105e26:	c0 
+c0105e27:	c7 44 24 04 92 00 00 	movl   $0x92,0x4(%esp)
+c0105e2e:	00 
+c0105e2f:	c7 04 24 08 9f 10 c0 	movl   $0xc0109f08,(%esp)
+c0105e36:	e8 bd a5 ff ff       	call   c01003f8 <__panic>
      *(unsigned char *)0x2000 = 0x0b;
-c0105b5d:	b8 00 20 00 00       	mov    $0x2000,%eax
-c0105b62:	c6 00 0b             	movb   $0xb,(%eax)
+c0105e3b:	b8 00 20 00 00       	mov    $0x2000,%eax
+c0105e40:	c6 00 0b             	movb   $0xb,(%eax)
      assert(pgfault_num==2);
-c0105b65:	a1 0c 30 12 c0       	mov    0xc012300c,%eax
-c0105b6a:	83 f8 02             	cmp    $0x2,%eax
-c0105b6d:	74 19                	je     c0105b88 <check_content_set+0x87>
-c0105b6f:	68 0d 99 10 c0       	push   $0xc010990d
-c0105b74:	68 3e 98 10 c0       	push   $0xc010983e
-c0105b79:	68 94 00 00 00       	push   $0x94
-c0105b7e:	68 d8 97 10 c0       	push   $0xc01097d8
-c0105b83:	e8 60 a8 ff ff       	call   c01003e8 <__panic>
+c0105e43:	a1 0c 40 12 c0       	mov    0xc012400c,%eax
+c0105e48:	83 f8 02             	cmp    $0x2,%eax
+c0105e4b:	74 24                	je     c0105e71 <check_content_set+0xa8>
+c0105e4d:	c7 44 24 0c 3d a0 10 	movl   $0xc010a03d,0xc(%esp)
+c0105e54:	c0 
+c0105e55:	c7 44 24 08 6e 9f 10 	movl   $0xc0109f6e,0x8(%esp)
+c0105e5c:	c0 
+c0105e5d:	c7 44 24 04 94 00 00 	movl   $0x94,0x4(%esp)
+c0105e64:	00 
+c0105e65:	c7 04 24 08 9f 10 c0 	movl   $0xc0109f08,(%esp)
+c0105e6c:	e8 87 a5 ff ff       	call   c01003f8 <__panic>
      *(unsigned char *)0x2010 = 0x0b;
-c0105b88:	b8 10 20 00 00       	mov    $0x2010,%eax
-c0105b8d:	c6 00 0b             	movb   $0xb,(%eax)
+c0105e71:	b8 10 20 00 00       	mov    $0x2010,%eax
+c0105e76:	c6 00 0b             	movb   $0xb,(%eax)
      assert(pgfault_num==2);
-c0105b90:	a1 0c 30 12 c0       	mov    0xc012300c,%eax
-c0105b95:	83 f8 02             	cmp    $0x2,%eax
-c0105b98:	74 19                	je     c0105bb3 <check_content_set+0xb2>
-c0105b9a:	68 0d 99 10 c0       	push   $0xc010990d
-c0105b9f:	68 3e 98 10 c0       	push   $0xc010983e
-c0105ba4:	68 96 00 00 00       	push   $0x96
-c0105ba9:	68 d8 97 10 c0       	push   $0xc01097d8
-c0105bae:	e8 35 a8 ff ff       	call   c01003e8 <__panic>
+c0105e79:	a1 0c 40 12 c0       	mov    0xc012400c,%eax
+c0105e7e:	83 f8 02             	cmp    $0x2,%eax
+c0105e81:	74 24                	je     c0105ea7 <check_content_set+0xde>
+c0105e83:	c7 44 24 0c 3d a0 10 	movl   $0xc010a03d,0xc(%esp)
+c0105e8a:	c0 
+c0105e8b:	c7 44 24 08 6e 9f 10 	movl   $0xc0109f6e,0x8(%esp)
+c0105e92:	c0 
+c0105e93:	c7 44 24 04 96 00 00 	movl   $0x96,0x4(%esp)
+c0105e9a:	00 
+c0105e9b:	c7 04 24 08 9f 10 c0 	movl   $0xc0109f08,(%esp)
+c0105ea2:	e8 51 a5 ff ff       	call   c01003f8 <__panic>
      *(unsigned char *)0x3000 = 0x0c;
-c0105bb3:	b8 00 30 00 00       	mov    $0x3000,%eax
-c0105bb8:	c6 00 0c             	movb   $0xc,(%eax)
+c0105ea7:	b8 00 30 00 00       	mov    $0x3000,%eax
+c0105eac:	c6 00 0c             	movb   $0xc,(%eax)
      assert(pgfault_num==3);
-c0105bbb:	a1 0c 30 12 c0       	mov    0xc012300c,%eax
-c0105bc0:	83 f8 03             	cmp    $0x3,%eax
-c0105bc3:	74 19                	je     c0105bde <check_content_set+0xdd>
-c0105bc5:	68 1c 99 10 c0       	push   $0xc010991c
-c0105bca:	68 3e 98 10 c0       	push   $0xc010983e
-c0105bcf:	68 98 00 00 00       	push   $0x98
-c0105bd4:	68 d8 97 10 c0       	push   $0xc01097d8
-c0105bd9:	e8 0a a8 ff ff       	call   c01003e8 <__panic>
+c0105eaf:	a1 0c 40 12 c0       	mov    0xc012400c,%eax
+c0105eb4:	83 f8 03             	cmp    $0x3,%eax
+c0105eb7:	74 24                	je     c0105edd <check_content_set+0x114>
+c0105eb9:	c7 44 24 0c 4c a0 10 	movl   $0xc010a04c,0xc(%esp)
+c0105ec0:	c0 
+c0105ec1:	c7 44 24 08 6e 9f 10 	movl   $0xc0109f6e,0x8(%esp)
+c0105ec8:	c0 
+c0105ec9:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
+c0105ed0:	00 
+c0105ed1:	c7 04 24 08 9f 10 c0 	movl   $0xc0109f08,(%esp)
+c0105ed8:	e8 1b a5 ff ff       	call   c01003f8 <__panic>
      *(unsigned char *)0x3010 = 0x0c;
-c0105bde:	b8 10 30 00 00       	mov    $0x3010,%eax
-c0105be3:	c6 00 0c             	movb   $0xc,(%eax)
+c0105edd:	b8 10 30 00 00       	mov    $0x3010,%eax
+c0105ee2:	c6 00 0c             	movb   $0xc,(%eax)
      assert(pgfault_num==3);
-c0105be6:	a1 0c 30 12 c0       	mov    0xc012300c,%eax
-c0105beb:	83 f8 03             	cmp    $0x3,%eax
-c0105bee:	74 19                	je     c0105c09 <check_content_set+0x108>
-c0105bf0:	68 1c 99 10 c0       	push   $0xc010991c
-c0105bf5:	68 3e 98 10 c0       	push   $0xc010983e
-c0105bfa:	68 9a 00 00 00       	push   $0x9a
-c0105bff:	68 d8 97 10 c0       	push   $0xc01097d8
-c0105c04:	e8 df a7 ff ff       	call   c01003e8 <__panic>
+c0105ee5:	a1 0c 40 12 c0       	mov    0xc012400c,%eax
+c0105eea:	83 f8 03             	cmp    $0x3,%eax
+c0105eed:	74 24                	je     c0105f13 <check_content_set+0x14a>
+c0105eef:	c7 44 24 0c 4c a0 10 	movl   $0xc010a04c,0xc(%esp)
+c0105ef6:	c0 
+c0105ef7:	c7 44 24 08 6e 9f 10 	movl   $0xc0109f6e,0x8(%esp)
+c0105efe:	c0 
+c0105eff:	c7 44 24 04 9a 00 00 	movl   $0x9a,0x4(%esp)
+c0105f06:	00 
+c0105f07:	c7 04 24 08 9f 10 c0 	movl   $0xc0109f08,(%esp)
+c0105f0e:	e8 e5 a4 ff ff       	call   c01003f8 <__panic>
      *(unsigned char *)0x4000 = 0x0d;
-c0105c09:	b8 00 40 00 00       	mov    $0x4000,%eax
-c0105c0e:	c6 00 0d             	movb   $0xd,(%eax)
+c0105f13:	b8 00 40 00 00       	mov    $0x4000,%eax
+c0105f18:	c6 00 0d             	movb   $0xd,(%eax)
      assert(pgfault_num==4);
-c0105c11:	a1 0c 30 12 c0       	mov    0xc012300c,%eax
-c0105c16:	83 f8 04             	cmp    $0x4,%eax
-c0105c19:	74 19                	je     c0105c34 <check_content_set+0x133>
-c0105c1b:	68 2b 99 10 c0       	push   $0xc010992b
-c0105c20:	68 3e 98 10 c0       	push   $0xc010983e
-c0105c25:	68 9c 00 00 00       	push   $0x9c
-c0105c2a:	68 d8 97 10 c0       	push   $0xc01097d8
-c0105c2f:	e8 b4 a7 ff ff       	call   c01003e8 <__panic>
+c0105f1b:	a1 0c 40 12 c0       	mov    0xc012400c,%eax
+c0105f20:	83 f8 04             	cmp    $0x4,%eax
+c0105f23:	74 24                	je     c0105f49 <check_content_set+0x180>
+c0105f25:	c7 44 24 0c 5b a0 10 	movl   $0xc010a05b,0xc(%esp)
+c0105f2c:	c0 
+c0105f2d:	c7 44 24 08 6e 9f 10 	movl   $0xc0109f6e,0x8(%esp)
+c0105f34:	c0 
+c0105f35:	c7 44 24 04 9c 00 00 	movl   $0x9c,0x4(%esp)
+c0105f3c:	00 
+c0105f3d:	c7 04 24 08 9f 10 c0 	movl   $0xc0109f08,(%esp)
+c0105f44:	e8 af a4 ff ff       	call   c01003f8 <__panic>
      *(unsigned char *)0x4010 = 0x0d;
-c0105c34:	b8 10 40 00 00       	mov    $0x4010,%eax
-c0105c39:	c6 00 0d             	movb   $0xd,(%eax)
+c0105f49:	b8 10 40 00 00       	mov    $0x4010,%eax
+c0105f4e:	c6 00 0d             	movb   $0xd,(%eax)
      assert(pgfault_num==4);
-c0105c3c:	a1 0c 30 12 c0       	mov    0xc012300c,%eax
-c0105c41:	83 f8 04             	cmp    $0x4,%eax
-c0105c44:	74 19                	je     c0105c5f <check_content_set+0x15e>
-c0105c46:	68 2b 99 10 c0       	push   $0xc010992b
-c0105c4b:	68 3e 98 10 c0       	push   $0xc010983e
-c0105c50:	68 9e 00 00 00       	push   $0x9e
-c0105c55:	68 d8 97 10 c0       	push   $0xc01097d8
-c0105c5a:	e8 89 a7 ff ff       	call   c01003e8 <__panic>
-}
-c0105c5f:	90                   	nop
-c0105c60:	c9                   	leave  
-c0105c61:	c3                   	ret    
+c0105f51:	a1 0c 40 12 c0       	mov    0xc012400c,%eax
+c0105f56:	83 f8 04             	cmp    $0x4,%eax
+c0105f59:	74 24                	je     c0105f7f <check_content_set+0x1b6>
+c0105f5b:	c7 44 24 0c 5b a0 10 	movl   $0xc010a05b,0xc(%esp)
+c0105f62:	c0 
+c0105f63:	c7 44 24 08 6e 9f 10 	movl   $0xc0109f6e,0x8(%esp)
+c0105f6a:	c0 
+c0105f6b:	c7 44 24 04 9e 00 00 	movl   $0x9e,0x4(%esp)
+c0105f72:	00 
+c0105f73:	c7 04 24 08 9f 10 c0 	movl   $0xc0109f08,(%esp)
+c0105f7a:	e8 79 a4 ff ff       	call   c01003f8 <__panic>
+}
+c0105f7f:	90                   	nop
+c0105f80:	c9                   	leave  
+c0105f81:	c3                   	ret    
 
-c0105c62 <check_content_access>:
+c0105f82 <check_content_access>:
 
 static inline int
 check_content_access(void)
 {
-c0105c62:	55                   	push   %ebp
-c0105c63:	89 e5                	mov    %esp,%ebp
-c0105c65:	83 ec 18             	sub    $0x18,%esp
+c0105f82:	55                   	push   %ebp
+c0105f83:	89 e5                	mov    %esp,%ebp
+c0105f85:	83 ec 18             	sub    $0x18,%esp
     int ret = sm->check_swap();
-c0105c68:	a1 18 30 12 c0       	mov    0xc0123018,%eax
-c0105c6d:	8b 40 1c             	mov    0x1c(%eax),%eax
-c0105c70:	ff d0                	call   *%eax
-c0105c72:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0105f88:	a1 18 40 12 c0       	mov    0xc0124018,%eax
+c0105f8d:	8b 40 1c             	mov    0x1c(%eax),%eax
+c0105f90:	ff d0                	call   *%eax
+c0105f92:	89 45 f4             	mov    %eax,-0xc(%ebp)
     return ret;
-c0105c75:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0105f95:	8b 45 f4             	mov    -0xc(%ebp),%eax
 }
-c0105c78:	c9                   	leave  
-c0105c79:	c3                   	ret    
+c0105f98:	c9                   	leave  
+c0105f99:	c3                   	ret    
 
-c0105c7a <check_swap>:
+c0105f9a <check_swap>:
 #define free_list (free_area.free_list)
 #define nr_free (free_area.nr_free)
 
 static void
 check_swap(void)
 {
-c0105c7a:	55                   	push   %ebp
-c0105c7b:	89 e5                	mov    %esp,%ebp
-c0105c7d:	83 ec 68             	sub    $0x68,%esp
+c0105f9a:	55                   	push   %ebp
+c0105f9b:	89 e5                	mov    %esp,%ebp
+c0105f9d:	83 ec 78             	sub    $0x78,%esp
     //backup mem env
      int ret, count = 0, total = 0, i;
-c0105c80:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
-c0105c87:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+c0105fa0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+c0105fa7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
      list_entry_t *le = &free_list;
-c0105c8e:	c7 45 e8 0c 31 12 c0 	movl   $0xc012310c,-0x18(%ebp)
+c0105fae:	c7 45 e8 0c 41 12 c0 	movl   $0xc012410c,-0x18(%ebp)
      while ((le = list_next(le)) != &free_list) {
-c0105c95:	eb 60                	jmp    c0105cf7 <check_swap+0x7d>
+c0105fb5:	eb 6a                	jmp    c0106021 <check_swap+0x87>
         struct Page *p = le2page(le, page_link);
-c0105c97:	8b 45 e8             	mov    -0x18(%ebp),%eax
-c0105c9a:	83 e8 0c             	sub    $0xc,%eax
-c0105c9d:	89 45 e0             	mov    %eax,-0x20(%ebp)
+c0105fb7:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0105fba:	83 e8 0c             	sub    $0xc,%eax
+c0105fbd:	89 45 e0             	mov    %eax,-0x20(%ebp)
         assert(PageProperty(p));
-c0105ca0:	8b 45 e0             	mov    -0x20(%ebp),%eax
-c0105ca3:	83 c0 04             	add    $0x4,%eax
-c0105ca6:	c7 45 b0 01 00 00 00 	movl   $0x1,-0x50(%ebp)
-c0105cad:	89 45 ac             	mov    %eax,-0x54(%ebp)
+c0105fc0:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0105fc3:	83 c0 04             	add    $0x4,%eax
+c0105fc6:	c7 45 b0 01 00 00 00 	movl   $0x1,-0x50(%ebp)
+c0105fcd:	89 45 ac             	mov    %eax,-0x54(%ebp)
  * @addr:   the address to count from
  * */
 static inline bool
 test_bit(int nr, volatile void *addr) {
     int oldbit;
     asm volatile ("btl %2, %1; sbbl %0,%0" : "=r" (oldbit) : "m" (*(volatile long *)addr), "Ir" (nr));
-c0105cb0:	8b 45 ac             	mov    -0x54(%ebp),%eax
-c0105cb3:	8b 55 b0             	mov    -0x50(%ebp),%edx
-c0105cb6:	0f a3 10             	bt     %edx,(%eax)
-c0105cb9:	19 c0                	sbb    %eax,%eax
-c0105cbb:	89 45 a8             	mov    %eax,-0x58(%ebp)
+c0105fd0:	8b 45 ac             	mov    -0x54(%ebp),%eax
+c0105fd3:	8b 55 b0             	mov    -0x50(%ebp),%edx
+c0105fd6:	0f a3 10             	bt     %edx,(%eax)
+c0105fd9:	19 c0                	sbb    %eax,%eax
+c0105fdb:	89 45 a8             	mov    %eax,-0x58(%ebp)
     return oldbit != 0;
-c0105cbe:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
-c0105cc2:	0f 95 c0             	setne  %al
-c0105cc5:	0f b6 c0             	movzbl %al,%eax
-c0105cc8:	85 c0                	test   %eax,%eax
-c0105cca:	75 19                	jne    c0105ce5 <check_swap+0x6b>
-c0105ccc:	68 3a 99 10 c0       	push   $0xc010993a
-c0105cd1:	68 3e 98 10 c0       	push   $0xc010983e
-c0105cd6:	68 b9 00 00 00       	push   $0xb9
-c0105cdb:	68 d8 97 10 c0       	push   $0xc01097d8
-c0105ce0:	e8 03 a7 ff ff       	call   c01003e8 <__panic>
+c0105fde:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
+c0105fe2:	0f 95 c0             	setne  %al
+c0105fe5:	0f b6 c0             	movzbl %al,%eax
+c0105fe8:	85 c0                	test   %eax,%eax
+c0105fea:	75 24                	jne    c0106010 <check_swap+0x76>
+c0105fec:	c7 44 24 0c 6a a0 10 	movl   $0xc010a06a,0xc(%esp)
+c0105ff3:	c0 
+c0105ff4:	c7 44 24 08 6e 9f 10 	movl   $0xc0109f6e,0x8(%esp)
+c0105ffb:	c0 
+c0105ffc:	c7 44 24 04 b9 00 00 	movl   $0xb9,0x4(%esp)
+c0106003:	00 
+c0106004:	c7 04 24 08 9f 10 c0 	movl   $0xc0109f08,(%esp)
+c010600b:	e8 e8 a3 ff ff       	call   c01003f8 <__panic>
         count ++, total += p->property;
-c0105ce5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
-c0105ce9:	8b 45 e0             	mov    -0x20(%ebp),%eax
-c0105cec:	8b 50 08             	mov    0x8(%eax),%edx
-c0105cef:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0105cf2:	01 d0                	add    %edx,%eax
-c0105cf4:	89 45 f0             	mov    %eax,-0x10(%ebp)
-c0105cf7:	8b 45 e8             	mov    -0x18(%ebp),%eax
-c0105cfa:	89 45 dc             	mov    %eax,-0x24(%ebp)
-c0105cfd:	8b 45 dc             	mov    -0x24(%ebp),%eax
-c0105d00:	8b 40 04             	mov    0x4(%eax),%eax
+c0106010:	ff 45 f4             	incl   -0xc(%ebp)
+c0106013:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0106016:	8b 50 08             	mov    0x8(%eax),%edx
+c0106019:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010601c:	01 d0                	add    %edx,%eax
+c010601e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0106021:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0106024:	89 45 dc             	mov    %eax,-0x24(%ebp)
+c0106027:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c010602a:	8b 40 04             	mov    0x4(%eax),%eax
 check_swap(void)
 {
     //backup mem env
      int ret, count = 0, total = 0, i;
      list_entry_t *le = &free_list;
      while ((le = list_next(le)) != &free_list) {
-c0105d03:	89 45 e8             	mov    %eax,-0x18(%ebp)
-c0105d06:	81 7d e8 0c 31 12 c0 	cmpl   $0xc012310c,-0x18(%ebp)
-c0105d0d:	75 88                	jne    c0105c97 <check_swap+0x1d>
+c010602d:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c0106030:	81 7d e8 0c 41 12 c0 	cmpl   $0xc012410c,-0x18(%ebp)
+c0106037:	0f 85 7a ff ff ff    	jne    c0105fb7 <check_swap+0x1d>
         struct Page *p = le2page(le, page_link);
         assert(PageProperty(p));
         count ++, total += p->property;
      }
      assert(total == nr_free_pages());
-c0105d0f:	e8 a1 d8 ff ff       	call   c01035b5 <nr_free_pages>
-c0105d14:	89 c2                	mov    %eax,%edx
-c0105d16:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0105d19:	39 c2                	cmp    %eax,%edx
-c0105d1b:	74 19                	je     c0105d36 <check_swap+0xbc>
-c0105d1d:	68 4a 99 10 c0       	push   $0xc010994a
-c0105d22:	68 3e 98 10 c0       	push   $0xc010983e
-c0105d27:	68 bc 00 00 00       	push   $0xbc
-c0105d2c:	68 d8 97 10 c0       	push   $0xc01097d8
-c0105d31:	e8 b2 a6 ff ff       	call   c01003e8 <__panic>
+c010603d:	e8 c9 d3 ff ff       	call   c010340b <nr_free_pages>
+c0106042:	89 c2                	mov    %eax,%edx
+c0106044:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0106047:	39 c2                	cmp    %eax,%edx
+c0106049:	74 24                	je     c010606f <check_swap+0xd5>
+c010604b:	c7 44 24 0c 7a a0 10 	movl   $0xc010a07a,0xc(%esp)
+c0106052:	c0 
+c0106053:	c7 44 24 08 6e 9f 10 	movl   $0xc0109f6e,0x8(%esp)
+c010605a:	c0 
+c010605b:	c7 44 24 04 bc 00 00 	movl   $0xbc,0x4(%esp)
+c0106062:	00 
+c0106063:	c7 04 24 08 9f 10 c0 	movl   $0xc0109f08,(%esp)
+c010606a:	e8 89 a3 ff ff       	call   c01003f8 <__panic>
      cprintf("BEGIN check_swap: count %d, total %d\n",count,total);
-c0105d36:	83 ec 04             	sub    $0x4,%esp
-c0105d39:	ff 75 f0             	pushl  -0x10(%ebp)
-c0105d3c:	ff 75 f4             	pushl  -0xc(%ebp)
-c0105d3f:	68 64 99 10 c0       	push   $0xc0109964
-c0105d44:	e8 39 a5 ff ff       	call   c0100282 <cprintf>
-c0105d49:	83 c4 10             	add    $0x10,%esp
+c010606f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0106072:	89 44 24 08          	mov    %eax,0x8(%esp)
+c0106076:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106079:	89 44 24 04          	mov    %eax,0x4(%esp)
+c010607d:	c7 04 24 94 a0 10 c0 	movl   $0xc010a094,(%esp)
+c0106084:	e8 18 a2 ff ff       	call   c01002a1 <cprintf>
      
      //now we set the phy pages env     
      struct mm_struct *mm = mm_create();
-c0105d4c:	e8 36 ee ff ff       	call   c0104b87 <mm_create>
-c0105d51:	89 45 d8             	mov    %eax,-0x28(%ebp)
+c0106089:	e8 29 ec ff ff       	call   c0104cb7 <mm_create>
+c010608e:	89 45 d8             	mov    %eax,-0x28(%ebp)
      assert(mm != NULL);
-c0105d54:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
-c0105d58:	75 19                	jne    c0105d73 <check_swap+0xf9>
-c0105d5a:	68 8a 99 10 c0       	push   $0xc010998a
-c0105d5f:	68 3e 98 10 c0       	push   $0xc010983e
-c0105d64:	68 c1 00 00 00       	push   $0xc1
-c0105d69:	68 d8 97 10 c0       	push   $0xc01097d8
-c0105d6e:	e8 75 a6 ff ff       	call   c01003e8 <__panic>
+c0106091:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
+c0106095:	75 24                	jne    c01060bb <check_swap+0x121>
+c0106097:	c7 44 24 0c ba a0 10 	movl   $0xc010a0ba,0xc(%esp)
+c010609e:	c0 
+c010609f:	c7 44 24 08 6e 9f 10 	movl   $0xc0109f6e,0x8(%esp)
+c01060a6:	c0 
+c01060a7:	c7 44 24 04 c1 00 00 	movl   $0xc1,0x4(%esp)
+c01060ae:	00 
+c01060af:	c7 04 24 08 9f 10 c0 	movl   $0xc0109f08,(%esp)
+c01060b6:	e8 3d a3 ff ff       	call   c01003f8 <__panic>
 
      extern struct mm_struct *check_mm_struct;
      assert(check_mm_struct == NULL);
-c0105d73:	a1 2c 30 12 c0       	mov    0xc012302c,%eax
-c0105d78:	85 c0                	test   %eax,%eax
-c0105d7a:	74 19                	je     c0105d95 <check_swap+0x11b>
-c0105d7c:	68 95 99 10 c0       	push   $0xc0109995
-c0105d81:	68 3e 98 10 c0       	push   $0xc010983e
-c0105d86:	68 c4 00 00 00       	push   $0xc4
-c0105d8b:	68 d8 97 10 c0       	push   $0xc01097d8
-c0105d90:	e8 53 a6 ff ff       	call   c01003e8 <__panic>
+c01060bb:	a1 2c 40 12 c0       	mov    0xc012402c,%eax
+c01060c0:	85 c0                	test   %eax,%eax
+c01060c2:	74 24                	je     c01060e8 <check_swap+0x14e>
+c01060c4:	c7 44 24 0c c5 a0 10 	movl   $0xc010a0c5,0xc(%esp)
+c01060cb:	c0 
+c01060cc:	c7 44 24 08 6e 9f 10 	movl   $0xc0109f6e,0x8(%esp)
+c01060d3:	c0 
+c01060d4:	c7 44 24 04 c4 00 00 	movl   $0xc4,0x4(%esp)
+c01060db:	00 
+c01060dc:	c7 04 24 08 9f 10 c0 	movl   $0xc0109f08,(%esp)
+c01060e3:	e8 10 a3 ff ff       	call   c01003f8 <__panic>
 
      check_mm_struct = mm;
-c0105d95:	8b 45 d8             	mov    -0x28(%ebp),%eax
-c0105d98:	a3 2c 30 12 c0       	mov    %eax,0xc012302c
+c01060e8:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c01060eb:	a3 2c 40 12 c0       	mov    %eax,0xc012402c
 
      pde_t *pgdir = mm->pgdir = boot_pgdir;
-c0105d9d:	8b 15 e0 f9 11 c0    	mov    0xc011f9e0,%edx
-c0105da3:	8b 45 d8             	mov    -0x28(%ebp),%eax
-c0105da6:	89 50 0c             	mov    %edx,0xc(%eax)
-c0105da9:	8b 45 d8             	mov    -0x28(%ebp),%eax
-c0105dac:	8b 40 0c             	mov    0xc(%eax),%eax
-c0105daf:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+c01060f0:	8b 15 e0 09 12 c0    	mov    0xc01209e0,%edx
+c01060f6:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c01060f9:	89 50 0c             	mov    %edx,0xc(%eax)
+c01060fc:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c01060ff:	8b 40 0c             	mov    0xc(%eax),%eax
+c0106102:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      assert(pgdir[0] == 0);
-c0105db2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
-c0105db5:	8b 00                	mov    (%eax),%eax
-c0105db7:	85 c0                	test   %eax,%eax
-c0105db9:	74 19                	je     c0105dd4 <check_swap+0x15a>
-c0105dbb:	68 ad 99 10 c0       	push   $0xc01099ad
-c0105dc0:	68 3e 98 10 c0       	push   $0xc010983e
-c0105dc5:	68 c9 00 00 00       	push   $0xc9
-c0105dca:	68 d8 97 10 c0       	push   $0xc01097d8
-c0105dcf:	e8 14 a6 ff ff       	call   c01003e8 <__panic>
+c0106105:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+c0106108:	8b 00                	mov    (%eax),%eax
+c010610a:	85 c0                	test   %eax,%eax
+c010610c:	74 24                	je     c0106132 <check_swap+0x198>
+c010610e:	c7 44 24 0c dd a0 10 	movl   $0xc010a0dd,0xc(%esp)
+c0106115:	c0 
+c0106116:	c7 44 24 08 6e 9f 10 	movl   $0xc0109f6e,0x8(%esp)
+c010611d:	c0 
+c010611e:	c7 44 24 04 c9 00 00 	movl   $0xc9,0x4(%esp)
+c0106125:	00 
+c0106126:	c7 04 24 08 9f 10 c0 	movl   $0xc0109f08,(%esp)
+c010612d:	e8 c6 a2 ff ff       	call   c01003f8 <__panic>
 
      struct vma_struct *vma = vma_create(BEING_CHECK_VALID_VADDR, CHECK_VALID_VADDR, VM_WRITE | VM_READ);
-c0105dd4:	83 ec 04             	sub    $0x4,%esp
-c0105dd7:	6a 03                	push   $0x3
-c0105dd9:	68 00 60 00 00       	push   $0x6000
-c0105dde:	68 00 10 00 00       	push   $0x1000
-c0105de3:	e8 1b ee ff ff       	call   c0104c03 <vma_create>
-c0105de8:	83 c4 10             	add    $0x10,%esp
-c0105deb:	89 45 d0             	mov    %eax,-0x30(%ebp)
+c0106132:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
+c0106139:	00 
+c010613a:	c7 44 24 04 00 60 00 	movl   $0x6000,0x4(%esp)
+c0106141:	00 
+c0106142:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
+c0106149:	e8 e1 eb ff ff       	call   c0104d2f <vma_create>
+c010614e:	89 45 d0             	mov    %eax,-0x30(%ebp)
      assert(vma != NULL);
-c0105dee:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
-c0105df2:	75 19                	jne    c0105e0d <check_swap+0x193>
-c0105df4:	68 bb 99 10 c0       	push   $0xc01099bb
-c0105df9:	68 3e 98 10 c0       	push   $0xc010983e
-c0105dfe:	68 cc 00 00 00       	push   $0xcc
-c0105e03:	68 d8 97 10 c0       	push   $0xc01097d8
-c0105e08:	e8 db a5 ff ff       	call   c01003e8 <__panic>
+c0106151:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
+c0106155:	75 24                	jne    c010617b <check_swap+0x1e1>
+c0106157:	c7 44 24 0c eb a0 10 	movl   $0xc010a0eb,0xc(%esp)
+c010615e:	c0 
+c010615f:	c7 44 24 08 6e 9f 10 	movl   $0xc0109f6e,0x8(%esp)
+c0106166:	c0 
+c0106167:	c7 44 24 04 cc 00 00 	movl   $0xcc,0x4(%esp)
+c010616e:	00 
+c010616f:	c7 04 24 08 9f 10 c0 	movl   $0xc0109f08,(%esp)
+c0106176:	e8 7d a2 ff ff       	call   c01003f8 <__panic>
 
      insert_vma_struct(mm, vma);
-c0105e0d:	83 ec 08             	sub    $0x8,%esp
-c0105e10:	ff 75 d0             	pushl  -0x30(%ebp)
-c0105e13:	ff 75 d8             	pushl  -0x28(%ebp)
-c0105e16:	e8 50 ef ff ff       	call   c0104d6b <insert_vma_struct>
-c0105e1b:	83 c4 10             	add    $0x10,%esp
+c010617b:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c010617e:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0106182:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c0106185:	89 04 24             	mov    %eax,(%esp)
+c0106188:	e8 33 ed ff ff       	call   c0104ec0 <insert_vma_struct>
 
      //setup the temp Page Table vaddr 0~4MB
      cprintf("setup Page Table for vaddr 0X1000, so alloc a page\n");
-c0105e1e:	83 ec 0c             	sub    $0xc,%esp
-c0105e21:	68 c8 99 10 c0       	push   $0xc01099c8
-c0105e26:	e8 57 a4 ff ff       	call   c0100282 <cprintf>
-c0105e2b:	83 c4 10             	add    $0x10,%esp
+c010618d:	c7 04 24 f8 a0 10 c0 	movl   $0xc010a0f8,(%esp)
+c0106194:	e8 08 a1 ff ff       	call   c01002a1 <cprintf>
      pte_t *temp_ptep=NULL;
-c0105e2e:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
+c0106199:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
      temp_ptep = get_pte(mm->pgdir, BEING_CHECK_VALID_VADDR, 1);
-c0105e35:	8b 45 d8             	mov    -0x28(%ebp),%eax
-c0105e38:	8b 40 0c             	mov    0xc(%eax),%eax
-c0105e3b:	83 ec 04             	sub    $0x4,%esp
-c0105e3e:	6a 01                	push   $0x1
-c0105e40:	68 00 10 00 00       	push   $0x1000
-c0105e45:	50                   	push   %eax
-c0105e46:	e8 30 dd ff ff       	call   c0103b7b <get_pte>
-c0105e4b:	83 c4 10             	add    $0x10,%esp
-c0105e4e:	89 45 cc             	mov    %eax,-0x34(%ebp)
+c01061a0:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c01061a3:	8b 40 0c             	mov    0xc(%eax),%eax
+c01061a6:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
+c01061ad:	00 
+c01061ae:	c7 44 24 04 00 10 00 	movl   $0x1000,0x4(%esp)
+c01061b5:	00 
+c01061b6:	89 04 24             	mov    %eax,(%esp)
+c01061b9:	e8 7c d8 ff ff       	call   c0103a3a <get_pte>
+c01061be:	89 45 cc             	mov    %eax,-0x34(%ebp)
      assert(temp_ptep!= NULL);
-c0105e51:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
-c0105e55:	75 19                	jne    c0105e70 <check_swap+0x1f6>
-c0105e57:	68 fc 99 10 c0       	push   $0xc01099fc
-c0105e5c:	68 3e 98 10 c0       	push   $0xc010983e
-c0105e61:	68 d4 00 00 00       	push   $0xd4
-c0105e66:	68 d8 97 10 c0       	push   $0xc01097d8
-c0105e6b:	e8 78 a5 ff ff       	call   c01003e8 <__panic>
+c01061c1:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
+c01061c5:	75 24                	jne    c01061eb <check_swap+0x251>
+c01061c7:	c7 44 24 0c 2c a1 10 	movl   $0xc010a12c,0xc(%esp)
+c01061ce:	c0 
+c01061cf:	c7 44 24 08 6e 9f 10 	movl   $0xc0109f6e,0x8(%esp)
+c01061d6:	c0 
+c01061d7:	c7 44 24 04 d4 00 00 	movl   $0xd4,0x4(%esp)
+c01061de:	00 
+c01061df:	c7 04 24 08 9f 10 c0 	movl   $0xc0109f08,(%esp)
+c01061e6:	e8 0d a2 ff ff       	call   c01003f8 <__panic>
      cprintf("setup Page Table vaddr 0~4MB OVER!\n");
-c0105e70:	83 ec 0c             	sub    $0xc,%esp
-c0105e73:	68 10 9a 10 c0       	push   $0xc0109a10
-c0105e78:	e8 05 a4 ff ff       	call   c0100282 <cprintf>
-c0105e7d:	83 c4 10             	add    $0x10,%esp
+c01061eb:	c7 04 24 40 a1 10 c0 	movl   $0xc010a140,(%esp)
+c01061f2:	e8 aa a0 ff ff       	call   c01002a1 <cprintf>
      
      for (i=0;i<CHECK_VALID_PHY_PAGE_NUM;i++) {
-c0105e80:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
-c0105e87:	e9 90 00 00 00       	jmp    c0105f1c <check_swap+0x2a2>
+c01061f7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+c01061fe:	e9 a4 00 00 00       	jmp    c01062a7 <check_swap+0x30d>
           check_rp[i] = alloc_page();
-c0105e8c:	83 ec 0c             	sub    $0xc,%esp
-c0105e8f:	6a 01                	push   $0x1
-c0105e91:	e8 7e d6 ff ff       	call   c0103514 <alloc_pages>
-c0105e96:	83 c4 10             	add    $0x10,%esp
-c0105e99:	89 c2                	mov    %eax,%edx
-c0105e9b:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c0105e9e:	89 14 85 40 30 12 c0 	mov    %edx,-0x3fedcfc0(,%eax,4)
+c0106203:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c010620a:	e8 5e d1 ff ff       	call   c010336d <alloc_pages>
+c010620f:	89 c2                	mov    %eax,%edx
+c0106211:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0106214:	89 14 85 40 40 12 c0 	mov    %edx,-0x3fedbfc0(,%eax,4)
           assert(check_rp[i] != NULL );
-c0105ea5:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c0105ea8:	8b 04 85 40 30 12 c0 	mov    -0x3fedcfc0(,%eax,4),%eax
-c0105eaf:	85 c0                	test   %eax,%eax
-c0105eb1:	75 19                	jne    c0105ecc <check_swap+0x252>
-c0105eb3:	68 34 9a 10 c0       	push   $0xc0109a34
-c0105eb8:	68 3e 98 10 c0       	push   $0xc010983e
-c0105ebd:	68 d9 00 00 00       	push   $0xd9
-c0105ec2:	68 d8 97 10 c0       	push   $0xc01097d8
-c0105ec7:	e8 1c a5 ff ff       	call   c01003e8 <__panic>
+c010621b:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c010621e:	8b 04 85 40 40 12 c0 	mov    -0x3fedbfc0(,%eax,4),%eax
+c0106225:	85 c0                	test   %eax,%eax
+c0106227:	75 24                	jne    c010624d <check_swap+0x2b3>
+c0106229:	c7 44 24 0c 64 a1 10 	movl   $0xc010a164,0xc(%esp)
+c0106230:	c0 
+c0106231:	c7 44 24 08 6e 9f 10 	movl   $0xc0109f6e,0x8(%esp)
+c0106238:	c0 
+c0106239:	c7 44 24 04 d9 00 00 	movl   $0xd9,0x4(%esp)
+c0106240:	00 
+c0106241:	c7 04 24 08 9f 10 c0 	movl   $0xc0109f08,(%esp)
+c0106248:	e8 ab a1 ff ff       	call   c01003f8 <__panic>
           assert(!PageProperty(check_rp[i]));
-c0105ecc:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c0105ecf:	8b 04 85 40 30 12 c0 	mov    -0x3fedcfc0(,%eax,4),%eax
-c0105ed6:	83 c0 04             	add    $0x4,%eax
-c0105ed9:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
-c0105ee0:	89 45 a4             	mov    %eax,-0x5c(%ebp)
+c010624d:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0106250:	8b 04 85 40 40 12 c0 	mov    -0x3fedbfc0(,%eax,4),%eax
+c0106257:	83 c0 04             	add    $0x4,%eax
+c010625a:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
+c0106261:	89 45 a4             	mov    %eax,-0x5c(%ebp)
  * @addr:   the address to count from
  * */
 static inline bool
 test_bit(int nr, volatile void *addr) {
     int oldbit;
     asm volatile ("btl %2, %1; sbbl %0,%0" : "=r" (oldbit) : "m" (*(volatile long *)addr), "Ir" (nr));
-c0105ee3:	8b 45 a4             	mov    -0x5c(%ebp),%eax
-c0105ee6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
-c0105ee9:	0f a3 10             	bt     %edx,(%eax)
-c0105eec:	19 c0                	sbb    %eax,%eax
-c0105eee:	89 45 a0             	mov    %eax,-0x60(%ebp)
+c0106264:	8b 45 a4             	mov    -0x5c(%ebp),%eax
+c0106267:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c010626a:	0f a3 10             	bt     %edx,(%eax)
+c010626d:	19 c0                	sbb    %eax,%eax
+c010626f:	89 45 a0             	mov    %eax,-0x60(%ebp)
     return oldbit != 0;
-c0105ef1:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
-c0105ef5:	0f 95 c0             	setne  %al
-c0105ef8:	0f b6 c0             	movzbl %al,%eax
-c0105efb:	85 c0                	test   %eax,%eax
-c0105efd:	74 19                	je     c0105f18 <check_swap+0x29e>
-c0105eff:	68 48 9a 10 c0       	push   $0xc0109a48
-c0105f04:	68 3e 98 10 c0       	push   $0xc010983e
-c0105f09:	68 da 00 00 00       	push   $0xda
-c0105f0e:	68 d8 97 10 c0       	push   $0xc01097d8
-c0105f13:	e8 d0 a4 ff ff       	call   c01003e8 <__panic>
+c0106272:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
+c0106276:	0f 95 c0             	setne  %al
+c0106279:	0f b6 c0             	movzbl %al,%eax
+c010627c:	85 c0                	test   %eax,%eax
+c010627e:	74 24                	je     c01062a4 <check_swap+0x30a>
+c0106280:	c7 44 24 0c 78 a1 10 	movl   $0xc010a178,0xc(%esp)
+c0106287:	c0 
+c0106288:	c7 44 24 08 6e 9f 10 	movl   $0xc0109f6e,0x8(%esp)
+c010628f:	c0 
+c0106290:	c7 44 24 04 da 00 00 	movl   $0xda,0x4(%esp)
+c0106297:	00 
+c0106298:	c7 04 24 08 9f 10 c0 	movl   $0xc0109f08,(%esp)
+c010629f:	e8 54 a1 ff ff       	call   c01003f8 <__panic>
      pte_t *temp_ptep=NULL;
      temp_ptep = get_pte(mm->pgdir, BEING_CHECK_VALID_VADDR, 1);
      assert(temp_ptep!= NULL);
      cprintf("setup Page Table vaddr 0~4MB OVER!\n");
      
      for (i=0;i<CHECK_VALID_PHY_PAGE_NUM;i++) {
-c0105f18:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
-c0105f1c:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
-c0105f20:	0f 8e 66 ff ff ff    	jle    c0105e8c <check_swap+0x212>
+c01062a4:	ff 45 ec             	incl   -0x14(%ebp)
+c01062a7:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
+c01062ab:	0f 8e 52 ff ff ff    	jle    c0106203 <check_swap+0x269>
           check_rp[i] = alloc_page();
           assert(check_rp[i] != NULL );
           assert(!PageProperty(check_rp[i]));
      }
      list_entry_t free_list_store = free_list;
-c0105f26:	a1 0c 31 12 c0       	mov    0xc012310c,%eax
-c0105f2b:	8b 15 10 31 12 c0    	mov    0xc0123110,%edx
-c0105f31:	89 45 98             	mov    %eax,-0x68(%ebp)
-c0105f34:	89 55 9c             	mov    %edx,-0x64(%ebp)
-c0105f37:	c7 45 c0 0c 31 12 c0 	movl   $0xc012310c,-0x40(%ebp)
+c01062b1:	a1 0c 41 12 c0       	mov    0xc012410c,%eax
+c01062b6:	8b 15 10 41 12 c0    	mov    0xc0124110,%edx
+c01062bc:	89 45 98             	mov    %eax,-0x68(%ebp)
+c01062bf:	89 55 9c             	mov    %edx,-0x64(%ebp)
+c01062c2:	c7 45 c0 0c 41 12 c0 	movl   $0xc012410c,-0x40(%ebp)
  * list_init - initialize a new entry
  * @elm:        new entry to be initialized
  * */
 static inline void
 list_init(list_entry_t *elm) {
     elm->prev = elm->next = elm;
-c0105f3e:	8b 45 c0             	mov    -0x40(%ebp),%eax
-c0105f41:	8b 55 c0             	mov    -0x40(%ebp),%edx
-c0105f44:	89 50 04             	mov    %edx,0x4(%eax)
-c0105f47:	8b 45 c0             	mov    -0x40(%ebp),%eax
-c0105f4a:	8b 50 04             	mov    0x4(%eax),%edx
-c0105f4d:	8b 45 c0             	mov    -0x40(%ebp),%eax
-c0105f50:	89 10                	mov    %edx,(%eax)
-c0105f52:	c7 45 c8 0c 31 12 c0 	movl   $0xc012310c,-0x38(%ebp)
+c01062c9:	8b 45 c0             	mov    -0x40(%ebp),%eax
+c01062cc:	8b 55 c0             	mov    -0x40(%ebp),%edx
+c01062cf:	89 50 04             	mov    %edx,0x4(%eax)
+c01062d2:	8b 45 c0             	mov    -0x40(%ebp),%eax
+c01062d5:	8b 50 04             	mov    0x4(%eax),%edx
+c01062d8:	8b 45 c0             	mov    -0x40(%ebp),%eax
+c01062db:	89 10                	mov    %edx,(%eax)
+c01062dd:	c7 45 c8 0c 41 12 c0 	movl   $0xc012410c,-0x38(%ebp)
  * list_empty - tests whether a list is empty
  * @list:       the list to test.
  * */
 static inline bool
 list_empty(list_entry_t *list) {
     return list->next == list;
-c0105f59:	8b 45 c8             	mov    -0x38(%ebp),%eax
-c0105f5c:	8b 40 04             	mov    0x4(%eax),%eax
-c0105f5f:	39 45 c8             	cmp    %eax,-0x38(%ebp)
-c0105f62:	0f 94 c0             	sete   %al
-c0105f65:	0f b6 c0             	movzbl %al,%eax
+c01062e4:	8b 45 c8             	mov    -0x38(%ebp),%eax
+c01062e7:	8b 40 04             	mov    0x4(%eax),%eax
+c01062ea:	39 45 c8             	cmp    %eax,-0x38(%ebp)
+c01062ed:	0f 94 c0             	sete   %al
+c01062f0:	0f b6 c0             	movzbl %al,%eax
      list_init(&free_list);
      assert(list_empty(&free_list));
-c0105f68:	85 c0                	test   %eax,%eax
-c0105f6a:	75 19                	jne    c0105f85 <check_swap+0x30b>
-c0105f6c:	68 63 9a 10 c0       	push   $0xc0109a63
-c0105f71:	68 3e 98 10 c0       	push   $0xc010983e
-c0105f76:	68 de 00 00 00       	push   $0xde
-c0105f7b:	68 d8 97 10 c0       	push   $0xc01097d8
-c0105f80:	e8 63 a4 ff ff       	call   c01003e8 <__panic>
+c01062f3:	85 c0                	test   %eax,%eax
+c01062f5:	75 24                	jne    c010631b <check_swap+0x381>
+c01062f7:	c7 44 24 0c 93 a1 10 	movl   $0xc010a193,0xc(%esp)
+c01062fe:	c0 
+c01062ff:	c7 44 24 08 6e 9f 10 	movl   $0xc0109f6e,0x8(%esp)
+c0106306:	c0 
+c0106307:	c7 44 24 04 de 00 00 	movl   $0xde,0x4(%esp)
+c010630e:	00 
+c010630f:	c7 04 24 08 9f 10 c0 	movl   $0xc0109f08,(%esp)
+c0106316:	e8 dd a0 ff ff       	call   c01003f8 <__panic>
      
      //assert(alloc_page() == NULL);
      
      unsigned int nr_free_store = nr_free;
-c0105f85:	a1 14 31 12 c0       	mov    0xc0123114,%eax
-c0105f8a:	89 45 bc             	mov    %eax,-0x44(%ebp)
+c010631b:	a1 14 41 12 c0       	mov    0xc0124114,%eax
+c0106320:	89 45 bc             	mov    %eax,-0x44(%ebp)
      nr_free = 0;
-c0105f8d:	c7 05 14 31 12 c0 00 	movl   $0x0,0xc0123114
-c0105f94:	00 00 00 
+c0106323:	c7 05 14 41 12 c0 00 	movl   $0x0,0xc0124114
+c010632a:	00 00 00 
      for (i=0;i<CHECK_VALID_PHY_PAGE_NUM;i++) {
-c0105f97:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
-c0105f9e:	eb 1c                	jmp    c0105fbc <check_swap+0x342>
+c010632d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+c0106334:	eb 1d                	jmp    c0106353 <check_swap+0x3b9>
         free_pages(check_rp[i],1);
-c0105fa0:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c0105fa3:	8b 04 85 40 30 12 c0 	mov    -0x3fedcfc0(,%eax,4),%eax
-c0105faa:	83 ec 08             	sub    $0x8,%esp
-c0105fad:	6a 01                	push   $0x1
-c0105faf:	50                   	push   %eax
-c0105fb0:	e8 cb d5 ff ff       	call   c0103580 <free_pages>
-c0105fb5:	83 c4 10             	add    $0x10,%esp
+c0106336:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0106339:	8b 04 85 40 40 12 c0 	mov    -0x3fedbfc0(,%eax,4),%eax
+c0106340:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+c0106347:	00 
+c0106348:	89 04 24             	mov    %eax,(%esp)
+c010634b:	e8 88 d0 ff ff       	call   c01033d8 <free_pages>
      
      //assert(alloc_page() == NULL);
      
      unsigned int nr_free_store = nr_free;
      nr_free = 0;
      for (i=0;i<CHECK_VALID_PHY_PAGE_NUM;i++) {
-c0105fb8:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
-c0105fbc:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
-c0105fc0:	7e de                	jle    c0105fa0 <check_swap+0x326>
+c0106350:	ff 45 ec             	incl   -0x14(%ebp)
+c0106353:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
+c0106357:	7e dd                	jle    c0106336 <check_swap+0x39c>
         free_pages(check_rp[i],1);
      }
      assert(nr_free==CHECK_VALID_PHY_PAGE_NUM);
-c0105fc2:	a1 14 31 12 c0       	mov    0xc0123114,%eax
-c0105fc7:	83 f8 04             	cmp    $0x4,%eax
-c0105fca:	74 19                	je     c0105fe5 <check_swap+0x36b>
-c0105fcc:	68 7c 9a 10 c0       	push   $0xc0109a7c
-c0105fd1:	68 3e 98 10 c0       	push   $0xc010983e
-c0105fd6:	68 e7 00 00 00       	push   $0xe7
-c0105fdb:	68 d8 97 10 c0       	push   $0xc01097d8
-c0105fe0:	e8 03 a4 ff ff       	call   c01003e8 <__panic>
+c0106359:	a1 14 41 12 c0       	mov    0xc0124114,%eax
+c010635e:	83 f8 04             	cmp    $0x4,%eax
+c0106361:	74 24                	je     c0106387 <check_swap+0x3ed>
+c0106363:	c7 44 24 0c ac a1 10 	movl   $0xc010a1ac,0xc(%esp)
+c010636a:	c0 
+c010636b:	c7 44 24 08 6e 9f 10 	movl   $0xc0109f6e,0x8(%esp)
+c0106372:	c0 
+c0106373:	c7 44 24 04 e7 00 00 	movl   $0xe7,0x4(%esp)
+c010637a:	00 
+c010637b:	c7 04 24 08 9f 10 c0 	movl   $0xc0109f08,(%esp)
+c0106382:	e8 71 a0 ff ff       	call   c01003f8 <__panic>
      
      cprintf("set up init env for check_swap begin!\n");
-c0105fe5:	83 ec 0c             	sub    $0xc,%esp
-c0105fe8:	68 a0 9a 10 c0       	push   $0xc0109aa0
-c0105fed:	e8 90 a2 ff ff       	call   c0100282 <cprintf>
-c0105ff2:	83 c4 10             	add    $0x10,%esp
+c0106387:	c7 04 24 d0 a1 10 c0 	movl   $0xc010a1d0,(%esp)
+c010638e:	e8 0e 9f ff ff       	call   c01002a1 <cprintf>
      //setup initial vir_page<->phy_page environment for page relpacement algorithm 
 
      
      pgfault_num=0;
-c0105ff5:	c7 05 0c 30 12 c0 00 	movl   $0x0,0xc012300c
-c0105ffc:	00 00 00 
+c0106393:	c7 05 0c 40 12 c0 00 	movl   $0x0,0xc012400c
+c010639a:	00 00 00 
      
      check_content_set();
-c0105fff:	e8 fd fa ff ff       	call   c0105b01 <check_content_set>
+c010639d:	e8 27 fa ff ff       	call   c0105dc9 <check_content_set>
      assert( nr_free == 0);         
-c0106004:	a1 14 31 12 c0       	mov    0xc0123114,%eax
-c0106009:	85 c0                	test   %eax,%eax
-c010600b:	74 19                	je     c0106026 <check_swap+0x3ac>
-c010600d:	68 c7 9a 10 c0       	push   $0xc0109ac7
-c0106012:	68 3e 98 10 c0       	push   $0xc010983e
-c0106017:	68 f0 00 00 00       	push   $0xf0
-c010601c:	68 d8 97 10 c0       	push   $0xc01097d8
-c0106021:	e8 c2 a3 ff ff       	call   c01003e8 <__panic>
+c01063a2:	a1 14 41 12 c0       	mov    0xc0124114,%eax
+c01063a7:	85 c0                	test   %eax,%eax
+c01063a9:	74 24                	je     c01063cf <check_swap+0x435>
+c01063ab:	c7 44 24 0c f7 a1 10 	movl   $0xc010a1f7,0xc(%esp)
+c01063b2:	c0 
+c01063b3:	c7 44 24 08 6e 9f 10 	movl   $0xc0109f6e,0x8(%esp)
+c01063ba:	c0 
+c01063bb:	c7 44 24 04 f0 00 00 	movl   $0xf0,0x4(%esp)
+c01063c2:	00 
+c01063c3:	c7 04 24 08 9f 10 c0 	movl   $0xc0109f08,(%esp)
+c01063ca:	e8 29 a0 ff ff       	call   c01003f8 <__panic>
      for(i = 0; i<MAX_SEQ_NO ; i++) 
-c0106026:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
-c010602d:	eb 26                	jmp    c0106055 <check_swap+0x3db>
+c01063cf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+c01063d6:	eb 25                	jmp    c01063fd <check_swap+0x463>
          swap_out_seq_no[i]=swap_in_seq_no[i]=-1;
-c010602f:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c0106032:	c7 04 85 60 30 12 c0 	movl   $0xffffffff,-0x3fedcfa0(,%eax,4)
-c0106039:	ff ff ff ff 
-c010603d:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c0106040:	8b 14 85 60 30 12 c0 	mov    -0x3fedcfa0(,%eax,4),%edx
-c0106047:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c010604a:	89 14 85 a0 30 12 c0 	mov    %edx,-0x3fedcf60(,%eax,4)
+c01063d8:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c01063db:	c7 04 85 60 40 12 c0 	movl   $0xffffffff,-0x3fedbfa0(,%eax,4)
+c01063e2:	ff ff ff ff 
+c01063e6:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c01063e9:	8b 14 85 60 40 12 c0 	mov    -0x3fedbfa0(,%eax,4),%edx
+c01063f0:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c01063f3:	89 14 85 a0 40 12 c0 	mov    %edx,-0x3fedbf60(,%eax,4)
      
      pgfault_num=0;
      
      check_content_set();
      assert( nr_free == 0);         
      for(i = 0; i<MAX_SEQ_NO ; i++) 
-c0106051:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
-c0106055:	83 7d ec 09          	cmpl   $0x9,-0x14(%ebp)
-c0106059:	7e d4                	jle    c010602f <check_swap+0x3b5>
+c01063fa:	ff 45 ec             	incl   -0x14(%ebp)
+c01063fd:	83 7d ec 09          	cmpl   $0x9,-0x14(%ebp)
+c0106401:	7e d5                	jle    c01063d8 <check_swap+0x43e>
          swap_out_seq_no[i]=swap_in_seq_no[i]=-1;
      
      for (i= 0;i<CHECK_VALID_PHY_PAGE_NUM;i++) {
-c010605b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
-c0106062:	e9 cc 00 00 00       	jmp    c0106133 <check_swap+0x4b9>
+c0106403:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+c010640a:	e9 ec 00 00 00       	jmp    c01064fb <check_swap+0x561>
          check_ptep[i]=0;
-c0106067:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c010606a:	c7 04 85 f4 30 12 c0 	movl   $0x0,-0x3fedcf0c(,%eax,4)
-c0106071:	00 00 00 00 
+c010640f:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0106412:	c7 04 85 f4 40 12 c0 	movl   $0x0,-0x3fedbf0c(,%eax,4)
+c0106419:	00 00 00 00 
          check_ptep[i] = get_pte(pgdir, (i+1)*0x1000, 0);
-c0106075:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c0106078:	83 c0 01             	add    $0x1,%eax
-c010607b:	c1 e0 0c             	shl    $0xc,%eax
-c010607e:	83 ec 04             	sub    $0x4,%esp
-c0106081:	6a 00                	push   $0x0
-c0106083:	50                   	push   %eax
-c0106084:	ff 75 d4             	pushl  -0x2c(%ebp)
-c0106087:	e8 ef da ff ff       	call   c0103b7b <get_pte>
-c010608c:	83 c4 10             	add    $0x10,%esp
-c010608f:	89 c2                	mov    %eax,%edx
-c0106091:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c0106094:	89 14 85 f4 30 12 c0 	mov    %edx,-0x3fedcf0c(,%eax,4)
+c010641d:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0106420:	40                   	inc    %eax
+c0106421:	c1 e0 0c             	shl    $0xc,%eax
+c0106424:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+c010642b:	00 
+c010642c:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0106430:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+c0106433:	89 04 24             	mov    %eax,(%esp)
+c0106436:	e8 ff d5 ff ff       	call   c0103a3a <get_pte>
+c010643b:	89 c2                	mov    %eax,%edx
+c010643d:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0106440:	89 14 85 f4 40 12 c0 	mov    %edx,-0x3fedbf0c(,%eax,4)
          //cprintf("i %d, check_ptep addr %x, value %x\n", i, check_ptep[i], *check_ptep[i]);
          assert(check_ptep[i] != NULL);
-c010609b:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c010609e:	8b 04 85 f4 30 12 c0 	mov    -0x3fedcf0c(,%eax,4),%eax
-c01060a5:	85 c0                	test   %eax,%eax
-c01060a7:	75 19                	jne    c01060c2 <check_swap+0x448>
-c01060a9:	68 d4 9a 10 c0       	push   $0xc0109ad4
-c01060ae:	68 3e 98 10 c0       	push   $0xc010983e
-c01060b3:	68 f8 00 00 00       	push   $0xf8
-c01060b8:	68 d8 97 10 c0       	push   $0xc01097d8
-c01060bd:	e8 26 a3 ff ff       	call   c01003e8 <__panic>
+c0106447:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c010644a:	8b 04 85 f4 40 12 c0 	mov    -0x3fedbf0c(,%eax,4),%eax
+c0106451:	85 c0                	test   %eax,%eax
+c0106453:	75 24                	jne    c0106479 <check_swap+0x4df>
+c0106455:	c7 44 24 0c 04 a2 10 	movl   $0xc010a204,0xc(%esp)
+c010645c:	c0 
+c010645d:	c7 44 24 08 6e 9f 10 	movl   $0xc0109f6e,0x8(%esp)
+c0106464:	c0 
+c0106465:	c7 44 24 04 f8 00 00 	movl   $0xf8,0x4(%esp)
+c010646c:	00 
+c010646d:	c7 04 24 08 9f 10 c0 	movl   $0xc0109f08,(%esp)
+c0106474:	e8 7f 9f ff ff       	call   c01003f8 <__panic>
          assert(pte2page(*check_ptep[i]) == check_rp[i]);
-c01060c2:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c01060c5:	8b 04 85 f4 30 12 c0 	mov    -0x3fedcf0c(,%eax,4),%eax
-c01060cc:	8b 00                	mov    (%eax),%eax
-c01060ce:	83 ec 0c             	sub    $0xc,%esp
-c01060d1:	50                   	push   %eax
-c01060d2:	e8 f4 f6 ff ff       	call   c01057cb <pte2page>
-c01060d7:	83 c4 10             	add    $0x10,%esp
-c01060da:	89 c2                	mov    %eax,%edx
-c01060dc:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c01060df:	8b 04 85 40 30 12 c0 	mov    -0x3fedcfc0(,%eax,4),%eax
-c01060e6:	39 c2                	cmp    %eax,%edx
-c01060e8:	74 19                	je     c0106103 <check_swap+0x489>
-c01060ea:	68 ec 9a 10 c0       	push   $0xc0109aec
-c01060ef:	68 3e 98 10 c0       	push   $0xc010983e
-c01060f4:	68 f9 00 00 00       	push   $0xf9
-c01060f9:	68 d8 97 10 c0       	push   $0xc01097d8
-c01060fe:	e8 e5 a2 ff ff       	call   c01003e8 <__panic>
+c0106479:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c010647c:	8b 04 85 f4 40 12 c0 	mov    -0x3fedbf0c(,%eax,4),%eax
+c0106483:	8b 00                	mov    (%eax),%eax
+c0106485:	89 04 24             	mov    %eax,(%esp)
+c0106488:	e8 a6 f5 ff ff       	call   c0105a33 <pte2page>
+c010648d:	89 c2                	mov    %eax,%edx
+c010648f:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0106492:	8b 04 85 40 40 12 c0 	mov    -0x3fedbfc0(,%eax,4),%eax
+c0106499:	39 c2                	cmp    %eax,%edx
+c010649b:	74 24                	je     c01064c1 <check_swap+0x527>
+c010649d:	c7 44 24 0c 1c a2 10 	movl   $0xc010a21c,0xc(%esp)
+c01064a4:	c0 
+c01064a5:	c7 44 24 08 6e 9f 10 	movl   $0xc0109f6e,0x8(%esp)
+c01064ac:	c0 
+c01064ad:	c7 44 24 04 f9 00 00 	movl   $0xf9,0x4(%esp)
+c01064b4:	00 
+c01064b5:	c7 04 24 08 9f 10 c0 	movl   $0xc0109f08,(%esp)
+c01064bc:	e8 37 9f ff ff       	call   c01003f8 <__panic>
          assert((*check_ptep[i] & PTE_P));          
-c0106103:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c0106106:	8b 04 85 f4 30 12 c0 	mov    -0x3fedcf0c(,%eax,4),%eax
-c010610d:	8b 00                	mov    (%eax),%eax
-c010610f:	83 e0 01             	and    $0x1,%eax
-c0106112:	85 c0                	test   %eax,%eax
-c0106114:	75 19                	jne    c010612f <check_swap+0x4b5>
-c0106116:	68 14 9b 10 c0       	push   $0xc0109b14
-c010611b:	68 3e 98 10 c0       	push   $0xc010983e
-c0106120:	68 fa 00 00 00       	push   $0xfa
-c0106125:	68 d8 97 10 c0       	push   $0xc01097d8
-c010612a:	e8 b9 a2 ff ff       	call   c01003e8 <__panic>
+c01064c1:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c01064c4:	8b 04 85 f4 40 12 c0 	mov    -0x3fedbf0c(,%eax,4),%eax
+c01064cb:	8b 00                	mov    (%eax),%eax
+c01064cd:	83 e0 01             	and    $0x1,%eax
+c01064d0:	85 c0                	test   %eax,%eax
+c01064d2:	75 24                	jne    c01064f8 <check_swap+0x55e>
+c01064d4:	c7 44 24 0c 44 a2 10 	movl   $0xc010a244,0xc(%esp)
+c01064db:	c0 
+c01064dc:	c7 44 24 08 6e 9f 10 	movl   $0xc0109f6e,0x8(%esp)
+c01064e3:	c0 
+c01064e4:	c7 44 24 04 fa 00 00 	movl   $0xfa,0x4(%esp)
+c01064eb:	00 
+c01064ec:	c7 04 24 08 9f 10 c0 	movl   $0xc0109f08,(%esp)
+c01064f3:	e8 00 9f ff ff       	call   c01003f8 <__panic>
      check_content_set();
      assert( nr_free == 0);         
      for(i = 0; i<MAX_SEQ_NO ; i++) 
          swap_out_seq_no[i]=swap_in_seq_no[i]=-1;
      
      for (i= 0;i<CHECK_VALID_PHY_PAGE_NUM;i++) {
-c010612f:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
-c0106133:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
-c0106137:	0f 8e 2a ff ff ff    	jle    c0106067 <check_swap+0x3ed>
+c01064f8:	ff 45 ec             	incl   -0x14(%ebp)
+c01064fb:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
+c01064ff:	0f 8e 0a ff ff ff    	jle    c010640f <check_swap+0x475>
          //cprintf("i %d, check_ptep addr %x, value %x\n", i, check_ptep[i], *check_ptep[i]);
          assert(check_ptep[i] != NULL);
          assert(pte2page(*check_ptep[i]) == check_rp[i]);
          assert((*check_ptep[i] & PTE_P));          
      }
      cprintf("set up init env for check_swap over!\n");
-c010613d:	83 ec 0c             	sub    $0xc,%esp
-c0106140:	68 30 9b 10 c0       	push   $0xc0109b30
-c0106145:	e8 38 a1 ff ff       	call   c0100282 <cprintf>
-c010614a:	83 c4 10             	add    $0x10,%esp
+c0106505:	c7 04 24 60 a2 10 c0 	movl   $0xc010a260,(%esp)
+c010650c:	e8 90 9d ff ff       	call   c01002a1 <cprintf>
      // now access the virt pages to test  page relpacement algorithm 
      ret=check_content_access();
-c010614d:	e8 10 fb ff ff       	call   c0105c62 <check_content_access>
-c0106152:	89 45 b8             	mov    %eax,-0x48(%ebp)
+c0106511:	e8 6c fa ff ff       	call   c0105f82 <check_content_access>
+c0106516:	89 45 b8             	mov    %eax,-0x48(%ebp)
      assert(ret==0);
-c0106155:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
-c0106159:	74 19                	je     c0106174 <check_swap+0x4fa>
-c010615b:	68 56 9b 10 c0       	push   $0xc0109b56
-c0106160:	68 3e 98 10 c0       	push   $0xc010983e
-c0106165:	68 ff 00 00 00       	push   $0xff
-c010616a:	68 d8 97 10 c0       	push   $0xc01097d8
-c010616f:	e8 74 a2 ff ff       	call   c01003e8 <__panic>
+c0106519:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
+c010651d:	74 24                	je     c0106543 <check_swap+0x5a9>
+c010651f:	c7 44 24 0c 86 a2 10 	movl   $0xc010a286,0xc(%esp)
+c0106526:	c0 
+c0106527:	c7 44 24 08 6e 9f 10 	movl   $0xc0109f6e,0x8(%esp)
+c010652e:	c0 
+c010652f:	c7 44 24 04 ff 00 00 	movl   $0xff,0x4(%esp)
+c0106536:	00 
+c0106537:	c7 04 24 08 9f 10 c0 	movl   $0xc0109f08,(%esp)
+c010653e:	e8 b5 9e ff ff       	call   c01003f8 <__panic>
      
      //restore kernel mem env
      for (i=0;i<CHECK_VALID_PHY_PAGE_NUM;i++) {
-c0106174:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
-c010617b:	eb 1c                	jmp    c0106199 <check_swap+0x51f>
+c0106543:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
+c010654a:	eb 1d                	jmp    c0106569 <check_swap+0x5cf>
          free_pages(check_rp[i],1);
-c010617d:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c0106180:	8b 04 85 40 30 12 c0 	mov    -0x3fedcfc0(,%eax,4),%eax
-c0106187:	83 ec 08             	sub    $0x8,%esp
-c010618a:	6a 01                	push   $0x1
-c010618c:	50                   	push   %eax
-c010618d:	e8 ee d3 ff ff       	call   c0103580 <free_pages>
-c0106192:	83 c4 10             	add    $0x10,%esp
+c010654c:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c010654f:	8b 04 85 40 40 12 c0 	mov    -0x3fedbfc0(,%eax,4),%eax
+c0106556:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+c010655d:	00 
+c010655e:	89 04 24             	mov    %eax,(%esp)
+c0106561:	e8 72 ce ff ff       	call   c01033d8 <free_pages>
      // now access the virt pages to test  page relpacement algorithm 
      ret=check_content_access();
      assert(ret==0);
      
      //restore kernel mem env
      for (i=0;i<CHECK_VALID_PHY_PAGE_NUM;i++) {
-c0106195:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
-c0106199:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
-c010619d:	7e de                	jle    c010617d <check_swap+0x503>
+c0106566:	ff 45 ec             	incl   -0x14(%ebp)
+c0106569:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
+c010656d:	7e dd                	jle    c010654c <check_swap+0x5b2>
          free_pages(check_rp[i],1);
      } 
 
      //free_page(pte2page(*temp_ptep));
      
      mm_destroy(mm);
-c010619f:	83 ec 0c             	sub    $0xc,%esp
-c01061a2:	ff 75 d8             	pushl  -0x28(%ebp)
-c01061a5:	e8 e5 ec ff ff       	call   c0104e8f <mm_destroy>
-c01061aa:	83 c4 10             	add    $0x10,%esp
+c010656f:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c0106572:	89 04 24             	mov    %eax,(%esp)
+c0106575:	e8 78 ea ff ff       	call   c0104ff2 <mm_destroy>
          
      nr_free = nr_free_store;
-c01061ad:	8b 45 bc             	mov    -0x44(%ebp),%eax
-c01061b0:	a3 14 31 12 c0       	mov    %eax,0xc0123114
+c010657a:	8b 45 bc             	mov    -0x44(%ebp),%eax
+c010657d:	a3 14 41 12 c0       	mov    %eax,0xc0124114
      free_list = free_list_store;
-c01061b5:	8b 45 98             	mov    -0x68(%ebp),%eax
-c01061b8:	8b 55 9c             	mov    -0x64(%ebp),%edx
-c01061bb:	a3 0c 31 12 c0       	mov    %eax,0xc012310c
-c01061c0:	89 15 10 31 12 c0    	mov    %edx,0xc0123110
+c0106582:	8b 45 98             	mov    -0x68(%ebp),%eax
+c0106585:	8b 55 9c             	mov    -0x64(%ebp),%edx
+c0106588:	a3 0c 41 12 c0       	mov    %eax,0xc012410c
+c010658d:	89 15 10 41 12 c0    	mov    %edx,0xc0124110
 
      
      le = &free_list;
-c01061c6:	c7 45 e8 0c 31 12 c0 	movl   $0xc012310c,-0x18(%ebp)
+c0106593:	c7 45 e8 0c 41 12 c0 	movl   $0xc012410c,-0x18(%ebp)
      while ((le = list_next(le)) != &free_list) {
-c01061cd:	eb 1d                	jmp    c01061ec <check_swap+0x572>
+c010659a:	eb 1c                	jmp    c01065b8 <check_swap+0x61e>
          struct Page *p = le2page(le, page_link);
-c01061cf:	8b 45 e8             	mov    -0x18(%ebp),%eax
-c01061d2:	83 e8 0c             	sub    $0xc,%eax
-c01061d5:	89 45 b4             	mov    %eax,-0x4c(%ebp)
+c010659c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c010659f:	83 e8 0c             	sub    $0xc,%eax
+c01065a2:	89 45 b4             	mov    %eax,-0x4c(%ebp)
          count --, total -= p->property;
-c01061d8:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
-c01061dc:	8b 55 f0             	mov    -0x10(%ebp),%edx
-c01061df:	8b 45 b4             	mov    -0x4c(%ebp),%eax
-c01061e2:	8b 40 08             	mov    0x8(%eax),%eax
-c01061e5:	29 c2                	sub    %eax,%edx
-c01061e7:	89 d0                	mov    %edx,%eax
-c01061e9:	89 45 f0             	mov    %eax,-0x10(%ebp)
-c01061ec:	8b 45 e8             	mov    -0x18(%ebp),%eax
-c01061ef:	89 45 c4             	mov    %eax,-0x3c(%ebp)
+c01065a5:	ff 4d f4             	decl   -0xc(%ebp)
+c01065a8:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c01065ab:	8b 45 b4             	mov    -0x4c(%ebp),%eax
+c01065ae:	8b 40 08             	mov    0x8(%eax),%eax
+c01065b1:	29 c2                	sub    %eax,%edx
+c01065b3:	89 d0                	mov    %edx,%eax
+c01065b5:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c01065b8:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c01065bb:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  * list_next - get the next entry
  * @listelm:    the list head
  **/
 static inline list_entry_t *
 list_next(list_entry_t *listelm) {
     return listelm->next;
-c01061f2:	8b 45 c4             	mov    -0x3c(%ebp),%eax
-c01061f5:	8b 40 04             	mov    0x4(%eax),%eax
+c01065be:	8b 45 c4             	mov    -0x3c(%ebp),%eax
+c01065c1:	8b 40 04             	mov    0x4(%eax),%eax
      nr_free = nr_free_store;
      free_list = free_list_store;
 
      
      le = &free_list;
      while ((le = list_next(le)) != &free_list) {
-c01061f8:	89 45 e8             	mov    %eax,-0x18(%ebp)
-c01061fb:	81 7d e8 0c 31 12 c0 	cmpl   $0xc012310c,-0x18(%ebp)
-c0106202:	75 cb                	jne    c01061cf <check_swap+0x555>
+c01065c4:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c01065c7:	81 7d e8 0c 41 12 c0 	cmpl   $0xc012410c,-0x18(%ebp)
+c01065ce:	75 cc                	jne    c010659c <check_swap+0x602>
          struct Page *p = le2page(le, page_link);
          count --, total -= p->property;
      }
      cprintf("count is %d, total is %d\n",count,total);
-c0106204:	83 ec 04             	sub    $0x4,%esp
-c0106207:	ff 75 f0             	pushl  -0x10(%ebp)
-c010620a:	ff 75 f4             	pushl  -0xc(%ebp)
-c010620d:	68 5d 9b 10 c0       	push   $0xc0109b5d
-c0106212:	e8 6b a0 ff ff       	call   c0100282 <cprintf>
-c0106217:	83 c4 10             	add    $0x10,%esp
+c01065d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01065d3:	89 44 24 08          	mov    %eax,0x8(%esp)
+c01065d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01065da:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01065de:	c7 04 24 8d a2 10 c0 	movl   $0xc010a28d,(%esp)
+c01065e5:	e8 b7 9c ff ff       	call   c01002a1 <cprintf>
      //assert(count == 0);
      
      cprintf("check_swap() succeeded!\n");
-c010621a:	83 ec 0c             	sub    $0xc,%esp
-c010621d:	68 77 9b 10 c0       	push   $0xc0109b77
-c0106222:	e8 5b a0 ff ff       	call   c0100282 <cprintf>
-c0106227:	83 c4 10             	add    $0x10,%esp
-}
-c010622a:	90                   	nop
-c010622b:	c9                   	leave  
-c010622c:	c3                   	ret    
+c01065ea:	c7 04 24 a7 a2 10 c0 	movl   $0xc010a2a7,(%esp)
+c01065f1:	e8 ab 9c ff ff       	call   c01002a1 <cprintf>
+}
+c01065f6:	90                   	nop
+c01065f7:	c9                   	leave  
+c01065f8:	c3                   	ret    
 
-c010622d <_fifo_init_mm>:
+c01065f9 <_fifo_init_mm>:
  * (2) _fifo_init_mm: init pra_list_head and let  mm->sm_priv point to the addr of pra_list_head.
  *              Now, From the memory control struct mm_struct, we can access FIFO PRA
  */
 static int
 _fifo_init_mm(struct mm_struct *mm)
 {     
-c010622d:	55                   	push   %ebp
-c010622e:	89 e5                	mov    %esp,%ebp
-c0106230:	83 ec 10             	sub    $0x10,%esp
-c0106233:	c7 45 fc 04 31 12 c0 	movl   $0xc0123104,-0x4(%ebp)
+c01065f9:	55                   	push   %ebp
+c01065fa:	89 e5                	mov    %esp,%ebp
+c01065fc:	83 ec 10             	sub    $0x10,%esp
+c01065ff:	c7 45 fc 04 41 12 c0 	movl   $0xc0124104,-0x4(%ebp)
  * list_init - initialize a new entry
  * @elm:        new entry to be initialized
  * */
 static inline void
 list_init(list_entry_t *elm) {
     elm->prev = elm->next = elm;
-c010623a:	8b 45 fc             	mov    -0x4(%ebp),%eax
-c010623d:	8b 55 fc             	mov    -0x4(%ebp),%edx
-c0106240:	89 50 04             	mov    %edx,0x4(%eax)
-c0106243:	8b 45 fc             	mov    -0x4(%ebp),%eax
-c0106246:	8b 50 04             	mov    0x4(%eax),%edx
-c0106249:	8b 45 fc             	mov    -0x4(%ebp),%eax
-c010624c:	89 10                	mov    %edx,(%eax)
+c0106606:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0106609:	8b 55 fc             	mov    -0x4(%ebp),%edx
+c010660c:	89 50 04             	mov    %edx,0x4(%eax)
+c010660f:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0106612:	8b 50 04             	mov    0x4(%eax),%edx
+c0106615:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0106618:	89 10                	mov    %edx,(%eax)
      list_init(&pra_list_head);
      mm->sm_priv = &pra_list_head;
-c010624e:	8b 45 08             	mov    0x8(%ebp),%eax
-c0106251:	c7 40 14 04 31 12 c0 	movl   $0xc0123104,0x14(%eax)
+c010661a:	8b 45 08             	mov    0x8(%ebp),%eax
+c010661d:	c7 40 14 04 41 12 c0 	movl   $0xc0124104,0x14(%eax)
      //cprintf(" mm->sm_priv %x in fifo_init_mm\n",mm->sm_priv);
      return 0;
-c0106258:	b8 00 00 00 00       	mov    $0x0,%eax
+c0106624:	b8 00 00 00 00       	mov    $0x0,%eax
 }
-c010625d:	c9                   	leave  
-c010625e:	c3                   	ret    
+c0106629:	c9                   	leave  
+c010662a:	c3                   	ret    
 
-c010625f <_fifo_map_swappable>:
+c010662b <_fifo_map_swappable>:
 /*
  * (3)_fifo_map_swappable: According FIFO PRA, we should link the most recent arrival page at the back of pra_list_head qeueue
  */
 static int
 _fifo_map_swappable(struct mm_struct *mm, uintptr_t addr, struct Page *page, int swap_in)
 {
-c010625f:	55                   	push   %ebp
-c0106260:	89 e5                	mov    %esp,%ebp
-c0106262:	83 ec 38             	sub    $0x38,%esp
+c010662b:	55                   	push   %ebp
+c010662c:	89 e5                	mov    %esp,%ebp
+c010662e:	83 ec 48             	sub    $0x48,%esp
     list_entry_t *head=(list_entry_t*) mm->sm_priv;
-c0106265:	8b 45 08             	mov    0x8(%ebp),%eax
-c0106268:	8b 40 14             	mov    0x14(%eax),%eax
-c010626b:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0106631:	8b 45 08             	mov    0x8(%ebp),%eax
+c0106634:	8b 40 14             	mov    0x14(%eax),%eax
+c0106637:	89 45 f4             	mov    %eax,-0xc(%ebp)
     list_entry_t *entry=&(page->pra_page_link);
-c010626e:	8b 45 10             	mov    0x10(%ebp),%eax
-c0106271:	83 c0 14             	add    $0x14,%eax
-c0106274:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c010663a:	8b 45 10             	mov    0x10(%ebp),%eax
+c010663d:	83 c0 14             	add    $0x14,%eax
+c0106640:	89 45 f0             	mov    %eax,-0x10(%ebp)
  
     assert(entry != NULL && head != NULL);
-c0106277:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
-c010627b:	74 06                	je     c0106283 <_fifo_map_swappable+0x24>
-c010627d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
-c0106281:	75 16                	jne    c0106299 <_fifo_map_swappable+0x3a>
-c0106283:	68 90 9b 10 c0       	push   $0xc0109b90
-c0106288:	68 ae 9b 10 c0       	push   $0xc0109bae
-c010628d:	6a 32                	push   $0x32
-c010628f:	68 c3 9b 10 c0       	push   $0xc0109bc3
-c0106294:	e8 4f a1 ff ff       	call   c01003e8 <__panic>
-c0106299:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c010629c:	89 45 ec             	mov    %eax,-0x14(%ebp)
-c010629f:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c01062a2:	89 45 e8             	mov    %eax,-0x18(%ebp)
-c01062a5:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c01062a8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
-c01062ab:	8b 45 e8             	mov    -0x18(%ebp),%eax
-c01062ae:	89 45 e0             	mov    %eax,-0x20(%ebp)
+c0106643:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c0106647:	74 06                	je     c010664f <_fifo_map_swappable+0x24>
+c0106649:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c010664d:	75 24                	jne    c0106673 <_fifo_map_swappable+0x48>
+c010664f:	c7 44 24 0c c0 a2 10 	movl   $0xc010a2c0,0xc(%esp)
+c0106656:	c0 
+c0106657:	c7 44 24 08 de a2 10 	movl   $0xc010a2de,0x8(%esp)
+c010665e:	c0 
+c010665f:	c7 44 24 04 32 00 00 	movl   $0x32,0x4(%esp)
+c0106666:	00 
+c0106667:	c7 04 24 f3 a2 10 c0 	movl   $0xc010a2f3,(%esp)
+c010666e:	e8 85 9d ff ff       	call   c01003f8 <__panic>
+c0106673:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106676:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c0106679:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010667c:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c010667f:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0106682:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+c0106685:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0106688:	89 45 e0             	mov    %eax,-0x20(%ebp)
  * Insert the new element @elm *after* the element @listelm which
  * is already in the list.
  * */
 static inline void
 list_add_after(list_entry_t *listelm, list_entry_t *elm) {
     __list_add(elm, listelm, listelm->next);
-c01062b1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-c01062b4:	8b 40 04             	mov    0x4(%eax),%eax
-c01062b7:	8b 55 e0             	mov    -0x20(%ebp),%edx
-c01062ba:	89 55 dc             	mov    %edx,-0x24(%ebp)
-c01062bd:	8b 55 e4             	mov    -0x1c(%ebp),%edx
-c01062c0:	89 55 d8             	mov    %edx,-0x28(%ebp)
-c01062c3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+c010668b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c010668e:	8b 40 04             	mov    0x4(%eax),%eax
+c0106691:	8b 55 e0             	mov    -0x20(%ebp),%edx
+c0106694:	89 55 dc             	mov    %edx,-0x24(%ebp)
+c0106697:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c010669a:	89 55 d8             	mov    %edx,-0x28(%ebp)
+c010669d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  * This is only for internal list manipulation where we know
  * the prev/next entries already!
  * */
 static inline void
 __list_add(list_entry_t *elm, list_entry_t *prev, list_entry_t *next) {
     prev->next = next->prev = elm;
-c01062c6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
-c01062c9:	8b 55 dc             	mov    -0x24(%ebp),%edx
-c01062cc:	89 10                	mov    %edx,(%eax)
-c01062ce:	8b 45 d4             	mov    -0x2c(%ebp),%eax
-c01062d1:	8b 10                	mov    (%eax),%edx
-c01062d3:	8b 45 d8             	mov    -0x28(%ebp),%eax
-c01062d6:	89 50 04             	mov    %edx,0x4(%eax)
+c01066a0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+c01066a3:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c01066a6:	89 10                	mov    %edx,(%eax)
+c01066a8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+c01066ab:	8b 10                	mov    (%eax),%edx
+c01066ad:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c01066b0:	89 50 04             	mov    %edx,0x4(%eax)
     elm->next = next;
-c01062d9:	8b 45 dc             	mov    -0x24(%ebp),%eax
-c01062dc:	8b 55 d4             	mov    -0x2c(%ebp),%edx
-c01062df:	89 50 04             	mov    %edx,0x4(%eax)
+c01066b3:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c01066b6:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c01066b9:	89 50 04             	mov    %edx,0x4(%eax)
     elm->prev = prev;
-c01062e2:	8b 45 dc             	mov    -0x24(%ebp),%eax
-c01062e5:	8b 55 d8             	mov    -0x28(%ebp),%edx
-c01062e8:	89 10                	mov    %edx,(%eax)
+c01066bc:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c01066bf:	8b 55 d8             	mov    -0x28(%ebp),%edx
+c01066c2:	89 10                	mov    %edx,(%eax)
     //record the page access situlation
     /*LAB3 EXERCISE 2: YOUR CODE*/ 
     //(1)link the most recent arrival page at the back of the pra_list_head qeueue.
     list_add(head, entry);
     return 0;
-c01062ea:	b8 00 00 00 00       	mov    $0x0,%eax
+c01066c4:	b8 00 00 00 00       	mov    $0x0,%eax
 }
-c01062ef:	c9                   	leave  
-c01062f0:	c3                   	ret    
+c01066c9:	c9                   	leave  
+c01066ca:	c3                   	ret    
 
-c01062f1 <_fifo_swap_out_victim>:
+c01066cb <_fifo_swap_out_victim>:
  *  (4)_fifo_swap_out_victim: According FIFO PRA, we should unlink the  earliest arrival page in front of pra_list_head qeueue,
  *                            then assign the value of *ptr_page to the addr of this page.
  */
 static int
 _fifo_swap_out_victim(struct mm_struct *mm, struct Page ** ptr_page, int in_tick)
 {
-c01062f1:	55                   	push   %ebp
-c01062f2:	89 e5                	mov    %esp,%ebp
-c01062f4:	83 ec 28             	sub    $0x28,%esp
+c01066cb:	55                   	push   %ebp
+c01066cc:	89 e5                	mov    %esp,%ebp
+c01066ce:	83 ec 38             	sub    $0x38,%esp
      list_entry_t *head=(list_entry_t*) mm->sm_priv;
-c01062f7:	8b 45 08             	mov    0x8(%ebp),%eax
-c01062fa:	8b 40 14             	mov    0x14(%eax),%eax
-c01062fd:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c01066d1:	8b 45 08             	mov    0x8(%ebp),%eax
+c01066d4:	8b 40 14             	mov    0x14(%eax),%eax
+c01066d7:	89 45 f4             	mov    %eax,-0xc(%ebp)
          assert(head != NULL);
-c0106300:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
-c0106304:	75 16                	jne    c010631c <_fifo_swap_out_victim+0x2b>
-c0106306:	68 d7 9b 10 c0       	push   $0xc0109bd7
-c010630b:	68 ae 9b 10 c0       	push   $0xc0109bae
-c0106310:	6a 41                	push   $0x41
-c0106312:	68 c3 9b 10 c0       	push   $0xc0109bc3
-c0106317:	e8 cc a0 ff ff       	call   c01003e8 <__panic>
+c01066da:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c01066de:	75 24                	jne    c0106704 <_fifo_swap_out_victim+0x39>
+c01066e0:	c7 44 24 0c 07 a3 10 	movl   $0xc010a307,0xc(%esp)
+c01066e7:	c0 
+c01066e8:	c7 44 24 08 de a2 10 	movl   $0xc010a2de,0x8(%esp)
+c01066ef:	c0 
+c01066f0:	c7 44 24 04 41 00 00 	movl   $0x41,0x4(%esp)
+c01066f7:	00 
+c01066f8:	c7 04 24 f3 a2 10 c0 	movl   $0xc010a2f3,(%esp)
+c01066ff:	e8 f4 9c ff ff       	call   c01003f8 <__panic>
      assert(in_tick==0);
-c010631c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
-c0106320:	74 16                	je     c0106338 <_fifo_swap_out_victim+0x47>
-c0106322:	68 e4 9b 10 c0       	push   $0xc0109be4
-c0106327:	68 ae 9b 10 c0       	push   $0xc0109bae
-c010632c:	6a 42                	push   $0x42
-c010632e:	68 c3 9b 10 c0       	push   $0xc0109bc3
-c0106333:	e8 b0 a0 ff ff       	call   c01003e8 <__panic>
+c0106704:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+c0106708:	74 24                	je     c010672e <_fifo_swap_out_victim+0x63>
+c010670a:	c7 44 24 0c 14 a3 10 	movl   $0xc010a314,0xc(%esp)
+c0106711:	c0 
+c0106712:	c7 44 24 08 de a2 10 	movl   $0xc010a2de,0x8(%esp)
+c0106719:	c0 
+c010671a:	c7 44 24 04 42 00 00 	movl   $0x42,0x4(%esp)
+c0106721:	00 
+c0106722:	c7 04 24 f3 a2 10 c0 	movl   $0xc010a2f3,(%esp)
+c0106729:	e8 ca 9c ff ff       	call   c01003f8 <__panic>
      /* Select the victim */
      /*LAB3 EXERCISE 2: YOUR CODE*/ 
      //(1)  unlink the  earliest arrival page in front of pra_list_head qeueue
      //(2)  assign the value of *ptr_page to the addr of this page
      /* Select the tail */
      list_entry_t *le = head->prev;
-c0106338:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c010633b:	8b 00                	mov    (%eax),%eax
-c010633d:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c010672e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106731:	8b 00                	mov    (%eax),%eax
+c0106733:	89 45 f0             	mov    %eax,-0x10(%ebp)
      assert(head!=le);
-c0106340:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0106343:	3b 45 f0             	cmp    -0x10(%ebp),%eax
-c0106346:	75 16                	jne    c010635e <_fifo_swap_out_victim+0x6d>
-c0106348:	68 ef 9b 10 c0       	push   $0xc0109bef
-c010634d:	68 ae 9b 10 c0       	push   $0xc0109bae
-c0106352:	6a 49                	push   $0x49
-c0106354:	68 c3 9b 10 c0       	push   $0xc0109bc3
-c0106359:	e8 8a a0 ff ff       	call   c01003e8 <__panic>
+c0106736:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106739:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+c010673c:	75 24                	jne    c0106762 <_fifo_swap_out_victim+0x97>
+c010673e:	c7 44 24 0c 1f a3 10 	movl   $0xc010a31f,0xc(%esp)
+c0106745:	c0 
+c0106746:	c7 44 24 08 de a2 10 	movl   $0xc010a2de,0x8(%esp)
+c010674d:	c0 
+c010674e:	c7 44 24 04 49 00 00 	movl   $0x49,0x4(%esp)
+c0106755:	00 
+c0106756:	c7 04 24 f3 a2 10 c0 	movl   $0xc010a2f3,(%esp)
+c010675d:	e8 96 9c ff ff       	call   c01003f8 <__panic>
      struct Page *p = le2page(le, pra_page_link);
-c010635e:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0106361:	83 e8 14             	sub    $0x14,%eax
-c0106364:	89 45 ec             	mov    %eax,-0x14(%ebp)
-c0106367:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c010636a:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c0106762:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0106765:	83 e8 14             	sub    $0x14,%eax
+c0106768:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c010676b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010676e:	89 45 e8             	mov    %eax,-0x18(%ebp)
  * Note: list_empty() on @listelm does not return true after this, the entry is
  * in an undefined state.
  * */
 static inline void
 list_del(list_entry_t *listelm) {
     __list_del(listelm->prev, listelm->next);
-c010636d:	8b 45 e8             	mov    -0x18(%ebp),%eax
-c0106370:	8b 40 04             	mov    0x4(%eax),%eax
-c0106373:	8b 55 e8             	mov    -0x18(%ebp),%edx
-c0106376:	8b 12                	mov    (%edx),%edx
-c0106378:	89 55 e4             	mov    %edx,-0x1c(%ebp)
-c010637b:	89 45 e0             	mov    %eax,-0x20(%ebp)
+c0106771:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0106774:	8b 40 04             	mov    0x4(%eax),%eax
+c0106777:	8b 55 e8             	mov    -0x18(%ebp),%edx
+c010677a:	8b 12                	mov    (%edx),%edx
+c010677c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+c010677f:	89 45 e0             	mov    %eax,-0x20(%ebp)
  * This is only for internal list manipulation where we know
  * the prev/next entries already!
  * */
 static inline void
 __list_del(list_entry_t *prev, list_entry_t *next) {
     prev->next = next;
-c010637e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-c0106381:	8b 55 e0             	mov    -0x20(%ebp),%edx
-c0106384:	89 50 04             	mov    %edx,0x4(%eax)
+c0106782:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0106785:	8b 55 e0             	mov    -0x20(%ebp),%edx
+c0106788:	89 50 04             	mov    %edx,0x4(%eax)
     next->prev = prev;
-c0106387:	8b 45 e0             	mov    -0x20(%ebp),%eax
-c010638a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
-c010638d:	89 10                	mov    %edx,(%eax)
+c010678b:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c010678e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c0106791:	89 10                	mov    %edx,(%eax)
      list_del(le);
      assert(p !=NULL);
-c010638f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
-c0106393:	75 16                	jne    c01063ab <_fifo_swap_out_victim+0xba>
-c0106395:	68 f8 9b 10 c0       	push   $0xc0109bf8
-c010639a:	68 ae 9b 10 c0       	push   $0xc0109bae
-c010639f:	6a 4c                	push   $0x4c
-c01063a1:	68 c3 9b 10 c0       	push   $0xc0109bc3
-c01063a6:	e8 3d a0 ff ff       	call   c01003e8 <__panic>
+c0106793:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+c0106797:	75 24                	jne    c01067bd <_fifo_swap_out_victim+0xf2>
+c0106799:	c7 44 24 0c 28 a3 10 	movl   $0xc010a328,0xc(%esp)
+c01067a0:	c0 
+c01067a1:	c7 44 24 08 de a2 10 	movl   $0xc010a2de,0x8(%esp)
+c01067a8:	c0 
+c01067a9:	c7 44 24 04 4c 00 00 	movl   $0x4c,0x4(%esp)
+c01067b0:	00 
+c01067b1:	c7 04 24 f3 a2 10 c0 	movl   $0xc010a2f3,(%esp)
+c01067b8:	e8 3b 9c ff ff       	call   c01003f8 <__panic>
      *ptr_page = p;
-c01063ab:	8b 45 0c             	mov    0xc(%ebp),%eax
-c01063ae:	8b 55 ec             	mov    -0x14(%ebp),%edx
-c01063b1:	89 10                	mov    %edx,(%eax)
+c01067bd:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01067c0:	8b 55 ec             	mov    -0x14(%ebp),%edx
+c01067c3:	89 10                	mov    %edx,(%eax)
      return 0;
-c01063b3:	b8 00 00 00 00       	mov    $0x0,%eax
+c01067c5:	b8 00 00 00 00       	mov    $0x0,%eax
 }
-c01063b8:	c9                   	leave  
-c01063b9:	c3                   	ret    
+c01067ca:	c9                   	leave  
+c01067cb:	c3                   	ret    
 
-c01063ba <_fifo_check_swap>:
+c01067cc <_fifo_check_swap>:
 
 static int
 _fifo_check_swap(void) {
-c01063ba:	55                   	push   %ebp
-c01063bb:	89 e5                	mov    %esp,%ebp
-c01063bd:	83 ec 08             	sub    $0x8,%esp
+c01067cc:	55                   	push   %ebp
+c01067cd:	89 e5                	mov    %esp,%ebp
+c01067cf:	83 ec 18             	sub    $0x18,%esp
     cprintf("write Virt Page c in fifo_check_swap\n");
-c01063c0:	83 ec 0c             	sub    $0xc,%esp
-c01063c3:	68 04 9c 10 c0       	push   $0xc0109c04
-c01063c8:	e8 b5 9e ff ff       	call   c0100282 <cprintf>
-c01063cd:	83 c4 10             	add    $0x10,%esp
+c01067d2:	c7 04 24 34 a3 10 c0 	movl   $0xc010a334,(%esp)
+c01067d9:	e8 c3 9a ff ff       	call   c01002a1 <cprintf>
     *(unsigned char *)0x3000 = 0x0c;
-c01063d0:	b8 00 30 00 00       	mov    $0x3000,%eax
-c01063d5:	c6 00 0c             	movb   $0xc,(%eax)
+c01067de:	b8 00 30 00 00       	mov    $0x3000,%eax
+c01067e3:	c6 00 0c             	movb   $0xc,(%eax)
     assert(pgfault_num==4);
-c01063d8:	a1 0c 30 12 c0       	mov    0xc012300c,%eax
-c01063dd:	83 f8 04             	cmp    $0x4,%eax
-c01063e0:	74 16                	je     c01063f8 <_fifo_check_swap+0x3e>
-c01063e2:	68 2a 9c 10 c0       	push   $0xc0109c2a
-c01063e7:	68 ae 9b 10 c0       	push   $0xc0109bae
-c01063ec:	6a 55                	push   $0x55
-c01063ee:	68 c3 9b 10 c0       	push   $0xc0109bc3
-c01063f3:	e8 f0 9f ff ff       	call   c01003e8 <__panic>
+c01067e6:	a1 0c 40 12 c0       	mov    0xc012400c,%eax
+c01067eb:	83 f8 04             	cmp    $0x4,%eax
+c01067ee:	74 24                	je     c0106814 <_fifo_check_swap+0x48>
+c01067f0:	c7 44 24 0c 5a a3 10 	movl   $0xc010a35a,0xc(%esp)
+c01067f7:	c0 
+c01067f8:	c7 44 24 08 de a2 10 	movl   $0xc010a2de,0x8(%esp)
+c01067ff:	c0 
+c0106800:	c7 44 24 04 55 00 00 	movl   $0x55,0x4(%esp)
+c0106807:	00 
+c0106808:	c7 04 24 f3 a2 10 c0 	movl   $0xc010a2f3,(%esp)
+c010680f:	e8 e4 9b ff ff       	call   c01003f8 <__panic>
     cprintf("write Virt Page a in fifo_check_swap\n");
-c01063f8:	83 ec 0c             	sub    $0xc,%esp
-c01063fb:	68 3c 9c 10 c0       	push   $0xc0109c3c
-c0106400:	e8 7d 9e ff ff       	call   c0100282 <cprintf>
-c0106405:	83 c4 10             	add    $0x10,%esp
+c0106814:	c7 04 24 6c a3 10 c0 	movl   $0xc010a36c,(%esp)
+c010681b:	e8 81 9a ff ff       	call   c01002a1 <cprintf>
     *(unsigned char *)0x1000 = 0x0a;
-c0106408:	b8 00 10 00 00       	mov    $0x1000,%eax
-c010640d:	c6 00 0a             	movb   $0xa,(%eax)
+c0106820:	b8 00 10 00 00       	mov    $0x1000,%eax
+c0106825:	c6 00 0a             	movb   $0xa,(%eax)
     assert(pgfault_num==4);
-c0106410:	a1 0c 30 12 c0       	mov    0xc012300c,%eax
-c0106415:	83 f8 04             	cmp    $0x4,%eax
-c0106418:	74 16                	je     c0106430 <_fifo_check_swap+0x76>
-c010641a:	68 2a 9c 10 c0       	push   $0xc0109c2a
-c010641f:	68 ae 9b 10 c0       	push   $0xc0109bae
-c0106424:	6a 58                	push   $0x58
-c0106426:	68 c3 9b 10 c0       	push   $0xc0109bc3
-c010642b:	e8 b8 9f ff ff       	call   c01003e8 <__panic>
+c0106828:	a1 0c 40 12 c0       	mov    0xc012400c,%eax
+c010682d:	83 f8 04             	cmp    $0x4,%eax
+c0106830:	74 24                	je     c0106856 <_fifo_check_swap+0x8a>
+c0106832:	c7 44 24 0c 5a a3 10 	movl   $0xc010a35a,0xc(%esp)
+c0106839:	c0 
+c010683a:	c7 44 24 08 de a2 10 	movl   $0xc010a2de,0x8(%esp)
+c0106841:	c0 
+c0106842:	c7 44 24 04 58 00 00 	movl   $0x58,0x4(%esp)
+c0106849:	00 
+c010684a:	c7 04 24 f3 a2 10 c0 	movl   $0xc010a2f3,(%esp)
+c0106851:	e8 a2 9b ff ff       	call   c01003f8 <__panic>
     cprintf("write Virt Page d in fifo_check_swap\n");
-c0106430:	83 ec 0c             	sub    $0xc,%esp
-c0106433:	68 64 9c 10 c0       	push   $0xc0109c64
-c0106438:	e8 45 9e ff ff       	call   c0100282 <cprintf>
-c010643d:	83 c4 10             	add    $0x10,%esp
+c0106856:	c7 04 24 94 a3 10 c0 	movl   $0xc010a394,(%esp)
+c010685d:	e8 3f 9a ff ff       	call   c01002a1 <cprintf>
     *(unsigned char *)0x4000 = 0x0d;
-c0106440:	b8 00 40 00 00       	mov    $0x4000,%eax
-c0106445:	c6 00 0d             	movb   $0xd,(%eax)
+c0106862:	b8 00 40 00 00       	mov    $0x4000,%eax
+c0106867:	c6 00 0d             	movb   $0xd,(%eax)
     assert(pgfault_num==4);
-c0106448:	a1 0c 30 12 c0       	mov    0xc012300c,%eax
-c010644d:	83 f8 04             	cmp    $0x4,%eax
-c0106450:	74 16                	je     c0106468 <_fifo_check_swap+0xae>
-c0106452:	68 2a 9c 10 c0       	push   $0xc0109c2a
-c0106457:	68 ae 9b 10 c0       	push   $0xc0109bae
-c010645c:	6a 5b                	push   $0x5b
-c010645e:	68 c3 9b 10 c0       	push   $0xc0109bc3
-c0106463:	e8 80 9f ff ff       	call   c01003e8 <__panic>
+c010686a:	a1 0c 40 12 c0       	mov    0xc012400c,%eax
+c010686f:	83 f8 04             	cmp    $0x4,%eax
+c0106872:	74 24                	je     c0106898 <_fifo_check_swap+0xcc>
+c0106874:	c7 44 24 0c 5a a3 10 	movl   $0xc010a35a,0xc(%esp)
+c010687b:	c0 
+c010687c:	c7 44 24 08 de a2 10 	movl   $0xc010a2de,0x8(%esp)
+c0106883:	c0 
+c0106884:	c7 44 24 04 5b 00 00 	movl   $0x5b,0x4(%esp)
+c010688b:	00 
+c010688c:	c7 04 24 f3 a2 10 c0 	movl   $0xc010a2f3,(%esp)
+c0106893:	e8 60 9b ff ff       	call   c01003f8 <__panic>
     cprintf("write Virt Page b in fifo_check_swap\n");
-c0106468:	83 ec 0c             	sub    $0xc,%esp
-c010646b:	68 8c 9c 10 c0       	push   $0xc0109c8c
-c0106470:	e8 0d 9e ff ff       	call   c0100282 <cprintf>
-c0106475:	83 c4 10             	add    $0x10,%esp
+c0106898:	c7 04 24 bc a3 10 c0 	movl   $0xc010a3bc,(%esp)
+c010689f:	e8 fd 99 ff ff       	call   c01002a1 <cprintf>
     *(unsigned char *)0x2000 = 0x0b;
-c0106478:	b8 00 20 00 00       	mov    $0x2000,%eax
-c010647d:	c6 00 0b             	movb   $0xb,(%eax)
+c01068a4:	b8 00 20 00 00       	mov    $0x2000,%eax
+c01068a9:	c6 00 0b             	movb   $0xb,(%eax)
     assert(pgfault_num==4);
-c0106480:	a1 0c 30 12 c0       	mov    0xc012300c,%eax
-c0106485:	83 f8 04             	cmp    $0x4,%eax
-c0106488:	74 16                	je     c01064a0 <_fifo_check_swap+0xe6>
-c010648a:	68 2a 9c 10 c0       	push   $0xc0109c2a
-c010648f:	68 ae 9b 10 c0       	push   $0xc0109bae
-c0106494:	6a 5e                	push   $0x5e
-c0106496:	68 c3 9b 10 c0       	push   $0xc0109bc3
-c010649b:	e8 48 9f ff ff       	call   c01003e8 <__panic>
+c01068ac:	a1 0c 40 12 c0       	mov    0xc012400c,%eax
+c01068b1:	83 f8 04             	cmp    $0x4,%eax
+c01068b4:	74 24                	je     c01068da <_fifo_check_swap+0x10e>
+c01068b6:	c7 44 24 0c 5a a3 10 	movl   $0xc010a35a,0xc(%esp)
+c01068bd:	c0 
+c01068be:	c7 44 24 08 de a2 10 	movl   $0xc010a2de,0x8(%esp)
+c01068c5:	c0 
+c01068c6:	c7 44 24 04 5e 00 00 	movl   $0x5e,0x4(%esp)
+c01068cd:	00 
+c01068ce:	c7 04 24 f3 a2 10 c0 	movl   $0xc010a2f3,(%esp)
+c01068d5:	e8 1e 9b ff ff       	call   c01003f8 <__panic>
     cprintf("write Virt Page e in fifo_check_swap\n");
-c01064a0:	83 ec 0c             	sub    $0xc,%esp
-c01064a3:	68 b4 9c 10 c0       	push   $0xc0109cb4
-c01064a8:	e8 d5 9d ff ff       	call   c0100282 <cprintf>
-c01064ad:	83 c4 10             	add    $0x10,%esp
+c01068da:	c7 04 24 e4 a3 10 c0 	movl   $0xc010a3e4,(%esp)
+c01068e1:	e8 bb 99 ff ff       	call   c01002a1 <cprintf>
     *(unsigned char *)0x5000 = 0x0e;
-c01064b0:	b8 00 50 00 00       	mov    $0x5000,%eax
-c01064b5:	c6 00 0e             	movb   $0xe,(%eax)
+c01068e6:	b8 00 50 00 00       	mov    $0x5000,%eax
+c01068eb:	c6 00 0e             	movb   $0xe,(%eax)
     assert(pgfault_num==5);
-c01064b8:	a1 0c 30 12 c0       	mov    0xc012300c,%eax
-c01064bd:	83 f8 05             	cmp    $0x5,%eax
-c01064c0:	74 16                	je     c01064d8 <_fifo_check_swap+0x11e>
-c01064c2:	68 da 9c 10 c0       	push   $0xc0109cda
-c01064c7:	68 ae 9b 10 c0       	push   $0xc0109bae
-c01064cc:	6a 61                	push   $0x61
-c01064ce:	68 c3 9b 10 c0       	push   $0xc0109bc3
-c01064d3:	e8 10 9f ff ff       	call   c01003e8 <__panic>
+c01068ee:	a1 0c 40 12 c0       	mov    0xc012400c,%eax
+c01068f3:	83 f8 05             	cmp    $0x5,%eax
+c01068f6:	74 24                	je     c010691c <_fifo_check_swap+0x150>
+c01068f8:	c7 44 24 0c 0a a4 10 	movl   $0xc010a40a,0xc(%esp)
+c01068ff:	c0 
+c0106900:	c7 44 24 08 de a2 10 	movl   $0xc010a2de,0x8(%esp)
+c0106907:	c0 
+c0106908:	c7 44 24 04 61 00 00 	movl   $0x61,0x4(%esp)
+c010690f:	00 
+c0106910:	c7 04 24 f3 a2 10 c0 	movl   $0xc010a2f3,(%esp)
+c0106917:	e8 dc 9a ff ff       	call   c01003f8 <__panic>
     cprintf("write Virt Page b in fifo_check_swap\n");
-c01064d8:	83 ec 0c             	sub    $0xc,%esp
-c01064db:	68 8c 9c 10 c0       	push   $0xc0109c8c
-c01064e0:	e8 9d 9d ff ff       	call   c0100282 <cprintf>
-c01064e5:	83 c4 10             	add    $0x10,%esp
+c010691c:	c7 04 24 bc a3 10 c0 	movl   $0xc010a3bc,(%esp)
+c0106923:	e8 79 99 ff ff       	call   c01002a1 <cprintf>
     *(unsigned char *)0x2000 = 0x0b;
-c01064e8:	b8 00 20 00 00       	mov    $0x2000,%eax
-c01064ed:	c6 00 0b             	movb   $0xb,(%eax)
+c0106928:	b8 00 20 00 00       	mov    $0x2000,%eax
+c010692d:	c6 00 0b             	movb   $0xb,(%eax)
     assert(pgfault_num==5);
-c01064f0:	a1 0c 30 12 c0       	mov    0xc012300c,%eax
-c01064f5:	83 f8 05             	cmp    $0x5,%eax
-c01064f8:	74 16                	je     c0106510 <_fifo_check_swap+0x156>
-c01064fa:	68 da 9c 10 c0       	push   $0xc0109cda
-c01064ff:	68 ae 9b 10 c0       	push   $0xc0109bae
-c0106504:	6a 64                	push   $0x64
-c0106506:	68 c3 9b 10 c0       	push   $0xc0109bc3
-c010650b:	e8 d8 9e ff ff       	call   c01003e8 <__panic>
+c0106930:	a1 0c 40 12 c0       	mov    0xc012400c,%eax
+c0106935:	83 f8 05             	cmp    $0x5,%eax
+c0106938:	74 24                	je     c010695e <_fifo_check_swap+0x192>
+c010693a:	c7 44 24 0c 0a a4 10 	movl   $0xc010a40a,0xc(%esp)
+c0106941:	c0 
+c0106942:	c7 44 24 08 de a2 10 	movl   $0xc010a2de,0x8(%esp)
+c0106949:	c0 
+c010694a:	c7 44 24 04 64 00 00 	movl   $0x64,0x4(%esp)
+c0106951:	00 
+c0106952:	c7 04 24 f3 a2 10 c0 	movl   $0xc010a2f3,(%esp)
+c0106959:	e8 9a 9a ff ff       	call   c01003f8 <__panic>
     cprintf("write Virt Page a in fifo_check_swap\n");
-c0106510:	83 ec 0c             	sub    $0xc,%esp
-c0106513:	68 3c 9c 10 c0       	push   $0xc0109c3c
-c0106518:	e8 65 9d ff ff       	call   c0100282 <cprintf>
-c010651d:	83 c4 10             	add    $0x10,%esp
+c010695e:	c7 04 24 6c a3 10 c0 	movl   $0xc010a36c,(%esp)
+c0106965:	e8 37 99 ff ff       	call   c01002a1 <cprintf>
     *(unsigned char *)0x1000 = 0x0a;
-c0106520:	b8 00 10 00 00       	mov    $0x1000,%eax
-c0106525:	c6 00 0a             	movb   $0xa,(%eax)
+c010696a:	b8 00 10 00 00       	mov    $0x1000,%eax
+c010696f:	c6 00 0a             	movb   $0xa,(%eax)
     assert(pgfault_num==6);
-c0106528:	a1 0c 30 12 c0       	mov    0xc012300c,%eax
-c010652d:	83 f8 06             	cmp    $0x6,%eax
-c0106530:	74 16                	je     c0106548 <_fifo_check_swap+0x18e>
-c0106532:	68 e9 9c 10 c0       	push   $0xc0109ce9
-c0106537:	68 ae 9b 10 c0       	push   $0xc0109bae
-c010653c:	6a 67                	push   $0x67
-c010653e:	68 c3 9b 10 c0       	push   $0xc0109bc3
-c0106543:	e8 a0 9e ff ff       	call   c01003e8 <__panic>
+c0106972:	a1 0c 40 12 c0       	mov    0xc012400c,%eax
+c0106977:	83 f8 06             	cmp    $0x6,%eax
+c010697a:	74 24                	je     c01069a0 <_fifo_check_swap+0x1d4>
+c010697c:	c7 44 24 0c 19 a4 10 	movl   $0xc010a419,0xc(%esp)
+c0106983:	c0 
+c0106984:	c7 44 24 08 de a2 10 	movl   $0xc010a2de,0x8(%esp)
+c010698b:	c0 
+c010698c:	c7 44 24 04 67 00 00 	movl   $0x67,0x4(%esp)
+c0106993:	00 
+c0106994:	c7 04 24 f3 a2 10 c0 	movl   $0xc010a2f3,(%esp)
+c010699b:	e8 58 9a ff ff       	call   c01003f8 <__panic>
     cprintf("write Virt Page b in fifo_check_swap\n");
-c0106548:	83 ec 0c             	sub    $0xc,%esp
-c010654b:	68 8c 9c 10 c0       	push   $0xc0109c8c
-c0106550:	e8 2d 9d ff ff       	call   c0100282 <cprintf>
-c0106555:	83 c4 10             	add    $0x10,%esp
+c01069a0:	c7 04 24 bc a3 10 c0 	movl   $0xc010a3bc,(%esp)
+c01069a7:	e8 f5 98 ff ff       	call   c01002a1 <cprintf>
     *(unsigned char *)0x2000 = 0x0b;
-c0106558:	b8 00 20 00 00       	mov    $0x2000,%eax
-c010655d:	c6 00 0b             	movb   $0xb,(%eax)
+c01069ac:	b8 00 20 00 00       	mov    $0x2000,%eax
+c01069b1:	c6 00 0b             	movb   $0xb,(%eax)
     assert(pgfault_num==7);
-c0106560:	a1 0c 30 12 c0       	mov    0xc012300c,%eax
-c0106565:	83 f8 07             	cmp    $0x7,%eax
-c0106568:	74 16                	je     c0106580 <_fifo_check_swap+0x1c6>
-c010656a:	68 f8 9c 10 c0       	push   $0xc0109cf8
-c010656f:	68 ae 9b 10 c0       	push   $0xc0109bae
-c0106574:	6a 6a                	push   $0x6a
-c0106576:	68 c3 9b 10 c0       	push   $0xc0109bc3
-c010657b:	e8 68 9e ff ff       	call   c01003e8 <__panic>
+c01069b4:	a1 0c 40 12 c0       	mov    0xc012400c,%eax
+c01069b9:	83 f8 07             	cmp    $0x7,%eax
+c01069bc:	74 24                	je     c01069e2 <_fifo_check_swap+0x216>
+c01069be:	c7 44 24 0c 28 a4 10 	movl   $0xc010a428,0xc(%esp)
+c01069c5:	c0 
+c01069c6:	c7 44 24 08 de a2 10 	movl   $0xc010a2de,0x8(%esp)
+c01069cd:	c0 
+c01069ce:	c7 44 24 04 6a 00 00 	movl   $0x6a,0x4(%esp)
+c01069d5:	00 
+c01069d6:	c7 04 24 f3 a2 10 c0 	movl   $0xc010a2f3,(%esp)
+c01069dd:	e8 16 9a ff ff       	call   c01003f8 <__panic>
     cprintf("write Virt Page c in fifo_check_swap\n");
-c0106580:	83 ec 0c             	sub    $0xc,%esp
-c0106583:	68 04 9c 10 c0       	push   $0xc0109c04
-c0106588:	e8 f5 9c ff ff       	call   c0100282 <cprintf>
-c010658d:	83 c4 10             	add    $0x10,%esp
+c01069e2:	c7 04 24 34 a3 10 c0 	movl   $0xc010a334,(%esp)
+c01069e9:	e8 b3 98 ff ff       	call   c01002a1 <cprintf>
     *(unsigned char *)0x3000 = 0x0c;
-c0106590:	b8 00 30 00 00       	mov    $0x3000,%eax
-c0106595:	c6 00 0c             	movb   $0xc,(%eax)
+c01069ee:	b8 00 30 00 00       	mov    $0x3000,%eax
+c01069f3:	c6 00 0c             	movb   $0xc,(%eax)
     assert(pgfault_num==8);
-c0106598:	a1 0c 30 12 c0       	mov    0xc012300c,%eax
-c010659d:	83 f8 08             	cmp    $0x8,%eax
-c01065a0:	74 16                	je     c01065b8 <_fifo_check_swap+0x1fe>
-c01065a2:	68 07 9d 10 c0       	push   $0xc0109d07
-c01065a7:	68 ae 9b 10 c0       	push   $0xc0109bae
-c01065ac:	6a 6d                	push   $0x6d
-c01065ae:	68 c3 9b 10 c0       	push   $0xc0109bc3
-c01065b3:	e8 30 9e ff ff       	call   c01003e8 <__panic>
+c01069f6:	a1 0c 40 12 c0       	mov    0xc012400c,%eax
+c01069fb:	83 f8 08             	cmp    $0x8,%eax
+c01069fe:	74 24                	je     c0106a24 <_fifo_check_swap+0x258>
+c0106a00:	c7 44 24 0c 37 a4 10 	movl   $0xc010a437,0xc(%esp)
+c0106a07:	c0 
+c0106a08:	c7 44 24 08 de a2 10 	movl   $0xc010a2de,0x8(%esp)
+c0106a0f:	c0 
+c0106a10:	c7 44 24 04 6d 00 00 	movl   $0x6d,0x4(%esp)
+c0106a17:	00 
+c0106a18:	c7 04 24 f3 a2 10 c0 	movl   $0xc010a2f3,(%esp)
+c0106a1f:	e8 d4 99 ff ff       	call   c01003f8 <__panic>
     cprintf("write Virt Page d in fifo_check_swap\n");
-c01065b8:	83 ec 0c             	sub    $0xc,%esp
-c01065bb:	68 64 9c 10 c0       	push   $0xc0109c64
-c01065c0:	e8 bd 9c ff ff       	call   c0100282 <cprintf>
-c01065c5:	83 c4 10             	add    $0x10,%esp
+c0106a24:	c7 04 24 94 a3 10 c0 	movl   $0xc010a394,(%esp)
+c0106a2b:	e8 71 98 ff ff       	call   c01002a1 <cprintf>
     *(unsigned char *)0x4000 = 0x0d;
-c01065c8:	b8 00 40 00 00       	mov    $0x4000,%eax
-c01065cd:	c6 00 0d             	movb   $0xd,(%eax)
+c0106a30:	b8 00 40 00 00       	mov    $0x4000,%eax
+c0106a35:	c6 00 0d             	movb   $0xd,(%eax)
     assert(pgfault_num==9);
-c01065d0:	a1 0c 30 12 c0       	mov    0xc012300c,%eax
-c01065d5:	83 f8 09             	cmp    $0x9,%eax
-c01065d8:	74 16                	je     c01065f0 <_fifo_check_swap+0x236>
-c01065da:	68 16 9d 10 c0       	push   $0xc0109d16
-c01065df:	68 ae 9b 10 c0       	push   $0xc0109bae
-c01065e4:	6a 70                	push   $0x70
-c01065e6:	68 c3 9b 10 c0       	push   $0xc0109bc3
-c01065eb:	e8 f8 9d ff ff       	call   c01003e8 <__panic>
+c0106a38:	a1 0c 40 12 c0       	mov    0xc012400c,%eax
+c0106a3d:	83 f8 09             	cmp    $0x9,%eax
+c0106a40:	74 24                	je     c0106a66 <_fifo_check_swap+0x29a>
+c0106a42:	c7 44 24 0c 46 a4 10 	movl   $0xc010a446,0xc(%esp)
+c0106a49:	c0 
+c0106a4a:	c7 44 24 08 de a2 10 	movl   $0xc010a2de,0x8(%esp)
+c0106a51:	c0 
+c0106a52:	c7 44 24 04 70 00 00 	movl   $0x70,0x4(%esp)
+c0106a59:	00 
+c0106a5a:	c7 04 24 f3 a2 10 c0 	movl   $0xc010a2f3,(%esp)
+c0106a61:	e8 92 99 ff ff       	call   c01003f8 <__panic>
     cprintf("write Virt Page e in fifo_check_swap\n");
-c01065f0:	83 ec 0c             	sub    $0xc,%esp
-c01065f3:	68 b4 9c 10 c0       	push   $0xc0109cb4
-c01065f8:	e8 85 9c ff ff       	call   c0100282 <cprintf>
-c01065fd:	83 c4 10             	add    $0x10,%esp
+c0106a66:	c7 04 24 e4 a3 10 c0 	movl   $0xc010a3e4,(%esp)
+c0106a6d:	e8 2f 98 ff ff       	call   c01002a1 <cprintf>
     *(unsigned char *)0x5000 = 0x0e;
-c0106600:	b8 00 50 00 00       	mov    $0x5000,%eax
-c0106605:	c6 00 0e             	movb   $0xe,(%eax)
+c0106a72:	b8 00 50 00 00       	mov    $0x5000,%eax
+c0106a77:	c6 00 0e             	movb   $0xe,(%eax)
     assert(pgfault_num==10);
-c0106608:	a1 0c 30 12 c0       	mov    0xc012300c,%eax
-c010660d:	83 f8 0a             	cmp    $0xa,%eax
-c0106610:	74 16                	je     c0106628 <_fifo_check_swap+0x26e>
-c0106612:	68 25 9d 10 c0       	push   $0xc0109d25
-c0106617:	68 ae 9b 10 c0       	push   $0xc0109bae
-c010661c:	6a 73                	push   $0x73
-c010661e:	68 c3 9b 10 c0       	push   $0xc0109bc3
-c0106623:	e8 c0 9d ff ff       	call   c01003e8 <__panic>
+c0106a7a:	a1 0c 40 12 c0       	mov    0xc012400c,%eax
+c0106a7f:	83 f8 0a             	cmp    $0xa,%eax
+c0106a82:	74 24                	je     c0106aa8 <_fifo_check_swap+0x2dc>
+c0106a84:	c7 44 24 0c 55 a4 10 	movl   $0xc010a455,0xc(%esp)
+c0106a8b:	c0 
+c0106a8c:	c7 44 24 08 de a2 10 	movl   $0xc010a2de,0x8(%esp)
+c0106a93:	c0 
+c0106a94:	c7 44 24 04 73 00 00 	movl   $0x73,0x4(%esp)
+c0106a9b:	00 
+c0106a9c:	c7 04 24 f3 a2 10 c0 	movl   $0xc010a2f3,(%esp)
+c0106aa3:	e8 50 99 ff ff       	call   c01003f8 <__panic>
     cprintf("write Virt Page a in fifo_check_swap\n");
-c0106628:	83 ec 0c             	sub    $0xc,%esp
-c010662b:	68 3c 9c 10 c0       	push   $0xc0109c3c
-c0106630:	e8 4d 9c ff ff       	call   c0100282 <cprintf>
-c0106635:	83 c4 10             	add    $0x10,%esp
+c0106aa8:	c7 04 24 6c a3 10 c0 	movl   $0xc010a36c,(%esp)
+c0106aaf:	e8 ed 97 ff ff       	call   c01002a1 <cprintf>
     assert(*(unsigned char *)0x1000 == 0x0a);
-c0106638:	b8 00 10 00 00       	mov    $0x1000,%eax
-c010663d:	0f b6 00             	movzbl (%eax),%eax
-c0106640:	3c 0a                	cmp    $0xa,%al
-c0106642:	74 16                	je     c010665a <_fifo_check_swap+0x2a0>
-c0106644:	68 38 9d 10 c0       	push   $0xc0109d38
-c0106649:	68 ae 9b 10 c0       	push   $0xc0109bae
-c010664e:	6a 75                	push   $0x75
-c0106650:	68 c3 9b 10 c0       	push   $0xc0109bc3
-c0106655:	e8 8e 9d ff ff       	call   c01003e8 <__panic>
+c0106ab4:	b8 00 10 00 00       	mov    $0x1000,%eax
+c0106ab9:	0f b6 00             	movzbl (%eax),%eax
+c0106abc:	3c 0a                	cmp    $0xa,%al
+c0106abe:	74 24                	je     c0106ae4 <_fifo_check_swap+0x318>
+c0106ac0:	c7 44 24 0c 68 a4 10 	movl   $0xc010a468,0xc(%esp)
+c0106ac7:	c0 
+c0106ac8:	c7 44 24 08 de a2 10 	movl   $0xc010a2de,0x8(%esp)
+c0106acf:	c0 
+c0106ad0:	c7 44 24 04 75 00 00 	movl   $0x75,0x4(%esp)
+c0106ad7:	00 
+c0106ad8:	c7 04 24 f3 a2 10 c0 	movl   $0xc010a2f3,(%esp)
+c0106adf:	e8 14 99 ff ff       	call   c01003f8 <__panic>
     *(unsigned char *)0x1000 = 0x0a;
-c010665a:	b8 00 10 00 00       	mov    $0x1000,%eax
-c010665f:	c6 00 0a             	movb   $0xa,(%eax)
+c0106ae4:	b8 00 10 00 00       	mov    $0x1000,%eax
+c0106ae9:	c6 00 0a             	movb   $0xa,(%eax)
     assert(pgfault_num==11);
-c0106662:	a1 0c 30 12 c0       	mov    0xc012300c,%eax
-c0106667:	83 f8 0b             	cmp    $0xb,%eax
-c010666a:	74 16                	je     c0106682 <_fifo_check_swap+0x2c8>
-c010666c:	68 59 9d 10 c0       	push   $0xc0109d59
-c0106671:	68 ae 9b 10 c0       	push   $0xc0109bae
-c0106676:	6a 77                	push   $0x77
-c0106678:	68 c3 9b 10 c0       	push   $0xc0109bc3
-c010667d:	e8 66 9d ff ff       	call   c01003e8 <__panic>
+c0106aec:	a1 0c 40 12 c0       	mov    0xc012400c,%eax
+c0106af1:	83 f8 0b             	cmp    $0xb,%eax
+c0106af4:	74 24                	je     c0106b1a <_fifo_check_swap+0x34e>
+c0106af6:	c7 44 24 0c 89 a4 10 	movl   $0xc010a489,0xc(%esp)
+c0106afd:	c0 
+c0106afe:	c7 44 24 08 de a2 10 	movl   $0xc010a2de,0x8(%esp)
+c0106b05:	c0 
+c0106b06:	c7 44 24 04 77 00 00 	movl   $0x77,0x4(%esp)
+c0106b0d:	00 
+c0106b0e:	c7 04 24 f3 a2 10 c0 	movl   $0xc010a2f3,(%esp)
+c0106b15:	e8 de 98 ff ff       	call   c01003f8 <__panic>
     return 0;
-c0106682:	b8 00 00 00 00       	mov    $0x0,%eax
+c0106b1a:	b8 00 00 00 00       	mov    $0x0,%eax
 }
-c0106687:	c9                   	leave  
-c0106688:	c3                   	ret    
+c0106b1f:	c9                   	leave  
+c0106b20:	c3                   	ret    
 
-c0106689 <_fifo_init>:
+c0106b21 <_fifo_init>:
 
 
 static int
 _fifo_init(void)
 {
-c0106689:	55                   	push   %ebp
-c010668a:	89 e5                	mov    %esp,%ebp
+c0106b21:	55                   	push   %ebp
+c0106b22:	89 e5                	mov    %esp,%ebp
     return 0;
-c010668c:	b8 00 00 00 00       	mov    $0x0,%eax
+c0106b24:	b8 00 00 00 00       	mov    $0x0,%eax
 }
-c0106691:	5d                   	pop    %ebp
-c0106692:	c3                   	ret    
+c0106b29:	5d                   	pop    %ebp
+c0106b2a:	c3                   	ret    
 
-c0106693 <_fifo_set_unswappable>:
+c0106b2b <_fifo_set_unswappable>:
 
 static int
 _fifo_set_unswappable(struct mm_struct *mm, uintptr_t addr)
 {
-c0106693:	55                   	push   %ebp
-c0106694:	89 e5                	mov    %esp,%ebp
+c0106b2b:	55                   	push   %ebp
+c0106b2c:	89 e5                	mov    %esp,%ebp
     return 0;
-c0106696:	b8 00 00 00 00       	mov    $0x0,%eax
+c0106b2e:	b8 00 00 00 00       	mov    $0x0,%eax
 }
-c010669b:	5d                   	pop    %ebp
-c010669c:	c3                   	ret    
+c0106b33:	5d                   	pop    %ebp
+c0106b34:	c3                   	ret    
 
-c010669d <_fifo_tick_event>:
+c0106b35 <_fifo_tick_event>:
 
 static int
 _fifo_tick_event(struct mm_struct *mm)
 { return 0; }
-c010669d:	55                   	push   %ebp
-c010669e:	89 e5                	mov    %esp,%ebp
-c01066a0:	b8 00 00 00 00       	mov    $0x0,%eax
-c01066a5:	5d                   	pop    %ebp
-c01066a6:	c3                   	ret    
+c0106b35:	55                   	push   %ebp
+c0106b36:	89 e5                	mov    %esp,%ebp
+c0106b38:	b8 00 00 00 00       	mov    $0x0,%eax
+c0106b3d:	5d                   	pop    %ebp
+c0106b3e:	c3                   	ret    
 
-c01066a7 <page2ppn>:
+c0106b3f <page2ppn>:
 
 extern struct Page *pages;
 extern size_t npage;
 
 static inline ppn_t
 page2ppn(struct Page *page) {
-c01066a7:	55                   	push   %ebp
-c01066a8:	89 e5                	mov    %esp,%ebp
+c0106b3f:	55                   	push   %ebp
+c0106b40:	89 e5                	mov    %esp,%ebp
     return page - pages;
-c01066aa:	8b 45 08             	mov    0x8(%ebp),%eax
-c01066ad:	8b 15 28 30 12 c0    	mov    0xc0123028,%edx
-c01066b3:	29 d0                	sub    %edx,%eax
-c01066b5:	c1 f8 05             	sar    $0x5,%eax
+c0106b42:	8b 45 08             	mov    0x8(%ebp),%eax
+c0106b45:	8b 15 28 40 12 c0    	mov    0xc0124028,%edx
+c0106b4b:	29 d0                	sub    %edx,%eax
+c0106b4d:	c1 f8 05             	sar    $0x5,%eax
 }
-c01066b8:	5d                   	pop    %ebp
-c01066b9:	c3                   	ret    
+c0106b50:	5d                   	pop    %ebp
+c0106b51:	c3                   	ret    
 
-c01066ba <page2pa>:
+c0106b52 <page2pa>:
 
 static inline uintptr_t
 page2pa(struct Page *page) {
-c01066ba:	55                   	push   %ebp
-c01066bb:	89 e5                	mov    %esp,%ebp
+c0106b52:	55                   	push   %ebp
+c0106b53:	89 e5                	mov    %esp,%ebp
+c0106b55:	83 ec 04             	sub    $0x4,%esp
     return page2ppn(page) << PGSHIFT;
-c01066bd:	ff 75 08             	pushl  0x8(%ebp)
-c01066c0:	e8 e2 ff ff ff       	call   c01066a7 <page2ppn>
-c01066c5:	83 c4 04             	add    $0x4,%esp
-c01066c8:	c1 e0 0c             	shl    $0xc,%eax
+c0106b58:	8b 45 08             	mov    0x8(%ebp),%eax
+c0106b5b:	89 04 24             	mov    %eax,(%esp)
+c0106b5e:	e8 dc ff ff ff       	call   c0106b3f <page2ppn>
+c0106b63:	c1 e0 0c             	shl    $0xc,%eax
 }
-c01066cb:	c9                   	leave  
-c01066cc:	c3                   	ret    
+c0106b66:	c9                   	leave  
+c0106b67:	c3                   	ret    
 
-c01066cd <page_ref>:
+c0106b68 <page_ref>:
 pde2page(pde_t pde) {
     return pa2page(PDE_ADDR(pde));
 }
 
 static inline int
 page_ref(struct Page *page) {
-c01066cd:	55                   	push   %ebp
-c01066ce:	89 e5                	mov    %esp,%ebp
+c0106b68:	55                   	push   %ebp
+c0106b69:	89 e5                	mov    %esp,%ebp
     return page->ref;
-c01066d0:	8b 45 08             	mov    0x8(%ebp),%eax
-c01066d3:	8b 00                	mov    (%eax),%eax
+c0106b6b:	8b 45 08             	mov    0x8(%ebp),%eax
+c0106b6e:	8b 00                	mov    (%eax),%eax
 }
-c01066d5:	5d                   	pop    %ebp
-c01066d6:	c3                   	ret    
+c0106b70:	5d                   	pop    %ebp
+c0106b71:	c3                   	ret    
 
-c01066d7 <set_page_ref>:
+c0106b72 <set_page_ref>:
 
 static inline void
 set_page_ref(struct Page *page, int val) {
-c01066d7:	55                   	push   %ebp
-c01066d8:	89 e5                	mov    %esp,%ebp
+c0106b72:	55                   	push   %ebp
+c0106b73:	89 e5                	mov    %esp,%ebp
     page->ref = val;
-c01066da:	8b 45 08             	mov    0x8(%ebp),%eax
-c01066dd:	8b 55 0c             	mov    0xc(%ebp),%edx
-c01066e0:	89 10                	mov    %edx,(%eax)
-}
-c01066e2:	90                   	nop
-c01066e3:	5d                   	pop    %ebp
-c01066e4:	c3                   	ret    
+c0106b75:	8b 45 08             	mov    0x8(%ebp),%eax
+c0106b78:	8b 55 0c             	mov    0xc(%ebp),%edx
+c0106b7b:	89 10                	mov    %edx,(%eax)
+}
+c0106b7d:	90                   	nop
+c0106b7e:	5d                   	pop    %ebp
+c0106b7f:	c3                   	ret    
 
-c01066e5 <default_init>:
+c0106b80 <default_init>:
 
 #define free_list (free_area.free_list)
 #define nr_free (free_area.nr_free)
 
 static void
 default_init(void) {
-c01066e5:	55                   	push   %ebp
-c01066e6:	89 e5                	mov    %esp,%ebp
-c01066e8:	83 ec 10             	sub    $0x10,%esp
-c01066eb:	c7 45 fc 0c 31 12 c0 	movl   $0xc012310c,-0x4(%ebp)
+c0106b80:	55                   	push   %ebp
+c0106b81:	89 e5                	mov    %esp,%ebp
+c0106b83:	83 ec 10             	sub    $0x10,%esp
+c0106b86:	c7 45 fc 0c 41 12 c0 	movl   $0xc012410c,-0x4(%ebp)
  * list_init - initialize a new entry
  * @elm:        new entry to be initialized
  * */
 static inline void
 list_init(list_entry_t *elm) {
     elm->prev = elm->next = elm;
-c01066f2:	8b 45 fc             	mov    -0x4(%ebp),%eax
-c01066f5:	8b 55 fc             	mov    -0x4(%ebp),%edx
-c01066f8:	89 50 04             	mov    %edx,0x4(%eax)
-c01066fb:	8b 45 fc             	mov    -0x4(%ebp),%eax
-c01066fe:	8b 50 04             	mov    0x4(%eax),%edx
-c0106701:	8b 45 fc             	mov    -0x4(%ebp),%eax
-c0106704:	89 10                	mov    %edx,(%eax)
+c0106b8d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0106b90:	8b 55 fc             	mov    -0x4(%ebp),%edx
+c0106b93:	89 50 04             	mov    %edx,0x4(%eax)
+c0106b96:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0106b99:	8b 50 04             	mov    0x4(%eax),%edx
+c0106b9c:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0106b9f:	89 10                	mov    %edx,(%eax)
     list_init(&free_list);
     nr_free = 0;
-c0106706:	c7 05 14 31 12 c0 00 	movl   $0x0,0xc0123114
-c010670d:	00 00 00 
+c0106ba1:	c7 05 14 41 12 c0 00 	movl   $0x0,0xc0124114
+c0106ba8:	00 00 00 
 }
-c0106710:	90                   	nop
-c0106711:	c9                   	leave  
-c0106712:	c3                   	ret    
+c0106bab:	90                   	nop
+c0106bac:	c9                   	leave  
+c0106bad:	c3                   	ret    
 
-c0106713 <default_init_memmap>:
+c0106bae <default_init_memmap>:
 
 static void
 default_init_memmap(struct Page *base, size_t n) {
-c0106713:	55                   	push   %ebp
-c0106714:	89 e5                	mov    %esp,%ebp
-c0106716:	83 ec 38             	sub    $0x38,%esp
+c0106bae:	55                   	push   %ebp
+c0106baf:	89 e5                	mov    %esp,%ebp
+c0106bb1:	83 ec 48             	sub    $0x48,%esp
     assert(n > 0);
-c0106719:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
-c010671d:	75 16                	jne    c0106735 <default_init_memmap+0x22>
-c010671f:	68 7c 9d 10 c0       	push   $0xc0109d7c
-c0106724:	68 82 9d 10 c0       	push   $0xc0109d82
-c0106729:	6a 6d                	push   $0x6d
-c010672b:	68 97 9d 10 c0       	push   $0xc0109d97
-c0106730:	e8 b3 9c ff ff       	call   c01003e8 <__panic>
+c0106bb4:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+c0106bb8:	75 24                	jne    c0106bde <default_init_memmap+0x30>
+c0106bba:	c7 44 24 0c ac a4 10 	movl   $0xc010a4ac,0xc(%esp)
+c0106bc1:	c0 
+c0106bc2:	c7 44 24 08 b2 a4 10 	movl   $0xc010a4b2,0x8(%esp)
+c0106bc9:	c0 
+c0106bca:	c7 44 24 04 6d 00 00 	movl   $0x6d,0x4(%esp)
+c0106bd1:	00 
+c0106bd2:	c7 04 24 c7 a4 10 c0 	movl   $0xc010a4c7,(%esp)
+c0106bd9:	e8 1a 98 ff ff       	call   c01003f8 <__panic>
     struct Page *p = base;
-c0106735:	8b 45 08             	mov    0x8(%ebp),%eax
-c0106738:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0106bde:	8b 45 08             	mov    0x8(%ebp),%eax
+c0106be1:	89 45 f4             	mov    %eax,-0xc(%ebp)
     for (; p != base + n; p ++) {
-c010673b:	eb 6c                	jmp    c01067a9 <default_init_memmap+0x96>
+c0106be4:	eb 7d                	jmp    c0106c63 <default_init_memmap+0xb5>
         assert(PageReserved(p));
-c010673d:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0106740:	83 c0 04             	add    $0x4,%eax
-c0106743:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
-c010674a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+c0106be6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106be9:	83 c0 04             	add    $0x4,%eax
+c0106bec:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+c0106bf3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  * @addr:   the address to count from
  * */
 static inline bool
 test_bit(int nr, volatile void *addr) {
     int oldbit;
     asm volatile ("btl %2, %1; sbbl %0,%0" : "=r" (oldbit) : "m" (*(volatile long *)addr), "Ir" (nr));
-c010674d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-c0106750:	8b 55 e8             	mov    -0x18(%ebp),%edx
-c0106753:	0f a3 10             	bt     %edx,(%eax)
-c0106756:	19 c0                	sbb    %eax,%eax
-c0106758:	89 45 e0             	mov    %eax,-0x20(%ebp)
+c0106bf6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0106bf9:	8b 55 e8             	mov    -0x18(%ebp),%edx
+c0106bfc:	0f a3 10             	bt     %edx,(%eax)
+c0106bff:	19 c0                	sbb    %eax,%eax
+c0106c01:	89 45 e0             	mov    %eax,-0x20(%ebp)
     return oldbit != 0;
-c010675b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
-c010675f:	0f 95 c0             	setne  %al
-c0106762:	0f b6 c0             	movzbl %al,%eax
-c0106765:	85 c0                	test   %eax,%eax
-c0106767:	75 16                	jne    c010677f <default_init_memmap+0x6c>
-c0106769:	68 ad 9d 10 c0       	push   $0xc0109dad
-c010676e:	68 82 9d 10 c0       	push   $0xc0109d82
-c0106773:	6a 70                	push   $0x70
-c0106775:	68 97 9d 10 c0       	push   $0xc0109d97
-c010677a:	e8 69 9c ff ff       	call   c01003e8 <__panic>
+c0106c04:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
+c0106c08:	0f 95 c0             	setne  %al
+c0106c0b:	0f b6 c0             	movzbl %al,%eax
+c0106c0e:	85 c0                	test   %eax,%eax
+c0106c10:	75 24                	jne    c0106c36 <default_init_memmap+0x88>
+c0106c12:	c7 44 24 0c dd a4 10 	movl   $0xc010a4dd,0xc(%esp)
+c0106c19:	c0 
+c0106c1a:	c7 44 24 08 b2 a4 10 	movl   $0xc010a4b2,0x8(%esp)
+c0106c21:	c0 
+c0106c22:	c7 44 24 04 70 00 00 	movl   $0x70,0x4(%esp)
+c0106c29:	00 
+c0106c2a:	c7 04 24 c7 a4 10 c0 	movl   $0xc010a4c7,(%esp)
+c0106c31:	e8 c2 97 ff ff       	call   c01003f8 <__panic>
         p->flags = p->property = 0;
-c010677f:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0106782:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
-c0106789:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c010678c:	8b 50 08             	mov    0x8(%eax),%edx
-c010678f:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0106792:	89 50 04             	mov    %edx,0x4(%eax)
+c0106c36:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106c39:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
+c0106c40:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106c43:	8b 50 08             	mov    0x8(%eax),%edx
+c0106c46:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106c49:	89 50 04             	mov    %edx,0x4(%eax)
+        //SetPageProperty(p);
         set_page_ref(p, 0);
-c0106795:	83 ec 08             	sub    $0x8,%esp
-c0106798:	6a 00                	push   $0x0
-c010679a:	ff 75 f4             	pushl  -0xc(%ebp)
-c010679d:	e8 35 ff ff ff       	call   c01066d7 <set_page_ref>
-c01067a2:	83 c4 10             	add    $0x10,%esp
+c0106c4c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+c0106c53:	00 
+c0106c54:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106c57:	89 04 24             	mov    %eax,(%esp)
+c0106c5a:	e8 13 ff ff ff       	call   c0106b72 <set_page_ref>
 
 static void
 default_init_memmap(struct Page *base, size_t n) {
     assert(n > 0);
     struct Page *p = base;
     for (; p != base + n; p ++) {
-c01067a5:	83 45 f4 20          	addl   $0x20,-0xc(%ebp)
-c01067a9:	8b 45 0c             	mov    0xc(%ebp),%eax
-c01067ac:	c1 e0 05             	shl    $0x5,%eax
-c01067af:	89 c2                	mov    %eax,%edx
-c01067b1:	8b 45 08             	mov    0x8(%ebp),%eax
-c01067b4:	01 d0                	add    %edx,%eax
-c01067b6:	3b 45 f4             	cmp    -0xc(%ebp),%eax
-c01067b9:	75 82                	jne    c010673d <default_init_memmap+0x2a>
+c0106c5f:	83 45 f4 20          	addl   $0x20,-0xc(%ebp)
+c0106c63:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0106c66:	c1 e0 05             	shl    $0x5,%eax
+c0106c69:	89 c2                	mov    %eax,%edx
+c0106c6b:	8b 45 08             	mov    0x8(%ebp),%eax
+c0106c6e:	01 d0                	add    %edx,%eax
+c0106c70:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+c0106c73:	0f 85 6d ff ff ff    	jne    c0106be6 <default_init_memmap+0x38>
         assert(PageReserved(p));
         p->flags = p->property = 0;
+        //SetPageProperty(p);
         set_page_ref(p, 0);
     }
     base->property = n;
-c01067bb:	8b 45 08             	mov    0x8(%ebp),%eax
-c01067be:	8b 55 0c             	mov    0xc(%ebp),%edx
-c01067c1:	89 50 08             	mov    %edx,0x8(%eax)
+c0106c79:	8b 45 08             	mov    0x8(%ebp),%eax
+c0106c7c:	8b 55 0c             	mov    0xc(%ebp),%edx
+c0106c7f:	89 50 08             	mov    %edx,0x8(%eax)
     SetPageProperty(base);
-c01067c4:	8b 45 08             	mov    0x8(%ebp),%eax
-c01067c7:	83 c0 04             	add    $0x4,%eax
-c01067ca:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
-c01067d1:	89 45 cc             	mov    %eax,-0x34(%ebp)
+c0106c82:	8b 45 08             	mov    0x8(%ebp),%eax
+c0106c85:	83 c0 04             	add    $0x4,%eax
+c0106c88:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
+c0106c8f:	89 45 cc             	mov    %eax,-0x34(%ebp)
  * Note that @nr may be almost arbitrarily large; this function is not
  * restricted to acting on a single-word quantity.
  * */
 static inline void
 set_bit(int nr, volatile void *addr) {
     asm volatile ("btsl %1, %0" :"=m" (*(volatile long *)addr) : "Ir" (nr));
-c01067d4:	8b 45 cc             	mov    -0x34(%ebp),%eax
-c01067d7:	8b 55 ec             	mov    -0x14(%ebp),%edx
-c01067da:	0f ab 10             	bts    %edx,(%eax)
+c0106c92:	8b 45 cc             	mov    -0x34(%ebp),%eax
+c0106c95:	8b 55 ec             	mov    -0x14(%ebp),%edx
+c0106c98:	0f ab 10             	bts    %edx,(%eax)
     nr_free += n;
-c01067dd:	8b 15 14 31 12 c0    	mov    0xc0123114,%edx
-c01067e3:	8b 45 0c             	mov    0xc(%ebp),%eax
-c01067e6:	01 d0                	add    %edx,%eax
-c01067e8:	a3 14 31 12 c0       	mov    %eax,0xc0123114
+c0106c9b:	8b 15 14 41 12 c0    	mov    0xc0124114,%edx
+c0106ca1:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0106ca4:	01 d0                	add    %edx,%eax
+c0106ca6:	a3 14 41 12 c0       	mov    %eax,0xc0124114
     list_add_before(&free_list, &(base->page_link));
-c01067ed:	8b 45 08             	mov    0x8(%ebp),%eax
-c01067f0:	83 c0 0c             	add    $0xc,%eax
-c01067f3:	c7 45 f0 0c 31 12 c0 	movl   $0xc012310c,-0x10(%ebp)
-c01067fa:	89 45 dc             	mov    %eax,-0x24(%ebp)
+c0106cab:	8b 45 08             	mov    0x8(%ebp),%eax
+c0106cae:	83 c0 0c             	add    $0xc,%eax
+c0106cb1:	c7 45 f0 0c 41 12 c0 	movl   $0xc012410c,-0x10(%ebp)
+c0106cb8:	89 45 dc             	mov    %eax,-0x24(%ebp)
  * Insert the new element @elm *before* the element @listelm which
  * is already in the list.
  * */
 static inline void
 list_add_before(list_entry_t *listelm, list_entry_t *elm) {
     __list_add(elm, listelm->prev, listelm);
-c01067fd:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0106800:	8b 00                	mov    (%eax),%eax
-c0106802:	8b 55 dc             	mov    -0x24(%ebp),%edx
-c0106805:	89 55 d8             	mov    %edx,-0x28(%ebp)
-c0106808:	89 45 d4             	mov    %eax,-0x2c(%ebp)
-c010680b:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c010680e:	89 45 d0             	mov    %eax,-0x30(%ebp)
+c0106cbb:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0106cbe:	8b 00                	mov    (%eax),%eax
+c0106cc0:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c0106cc3:	89 55 d8             	mov    %edx,-0x28(%ebp)
+c0106cc6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+c0106cc9:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0106ccc:	89 45 d0             	mov    %eax,-0x30(%ebp)
  * This is only for internal list manipulation where we know
  * the prev/next entries already!
  * */
 static inline void
 __list_add(list_entry_t *elm, list_entry_t *prev, list_entry_t *next) {
     prev->next = next->prev = elm;
-c0106811:	8b 45 d0             	mov    -0x30(%ebp),%eax
-c0106814:	8b 55 d8             	mov    -0x28(%ebp),%edx
-c0106817:	89 10                	mov    %edx,(%eax)
-c0106819:	8b 45 d0             	mov    -0x30(%ebp),%eax
-c010681c:	8b 10                	mov    (%eax),%edx
-c010681e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
-c0106821:	89 50 04             	mov    %edx,0x4(%eax)
+c0106ccf:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c0106cd2:	8b 55 d8             	mov    -0x28(%ebp),%edx
+c0106cd5:	89 10                	mov    %edx,(%eax)
+c0106cd7:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c0106cda:	8b 10                	mov    (%eax),%edx
+c0106cdc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+c0106cdf:	89 50 04             	mov    %edx,0x4(%eax)
     elm->next = next;
-c0106824:	8b 45 d8             	mov    -0x28(%ebp),%eax
-c0106827:	8b 55 d0             	mov    -0x30(%ebp),%edx
-c010682a:	89 50 04             	mov    %edx,0x4(%eax)
+c0106ce2:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c0106ce5:	8b 55 d0             	mov    -0x30(%ebp),%edx
+c0106ce8:	89 50 04             	mov    %edx,0x4(%eax)
     elm->prev = prev;
-c010682d:	8b 45 d8             	mov    -0x28(%ebp),%eax
-c0106830:	8b 55 d4             	mov    -0x2c(%ebp),%edx
-c0106833:	89 10                	mov    %edx,(%eax)
-}
-c0106835:	90                   	nop
-c0106836:	c9                   	leave  
-c0106837:	c3                   	ret    
+c0106ceb:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c0106cee:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c0106cf1:	89 10                	mov    %edx,(%eax)
+}
+c0106cf3:	90                   	nop
+c0106cf4:	c9                   	leave  
+c0106cf5:	c3                   	ret    
 
-c0106838 <default_alloc_pages>:
+c0106cf6 <default_alloc_pages>:
 
 static struct Page *
 default_alloc_pages(size_t n) {
-c0106838:	55                   	push   %ebp
-c0106839:	89 e5                	mov    %esp,%ebp
-c010683b:	83 ec 58             	sub    $0x58,%esp
+c0106cf6:	55                   	push   %ebp
+c0106cf7:	89 e5                	mov    %esp,%ebp
+c0106cf9:	83 ec 68             	sub    $0x68,%esp
     assert(n > 0);
-c010683e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
-c0106842:	75 16                	jne    c010685a <default_alloc_pages+0x22>
-c0106844:	68 7c 9d 10 c0       	push   $0xc0109d7c
-c0106849:	68 82 9d 10 c0       	push   $0xc0109d82
-c010684e:	6a 7c                	push   $0x7c
-c0106850:	68 97 9d 10 c0       	push   $0xc0109d97
-c0106855:	e8 8e 9b ff ff       	call   c01003e8 <__panic>
+c0106cfc:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+c0106d00:	75 24                	jne    c0106d26 <default_alloc_pages+0x30>
+c0106d02:	c7 44 24 0c ac a4 10 	movl   $0xc010a4ac,0xc(%esp)
+c0106d09:	c0 
+c0106d0a:	c7 44 24 08 b2 a4 10 	movl   $0xc010a4b2,0x8(%esp)
+c0106d11:	c0 
+c0106d12:	c7 44 24 04 7d 00 00 	movl   $0x7d,0x4(%esp)
+c0106d19:	00 
+c0106d1a:	c7 04 24 c7 a4 10 c0 	movl   $0xc010a4c7,(%esp)
+c0106d21:	e8 d2 96 ff ff       	call   c01003f8 <__panic>
     if (n > nr_free) {
-c010685a:	a1 14 31 12 c0       	mov    0xc0123114,%eax
-c010685f:	3b 45 08             	cmp    0x8(%ebp),%eax
-c0106862:	73 0a                	jae    c010686e <default_alloc_pages+0x36>
+c0106d26:	a1 14 41 12 c0       	mov    0xc0124114,%eax
+c0106d2b:	3b 45 08             	cmp    0x8(%ebp),%eax
+c0106d2e:	73 0a                	jae    c0106d3a <default_alloc_pages+0x44>
         return NULL;
-c0106864:	b8 00 00 00 00       	mov    $0x0,%eax
-c0106869:	e9 36 01 00 00       	jmp    c01069a4 <default_alloc_pages+0x16c>
+c0106d30:	b8 00 00 00 00       	mov    $0x0,%eax
+c0106d35:	e9 35 01 00 00       	jmp    c0106e6f <default_alloc_pages+0x179>
     }
     struct Page *page = NULL;
-c010686e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+c0106d3a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     list_entry_t *le = &free_list;
-c0106875:	c7 45 f0 0c 31 12 c0 	movl   $0xc012310c,-0x10(%ebp)
-    // TODO: optimize (next-fit)
+c0106d41:	c7 45 f0 0c 41 12 c0 	movl   $0xc012410c,-0x10(%ebp)
     while ((le = list_next(le)) != &free_list) {
-c010687c:	eb 1c                	jmp    c010689a <default_alloc_pages+0x62>
+c0106d48:	eb 1c                	jmp    c0106d66 <default_alloc_pages+0x70>
         struct Page *p = le2page(le, page_link);
-c010687e:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0106881:	83 e8 0c             	sub    $0xc,%eax
-c0106884:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c0106d4a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0106d4d:	83 e8 0c             	sub    $0xc,%eax
+c0106d50:	89 45 e8             	mov    %eax,-0x18(%ebp)
         if (p->property >= n) {
-c0106887:	8b 45 e8             	mov    -0x18(%ebp),%eax
-c010688a:	8b 40 08             	mov    0x8(%eax),%eax
-c010688d:	3b 45 08             	cmp    0x8(%ebp),%eax
-c0106890:	72 08                	jb     c010689a <default_alloc_pages+0x62>
+c0106d53:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0106d56:	8b 40 08             	mov    0x8(%eax),%eax
+c0106d59:	3b 45 08             	cmp    0x8(%ebp),%eax
+c0106d5c:	72 08                	jb     c0106d66 <default_alloc_pages+0x70>
             page = p;
-c0106892:	8b 45 e8             	mov    -0x18(%ebp),%eax
-c0106895:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0106d5e:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0106d61:	89 45 f4             	mov    %eax,-0xc(%ebp)
             break;
-c0106898:	eb 18                	jmp    c01068b2 <default_alloc_pages+0x7a>
-c010689a:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c010689d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+c0106d64:	eb 18                	jmp    c0106d7e <default_alloc_pages+0x88>
+c0106d66:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0106d69:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  * list_next - get the next entry
  * @listelm:    the list head
  **/
 static inline list_entry_t *
 list_next(list_entry_t *listelm) {
     return listelm->next;
-c01068a0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
-c01068a3:	8b 40 04             	mov    0x4(%eax),%eax
+c0106d6c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+c0106d6f:	8b 40 04             	mov    0x4(%eax),%eax
+    if (n > nr_free) {
         return NULL;
     }
     struct Page *page = NULL;
     list_entry_t *le = &free_list;
-    // TODO: optimize (next-fit)
     while ((le = list_next(le)) != &free_list) {
-c01068a6:	89 45 f0             	mov    %eax,-0x10(%ebp)
-c01068a9:	81 7d f0 0c 31 12 c0 	cmpl   $0xc012310c,-0x10(%ebp)
-c01068b0:	75 cc                	jne    c010687e <default_alloc_pages+0x46>
+c0106d72:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0106d75:	81 7d f0 0c 41 12 c0 	cmpl   $0xc012410c,-0x10(%ebp)
+c0106d7c:	75 cc                	jne    c0106d4a <default_alloc_pages+0x54>
         if (p->property >= n) {
             page = p;
             break;
         }
     }
     if (page != NULL) {
-c01068b2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
-c01068b6:	0f 84 e5 00 00 00    	je     c01069a1 <default_alloc_pages+0x169>
+c0106d7e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0106d82:	0f 84 e4 00 00 00    	je     c0106e6c <default_alloc_pages+0x176>
+        //list_del(&(page->page_link));
         if (page->property > n) {
-c01068bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c01068bf:	8b 40 08             	mov    0x8(%eax),%eax
-c01068c2:	3b 45 08             	cmp    0x8(%ebp),%eax
-c01068c5:	0f 86 85 00 00 00    	jbe    c0106950 <default_alloc_pages+0x118>
+c0106d88:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106d8b:	8b 40 08             	mov    0x8(%eax),%eax
+c0106d8e:	3b 45 08             	cmp    0x8(%ebp),%eax
+c0106d91:	0f 86 84 00 00 00    	jbe    c0106e1b <default_alloc_pages+0x125>
             struct Page *p = page + n;
-c01068cb:	8b 45 08             	mov    0x8(%ebp),%eax
-c01068ce:	c1 e0 05             	shl    $0x5,%eax
-c01068d1:	89 c2                	mov    %eax,%edx
-c01068d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c01068d6:	01 d0                	add    %edx,%eax
-c01068d8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+c0106d97:	8b 45 08             	mov    0x8(%ebp),%eax
+c0106d9a:	c1 e0 05             	shl    $0x5,%eax
+c0106d9d:	89 c2                	mov    %eax,%edx
+c0106d9f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106da2:	01 d0                	add    %edx,%eax
+c0106da4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
             p->property = page->property - n;
-c01068db:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c01068de:	8b 40 08             	mov    0x8(%eax),%eax
-c01068e1:	2b 45 08             	sub    0x8(%ebp),%eax
-c01068e4:	89 c2                	mov    %eax,%edx
-c01068e6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-c01068e9:	89 50 08             	mov    %edx,0x8(%eax)
+c0106da7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106daa:	8b 40 08             	mov    0x8(%eax),%eax
+c0106dad:	2b 45 08             	sub    0x8(%ebp),%eax
+c0106db0:	89 c2                	mov    %eax,%edx
+c0106db2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0106db5:	89 50 08             	mov    %edx,0x8(%eax)
             SetPageProperty(p);
-c01068ec:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-c01068ef:	83 c0 04             	add    $0x4,%eax
-c01068f2:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
-c01068f9:	89 45 c0             	mov    %eax,-0x40(%ebp)
-c01068fc:	8b 45 c0             	mov    -0x40(%ebp),%eax
-c01068ff:	8b 55 dc             	mov    -0x24(%ebp),%edx
-c0106902:	0f ab 10             	bts    %edx,(%eax)
-            list_add_after(&(page->page_link), &(p->page_link));
-c0106905:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-c0106908:	83 c0 0c             	add    $0xc,%eax
-c010690b:	8b 55 f4             	mov    -0xc(%ebp),%edx
-c010690e:	83 c2 0c             	add    $0xc,%edx
-c0106911:	89 55 ec             	mov    %edx,-0x14(%ebp)
-c0106914:	89 45 d0             	mov    %eax,-0x30(%ebp)
- * Insert the new element @elm *after* the element @listelm which
+c0106db8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0106dbb:	83 c0 04             	add    $0x4,%eax
+c0106dbe:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
+c0106dc5:	89 45 c0             	mov    %eax,-0x40(%ebp)
+c0106dc8:	8b 45 c0             	mov    -0x40(%ebp),%eax
+c0106dcb:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c0106dce:	0f ab 10             	bts    %edx,(%eax)
+            list_add_before(&(page->page_link), &(p->page_link));
+c0106dd1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0106dd4:	83 c0 0c             	add    $0xc,%eax
+c0106dd7:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0106dda:	83 c2 0c             	add    $0xc,%edx
+c0106ddd:	89 55 ec             	mov    %edx,-0x14(%ebp)
+c0106de0:	89 45 d0             	mov    %eax,-0x30(%ebp)
+ * Insert the new element @elm *before* the element @listelm which
  * is already in the list.
  * */
 static inline void
-list_add_after(list_entry_t *listelm, list_entry_t *elm) {
-    __list_add(elm, listelm, listelm->next);
-c0106917:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c010691a:	8b 40 04             	mov    0x4(%eax),%eax
-c010691d:	8b 55 d0             	mov    -0x30(%ebp),%edx
-c0106920:	89 55 cc             	mov    %edx,-0x34(%ebp)
-c0106923:	8b 55 ec             	mov    -0x14(%ebp),%edx
-c0106926:	89 55 c8             	mov    %edx,-0x38(%ebp)
-c0106929:	89 45 c4             	mov    %eax,-0x3c(%ebp)
+list_add_before(list_entry_t *listelm, list_entry_t *elm) {
+    __list_add(elm, listelm->prev, listelm);
+c0106de3:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0106de6:	8b 00                	mov    (%eax),%eax
+c0106de8:	8b 55 d0             	mov    -0x30(%ebp),%edx
+c0106deb:	89 55 cc             	mov    %edx,-0x34(%ebp)
+c0106dee:	89 45 c8             	mov    %eax,-0x38(%ebp)
+c0106df1:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0106df4:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  * This is only for internal list manipulation where we know
  * the prev/next entries already!
  * */
 static inline void
 __list_add(list_entry_t *elm, list_entry_t *prev, list_entry_t *next) {
     prev->next = next->prev = elm;
-c010692c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
-c010692f:	8b 55 cc             	mov    -0x34(%ebp),%edx
-c0106932:	89 10                	mov    %edx,(%eax)
-c0106934:	8b 45 c4             	mov    -0x3c(%ebp),%eax
-c0106937:	8b 10                	mov    (%eax),%edx
-c0106939:	8b 45 c8             	mov    -0x38(%ebp),%eax
-c010693c:	89 50 04             	mov    %edx,0x4(%eax)
+c0106df7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
+c0106dfa:	8b 55 cc             	mov    -0x34(%ebp),%edx
+c0106dfd:	89 10                	mov    %edx,(%eax)
+c0106dff:	8b 45 c4             	mov    -0x3c(%ebp),%eax
+c0106e02:	8b 10                	mov    (%eax),%edx
+c0106e04:	8b 45 c8             	mov    -0x38(%ebp),%eax
+c0106e07:	89 50 04             	mov    %edx,0x4(%eax)
     elm->next = next;
-c010693f:	8b 45 cc             	mov    -0x34(%ebp),%eax
-c0106942:	8b 55 c4             	mov    -0x3c(%ebp),%edx
-c0106945:	89 50 04             	mov    %edx,0x4(%eax)
+c0106e0a:	8b 45 cc             	mov    -0x34(%ebp),%eax
+c0106e0d:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+c0106e10:	89 50 04             	mov    %edx,0x4(%eax)
     elm->prev = prev;
-c0106948:	8b 45 cc             	mov    -0x34(%ebp),%eax
-c010694b:	8b 55 c8             	mov    -0x38(%ebp),%edx
-c010694e:	89 10                	mov    %edx,(%eax)
-        }
+c0106e13:	8b 45 cc             	mov    -0x34(%ebp),%eax
+c0106e16:	8b 55 c8             	mov    -0x38(%ebp),%edx
+c0106e19:	89 10                	mov    %edx,(%eax)
+    }
+        nr_free -= n;
+c0106e1b:	a1 14 41 12 c0       	mov    0xc0124114,%eax
+c0106e20:	2b 45 08             	sub    0x8(%ebp),%eax
+c0106e23:	a3 14 41 12 c0       	mov    %eax,0xc0124114
         list_del(&(page->page_link));
-c0106950:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0106953:	83 c0 0c             	add    $0xc,%eax
-c0106956:	89 45 d8             	mov    %eax,-0x28(%ebp)
+c0106e28:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106e2b:	83 c0 0c             	add    $0xc,%eax
+c0106e2e:	89 45 d8             	mov    %eax,-0x28(%ebp)
  * Note: list_empty() on @listelm does not return true after this, the entry is
  * in an undefined state.
  * */
 static inline void
 list_del(list_entry_t *listelm) {
     __list_del(listelm->prev, listelm->next);
-c0106959:	8b 45 d8             	mov    -0x28(%ebp),%eax
-c010695c:	8b 40 04             	mov    0x4(%eax),%eax
-c010695f:	8b 55 d8             	mov    -0x28(%ebp),%edx
-c0106962:	8b 12                	mov    (%edx),%edx
-c0106964:	89 55 b8             	mov    %edx,-0x48(%ebp)
-c0106967:	89 45 b4             	mov    %eax,-0x4c(%ebp)
+c0106e31:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c0106e34:	8b 40 04             	mov    0x4(%eax),%eax
+c0106e37:	8b 55 d8             	mov    -0x28(%ebp),%edx
+c0106e3a:	8b 12                	mov    (%edx),%edx
+c0106e3c:	89 55 b8             	mov    %edx,-0x48(%ebp)
+c0106e3f:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  * This is only for internal list manipulation where we know
  * the prev/next entries already!
  * */
 static inline void
 __list_del(list_entry_t *prev, list_entry_t *next) {
     prev->next = next;
-c010696a:	8b 45 b8             	mov    -0x48(%ebp),%eax
-c010696d:	8b 55 b4             	mov    -0x4c(%ebp),%edx
-c0106970:	89 50 04             	mov    %edx,0x4(%eax)
+c0106e42:	8b 45 b8             	mov    -0x48(%ebp),%eax
+c0106e45:	8b 55 b4             	mov    -0x4c(%ebp),%edx
+c0106e48:	89 50 04             	mov    %edx,0x4(%eax)
     next->prev = prev;
-c0106973:	8b 45 b4             	mov    -0x4c(%ebp),%eax
-c0106976:	8b 55 b8             	mov    -0x48(%ebp),%edx
-c0106979:	89 10                	mov    %edx,(%eax)
-        nr_free -= n;
-c010697b:	a1 14 31 12 c0       	mov    0xc0123114,%eax
-c0106980:	2b 45 08             	sub    0x8(%ebp),%eax
-c0106983:	a3 14 31 12 c0       	mov    %eax,0xc0123114
+c0106e4b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
+c0106e4e:	8b 55 b8             	mov    -0x48(%ebp),%edx
+c0106e51:	89 10                	mov    %edx,(%eax)
         ClearPageProperty(page);
-c0106988:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c010698b:	83 c0 04             	add    $0x4,%eax
-c010698e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
-c0106995:	89 45 bc             	mov    %eax,-0x44(%ebp)
+c0106e53:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106e56:	83 c0 04             	add    $0x4,%eax
+c0106e59:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
+c0106e60:	89 45 bc             	mov    %eax,-0x44(%ebp)
  * @nr:     the bit to clear
  * @addr:   the address to start counting from
  * */
 static inline void
 clear_bit(int nr, volatile void *addr) {
     asm volatile ("btrl %1, %0" :"=m" (*(volatile long *)addr) : "Ir" (nr));
-c0106998:	8b 45 bc             	mov    -0x44(%ebp),%eax
-c010699b:	8b 55 e0             	mov    -0x20(%ebp),%edx
-c010699e:	0f b3 10             	btr    %edx,(%eax)
+c0106e63:	8b 45 bc             	mov    -0x44(%ebp),%eax
+c0106e66:	8b 55 e0             	mov    -0x20(%ebp),%edx
+c0106e69:	0f b3 10             	btr    %edx,(%eax)
     }
     return page;
-c01069a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106e6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
 }
-c01069a4:	c9                   	leave  
-c01069a5:	c3                   	ret    
+c0106e6f:	c9                   	leave  
+c0106e70:	c3                   	ret    
 
-c01069a6 <default_free_pages>:
+c0106e71 <default_free_pages>:
 
 static void
 default_free_pages(struct Page *base, size_t n) {
-c01069a6:	55                   	push   %ebp
-c01069a7:	89 e5                	mov    %esp,%ebp
-c01069a9:	81 ec 88 00 00 00    	sub    $0x88,%esp
+c0106e71:	55                   	push   %ebp
+c0106e72:	89 e5                	mov    %esp,%ebp
+c0106e74:	81 ec 98 00 00 00    	sub    $0x98,%esp
     assert(n > 0);
-c01069af:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
-c01069b3:	75 19                	jne    c01069ce <default_free_pages+0x28>
-c01069b5:	68 7c 9d 10 c0       	push   $0xc0109d7c
-c01069ba:	68 82 9d 10 c0       	push   $0xc0109d82
-c01069bf:	68 9a 00 00 00       	push   $0x9a
-c01069c4:	68 97 9d 10 c0       	push   $0xc0109d97
-c01069c9:	e8 1a 9a ff ff       	call   c01003e8 <__panic>
+c0106e7a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+c0106e7e:	75 24                	jne    c0106ea4 <default_free_pages+0x33>
+c0106e80:	c7 44 24 0c ac a4 10 	movl   $0xc010a4ac,0xc(%esp)
+c0106e87:	c0 
+c0106e88:	c7 44 24 08 b2 a4 10 	movl   $0xc010a4b2,0x8(%esp)
+c0106e8f:	c0 
+c0106e90:	c7 44 24 04 9b 00 00 	movl   $0x9b,0x4(%esp)
+c0106e97:	00 
+c0106e98:	c7 04 24 c7 a4 10 c0 	movl   $0xc010a4c7,(%esp)
+c0106e9f:	e8 54 95 ff ff       	call   c01003f8 <__panic>
     struct Page *p = base;
-c01069ce:	8b 45 08             	mov    0x8(%ebp),%eax
-c01069d1:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0106ea4:	8b 45 08             	mov    0x8(%ebp),%eax
+c0106ea7:	89 45 f4             	mov    %eax,-0xc(%ebp)
     for (; p != base + n; p ++) {
-c01069d4:	e9 8f 00 00 00       	jmp    c0106a68 <default_free_pages+0xc2>
+c0106eaa:	e9 9d 00 00 00       	jmp    c0106f4c <default_free_pages+0xdb>
         assert(!PageReserved(p) && !PageProperty(p));
-c01069d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c01069dc:	83 c0 04             	add    $0x4,%eax
-c01069df:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
-c01069e6:	89 45 bc             	mov    %eax,-0x44(%ebp)
+c0106eaf:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106eb2:	83 c0 04             	add    $0x4,%eax
+c0106eb5:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
+c0106ebc:	89 45 bc             	mov    %eax,-0x44(%ebp)
  * @addr:   the address to count from
  * */
 static inline bool
 test_bit(int nr, volatile void *addr) {
     int oldbit;
     asm volatile ("btl %2, %1; sbbl %0,%0" : "=r" (oldbit) : "m" (*(volatile long *)addr), "Ir" (nr));
-c01069e9:	8b 45 bc             	mov    -0x44(%ebp),%eax
-c01069ec:	8b 55 c0             	mov    -0x40(%ebp),%edx
-c01069ef:	0f a3 10             	bt     %edx,(%eax)
-c01069f2:	19 c0                	sbb    %eax,%eax
-c01069f4:	89 45 b8             	mov    %eax,-0x48(%ebp)
+c0106ebf:	8b 45 bc             	mov    -0x44(%ebp),%eax
+c0106ec2:	8b 55 c0             	mov    -0x40(%ebp),%edx
+c0106ec5:	0f a3 10             	bt     %edx,(%eax)
+c0106ec8:	19 c0                	sbb    %eax,%eax
+c0106eca:	89 45 b8             	mov    %eax,-0x48(%ebp)
     return oldbit != 0;
-c01069f7:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
-c01069fb:	0f 95 c0             	setne  %al
-c01069fe:	0f b6 c0             	movzbl %al,%eax
-c0106a01:	85 c0                	test   %eax,%eax
-c0106a03:	75 2c                	jne    c0106a31 <default_free_pages+0x8b>
-c0106a05:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0106a08:	83 c0 04             	add    $0x4,%eax
-c0106a0b:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
-c0106a12:	89 45 b4             	mov    %eax,-0x4c(%ebp)
+c0106ecd:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
+c0106ed1:	0f 95 c0             	setne  %al
+c0106ed4:	0f b6 c0             	movzbl %al,%eax
+c0106ed7:	85 c0                	test   %eax,%eax
+c0106ed9:	75 2c                	jne    c0106f07 <default_free_pages+0x96>
+c0106edb:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106ede:	83 c0 04             	add    $0x4,%eax
+c0106ee1:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
+c0106ee8:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  * @addr:   the address to count from
  * */
 static inline bool
 test_bit(int nr, volatile void *addr) {
     int oldbit;
     asm volatile ("btl %2, %1; sbbl %0,%0" : "=r" (oldbit) : "m" (*(volatile long *)addr), "Ir" (nr));
-c0106a15:	8b 45 b4             	mov    -0x4c(%ebp),%eax
-c0106a18:	8b 55 ec             	mov    -0x14(%ebp),%edx
-c0106a1b:	0f a3 10             	bt     %edx,(%eax)
-c0106a1e:	19 c0                	sbb    %eax,%eax
-c0106a20:	89 45 b0             	mov    %eax,-0x50(%ebp)
+c0106eeb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
+c0106eee:	8b 55 ec             	mov    -0x14(%ebp),%edx
+c0106ef1:	0f a3 10             	bt     %edx,(%eax)
+c0106ef4:	19 c0                	sbb    %eax,%eax
+c0106ef6:	89 45 b0             	mov    %eax,-0x50(%ebp)
     return oldbit != 0;
-c0106a23:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
-c0106a27:	0f 95 c0             	setne  %al
-c0106a2a:	0f b6 c0             	movzbl %al,%eax
-c0106a2d:	85 c0                	test   %eax,%eax
-c0106a2f:	74 19                	je     c0106a4a <default_free_pages+0xa4>
-c0106a31:	68 c0 9d 10 c0       	push   $0xc0109dc0
-c0106a36:	68 82 9d 10 c0       	push   $0xc0109d82
-c0106a3b:	68 9d 00 00 00       	push   $0x9d
-c0106a40:	68 97 9d 10 c0       	push   $0xc0109d97
-c0106a45:	e8 9e 99 ff ff       	call   c01003e8 <__panic>
+c0106ef9:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
+c0106efd:	0f 95 c0             	setne  %al
+c0106f00:	0f b6 c0             	movzbl %al,%eax
+c0106f03:	85 c0                	test   %eax,%eax
+c0106f05:	74 24                	je     c0106f2b <default_free_pages+0xba>
+c0106f07:	c7 44 24 0c f0 a4 10 	movl   $0xc010a4f0,0xc(%esp)
+c0106f0e:	c0 
+c0106f0f:	c7 44 24 08 b2 a4 10 	movl   $0xc010a4b2,0x8(%esp)
+c0106f16:	c0 
+c0106f17:	c7 44 24 04 9e 00 00 	movl   $0x9e,0x4(%esp)
+c0106f1e:	00 
+c0106f1f:	c7 04 24 c7 a4 10 c0 	movl   $0xc010a4c7,(%esp)
+c0106f26:	e8 cd 94 ff ff       	call   c01003f8 <__panic>
         p->flags = 0;
-c0106a4a:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0106a4d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
+c0106f2b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106f2e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
         set_page_ref(p, 0);
-c0106a54:	83 ec 08             	sub    $0x8,%esp
-c0106a57:	6a 00                	push   $0x0
-c0106a59:	ff 75 f4             	pushl  -0xc(%ebp)
-c0106a5c:	e8 76 fc ff ff       	call   c01066d7 <set_page_ref>
-c0106a61:	83 c4 10             	add    $0x10,%esp
+c0106f35:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+c0106f3c:	00 
+c0106f3d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106f40:	89 04 24             	mov    %eax,(%esp)
+c0106f43:	e8 2a fc ff ff       	call   c0106b72 <set_page_ref>
 
 static void
 default_free_pages(struct Page *base, size_t n) {
     assert(n > 0);
     struct Page *p = base;
     for (; p != base + n; p ++) {
-c0106a64:	83 45 f4 20          	addl   $0x20,-0xc(%ebp)
-c0106a68:	8b 45 0c             	mov    0xc(%ebp),%eax
-c0106a6b:	c1 e0 05             	shl    $0x5,%eax
-c0106a6e:	89 c2                	mov    %eax,%edx
-c0106a70:	8b 45 08             	mov    0x8(%ebp),%eax
-c0106a73:	01 d0                	add    %edx,%eax
-c0106a75:	3b 45 f4             	cmp    -0xc(%ebp),%eax
-c0106a78:	0f 85 5b ff ff ff    	jne    c01069d9 <default_free_pages+0x33>
+c0106f48:	83 45 f4 20          	addl   $0x20,-0xc(%ebp)
+c0106f4c:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0106f4f:	c1 e0 05             	shl    $0x5,%eax
+c0106f52:	89 c2                	mov    %eax,%edx
+c0106f54:	8b 45 08             	mov    0x8(%ebp),%eax
+c0106f57:	01 d0                	add    %edx,%eax
+c0106f59:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+c0106f5c:	0f 85 4d ff ff ff    	jne    c0106eaf <default_free_pages+0x3e>
         assert(!PageReserved(p) && !PageProperty(p));
         p->flags = 0;
         set_page_ref(p, 0);
     }
     base->property = n;
-c0106a7e:	8b 45 08             	mov    0x8(%ebp),%eax
-c0106a81:	8b 55 0c             	mov    0xc(%ebp),%edx
-c0106a84:	89 50 08             	mov    %edx,0x8(%eax)
+c0106f62:	8b 45 08             	mov    0x8(%ebp),%eax
+c0106f65:	8b 55 0c             	mov    0xc(%ebp),%edx
+c0106f68:	89 50 08             	mov    %edx,0x8(%eax)
     SetPageProperty(base);
-c0106a87:	8b 45 08             	mov    0x8(%ebp),%eax
-c0106a8a:	83 c0 04             	add    $0x4,%eax
-c0106a8d:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
-c0106a94:	89 45 ac             	mov    %eax,-0x54(%ebp)
+c0106f6b:	8b 45 08             	mov    0x8(%ebp),%eax
+c0106f6e:	83 c0 04             	add    $0x4,%eax
+c0106f71:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
+c0106f78:	89 45 ac             	mov    %eax,-0x54(%ebp)
  * Note that @nr may be almost arbitrarily large; this function is not
  * restricted to acting on a single-word quantity.
  * */
 static inline void
 set_bit(int nr, volatile void *addr) {
     asm volatile ("btsl %1, %0" :"=m" (*(volatile long *)addr) : "Ir" (nr));
-c0106a97:	8b 45 ac             	mov    -0x54(%ebp),%eax
-c0106a9a:	8b 55 e0             	mov    -0x20(%ebp),%edx
-c0106a9d:	0f ab 10             	bts    %edx,(%eax)
-c0106aa0:	c7 45 e8 0c 31 12 c0 	movl   $0xc012310c,-0x18(%ebp)
+c0106f7b:	8b 45 ac             	mov    -0x54(%ebp),%eax
+c0106f7e:	8b 55 e0             	mov    -0x20(%ebp),%edx
+c0106f81:	0f ab 10             	bts    %edx,(%eax)
+c0106f84:	c7 45 e8 0c 41 12 c0 	movl   $0xc012410c,-0x18(%ebp)
  * list_next - get the next entry
  * @listelm:    the list head
  **/
 static inline list_entry_t *
 list_next(list_entry_t *listelm) {
     return listelm->next;
-c0106aa7:	8b 45 e8             	mov    -0x18(%ebp),%eax
-c0106aaa:	8b 40 04             	mov    0x4(%eax),%eax
+c0106f8b:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0106f8e:	8b 40 04             	mov    0x4(%eax),%eax
     list_entry_t *le = list_next(&free_list);
-c0106aad:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0106f91:	89 45 f0             	mov    %eax,-0x10(%ebp)
     while (le != &free_list) {
-c0106ab0:	e9 fa 00 00 00       	jmp    c0106baf <default_free_pages+0x209>
+c0106f94:	e9 fa 00 00 00       	jmp    c0107093 <default_free_pages+0x222>
         p = le2page(le, page_link);
-c0106ab5:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0106ab8:	83 e8 0c             	sub    $0xc,%eax
-c0106abb:	89 45 f4             	mov    %eax,-0xc(%ebp)
-c0106abe:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0106ac1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
-c0106ac4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-c0106ac7:	8b 40 04             	mov    0x4(%eax),%eax
+c0106f99:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0106f9c:	83 e8 0c             	sub    $0xc,%eax
+c0106f9f:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0106fa2:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0106fa5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+c0106fa8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0106fab:	8b 40 04             	mov    0x4(%eax),%eax
         le = list_next(le);
-c0106aca:	89 45 f0             	mov    %eax,-0x10(%ebp)
-        // TODO: optimize
+c0106fae:	89 45 f0             	mov    %eax,-0x10(%ebp)
         if (base + base->property == p) {
-c0106acd:	8b 45 08             	mov    0x8(%ebp),%eax
-c0106ad0:	8b 40 08             	mov    0x8(%eax),%eax
-c0106ad3:	c1 e0 05             	shl    $0x5,%eax
-c0106ad6:	89 c2                	mov    %eax,%edx
-c0106ad8:	8b 45 08             	mov    0x8(%ebp),%eax
-c0106adb:	01 d0                	add    %edx,%eax
-c0106add:	3b 45 f4             	cmp    -0xc(%ebp),%eax
-c0106ae0:	75 5a                	jne    c0106b3c <default_free_pages+0x196>
+c0106fb1:	8b 45 08             	mov    0x8(%ebp),%eax
+c0106fb4:	8b 40 08             	mov    0x8(%eax),%eax
+c0106fb7:	c1 e0 05             	shl    $0x5,%eax
+c0106fba:	89 c2                	mov    %eax,%edx
+c0106fbc:	8b 45 08             	mov    0x8(%ebp),%eax
+c0106fbf:	01 d0                	add    %edx,%eax
+c0106fc1:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+c0106fc4:	75 5a                	jne    c0107020 <default_free_pages+0x1af>
             base->property += p->property;
-c0106ae2:	8b 45 08             	mov    0x8(%ebp),%eax
-c0106ae5:	8b 50 08             	mov    0x8(%eax),%edx
-c0106ae8:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0106aeb:	8b 40 08             	mov    0x8(%eax),%eax
-c0106aee:	01 c2                	add    %eax,%edx
-c0106af0:	8b 45 08             	mov    0x8(%ebp),%eax
-c0106af3:	89 50 08             	mov    %edx,0x8(%eax)
+c0106fc6:	8b 45 08             	mov    0x8(%ebp),%eax
+c0106fc9:	8b 50 08             	mov    0x8(%eax),%edx
+c0106fcc:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106fcf:	8b 40 08             	mov    0x8(%eax),%eax
+c0106fd2:	01 c2                	add    %eax,%edx
+c0106fd4:	8b 45 08             	mov    0x8(%ebp),%eax
+c0106fd7:	89 50 08             	mov    %edx,0x8(%eax)
             ClearPageProperty(p);
-c0106af6:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0106af9:	83 c0 04             	add    $0x4,%eax
-c0106afc:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
-c0106b03:	89 45 a0             	mov    %eax,-0x60(%ebp)
+c0106fda:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106fdd:	83 c0 04             	add    $0x4,%eax
+c0106fe0:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
+c0106fe7:	89 45 a0             	mov    %eax,-0x60(%ebp)
  * @nr:     the bit to clear
  * @addr:   the address to start counting from
  * */
 static inline void
 clear_bit(int nr, volatile void *addr) {
     asm volatile ("btrl %1, %0" :"=m" (*(volatile long *)addr) : "Ir" (nr));
-c0106b06:	8b 45 a0             	mov    -0x60(%ebp),%eax
-c0106b09:	8b 55 d4             	mov    -0x2c(%ebp),%edx
-c0106b0c:	0f b3 10             	btr    %edx,(%eax)
+c0106fea:	8b 45 a0             	mov    -0x60(%ebp),%eax
+c0106fed:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c0106ff0:	0f b3 10             	btr    %edx,(%eax)
             list_del(&(p->page_link));
-c0106b0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0106b12:	83 c0 0c             	add    $0xc,%eax
-c0106b15:	89 45 dc             	mov    %eax,-0x24(%ebp)
+c0106ff3:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0106ff6:	83 c0 0c             	add    $0xc,%eax
+c0106ff9:	89 45 dc             	mov    %eax,-0x24(%ebp)
  * Note: list_empty() on @listelm does not return true after this, the entry is
  * in an undefined state.
  * */
 static inline void
 list_del(list_entry_t *listelm) {
     __list_del(listelm->prev, listelm->next);
-c0106b18:	8b 45 dc             	mov    -0x24(%ebp),%eax
-c0106b1b:	8b 40 04             	mov    0x4(%eax),%eax
-c0106b1e:	8b 55 dc             	mov    -0x24(%ebp),%edx
-c0106b21:	8b 12                	mov    (%edx),%edx
-c0106b23:	89 55 a8             	mov    %edx,-0x58(%ebp)
-c0106b26:	89 45 a4             	mov    %eax,-0x5c(%ebp)
+c0106ffc:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0106fff:	8b 40 04             	mov    0x4(%eax),%eax
+c0107002:	8b 55 dc             	mov    -0x24(%ebp),%edx
+c0107005:	8b 12                	mov    (%edx),%edx
+c0107007:	89 55 a8             	mov    %edx,-0x58(%ebp)
+c010700a:	89 45 a4             	mov    %eax,-0x5c(%ebp)
  * This is only for internal list manipulation where we know
  * the prev/next entries already!
  * */
 static inline void
 __list_del(list_entry_t *prev, list_entry_t *next) {
     prev->next = next;
-c0106b29:	8b 45 a8             	mov    -0x58(%ebp),%eax
-c0106b2c:	8b 55 a4             	mov    -0x5c(%ebp),%edx
-c0106b2f:	89 50 04             	mov    %edx,0x4(%eax)
+c010700d:	8b 45 a8             	mov    -0x58(%ebp),%eax
+c0107010:	8b 55 a4             	mov    -0x5c(%ebp),%edx
+c0107013:	89 50 04             	mov    %edx,0x4(%eax)
     next->prev = prev;
-c0106b32:	8b 45 a4             	mov    -0x5c(%ebp),%eax
-c0106b35:	8b 55 a8             	mov    -0x58(%ebp),%edx
-c0106b38:	89 10                	mov    %edx,(%eax)
-c0106b3a:	eb 73                	jmp    c0106baf <default_free_pages+0x209>
+c0107016:	8b 45 a4             	mov    -0x5c(%ebp),%eax
+c0107019:	8b 55 a8             	mov    -0x58(%ebp),%edx
+c010701c:	89 10                	mov    %edx,(%eax)
+c010701e:	eb 73                	jmp    c0107093 <default_free_pages+0x222>
         }
         else if (p + p->property == base) {
-c0106b3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0106b3f:	8b 40 08             	mov    0x8(%eax),%eax
-c0106b42:	c1 e0 05             	shl    $0x5,%eax
-c0106b45:	89 c2                	mov    %eax,%edx
-c0106b47:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0106b4a:	01 d0                	add    %edx,%eax
-c0106b4c:	3b 45 08             	cmp    0x8(%ebp),%eax
-c0106b4f:	75 5e                	jne    c0106baf <default_free_pages+0x209>
+c0107020:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0107023:	8b 40 08             	mov    0x8(%eax),%eax
+c0107026:	c1 e0 05             	shl    $0x5,%eax
+c0107029:	89 c2                	mov    %eax,%edx
+c010702b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010702e:	01 d0                	add    %edx,%eax
+c0107030:	3b 45 08             	cmp    0x8(%ebp),%eax
+c0107033:	75 5e                	jne    c0107093 <default_free_pages+0x222>
             p->property += base->property;
-c0106b51:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0106b54:	8b 50 08             	mov    0x8(%eax),%edx
-c0106b57:	8b 45 08             	mov    0x8(%ebp),%eax
-c0106b5a:	8b 40 08             	mov    0x8(%eax),%eax
-c0106b5d:	01 c2                	add    %eax,%edx
-c0106b5f:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0106b62:	89 50 08             	mov    %edx,0x8(%eax)
+c0107035:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0107038:	8b 50 08             	mov    0x8(%eax),%edx
+c010703b:	8b 45 08             	mov    0x8(%ebp),%eax
+c010703e:	8b 40 08             	mov    0x8(%eax),%eax
+c0107041:	01 c2                	add    %eax,%edx
+c0107043:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0107046:	89 50 08             	mov    %edx,0x8(%eax)
             ClearPageProperty(base);
-c0106b65:	8b 45 08             	mov    0x8(%ebp),%eax
-c0106b68:	83 c0 04             	add    $0x4,%eax
-c0106b6b:	c7 45 cc 01 00 00 00 	movl   $0x1,-0x34(%ebp)
-c0106b72:	89 45 94             	mov    %eax,-0x6c(%ebp)
-c0106b75:	8b 45 94             	mov    -0x6c(%ebp),%eax
-c0106b78:	8b 55 cc             	mov    -0x34(%ebp),%edx
-c0106b7b:	0f b3 10             	btr    %edx,(%eax)
+c0107049:	8b 45 08             	mov    0x8(%ebp),%eax
+c010704c:	83 c0 04             	add    $0x4,%eax
+c010704f:	c7 45 cc 01 00 00 00 	movl   $0x1,-0x34(%ebp)
+c0107056:	89 45 94             	mov    %eax,-0x6c(%ebp)
+c0107059:	8b 45 94             	mov    -0x6c(%ebp),%eax
+c010705c:	8b 55 cc             	mov    -0x34(%ebp),%edx
+c010705f:	0f b3 10             	btr    %edx,(%eax)
             base = p;
-c0106b7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0106b81:	89 45 08             	mov    %eax,0x8(%ebp)
+c0107062:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0107065:	89 45 08             	mov    %eax,0x8(%ebp)
             list_del(&(p->page_link));
-c0106b84:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0106b87:	83 c0 0c             	add    $0xc,%eax
-c0106b8a:	89 45 d8             	mov    %eax,-0x28(%ebp)
+c0107068:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010706b:	83 c0 0c             	add    $0xc,%eax
+c010706e:	89 45 d8             	mov    %eax,-0x28(%ebp)
  * Note: list_empty() on @listelm does not return true after this, the entry is
  * in an undefined state.
  * */
 static inline void
 list_del(list_entry_t *listelm) {
     __list_del(listelm->prev, listelm->next);
-c0106b8d:	8b 45 d8             	mov    -0x28(%ebp),%eax
-c0106b90:	8b 40 04             	mov    0x4(%eax),%eax
-c0106b93:	8b 55 d8             	mov    -0x28(%ebp),%edx
-c0106b96:	8b 12                	mov    (%edx),%edx
-c0106b98:	89 55 9c             	mov    %edx,-0x64(%ebp)
-c0106b9b:	89 45 98             	mov    %eax,-0x68(%ebp)
+c0107071:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c0107074:	8b 40 04             	mov    0x4(%eax),%eax
+c0107077:	8b 55 d8             	mov    -0x28(%ebp),%edx
+c010707a:	8b 12                	mov    (%edx),%edx
+c010707c:	89 55 9c             	mov    %edx,-0x64(%ebp)
+c010707f:	89 45 98             	mov    %eax,-0x68(%ebp)
  * This is only for internal list manipulation where we know
  * the prev/next entries already!
  * */
 static inline void
 __list_del(list_entry_t *prev, list_entry_t *next) {
     prev->next = next;
-c0106b9e:	8b 45 9c             	mov    -0x64(%ebp),%eax
-c0106ba1:	8b 55 98             	mov    -0x68(%ebp),%edx
-c0106ba4:	89 50 04             	mov    %edx,0x4(%eax)
+c0107082:	8b 45 9c             	mov    -0x64(%ebp),%eax
+c0107085:	8b 55 98             	mov    -0x68(%ebp),%edx
+c0107088:	89 50 04             	mov    %edx,0x4(%eax)
     next->prev = prev;
-c0106ba7:	8b 45 98             	mov    -0x68(%ebp),%eax
-c0106baa:	8b 55 9c             	mov    -0x64(%ebp),%edx
-c0106bad:	89 10                	mov    %edx,(%eax)
+c010708b:	8b 45 98             	mov    -0x68(%ebp),%eax
+c010708e:	8b 55 9c             	mov    -0x64(%ebp),%edx
+c0107091:	89 10                	mov    %edx,(%eax)
         set_page_ref(p, 0);
     }
     base->property = n;
     SetPageProperty(base);
     list_entry_t *le = list_next(&free_list);
     while (le != &free_list) {
-c0106baf:	81 7d f0 0c 31 12 c0 	cmpl   $0xc012310c,-0x10(%ebp)
-c0106bb6:	0f 85 f9 fe ff ff    	jne    c0106ab5 <default_free_pages+0x10f>
+c0107093:	81 7d f0 0c 41 12 c0 	cmpl   $0xc012410c,-0x10(%ebp)
+c010709a:	0f 85 f9 fe ff ff    	jne    c0106f99 <default_free_pages+0x128>
             ClearPageProperty(base);
             base = p;
             list_del(&(p->page_link));
         }
     }
     nr_free += n;
-c0106bbc:	8b 15 14 31 12 c0    	mov    0xc0123114,%edx
-c0106bc2:	8b 45 0c             	mov    0xc(%ebp),%eax
-c0106bc5:	01 d0                	add    %edx,%eax
-c0106bc7:	a3 14 31 12 c0       	mov    %eax,0xc0123114
-c0106bcc:	c7 45 d0 0c 31 12 c0 	movl   $0xc012310c,-0x30(%ebp)
+c01070a0:	8b 15 14 41 12 c0    	mov    0xc0124114,%edx
+c01070a6:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01070a9:	01 d0                	add    %edx,%eax
+c01070ab:	a3 14 41 12 c0       	mov    %eax,0xc0124114
+c01070b0:	c7 45 d0 0c 41 12 c0 	movl   $0xc012410c,-0x30(%ebp)
  * list_next - get the next entry
  * @listelm:    the list head
  **/
 static inline list_entry_t *
 list_next(list_entry_t *listelm) {
     return listelm->next;
-c0106bd3:	8b 45 d0             	mov    -0x30(%ebp),%eax
-c0106bd6:	8b 40 04             	mov    0x4(%eax),%eax
-    le = list_next(&free_list);
-c0106bd9:	89 45 f0             	mov    %eax,-0x10(%ebp)
-    while (le != &free_list) {
-c0106bdc:	eb 5b                	jmp    c0106c39 <default_free_pages+0x293>
+c01070b7:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c01070ba:	8b 40 04             	mov    0x4(%eax),%eax
+    for (le = list_next(&free_list);le != &free_list;le = list_next(le))
+c01070bd:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c01070c0:	eb 66                	jmp    c0107128 <default_free_pages+0x2b7>
+    {
         p = le2page(le, page_link);
-c0106bde:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0106be1:	83 e8 0c             	sub    $0xc,%eax
-c0106be4:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c01070c2:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01070c5:	83 e8 0c             	sub    $0xc,%eax
+c01070c8:	89 45 f4             	mov    %eax,-0xc(%ebp)
         if (base + base->property <= p) {
-c0106be7:	8b 45 08             	mov    0x8(%ebp),%eax
-c0106bea:	8b 40 08             	mov    0x8(%eax),%eax
-c0106bed:	c1 e0 05             	shl    $0x5,%eax
-c0106bf0:	89 c2                	mov    %eax,%edx
-c0106bf2:	8b 45 08             	mov    0x8(%ebp),%eax
-c0106bf5:	01 d0                	add    %edx,%eax
-c0106bf7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
-c0106bfa:	77 2e                	ja     c0106c2a <default_free_pages+0x284>
+c01070cb:	8b 45 08             	mov    0x8(%ebp),%eax
+c01070ce:	8b 40 08             	mov    0x8(%eax),%eax
+c01070d1:	c1 e0 05             	shl    $0x5,%eax
+c01070d4:	89 c2                	mov    %eax,%edx
+c01070d6:	8b 45 08             	mov    0x8(%ebp),%eax
+c01070d9:	01 d0                	add    %edx,%eax
+c01070db:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+c01070de:	77 39                	ja     c0107119 <default_free_pages+0x2a8>
             assert(base + base->property != p);
-c0106bfc:	8b 45 08             	mov    0x8(%ebp),%eax
-c0106bff:	8b 40 08             	mov    0x8(%eax),%eax
-c0106c02:	c1 e0 05             	shl    $0x5,%eax
-c0106c05:	89 c2                	mov    %eax,%edx
-c0106c07:	8b 45 08             	mov    0x8(%ebp),%eax
-c0106c0a:	01 d0                	add    %edx,%eax
-c0106c0c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
-c0106c0f:	75 33                	jne    c0106c44 <default_free_pages+0x29e>
-c0106c11:	68 e5 9d 10 c0       	push   $0xc0109de5
-c0106c16:	68 82 9d 10 c0       	push   $0xc0109d82
-c0106c1b:	68 b9 00 00 00       	push   $0xb9
-c0106c20:	68 97 9d 10 c0       	push   $0xc0109d97
-c0106c25:	e8 be 97 ff ff       	call   c01003e8 <__panic>
-c0106c2a:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0106c2d:	89 45 c8             	mov    %eax,-0x38(%ebp)
-c0106c30:	8b 45 c8             	mov    -0x38(%ebp),%eax
-c0106c33:	8b 40 04             	mov    0x4(%eax),%eax
-            break;
-        }
-        le = list_next(le);
-c0106c36:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c01070e0:	8b 45 08             	mov    0x8(%ebp),%eax
+c01070e3:	8b 40 08             	mov    0x8(%eax),%eax
+c01070e6:	c1 e0 05             	shl    $0x5,%eax
+c01070e9:	89 c2                	mov    %eax,%edx
+c01070eb:	8b 45 08             	mov    0x8(%ebp),%eax
+c01070ee:	01 d0                	add    %edx,%eax
+c01070f0:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+c01070f3:	75 3e                	jne    c0107133 <default_free_pages+0x2c2>
+c01070f5:	c7 44 24 0c 15 a5 10 	movl   $0xc010a515,0xc(%esp)
+c01070fc:	c0 
+c01070fd:	c7 44 24 08 b2 a4 10 	movl   $0xc010a4b2,0x8(%esp)
+c0107104:	c0 
+c0107105:	c7 44 24 04 b9 00 00 	movl   $0xb9,0x4(%esp)
+c010710c:	00 
+c010710d:	c7 04 24 c7 a4 10 c0 	movl   $0xc010a4c7,(%esp)
+c0107114:	e8 df 92 ff ff       	call   c01003f8 <__panic>
+c0107119:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010711c:	89 45 c8             	mov    %eax,-0x38(%ebp)
+c010711f:	8b 45 c8             	mov    -0x38(%ebp),%eax
+c0107122:	8b 40 04             	mov    0x4(%eax),%eax
+            base = p;
             list_del(&(p->page_link));
         }
     }
     nr_free += n;
-    le = list_next(&free_list);
-    while (le != &free_list) {
-c0106c39:	81 7d f0 0c 31 12 c0 	cmpl   $0xc012310c,-0x10(%ebp)
-c0106c40:	75 9c                	jne    c0106bde <default_free_pages+0x238>
-c0106c42:	eb 01                	jmp    c0106c45 <default_free_pages+0x29f>
+    for (le = list_next(&free_list);le != &free_list;le = list_next(le))
+c0107125:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0107128:	81 7d f0 0c 41 12 c0 	cmpl   $0xc012410c,-0x10(%ebp)
+c010712f:	75 91                	jne    c01070c2 <default_free_pages+0x251>
+c0107131:	eb 01                	jmp    c0107134 <default_free_pages+0x2c3>
+    {
         p = le2page(le, page_link);
         if (base + base->property <= p) {
             assert(base + base->property != p);
             break;
-c0106c44:	90                   	nop
+c0107133:	90                   	nop
         }
-        le = list_next(le);
     }
     list_add_before(le, &(base->page_link));
-c0106c45:	8b 45 08             	mov    0x8(%ebp),%eax
-c0106c48:	8d 50 0c             	lea    0xc(%eax),%edx
-c0106c4b:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0106c4e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
-c0106c51:	89 55 90             	mov    %edx,-0x70(%ebp)
+c0107134:	8b 45 08             	mov    0x8(%ebp),%eax
+c0107137:	8d 50 0c             	lea    0xc(%eax),%edx
+c010713a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010713d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
+c0107140:	89 55 90             	mov    %edx,-0x70(%ebp)
  * Insert the new element @elm *before* the element @listelm which
  * is already in the list.
  * */
 static inline void
 list_add_before(list_entry_t *listelm, list_entry_t *elm) {
     __list_add(elm, listelm->prev, listelm);
-c0106c54:	8b 45 c4             	mov    -0x3c(%ebp),%eax
-c0106c57:	8b 00                	mov    (%eax),%eax
-c0106c59:	8b 55 90             	mov    -0x70(%ebp),%edx
-c0106c5c:	89 55 8c             	mov    %edx,-0x74(%ebp)
-c0106c5f:	89 45 88             	mov    %eax,-0x78(%ebp)
-c0106c62:	8b 45 c4             	mov    -0x3c(%ebp),%eax
-c0106c65:	89 45 84             	mov    %eax,-0x7c(%ebp)
+c0107143:	8b 45 c4             	mov    -0x3c(%ebp),%eax
+c0107146:	8b 00                	mov    (%eax),%eax
+c0107148:	8b 55 90             	mov    -0x70(%ebp),%edx
+c010714b:	89 55 8c             	mov    %edx,-0x74(%ebp)
+c010714e:	89 45 88             	mov    %eax,-0x78(%ebp)
+c0107151:	8b 45 c4             	mov    -0x3c(%ebp),%eax
+c0107154:	89 45 84             	mov    %eax,-0x7c(%ebp)
  * This is only for internal list manipulation where we know
  * the prev/next entries already!
  * */
 static inline void
 __list_add(list_entry_t *elm, list_entry_t *prev, list_entry_t *next) {
     prev->next = next->prev = elm;
-c0106c68:	8b 45 84             	mov    -0x7c(%ebp),%eax
-c0106c6b:	8b 55 8c             	mov    -0x74(%ebp),%edx
-c0106c6e:	89 10                	mov    %edx,(%eax)
-c0106c70:	8b 45 84             	mov    -0x7c(%ebp),%eax
-c0106c73:	8b 10                	mov    (%eax),%edx
-c0106c75:	8b 45 88             	mov    -0x78(%ebp),%eax
-c0106c78:	89 50 04             	mov    %edx,0x4(%eax)
+c0107157:	8b 45 84             	mov    -0x7c(%ebp),%eax
+c010715a:	8b 55 8c             	mov    -0x74(%ebp),%edx
+c010715d:	89 10                	mov    %edx,(%eax)
+c010715f:	8b 45 84             	mov    -0x7c(%ebp),%eax
+c0107162:	8b 10                	mov    (%eax),%edx
+c0107164:	8b 45 88             	mov    -0x78(%ebp),%eax
+c0107167:	89 50 04             	mov    %edx,0x4(%eax)
     elm->next = next;
-c0106c7b:	8b 45 8c             	mov    -0x74(%ebp),%eax
-c0106c7e:	8b 55 84             	mov    -0x7c(%ebp),%edx
-c0106c81:	89 50 04             	mov    %edx,0x4(%eax)
+c010716a:	8b 45 8c             	mov    -0x74(%ebp),%eax
+c010716d:	8b 55 84             	mov    -0x7c(%ebp),%edx
+c0107170:	89 50 04             	mov    %edx,0x4(%eax)
     elm->prev = prev;
-c0106c84:	8b 45 8c             	mov    -0x74(%ebp),%eax
-c0106c87:	8b 55 88             	mov    -0x78(%ebp),%edx
-c0106c8a:	89 10                	mov    %edx,(%eax)
-}
-c0106c8c:	90                   	nop
-c0106c8d:	c9                   	leave  
-c0106c8e:	c3                   	ret    
+c0107173:	8b 45 8c             	mov    -0x74(%ebp),%eax
+c0107176:	8b 55 88             	mov    -0x78(%ebp),%edx
+c0107179:	89 10                	mov    %edx,(%eax)
+}
+c010717b:	90                   	nop
+c010717c:	c9                   	leave  
+c010717d:	c3                   	ret    
 
-c0106c8f <default_nr_free_pages>:
+c010717e <default_nr_free_pages>:
 
 static size_t
 default_nr_free_pages(void) {
-c0106c8f:	55                   	push   %ebp
-c0106c90:	89 e5                	mov    %esp,%ebp
+c010717e:	55                   	push   %ebp
+c010717f:	89 e5                	mov    %esp,%ebp
     return nr_free;
-c0106c92:	a1 14 31 12 c0       	mov    0xc0123114,%eax
+c0107181:	a1 14 41 12 c0       	mov    0xc0124114,%eax
 }
-c0106c97:	5d                   	pop    %ebp
-c0106c98:	c3                   	ret    
+c0107186:	5d                   	pop    %ebp
+c0107187:	c3                   	ret    
 
-c0106c99 <basic_check>:
+c0107188 <basic_check>:
 
 static void
 basic_check(void) {
-c0106c99:	55                   	push   %ebp
-c0106c9a:	89 e5                	mov    %esp,%ebp
-c0106c9c:	83 ec 38             	sub    $0x38,%esp
+c0107188:	55                   	push   %ebp
+c0107189:	89 e5                	mov    %esp,%ebp
+c010718b:	83 ec 48             	sub    $0x48,%esp
     struct Page *p0, *p1, *p2;
     p0 = p1 = p2 = NULL;
-c0106c9f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
-c0106ca6:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0106ca9:	89 45 f0             	mov    %eax,-0x10(%ebp)
-c0106cac:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0106caf:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c010718e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+c0107195:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0107198:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c010719b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010719e:	89 45 ec             	mov    %eax,-0x14(%ebp)
     assert((p0 = alloc_page()) != NULL);
-c0106cb2:	83 ec 0c             	sub    $0xc,%esp
-c0106cb5:	6a 01                	push   $0x1
-c0106cb7:	e8 58 c8 ff ff       	call   c0103514 <alloc_pages>
-c0106cbc:	83 c4 10             	add    $0x10,%esp
-c0106cbf:	89 45 ec             	mov    %eax,-0x14(%ebp)
-c0106cc2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
-c0106cc6:	75 19                	jne    c0106ce1 <basic_check+0x48>
-c0106cc8:	68 00 9e 10 c0       	push   $0xc0109e00
-c0106ccd:	68 82 9d 10 c0       	push   $0xc0109d82
-c0106cd2:	68 ca 00 00 00       	push   $0xca
-c0106cd7:	68 97 9d 10 c0       	push   $0xc0109d97
-c0106cdc:	e8 07 97 ff ff       	call   c01003e8 <__panic>
+c01071a1:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c01071a8:	e8 c0 c1 ff ff       	call   c010336d <alloc_pages>
+c01071ad:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c01071b0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+c01071b4:	75 24                	jne    c01071da <basic_check+0x52>
+c01071b6:	c7 44 24 0c 30 a5 10 	movl   $0xc010a530,0xc(%esp)
+c01071bd:	c0 
+c01071be:	c7 44 24 08 b2 a4 10 	movl   $0xc010a4b2,0x8(%esp)
+c01071c5:	c0 
+c01071c6:	c7 44 24 04 c9 00 00 	movl   $0xc9,0x4(%esp)
+c01071cd:	00 
+c01071ce:	c7 04 24 c7 a4 10 c0 	movl   $0xc010a4c7,(%esp)
+c01071d5:	e8 1e 92 ff ff       	call   c01003f8 <__panic>
     assert((p1 = alloc_page()) != NULL);
-c0106ce1:	83 ec 0c             	sub    $0xc,%esp
-c0106ce4:	6a 01                	push   $0x1
-c0106ce6:	e8 29 c8 ff ff       	call   c0103514 <alloc_pages>
-c0106ceb:	83 c4 10             	add    $0x10,%esp
-c0106cee:	89 45 f0             	mov    %eax,-0x10(%ebp)
-c0106cf1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
-c0106cf5:	75 19                	jne    c0106d10 <basic_check+0x77>
-c0106cf7:	68 1c 9e 10 c0       	push   $0xc0109e1c
-c0106cfc:	68 82 9d 10 c0       	push   $0xc0109d82
-c0106d01:	68 cb 00 00 00       	push   $0xcb
-c0106d06:	68 97 9d 10 c0       	push   $0xc0109d97
-c0106d0b:	e8 d8 96 ff ff       	call   c01003e8 <__panic>
+c01071da:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c01071e1:	e8 87 c1 ff ff       	call   c010336d <alloc_pages>
+c01071e6:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c01071e9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c01071ed:	75 24                	jne    c0107213 <basic_check+0x8b>
+c01071ef:	c7 44 24 0c 4c a5 10 	movl   $0xc010a54c,0xc(%esp)
+c01071f6:	c0 
+c01071f7:	c7 44 24 08 b2 a4 10 	movl   $0xc010a4b2,0x8(%esp)
+c01071fe:	c0 
+c01071ff:	c7 44 24 04 ca 00 00 	movl   $0xca,0x4(%esp)
+c0107206:	00 
+c0107207:	c7 04 24 c7 a4 10 c0 	movl   $0xc010a4c7,(%esp)
+c010720e:	e8 e5 91 ff ff       	call   c01003f8 <__panic>
     assert((p2 = alloc_page()) != NULL);
-c0106d10:	83 ec 0c             	sub    $0xc,%esp
-c0106d13:	6a 01                	push   $0x1
-c0106d15:	e8 fa c7 ff ff       	call   c0103514 <alloc_pages>
-c0106d1a:	83 c4 10             	add    $0x10,%esp
-c0106d1d:	89 45 f4             	mov    %eax,-0xc(%ebp)
-c0106d20:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
-c0106d24:	75 19                	jne    c0106d3f <basic_check+0xa6>
-c0106d26:	68 38 9e 10 c0       	push   $0xc0109e38
-c0106d2b:	68 82 9d 10 c0       	push   $0xc0109d82
-c0106d30:	68 cc 00 00 00       	push   $0xcc
-c0106d35:	68 97 9d 10 c0       	push   $0xc0109d97
-c0106d3a:	e8 a9 96 ff ff       	call   c01003e8 <__panic>
+c0107213:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c010721a:	e8 4e c1 ff ff       	call   c010336d <alloc_pages>
+c010721f:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0107222:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0107226:	75 24                	jne    c010724c <basic_check+0xc4>
+c0107228:	c7 44 24 0c 68 a5 10 	movl   $0xc010a568,0xc(%esp)
+c010722f:	c0 
+c0107230:	c7 44 24 08 b2 a4 10 	movl   $0xc010a4b2,0x8(%esp)
+c0107237:	c0 
+c0107238:	c7 44 24 04 cb 00 00 	movl   $0xcb,0x4(%esp)
+c010723f:	00 
+c0107240:	c7 04 24 c7 a4 10 c0 	movl   $0xc010a4c7,(%esp)
+c0107247:	e8 ac 91 ff ff       	call   c01003f8 <__panic>
 
     assert(p0 != p1 && p0 != p2 && p1 != p2);
-c0106d3f:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c0106d42:	3b 45 f0             	cmp    -0x10(%ebp),%eax
-c0106d45:	74 10                	je     c0106d57 <basic_check+0xbe>
-c0106d47:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c0106d4a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
-c0106d4d:	74 08                	je     c0106d57 <basic_check+0xbe>
-c0106d4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0106d52:	3b 45 f4             	cmp    -0xc(%ebp),%eax
-c0106d55:	75 19                	jne    c0106d70 <basic_check+0xd7>
-c0106d57:	68 54 9e 10 c0       	push   $0xc0109e54
-c0106d5c:	68 82 9d 10 c0       	push   $0xc0109d82
-c0106d61:	68 ce 00 00 00       	push   $0xce
-c0106d66:	68 97 9d 10 c0       	push   $0xc0109d97
-c0106d6b:	e8 78 96 ff ff       	call   c01003e8 <__panic>
+c010724c:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c010724f:	3b 45 f0             	cmp    -0x10(%ebp),%eax
+c0107252:	74 10                	je     c0107264 <basic_check+0xdc>
+c0107254:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0107257:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+c010725a:	74 08                	je     c0107264 <basic_check+0xdc>
+c010725c:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010725f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+c0107262:	75 24                	jne    c0107288 <basic_check+0x100>
+c0107264:	c7 44 24 0c 84 a5 10 	movl   $0xc010a584,0xc(%esp)
+c010726b:	c0 
+c010726c:	c7 44 24 08 b2 a4 10 	movl   $0xc010a4b2,0x8(%esp)
+c0107273:	c0 
+c0107274:	c7 44 24 04 cd 00 00 	movl   $0xcd,0x4(%esp)
+c010727b:	00 
+c010727c:	c7 04 24 c7 a4 10 c0 	movl   $0xc010a4c7,(%esp)
+c0107283:	e8 70 91 ff ff       	call   c01003f8 <__panic>
     assert(page_ref(p0) == 0 && page_ref(p1) == 0 && page_ref(p2) == 0);
-c0106d70:	83 ec 0c             	sub    $0xc,%esp
-c0106d73:	ff 75 ec             	pushl  -0x14(%ebp)
-c0106d76:	e8 52 f9 ff ff       	call   c01066cd <page_ref>
-c0106d7b:	83 c4 10             	add    $0x10,%esp
-c0106d7e:	85 c0                	test   %eax,%eax
-c0106d80:	75 24                	jne    c0106da6 <basic_check+0x10d>
-c0106d82:	83 ec 0c             	sub    $0xc,%esp
-c0106d85:	ff 75 f0             	pushl  -0x10(%ebp)
-c0106d88:	e8 40 f9 ff ff       	call   c01066cd <page_ref>
-c0106d8d:	83 c4 10             	add    $0x10,%esp
-c0106d90:	85 c0                	test   %eax,%eax
-c0106d92:	75 12                	jne    c0106da6 <basic_check+0x10d>
-c0106d94:	83 ec 0c             	sub    $0xc,%esp
-c0106d97:	ff 75 f4             	pushl  -0xc(%ebp)
-c0106d9a:	e8 2e f9 ff ff       	call   c01066cd <page_ref>
-c0106d9f:	83 c4 10             	add    $0x10,%esp
-c0106da2:	85 c0                	test   %eax,%eax
-c0106da4:	74 19                	je     c0106dbf <basic_check+0x126>
-c0106da6:	68 78 9e 10 c0       	push   $0xc0109e78
-c0106dab:	68 82 9d 10 c0       	push   $0xc0109d82
-c0106db0:	68 cf 00 00 00       	push   $0xcf
-c0106db5:	68 97 9d 10 c0       	push   $0xc0109d97
-c0106dba:	e8 29 96 ff ff       	call   c01003e8 <__panic>
+c0107288:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c010728b:	89 04 24             	mov    %eax,(%esp)
+c010728e:	e8 d5 f8 ff ff       	call   c0106b68 <page_ref>
+c0107293:	85 c0                	test   %eax,%eax
+c0107295:	75 1e                	jne    c01072b5 <basic_check+0x12d>
+c0107297:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010729a:	89 04 24             	mov    %eax,(%esp)
+c010729d:	e8 c6 f8 ff ff       	call   c0106b68 <page_ref>
+c01072a2:	85 c0                	test   %eax,%eax
+c01072a4:	75 0f                	jne    c01072b5 <basic_check+0x12d>
+c01072a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01072a9:	89 04 24             	mov    %eax,(%esp)
+c01072ac:	e8 b7 f8 ff ff       	call   c0106b68 <page_ref>
+c01072b1:	85 c0                	test   %eax,%eax
+c01072b3:	74 24                	je     c01072d9 <basic_check+0x151>
+c01072b5:	c7 44 24 0c a8 a5 10 	movl   $0xc010a5a8,0xc(%esp)
+c01072bc:	c0 
+c01072bd:	c7 44 24 08 b2 a4 10 	movl   $0xc010a4b2,0x8(%esp)
+c01072c4:	c0 
+c01072c5:	c7 44 24 04 ce 00 00 	movl   $0xce,0x4(%esp)
+c01072cc:	00 
+c01072cd:	c7 04 24 c7 a4 10 c0 	movl   $0xc010a4c7,(%esp)
+c01072d4:	e8 1f 91 ff ff       	call   c01003f8 <__panic>
 
     assert(page2pa(p0) < npage * PGSIZE);
-c0106dbf:	83 ec 0c             	sub    $0xc,%esp
-c0106dc2:	ff 75 ec             	pushl  -0x14(%ebp)
-c0106dc5:	e8 f0 f8 ff ff       	call   c01066ba <page2pa>
-c0106dca:	83 c4 10             	add    $0x10,%esp
-c0106dcd:	89 c2                	mov    %eax,%edx
-c0106dcf:	a1 80 2f 12 c0       	mov    0xc0122f80,%eax
-c0106dd4:	c1 e0 0c             	shl    $0xc,%eax
-c0106dd7:	39 c2                	cmp    %eax,%edx
-c0106dd9:	72 19                	jb     c0106df4 <basic_check+0x15b>
-c0106ddb:	68 b4 9e 10 c0       	push   $0xc0109eb4
-c0106de0:	68 82 9d 10 c0       	push   $0xc0109d82
-c0106de5:	68 d1 00 00 00       	push   $0xd1
-c0106dea:	68 97 9d 10 c0       	push   $0xc0109d97
-c0106def:	e8 f4 95 ff ff       	call   c01003e8 <__panic>
+c01072d9:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c01072dc:	89 04 24             	mov    %eax,(%esp)
+c01072df:	e8 6e f8 ff ff       	call   c0106b52 <page2pa>
+c01072e4:	8b 15 80 3f 12 c0    	mov    0xc0123f80,%edx
+c01072ea:	c1 e2 0c             	shl    $0xc,%edx
+c01072ed:	39 d0                	cmp    %edx,%eax
+c01072ef:	72 24                	jb     c0107315 <basic_check+0x18d>
+c01072f1:	c7 44 24 0c e4 a5 10 	movl   $0xc010a5e4,0xc(%esp)
+c01072f8:	c0 
+c01072f9:	c7 44 24 08 b2 a4 10 	movl   $0xc010a4b2,0x8(%esp)
+c0107300:	c0 
+c0107301:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
+c0107308:	00 
+c0107309:	c7 04 24 c7 a4 10 c0 	movl   $0xc010a4c7,(%esp)
+c0107310:	e8 e3 90 ff ff       	call   c01003f8 <__panic>
     assert(page2pa(p1) < npage * PGSIZE);
-c0106df4:	83 ec 0c             	sub    $0xc,%esp
-c0106df7:	ff 75 f0             	pushl  -0x10(%ebp)
-c0106dfa:	e8 bb f8 ff ff       	call   c01066ba <page2pa>
-c0106dff:	83 c4 10             	add    $0x10,%esp
-c0106e02:	89 c2                	mov    %eax,%edx
-c0106e04:	a1 80 2f 12 c0       	mov    0xc0122f80,%eax
-c0106e09:	c1 e0 0c             	shl    $0xc,%eax
-c0106e0c:	39 c2                	cmp    %eax,%edx
-c0106e0e:	72 19                	jb     c0106e29 <basic_check+0x190>
-c0106e10:	68 d1 9e 10 c0       	push   $0xc0109ed1
-c0106e15:	68 82 9d 10 c0       	push   $0xc0109d82
-c0106e1a:	68 d2 00 00 00       	push   $0xd2
-c0106e1f:	68 97 9d 10 c0       	push   $0xc0109d97
-c0106e24:	e8 bf 95 ff ff       	call   c01003e8 <__panic>
+c0107315:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0107318:	89 04 24             	mov    %eax,(%esp)
+c010731b:	e8 32 f8 ff ff       	call   c0106b52 <page2pa>
+c0107320:	8b 15 80 3f 12 c0    	mov    0xc0123f80,%edx
+c0107326:	c1 e2 0c             	shl    $0xc,%edx
+c0107329:	39 d0                	cmp    %edx,%eax
+c010732b:	72 24                	jb     c0107351 <basic_check+0x1c9>
+c010732d:	c7 44 24 0c 01 a6 10 	movl   $0xc010a601,0xc(%esp)
+c0107334:	c0 
+c0107335:	c7 44 24 08 b2 a4 10 	movl   $0xc010a4b2,0x8(%esp)
+c010733c:	c0 
+c010733d:	c7 44 24 04 d1 00 00 	movl   $0xd1,0x4(%esp)
+c0107344:	00 
+c0107345:	c7 04 24 c7 a4 10 c0 	movl   $0xc010a4c7,(%esp)
+c010734c:	e8 a7 90 ff ff       	call   c01003f8 <__panic>
     assert(page2pa(p2) < npage * PGSIZE);
-c0106e29:	83 ec 0c             	sub    $0xc,%esp
-c0106e2c:	ff 75 f4             	pushl  -0xc(%ebp)
-c0106e2f:	e8 86 f8 ff ff       	call   c01066ba <page2pa>
-c0106e34:	83 c4 10             	add    $0x10,%esp
-c0106e37:	89 c2                	mov    %eax,%edx
-c0106e39:	a1 80 2f 12 c0       	mov    0xc0122f80,%eax
-c0106e3e:	c1 e0 0c             	shl    $0xc,%eax
-c0106e41:	39 c2                	cmp    %eax,%edx
-c0106e43:	72 19                	jb     c0106e5e <basic_check+0x1c5>
-c0106e45:	68 ee 9e 10 c0       	push   $0xc0109eee
-c0106e4a:	68 82 9d 10 c0       	push   $0xc0109d82
-c0106e4f:	68 d3 00 00 00       	push   $0xd3
-c0106e54:	68 97 9d 10 c0       	push   $0xc0109d97
-c0106e59:	e8 8a 95 ff ff       	call   c01003e8 <__panic>
+c0107351:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0107354:	89 04 24             	mov    %eax,(%esp)
+c0107357:	e8 f6 f7 ff ff       	call   c0106b52 <page2pa>
+c010735c:	8b 15 80 3f 12 c0    	mov    0xc0123f80,%edx
+c0107362:	c1 e2 0c             	shl    $0xc,%edx
+c0107365:	39 d0                	cmp    %edx,%eax
+c0107367:	72 24                	jb     c010738d <basic_check+0x205>
+c0107369:	c7 44 24 0c 1e a6 10 	movl   $0xc010a61e,0xc(%esp)
+c0107370:	c0 
+c0107371:	c7 44 24 08 b2 a4 10 	movl   $0xc010a4b2,0x8(%esp)
+c0107378:	c0 
+c0107379:	c7 44 24 04 d2 00 00 	movl   $0xd2,0x4(%esp)
+c0107380:	00 
+c0107381:	c7 04 24 c7 a4 10 c0 	movl   $0xc010a4c7,(%esp)
+c0107388:	e8 6b 90 ff ff       	call   c01003f8 <__panic>
 
     list_entry_t free_list_store = free_list;
-c0106e5e:	a1 0c 31 12 c0       	mov    0xc012310c,%eax
-c0106e63:	8b 15 10 31 12 c0    	mov    0xc0123110,%edx
-c0106e69:	89 45 d0             	mov    %eax,-0x30(%ebp)
-c0106e6c:	89 55 d4             	mov    %edx,-0x2c(%ebp)
-c0106e6f:	c7 45 e4 0c 31 12 c0 	movl   $0xc012310c,-0x1c(%ebp)
+c010738d:	a1 0c 41 12 c0       	mov    0xc012410c,%eax
+c0107392:	8b 15 10 41 12 c0    	mov    0xc0124110,%edx
+c0107398:	89 45 d0             	mov    %eax,-0x30(%ebp)
+c010739b:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+c010739e:	c7 45 e4 0c 41 12 c0 	movl   $0xc012410c,-0x1c(%ebp)
  * list_init - initialize a new entry
  * @elm:        new entry to be initialized
  * */
 static inline void
 list_init(list_entry_t *elm) {
     elm->prev = elm->next = elm;
-c0106e76:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-c0106e79:	8b 55 e4             	mov    -0x1c(%ebp),%edx
-c0106e7c:	89 50 04             	mov    %edx,0x4(%eax)
-c0106e7f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-c0106e82:	8b 50 04             	mov    0x4(%eax),%edx
-c0106e85:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-c0106e88:	89 10                	mov    %edx,(%eax)
-c0106e8a:	c7 45 d8 0c 31 12 c0 	movl   $0xc012310c,-0x28(%ebp)
+c01073a5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c01073a8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c01073ab:	89 50 04             	mov    %edx,0x4(%eax)
+c01073ae:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c01073b1:	8b 50 04             	mov    0x4(%eax),%edx
+c01073b4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c01073b7:	89 10                	mov    %edx,(%eax)
+c01073b9:	c7 45 d8 0c 41 12 c0 	movl   $0xc012410c,-0x28(%ebp)
  * list_empty - tests whether a list is empty
  * @list:       the list to test.
  * */
 static inline bool
 list_empty(list_entry_t *list) {
     return list->next == list;
-c0106e91:	8b 45 d8             	mov    -0x28(%ebp),%eax
-c0106e94:	8b 40 04             	mov    0x4(%eax),%eax
-c0106e97:	39 45 d8             	cmp    %eax,-0x28(%ebp)
-c0106e9a:	0f 94 c0             	sete   %al
-c0106e9d:	0f b6 c0             	movzbl %al,%eax
+c01073c0:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c01073c3:	8b 40 04             	mov    0x4(%eax),%eax
+c01073c6:	39 45 d8             	cmp    %eax,-0x28(%ebp)
+c01073c9:	0f 94 c0             	sete   %al
+c01073cc:	0f b6 c0             	movzbl %al,%eax
     list_init(&free_list);
     assert(list_empty(&free_list));
-c0106ea0:	85 c0                	test   %eax,%eax
-c0106ea2:	75 19                	jne    c0106ebd <basic_check+0x224>
-c0106ea4:	68 0b 9f 10 c0       	push   $0xc0109f0b
-c0106ea9:	68 82 9d 10 c0       	push   $0xc0109d82
-c0106eae:	68 d7 00 00 00       	push   $0xd7
-c0106eb3:	68 97 9d 10 c0       	push   $0xc0109d97
-c0106eb8:	e8 2b 95 ff ff       	call   c01003e8 <__panic>
+c01073cf:	85 c0                	test   %eax,%eax
+c01073d1:	75 24                	jne    c01073f7 <basic_check+0x26f>
+c01073d3:	c7 44 24 0c 3b a6 10 	movl   $0xc010a63b,0xc(%esp)
+c01073da:	c0 
+c01073db:	c7 44 24 08 b2 a4 10 	movl   $0xc010a4b2,0x8(%esp)
+c01073e2:	c0 
+c01073e3:	c7 44 24 04 d6 00 00 	movl   $0xd6,0x4(%esp)
+c01073ea:	00 
+c01073eb:	c7 04 24 c7 a4 10 c0 	movl   $0xc010a4c7,(%esp)
+c01073f2:	e8 01 90 ff ff       	call   c01003f8 <__panic>
 
     unsigned int nr_free_store = nr_free;
-c0106ebd:	a1 14 31 12 c0       	mov    0xc0123114,%eax
-c0106ec2:	89 45 e0             	mov    %eax,-0x20(%ebp)
+c01073f7:	a1 14 41 12 c0       	mov    0xc0124114,%eax
+c01073fc:	89 45 e0             	mov    %eax,-0x20(%ebp)
     nr_free = 0;
-c0106ec5:	c7 05 14 31 12 c0 00 	movl   $0x0,0xc0123114
-c0106ecc:	00 00 00 
+c01073ff:	c7 05 14 41 12 c0 00 	movl   $0x0,0xc0124114
+c0107406:	00 00 00 
 
     assert(alloc_page() == NULL);
-c0106ecf:	83 ec 0c             	sub    $0xc,%esp
-c0106ed2:	6a 01                	push   $0x1
-c0106ed4:	e8 3b c6 ff ff       	call   c0103514 <alloc_pages>
-c0106ed9:	83 c4 10             	add    $0x10,%esp
-c0106edc:	85 c0                	test   %eax,%eax
-c0106ede:	74 19                	je     c0106ef9 <basic_check+0x260>
-c0106ee0:	68 22 9f 10 c0       	push   $0xc0109f22
-c0106ee5:	68 82 9d 10 c0       	push   $0xc0109d82
-c0106eea:	68 dc 00 00 00       	push   $0xdc
-c0106eef:	68 97 9d 10 c0       	push   $0xc0109d97
-c0106ef4:	e8 ef 94 ff ff       	call   c01003e8 <__panic>
+c0107409:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c0107410:	e8 58 bf ff ff       	call   c010336d <alloc_pages>
+c0107415:	85 c0                	test   %eax,%eax
+c0107417:	74 24                	je     c010743d <basic_check+0x2b5>
+c0107419:	c7 44 24 0c 52 a6 10 	movl   $0xc010a652,0xc(%esp)
+c0107420:	c0 
+c0107421:	c7 44 24 08 b2 a4 10 	movl   $0xc010a4b2,0x8(%esp)
+c0107428:	c0 
+c0107429:	c7 44 24 04 db 00 00 	movl   $0xdb,0x4(%esp)
+c0107430:	00 
+c0107431:	c7 04 24 c7 a4 10 c0 	movl   $0xc010a4c7,(%esp)
+c0107438:	e8 bb 8f ff ff       	call   c01003f8 <__panic>
 
     free_page(p0);
-c0106ef9:	83 ec 08             	sub    $0x8,%esp
-c0106efc:	6a 01                	push   $0x1
-c0106efe:	ff 75 ec             	pushl  -0x14(%ebp)
-c0106f01:	e8 7a c6 ff ff       	call   c0103580 <free_pages>
-c0106f06:	83 c4 10             	add    $0x10,%esp
+c010743d:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+c0107444:	00 
+c0107445:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0107448:	89 04 24             	mov    %eax,(%esp)
+c010744b:	e8 88 bf ff ff       	call   c01033d8 <free_pages>
     free_page(p1);
-c0106f09:	83 ec 08             	sub    $0x8,%esp
-c0106f0c:	6a 01                	push   $0x1
-c0106f0e:	ff 75 f0             	pushl  -0x10(%ebp)
-c0106f11:	e8 6a c6 ff ff       	call   c0103580 <free_pages>
-c0106f16:	83 c4 10             	add    $0x10,%esp
+c0107450:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+c0107457:	00 
+c0107458:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010745b:	89 04 24             	mov    %eax,(%esp)
+c010745e:	e8 75 bf ff ff       	call   c01033d8 <free_pages>
     free_page(p2);
-c0106f19:	83 ec 08             	sub    $0x8,%esp
-c0106f1c:	6a 01                	push   $0x1
-c0106f1e:	ff 75 f4             	pushl  -0xc(%ebp)
-c0106f21:	e8 5a c6 ff ff       	call   c0103580 <free_pages>
-c0106f26:	83 c4 10             	add    $0x10,%esp
+c0107463:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+c010746a:	00 
+c010746b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c010746e:	89 04 24             	mov    %eax,(%esp)
+c0107471:	e8 62 bf ff ff       	call   c01033d8 <free_pages>
     assert(nr_free == 3);
-c0106f29:	a1 14 31 12 c0       	mov    0xc0123114,%eax
-c0106f2e:	83 f8 03             	cmp    $0x3,%eax
-c0106f31:	74 19                	je     c0106f4c <basic_check+0x2b3>
-c0106f33:	68 37 9f 10 c0       	push   $0xc0109f37
-c0106f38:	68 82 9d 10 c0       	push   $0xc0109d82
-c0106f3d:	68 e1 00 00 00       	push   $0xe1
-c0106f42:	68 97 9d 10 c0       	push   $0xc0109d97
-c0106f47:	e8 9c 94 ff ff       	call   c01003e8 <__panic>
+c0107476:	a1 14 41 12 c0       	mov    0xc0124114,%eax
+c010747b:	83 f8 03             	cmp    $0x3,%eax
+c010747e:	74 24                	je     c01074a4 <basic_check+0x31c>
+c0107480:	c7 44 24 0c 67 a6 10 	movl   $0xc010a667,0xc(%esp)
+c0107487:	c0 
+c0107488:	c7 44 24 08 b2 a4 10 	movl   $0xc010a4b2,0x8(%esp)
+c010748f:	c0 
+c0107490:	c7 44 24 04 e0 00 00 	movl   $0xe0,0x4(%esp)
+c0107497:	00 
+c0107498:	c7 04 24 c7 a4 10 c0 	movl   $0xc010a4c7,(%esp)
+c010749f:	e8 54 8f ff ff       	call   c01003f8 <__panic>
 
     assert((p0 = alloc_page()) != NULL);
-c0106f4c:	83 ec 0c             	sub    $0xc,%esp
-c0106f4f:	6a 01                	push   $0x1
-c0106f51:	e8 be c5 ff ff       	call   c0103514 <alloc_pages>
-c0106f56:	83 c4 10             	add    $0x10,%esp
-c0106f59:	89 45 ec             	mov    %eax,-0x14(%ebp)
-c0106f5c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
-c0106f60:	75 19                	jne    c0106f7b <basic_check+0x2e2>
-c0106f62:	68 00 9e 10 c0       	push   $0xc0109e00
-c0106f67:	68 82 9d 10 c0       	push   $0xc0109d82
-c0106f6c:	68 e3 00 00 00       	push   $0xe3
-c0106f71:	68 97 9d 10 c0       	push   $0xc0109d97
-c0106f76:	e8 6d 94 ff ff       	call   c01003e8 <__panic>
+c01074a4:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c01074ab:	e8 bd be ff ff       	call   c010336d <alloc_pages>
+c01074b0:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c01074b3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
+c01074b7:	75 24                	jne    c01074dd <basic_check+0x355>
+c01074b9:	c7 44 24 0c 30 a5 10 	movl   $0xc010a530,0xc(%esp)
+c01074c0:	c0 
+c01074c1:	c7 44 24 08 b2 a4 10 	movl   $0xc010a4b2,0x8(%esp)
+c01074c8:	c0 
+c01074c9:	c7 44 24 04 e2 00 00 	movl   $0xe2,0x4(%esp)
+c01074d0:	00 
+c01074d1:	c7 04 24 c7 a4 10 c0 	movl   $0xc010a4c7,(%esp)
+c01074d8:	e8 1b 8f ff ff       	call   c01003f8 <__panic>
     assert((p1 = alloc_page()) != NULL);
-c0106f7b:	83 ec 0c             	sub    $0xc,%esp
-c0106f7e:	6a 01                	push   $0x1
-c0106f80:	e8 8f c5 ff ff       	call   c0103514 <alloc_pages>
-c0106f85:	83 c4 10             	add    $0x10,%esp
-c0106f88:	89 45 f0             	mov    %eax,-0x10(%ebp)
-c0106f8b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
-c0106f8f:	75 19                	jne    c0106faa <basic_check+0x311>
-c0106f91:	68 1c 9e 10 c0       	push   $0xc0109e1c
-c0106f96:	68 82 9d 10 c0       	push   $0xc0109d82
-c0106f9b:	68 e4 00 00 00       	push   $0xe4
-c0106fa0:	68 97 9d 10 c0       	push   $0xc0109d97
-c0106fa5:	e8 3e 94 ff ff       	call   c01003e8 <__panic>
+c01074dd:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c01074e4:	e8 84 be ff ff       	call   c010336d <alloc_pages>
+c01074e9:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c01074ec:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c01074f0:	75 24                	jne    c0107516 <basic_check+0x38e>
+c01074f2:	c7 44 24 0c 4c a5 10 	movl   $0xc010a54c,0xc(%esp)
+c01074f9:	c0 
+c01074fa:	c7 44 24 08 b2 a4 10 	movl   $0xc010a4b2,0x8(%esp)
+c0107501:	c0 
+c0107502:	c7 44 24 04 e3 00 00 	movl   $0xe3,0x4(%esp)
+c0107509:	00 
+c010750a:	c7 04 24 c7 a4 10 c0 	movl   $0xc010a4c7,(%esp)
+c0107511:	e8 e2 8e ff ff       	call   c01003f8 <__panic>
     assert((p2 = alloc_page()) != NULL);
-c0106faa:	83 ec 0c             	sub    $0xc,%esp
-c0106fad:	6a 01                	push   $0x1
-c0106faf:	e8 60 c5 ff ff       	call   c0103514 <alloc_pages>
-c0106fb4:	83 c4 10             	add    $0x10,%esp
-c0106fb7:	89 45 f4             	mov    %eax,-0xc(%ebp)
-c0106fba:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
-c0106fbe:	75 19                	jne    c0106fd9 <basic_check+0x340>
-c0106fc0:	68 38 9e 10 c0       	push   $0xc0109e38
-c0106fc5:	68 82 9d 10 c0       	push   $0xc0109d82
-c0106fca:	68 e5 00 00 00       	push   $0xe5
-c0106fcf:	68 97 9d 10 c0       	push   $0xc0109d97
-c0106fd4:	e8 0f 94 ff ff       	call   c01003e8 <__panic>
+c0107516:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c010751d:	e8 4b be ff ff       	call   c010336d <alloc_pages>
+c0107522:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0107525:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0107529:	75 24                	jne    c010754f <basic_check+0x3c7>
+c010752b:	c7 44 24 0c 68 a5 10 	movl   $0xc010a568,0xc(%esp)
+c0107532:	c0 
+c0107533:	c7 44 24 08 b2 a4 10 	movl   $0xc010a4b2,0x8(%esp)
+c010753a:	c0 
+c010753b:	c7 44 24 04 e4 00 00 	movl   $0xe4,0x4(%esp)
+c0107542:	00 
+c0107543:	c7 04 24 c7 a4 10 c0 	movl   $0xc010a4c7,(%esp)
+c010754a:	e8 a9 8e ff ff       	call   c01003f8 <__panic>
 
     assert(alloc_page() == NULL);
-c0106fd9:	83 ec 0c             	sub    $0xc,%esp
-c0106fdc:	6a 01                	push   $0x1
-c0106fde:	e8 31 c5 ff ff       	call   c0103514 <alloc_pages>
-c0106fe3:	83 c4 10             	add    $0x10,%esp
-c0106fe6:	85 c0                	test   %eax,%eax
-c0106fe8:	74 19                	je     c0107003 <basic_check+0x36a>
-c0106fea:	68 22 9f 10 c0       	push   $0xc0109f22
-c0106fef:	68 82 9d 10 c0       	push   $0xc0109d82
-c0106ff4:	68 e7 00 00 00       	push   $0xe7
-c0106ff9:	68 97 9d 10 c0       	push   $0xc0109d97
-c0106ffe:	e8 e5 93 ff ff       	call   c01003e8 <__panic>
+c010754f:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c0107556:	e8 12 be ff ff       	call   c010336d <alloc_pages>
+c010755b:	85 c0                	test   %eax,%eax
+c010755d:	74 24                	je     c0107583 <basic_check+0x3fb>
+c010755f:	c7 44 24 0c 52 a6 10 	movl   $0xc010a652,0xc(%esp)
+c0107566:	c0 
+c0107567:	c7 44 24 08 b2 a4 10 	movl   $0xc010a4b2,0x8(%esp)
+c010756e:	c0 
+c010756f:	c7 44 24 04 e6 00 00 	movl   $0xe6,0x4(%esp)
+c0107576:	00 
+c0107577:	c7 04 24 c7 a4 10 c0 	movl   $0xc010a4c7,(%esp)
+c010757e:	e8 75 8e ff ff       	call   c01003f8 <__panic>
 
     free_page(p0);
-c0107003:	83 ec 08             	sub    $0x8,%esp
-c0107006:	6a 01                	push   $0x1
-c0107008:	ff 75 ec             	pushl  -0x14(%ebp)
-c010700b:	e8 70 c5 ff ff       	call   c0103580 <free_pages>
-c0107010:	83 c4 10             	add    $0x10,%esp
-c0107013:	c7 45 e8 0c 31 12 c0 	movl   $0xc012310c,-0x18(%ebp)
-c010701a:	8b 45 e8             	mov    -0x18(%ebp),%eax
-c010701d:	8b 40 04             	mov    0x4(%eax),%eax
-c0107020:	39 45 e8             	cmp    %eax,-0x18(%ebp)
-c0107023:	0f 94 c0             	sete   %al
-c0107026:	0f b6 c0             	movzbl %al,%eax
+c0107583:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+c010758a:	00 
+c010758b:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c010758e:	89 04 24             	mov    %eax,(%esp)
+c0107591:	e8 42 be ff ff       	call   c01033d8 <free_pages>
+c0107596:	c7 45 e8 0c 41 12 c0 	movl   $0xc012410c,-0x18(%ebp)
+c010759d:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c01075a0:	8b 40 04             	mov    0x4(%eax),%eax
+c01075a3:	39 45 e8             	cmp    %eax,-0x18(%ebp)
+c01075a6:	0f 94 c0             	sete   %al
+c01075a9:	0f b6 c0             	movzbl %al,%eax
     assert(!list_empty(&free_list));
-c0107029:	85 c0                	test   %eax,%eax
-c010702b:	74 19                	je     c0107046 <basic_check+0x3ad>
-c010702d:	68 44 9f 10 c0       	push   $0xc0109f44
-c0107032:	68 82 9d 10 c0       	push   $0xc0109d82
-c0107037:	68 ea 00 00 00       	push   $0xea
-c010703c:	68 97 9d 10 c0       	push   $0xc0109d97
-c0107041:	e8 a2 93 ff ff       	call   c01003e8 <__panic>
+c01075ac:	85 c0                	test   %eax,%eax
+c01075ae:	74 24                	je     c01075d4 <basic_check+0x44c>
+c01075b0:	c7 44 24 0c 74 a6 10 	movl   $0xc010a674,0xc(%esp)
+c01075b7:	c0 
+c01075b8:	c7 44 24 08 b2 a4 10 	movl   $0xc010a4b2,0x8(%esp)
+c01075bf:	c0 
+c01075c0:	c7 44 24 04 e9 00 00 	movl   $0xe9,0x4(%esp)
+c01075c7:	00 
+c01075c8:	c7 04 24 c7 a4 10 c0 	movl   $0xc010a4c7,(%esp)
+c01075cf:	e8 24 8e ff ff       	call   c01003f8 <__panic>
 
     struct Page *p;
     assert((p = alloc_page()) == p0);
-c0107046:	83 ec 0c             	sub    $0xc,%esp
-c0107049:	6a 01                	push   $0x1
-c010704b:	e8 c4 c4 ff ff       	call   c0103514 <alloc_pages>
-c0107050:	83 c4 10             	add    $0x10,%esp
-c0107053:	89 45 dc             	mov    %eax,-0x24(%ebp)
-c0107056:	8b 45 dc             	mov    -0x24(%ebp),%eax
-c0107059:	3b 45 ec             	cmp    -0x14(%ebp),%eax
-c010705c:	74 19                	je     c0107077 <basic_check+0x3de>
-c010705e:	68 5c 9f 10 c0       	push   $0xc0109f5c
-c0107063:	68 82 9d 10 c0       	push   $0xc0109d82
-c0107068:	68 ed 00 00 00       	push   $0xed
-c010706d:	68 97 9d 10 c0       	push   $0xc0109d97
-c0107072:	e8 71 93 ff ff       	call   c01003e8 <__panic>
+c01075d4:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c01075db:	e8 8d bd ff ff       	call   c010336d <alloc_pages>
+c01075e0:	89 45 dc             	mov    %eax,-0x24(%ebp)
+c01075e3:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c01075e6:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+c01075e9:	74 24                	je     c010760f <basic_check+0x487>
+c01075eb:	c7 44 24 0c 8c a6 10 	movl   $0xc010a68c,0xc(%esp)
+c01075f2:	c0 
+c01075f3:	c7 44 24 08 b2 a4 10 	movl   $0xc010a4b2,0x8(%esp)
+c01075fa:	c0 
+c01075fb:	c7 44 24 04 ec 00 00 	movl   $0xec,0x4(%esp)
+c0107602:	00 
+c0107603:	c7 04 24 c7 a4 10 c0 	movl   $0xc010a4c7,(%esp)
+c010760a:	e8 e9 8d ff ff       	call   c01003f8 <__panic>
     assert(alloc_page() == NULL);
-c0107077:	83 ec 0c             	sub    $0xc,%esp
-c010707a:	6a 01                	push   $0x1
-c010707c:	e8 93 c4 ff ff       	call   c0103514 <alloc_pages>
-c0107081:	83 c4 10             	add    $0x10,%esp
-c0107084:	85 c0                	test   %eax,%eax
-c0107086:	74 19                	je     c01070a1 <basic_check+0x408>
-c0107088:	68 22 9f 10 c0       	push   $0xc0109f22
-c010708d:	68 82 9d 10 c0       	push   $0xc0109d82
-c0107092:	68 ee 00 00 00       	push   $0xee
-c0107097:	68 97 9d 10 c0       	push   $0xc0109d97
-c010709c:	e8 47 93 ff ff       	call   c01003e8 <__panic>
+c010760f:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c0107616:	e8 52 bd ff ff       	call   c010336d <alloc_pages>
+c010761b:	85 c0                	test   %eax,%eax
+c010761d:	74 24                	je     c0107643 <basic_check+0x4bb>
+c010761f:	c7 44 24 0c 52 a6 10 	movl   $0xc010a652,0xc(%esp)
+c0107626:	c0 
+c0107627:	c7 44 24 08 b2 a4 10 	movl   $0xc010a4b2,0x8(%esp)
+c010762e:	c0 
+c010762f:	c7 44 24 04 ed 00 00 	movl   $0xed,0x4(%esp)
+c0107636:	00 
+c0107637:	c7 04 24 c7 a4 10 c0 	movl   $0xc010a4c7,(%esp)
+c010763e:	e8 b5 8d ff ff       	call   c01003f8 <__panic>
 
     assert(nr_free == 0);
-c01070a1:	a1 14 31 12 c0       	mov    0xc0123114,%eax
-c01070a6:	85 c0                	test   %eax,%eax
-c01070a8:	74 19                	je     c01070c3 <basic_check+0x42a>
-c01070aa:	68 75 9f 10 c0       	push   $0xc0109f75
-c01070af:	68 82 9d 10 c0       	push   $0xc0109d82
-c01070b4:	68 f0 00 00 00       	push   $0xf0
-c01070b9:	68 97 9d 10 c0       	push   $0xc0109d97
-c01070be:	e8 25 93 ff ff       	call   c01003e8 <__panic>
+c0107643:	a1 14 41 12 c0       	mov    0xc0124114,%eax
+c0107648:	85 c0                	test   %eax,%eax
+c010764a:	74 24                	je     c0107670 <basic_check+0x4e8>
+c010764c:	c7 44 24 0c a5 a6 10 	movl   $0xc010a6a5,0xc(%esp)
+c0107653:	c0 
+c0107654:	c7 44 24 08 b2 a4 10 	movl   $0xc010a4b2,0x8(%esp)
+c010765b:	c0 
+c010765c:	c7 44 24 04 ef 00 00 	movl   $0xef,0x4(%esp)
+c0107663:	00 
+c0107664:	c7 04 24 c7 a4 10 c0 	movl   $0xc010a4c7,(%esp)
+c010766b:	e8 88 8d ff ff       	call   c01003f8 <__panic>
     free_list = free_list_store;
-c01070c3:	8b 45 d0             	mov    -0x30(%ebp),%eax
-c01070c6:	8b 55 d4             	mov    -0x2c(%ebp),%edx
-c01070c9:	a3 0c 31 12 c0       	mov    %eax,0xc012310c
-c01070ce:	89 15 10 31 12 c0    	mov    %edx,0xc0123110
+c0107670:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c0107673:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c0107676:	a3 0c 41 12 c0       	mov    %eax,0xc012410c
+c010767b:	89 15 10 41 12 c0    	mov    %edx,0xc0124110
     nr_free = nr_free_store;
-c01070d4:	8b 45 e0             	mov    -0x20(%ebp),%eax
-c01070d7:	a3 14 31 12 c0       	mov    %eax,0xc0123114
+c0107681:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0107684:	a3 14 41 12 c0       	mov    %eax,0xc0124114
 
     free_page(p);
-c01070dc:	83 ec 08             	sub    $0x8,%esp
-c01070df:	6a 01                	push   $0x1
-c01070e1:	ff 75 dc             	pushl  -0x24(%ebp)
-c01070e4:	e8 97 c4 ff ff       	call   c0103580 <free_pages>
-c01070e9:	83 c4 10             	add    $0x10,%esp
+c0107689:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+c0107690:	00 
+c0107691:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0107694:	89 04 24             	mov    %eax,(%esp)
+c0107697:	e8 3c bd ff ff       	call   c01033d8 <free_pages>
     free_page(p1);
-c01070ec:	83 ec 08             	sub    $0x8,%esp
-c01070ef:	6a 01                	push   $0x1
-c01070f1:	ff 75 f0             	pushl  -0x10(%ebp)
-c01070f4:	e8 87 c4 ff ff       	call   c0103580 <free_pages>
-c01070f9:	83 c4 10             	add    $0x10,%esp
+c010769c:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+c01076a3:	00 
+c01076a4:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01076a7:	89 04 24             	mov    %eax,(%esp)
+c01076aa:	e8 29 bd ff ff       	call   c01033d8 <free_pages>
     free_page(p2);
-c01070fc:	83 ec 08             	sub    $0x8,%esp
-c01070ff:	6a 01                	push   $0x1
-c0107101:	ff 75 f4             	pushl  -0xc(%ebp)
-c0107104:	e8 77 c4 ff ff       	call   c0103580 <free_pages>
-c0107109:	83 c4 10             	add    $0x10,%esp
-}
-c010710c:	90                   	nop
-c010710d:	c9                   	leave  
-c010710e:	c3                   	ret    
+c01076af:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+c01076b6:	00 
+c01076b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01076ba:	89 04 24             	mov    %eax,(%esp)
+c01076bd:	e8 16 bd ff ff       	call   c01033d8 <free_pages>
+}
+c01076c2:	90                   	nop
+c01076c3:	c9                   	leave  
+c01076c4:	c3                   	ret    
 
-c010710f <default_check>:
+c01076c5 <default_check>:
 
 // LAB2: below code is used to check the first fit allocation algorithm (your EXERCISE 1) 
 // NOTICE: You SHOULD NOT CHANGE basic_check, default_check functions!
 static void
 default_check(void) {
-c010710f:	55                   	push   %ebp
-c0107110:	89 e5                	mov    %esp,%ebp
-c0107112:	81 ec 88 00 00 00    	sub    $0x88,%esp
+c01076c5:	55                   	push   %ebp
+c01076c6:	89 e5                	mov    %esp,%ebp
+c01076c8:	81 ec 98 00 00 00    	sub    $0x98,%esp
     int count = 0, total = 0;
-c0107118:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
-c010711f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+c01076ce:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+c01076d5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
     list_entry_t *le = &free_list;
-c0107126:	c7 45 ec 0c 31 12 c0 	movl   $0xc012310c,-0x14(%ebp)
+c01076dc:	c7 45 ec 0c 41 12 c0 	movl   $0xc012410c,-0x14(%ebp)
     while ((le = list_next(le)) != &free_list) {
-c010712d:	eb 60                	jmp    c010718f <default_check+0x80>
+c01076e3:	eb 6a                	jmp    c010774f <default_check+0x8a>
         struct Page *p = le2page(le, page_link);
-c010712f:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c0107132:	83 e8 0c             	sub    $0xc,%eax
-c0107135:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+c01076e5:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c01076e8:	83 e8 0c             	sub    $0xc,%eax
+c01076eb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
         assert(PageProperty(p));
-c0107138:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-c010713b:	83 c0 04             	add    $0x4,%eax
-c010713e:	c7 45 b0 01 00 00 00 	movl   $0x1,-0x50(%ebp)
-c0107145:	89 45 ac             	mov    %eax,-0x54(%ebp)
+c01076ee:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c01076f1:	83 c0 04             	add    $0x4,%eax
+c01076f4:	c7 45 b0 01 00 00 00 	movl   $0x1,-0x50(%ebp)
+c01076fb:	89 45 ac             	mov    %eax,-0x54(%ebp)
  * @addr:   the address to count from
  * */
 static inline bool
 test_bit(int nr, volatile void *addr) {
     int oldbit;
     asm volatile ("btl %2, %1; sbbl %0,%0" : "=r" (oldbit) : "m" (*(volatile long *)addr), "Ir" (nr));
-c0107148:	8b 45 ac             	mov    -0x54(%ebp),%eax
-c010714b:	8b 55 b0             	mov    -0x50(%ebp),%edx
-c010714e:	0f a3 10             	bt     %edx,(%eax)
-c0107151:	19 c0                	sbb    %eax,%eax
-c0107153:	89 45 a8             	mov    %eax,-0x58(%ebp)
+c01076fe:	8b 45 ac             	mov    -0x54(%ebp),%eax
+c0107701:	8b 55 b0             	mov    -0x50(%ebp),%edx
+c0107704:	0f a3 10             	bt     %edx,(%eax)
+c0107707:	19 c0                	sbb    %eax,%eax
+c0107709:	89 45 a8             	mov    %eax,-0x58(%ebp)
     return oldbit != 0;
-c0107156:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
-c010715a:	0f 95 c0             	setne  %al
-c010715d:	0f b6 c0             	movzbl %al,%eax
-c0107160:	85 c0                	test   %eax,%eax
-c0107162:	75 19                	jne    c010717d <default_check+0x6e>
-c0107164:	68 82 9f 10 c0       	push   $0xc0109f82
-c0107169:	68 82 9d 10 c0       	push   $0xc0109d82
-c010716e:	68 01 01 00 00       	push   $0x101
-c0107173:	68 97 9d 10 c0       	push   $0xc0109d97
-c0107178:	e8 6b 92 ff ff       	call   c01003e8 <__panic>
+c010770c:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
+c0107710:	0f 95 c0             	setne  %al
+c0107713:	0f b6 c0             	movzbl %al,%eax
+c0107716:	85 c0                	test   %eax,%eax
+c0107718:	75 24                	jne    c010773e <default_check+0x79>
+c010771a:	c7 44 24 0c b2 a6 10 	movl   $0xc010a6b2,0xc(%esp)
+c0107721:	c0 
+c0107722:	c7 44 24 08 b2 a4 10 	movl   $0xc010a4b2,0x8(%esp)
+c0107729:	c0 
+c010772a:	c7 44 24 04 00 01 00 	movl   $0x100,0x4(%esp)
+c0107731:	00 
+c0107732:	c7 04 24 c7 a4 10 c0 	movl   $0xc010a4c7,(%esp)
+c0107739:	e8 ba 8c ff ff       	call   c01003f8 <__panic>
         count ++, total += p->property;
-c010717d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
-c0107181:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-c0107184:	8b 50 08             	mov    0x8(%eax),%edx
-c0107187:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c010718a:	01 d0                	add    %edx,%eax
-c010718c:	89 45 f0             	mov    %eax,-0x10(%ebp)
-c010718f:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c0107192:	89 45 e0             	mov    %eax,-0x20(%ebp)
+c010773e:	ff 45 f4             	incl   -0xc(%ebp)
+c0107741:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0107744:	8b 50 08             	mov    0x8(%eax),%edx
+c0107747:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010774a:	01 d0                	add    %edx,%eax
+c010774c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c010774f:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0107752:	89 45 e0             	mov    %eax,-0x20(%ebp)
  * list_next - get the next entry
  * @listelm:    the list head
  **/
 static inline list_entry_t *
 list_next(list_entry_t *listelm) {
     return listelm->next;
-c0107195:	8b 45 e0             	mov    -0x20(%ebp),%eax
-c0107198:	8b 40 04             	mov    0x4(%eax),%eax
+c0107755:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0107758:	8b 40 04             	mov    0x4(%eax),%eax
 // NOTICE: You SHOULD NOT CHANGE basic_check, default_check functions!
 static void
 default_check(void) {
     int count = 0, total = 0;
     list_entry_t *le = &free_list;
     while ((le = list_next(le)) != &free_list) {
-c010719b:	89 45 ec             	mov    %eax,-0x14(%ebp)
-c010719e:	81 7d ec 0c 31 12 c0 	cmpl   $0xc012310c,-0x14(%ebp)
-c01071a5:	75 88                	jne    c010712f <default_check+0x20>
+c010775b:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c010775e:	81 7d ec 0c 41 12 c0 	cmpl   $0xc012410c,-0x14(%ebp)
+c0107765:	0f 85 7a ff ff ff    	jne    c01076e5 <default_check+0x20>
         struct Page *p = le2page(le, page_link);
         assert(PageProperty(p));
         count ++, total += p->property;
     }
     assert(total == nr_free_pages());
-c01071a7:	e8 09 c4 ff ff       	call   c01035b5 <nr_free_pages>
-c01071ac:	89 c2                	mov    %eax,%edx
-c01071ae:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c01071b1:	39 c2                	cmp    %eax,%edx
-c01071b3:	74 19                	je     c01071ce <default_check+0xbf>
-c01071b5:	68 92 9f 10 c0       	push   $0xc0109f92
-c01071ba:	68 82 9d 10 c0       	push   $0xc0109d82
-c01071bf:	68 04 01 00 00       	push   $0x104
-c01071c4:	68 97 9d 10 c0       	push   $0xc0109d97
-c01071c9:	e8 1a 92 ff ff       	call   c01003e8 <__panic>
+c010776b:	e8 9b bc ff ff       	call   c010340b <nr_free_pages>
+c0107770:	89 c2                	mov    %eax,%edx
+c0107772:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0107775:	39 c2                	cmp    %eax,%edx
+c0107777:	74 24                	je     c010779d <default_check+0xd8>
+c0107779:	c7 44 24 0c c2 a6 10 	movl   $0xc010a6c2,0xc(%esp)
+c0107780:	c0 
+c0107781:	c7 44 24 08 b2 a4 10 	movl   $0xc010a4b2,0x8(%esp)
+c0107788:	c0 
+c0107789:	c7 44 24 04 03 01 00 	movl   $0x103,0x4(%esp)
+c0107790:	00 
+c0107791:	c7 04 24 c7 a4 10 c0 	movl   $0xc010a4c7,(%esp)
+c0107798:	e8 5b 8c ff ff       	call   c01003f8 <__panic>
 
     basic_check();
-c01071ce:	e8 c6 fa ff ff       	call   c0106c99 <basic_check>
+c010779d:	e8 e6 f9 ff ff       	call   c0107188 <basic_check>
 
     struct Page *p0 = alloc_pages(5), *p1, *p2;
-c01071d3:	83 ec 0c             	sub    $0xc,%esp
-c01071d6:	6a 05                	push   $0x5
-c01071d8:	e8 37 c3 ff ff       	call   c0103514 <alloc_pages>
-c01071dd:	83 c4 10             	add    $0x10,%esp
-c01071e0:	89 45 dc             	mov    %eax,-0x24(%ebp)
+c01077a2:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
+c01077a9:	e8 bf bb ff ff       	call   c010336d <alloc_pages>
+c01077ae:	89 45 dc             	mov    %eax,-0x24(%ebp)
     assert(p0 != NULL);
-c01071e3:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
-c01071e7:	75 19                	jne    c0107202 <default_check+0xf3>
-c01071e9:	68 ab 9f 10 c0       	push   $0xc0109fab
-c01071ee:	68 82 9d 10 c0       	push   $0xc0109d82
-c01071f3:	68 09 01 00 00       	push   $0x109
-c01071f8:	68 97 9d 10 c0       	push   $0xc0109d97
-c01071fd:	e8 e6 91 ff ff       	call   c01003e8 <__panic>
+c01077b1:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+c01077b5:	75 24                	jne    c01077db <default_check+0x116>
+c01077b7:	c7 44 24 0c db a6 10 	movl   $0xc010a6db,0xc(%esp)
+c01077be:	c0 
+c01077bf:	c7 44 24 08 b2 a4 10 	movl   $0xc010a4b2,0x8(%esp)
+c01077c6:	c0 
+c01077c7:	c7 44 24 04 08 01 00 	movl   $0x108,0x4(%esp)
+c01077ce:	00 
+c01077cf:	c7 04 24 c7 a4 10 c0 	movl   $0xc010a4c7,(%esp)
+c01077d6:	e8 1d 8c ff ff       	call   c01003f8 <__panic>
     assert(!PageProperty(p0));
-c0107202:	8b 45 dc             	mov    -0x24(%ebp),%eax
-c0107205:	83 c0 04             	add    $0x4,%eax
-c0107208:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
-c010720f:	89 45 a4             	mov    %eax,-0x5c(%ebp)
+c01077db:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c01077de:	83 c0 04             	add    $0x4,%eax
+c01077e1:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
+c01077e8:	89 45 a4             	mov    %eax,-0x5c(%ebp)
  * @addr:   the address to count from
  * */
 static inline bool
 test_bit(int nr, volatile void *addr) {
     int oldbit;
     asm volatile ("btl %2, %1; sbbl %0,%0" : "=r" (oldbit) : "m" (*(volatile long *)addr), "Ir" (nr));
-c0107212:	8b 45 a4             	mov    -0x5c(%ebp),%eax
-c0107215:	8b 55 e8             	mov    -0x18(%ebp),%edx
-c0107218:	0f a3 10             	bt     %edx,(%eax)
-c010721b:	19 c0                	sbb    %eax,%eax
-c010721d:	89 45 a0             	mov    %eax,-0x60(%ebp)
+c01077eb:	8b 45 a4             	mov    -0x5c(%ebp),%eax
+c01077ee:	8b 55 e8             	mov    -0x18(%ebp),%edx
+c01077f1:	0f a3 10             	bt     %edx,(%eax)
+c01077f4:	19 c0                	sbb    %eax,%eax
+c01077f6:	89 45 a0             	mov    %eax,-0x60(%ebp)
     return oldbit != 0;
-c0107220:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
-c0107224:	0f 95 c0             	setne  %al
-c0107227:	0f b6 c0             	movzbl %al,%eax
-c010722a:	85 c0                	test   %eax,%eax
-c010722c:	74 19                	je     c0107247 <default_check+0x138>
-c010722e:	68 b6 9f 10 c0       	push   $0xc0109fb6
-c0107233:	68 82 9d 10 c0       	push   $0xc0109d82
-c0107238:	68 0a 01 00 00       	push   $0x10a
-c010723d:	68 97 9d 10 c0       	push   $0xc0109d97
-c0107242:	e8 a1 91 ff ff       	call   c01003e8 <__panic>
+c01077f9:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
+c01077fd:	0f 95 c0             	setne  %al
+c0107800:	0f b6 c0             	movzbl %al,%eax
+c0107803:	85 c0                	test   %eax,%eax
+c0107805:	74 24                	je     c010782b <default_check+0x166>
+c0107807:	c7 44 24 0c e6 a6 10 	movl   $0xc010a6e6,0xc(%esp)
+c010780e:	c0 
+c010780f:	c7 44 24 08 b2 a4 10 	movl   $0xc010a4b2,0x8(%esp)
+c0107816:	c0 
+c0107817:	c7 44 24 04 09 01 00 	movl   $0x109,0x4(%esp)
+c010781e:	00 
+c010781f:	c7 04 24 c7 a4 10 c0 	movl   $0xc010a4c7,(%esp)
+c0107826:	e8 cd 8b ff ff       	call   c01003f8 <__panic>
 
     list_entry_t free_list_store = free_list;
-c0107247:	a1 0c 31 12 c0       	mov    0xc012310c,%eax
-c010724c:	8b 15 10 31 12 c0    	mov    0xc0123110,%edx
-c0107252:	89 45 80             	mov    %eax,-0x80(%ebp)
-c0107255:	89 55 84             	mov    %edx,-0x7c(%ebp)
-c0107258:	c7 45 d0 0c 31 12 c0 	movl   $0xc012310c,-0x30(%ebp)
+c010782b:	a1 0c 41 12 c0       	mov    0xc012410c,%eax
+c0107830:	8b 15 10 41 12 c0    	mov    0xc0124110,%edx
+c0107836:	89 45 80             	mov    %eax,-0x80(%ebp)
+c0107839:	89 55 84             	mov    %edx,-0x7c(%ebp)
+c010783c:	c7 45 d0 0c 41 12 c0 	movl   $0xc012410c,-0x30(%ebp)
  * list_init - initialize a new entry
  * @elm:        new entry to be initialized
  * */
 static inline void
 list_init(list_entry_t *elm) {
     elm->prev = elm->next = elm;
-c010725f:	8b 45 d0             	mov    -0x30(%ebp),%eax
-c0107262:	8b 55 d0             	mov    -0x30(%ebp),%edx
-c0107265:	89 50 04             	mov    %edx,0x4(%eax)
-c0107268:	8b 45 d0             	mov    -0x30(%ebp),%eax
-c010726b:	8b 50 04             	mov    0x4(%eax),%edx
-c010726e:	8b 45 d0             	mov    -0x30(%ebp),%eax
-c0107271:	89 10                	mov    %edx,(%eax)
-c0107273:	c7 45 d8 0c 31 12 c0 	movl   $0xc012310c,-0x28(%ebp)
+c0107843:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c0107846:	8b 55 d0             	mov    -0x30(%ebp),%edx
+c0107849:	89 50 04             	mov    %edx,0x4(%eax)
+c010784c:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c010784f:	8b 50 04             	mov    0x4(%eax),%edx
+c0107852:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c0107855:	89 10                	mov    %edx,(%eax)
+c0107857:	c7 45 d8 0c 41 12 c0 	movl   $0xc012410c,-0x28(%ebp)
  * list_empty - tests whether a list is empty
  * @list:       the list to test.
  * */
 static inline bool
 list_empty(list_entry_t *list) {
     return list->next == list;
-c010727a:	8b 45 d8             	mov    -0x28(%ebp),%eax
-c010727d:	8b 40 04             	mov    0x4(%eax),%eax
-c0107280:	39 45 d8             	cmp    %eax,-0x28(%ebp)
-c0107283:	0f 94 c0             	sete   %al
-c0107286:	0f b6 c0             	movzbl %al,%eax
+c010785e:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c0107861:	8b 40 04             	mov    0x4(%eax),%eax
+c0107864:	39 45 d8             	cmp    %eax,-0x28(%ebp)
+c0107867:	0f 94 c0             	sete   %al
+c010786a:	0f b6 c0             	movzbl %al,%eax
     list_init(&free_list);
     assert(list_empty(&free_list));
-c0107289:	85 c0                	test   %eax,%eax
-c010728b:	75 19                	jne    c01072a6 <default_check+0x197>
-c010728d:	68 0b 9f 10 c0       	push   $0xc0109f0b
-c0107292:	68 82 9d 10 c0       	push   $0xc0109d82
-c0107297:	68 0e 01 00 00       	push   $0x10e
-c010729c:	68 97 9d 10 c0       	push   $0xc0109d97
-c01072a1:	e8 42 91 ff ff       	call   c01003e8 <__panic>
+c010786d:	85 c0                	test   %eax,%eax
+c010786f:	75 24                	jne    c0107895 <default_check+0x1d0>
+c0107871:	c7 44 24 0c 3b a6 10 	movl   $0xc010a63b,0xc(%esp)
+c0107878:	c0 
+c0107879:	c7 44 24 08 b2 a4 10 	movl   $0xc010a4b2,0x8(%esp)
+c0107880:	c0 
+c0107881:	c7 44 24 04 0d 01 00 	movl   $0x10d,0x4(%esp)
+c0107888:	00 
+c0107889:	c7 04 24 c7 a4 10 c0 	movl   $0xc010a4c7,(%esp)
+c0107890:	e8 63 8b ff ff       	call   c01003f8 <__panic>
     assert(alloc_page() == NULL);
-c01072a6:	83 ec 0c             	sub    $0xc,%esp
-c01072a9:	6a 01                	push   $0x1
-c01072ab:	e8 64 c2 ff ff       	call   c0103514 <alloc_pages>
-c01072b0:	83 c4 10             	add    $0x10,%esp
-c01072b3:	85 c0                	test   %eax,%eax
-c01072b5:	74 19                	je     c01072d0 <default_check+0x1c1>
-c01072b7:	68 22 9f 10 c0       	push   $0xc0109f22
-c01072bc:	68 82 9d 10 c0       	push   $0xc0109d82
-c01072c1:	68 0f 01 00 00       	push   $0x10f
-c01072c6:	68 97 9d 10 c0       	push   $0xc0109d97
-c01072cb:	e8 18 91 ff ff       	call   c01003e8 <__panic>
+c0107895:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c010789c:	e8 cc ba ff ff       	call   c010336d <alloc_pages>
+c01078a1:	85 c0                	test   %eax,%eax
+c01078a3:	74 24                	je     c01078c9 <default_check+0x204>
+c01078a5:	c7 44 24 0c 52 a6 10 	movl   $0xc010a652,0xc(%esp)
+c01078ac:	c0 
+c01078ad:	c7 44 24 08 b2 a4 10 	movl   $0xc010a4b2,0x8(%esp)
+c01078b4:	c0 
+c01078b5:	c7 44 24 04 0e 01 00 	movl   $0x10e,0x4(%esp)
+c01078bc:	00 
+c01078bd:	c7 04 24 c7 a4 10 c0 	movl   $0xc010a4c7,(%esp)
+c01078c4:	e8 2f 8b ff ff       	call   c01003f8 <__panic>
 
     unsigned int nr_free_store = nr_free;
-c01072d0:	a1 14 31 12 c0       	mov    0xc0123114,%eax
-c01072d5:	89 45 cc             	mov    %eax,-0x34(%ebp)
+c01078c9:	a1 14 41 12 c0       	mov    0xc0124114,%eax
+c01078ce:	89 45 cc             	mov    %eax,-0x34(%ebp)
     nr_free = 0;
-c01072d8:	c7 05 14 31 12 c0 00 	movl   $0x0,0xc0123114
-c01072df:	00 00 00 
+c01078d1:	c7 05 14 41 12 c0 00 	movl   $0x0,0xc0124114
+c01078d8:	00 00 00 
 
     free_pages(p0 + 2, 3);
-c01072e2:	8b 45 dc             	mov    -0x24(%ebp),%eax
-c01072e5:	83 c0 40             	add    $0x40,%eax
-c01072e8:	83 ec 08             	sub    $0x8,%esp
-c01072eb:	6a 03                	push   $0x3
-c01072ed:	50                   	push   %eax
-c01072ee:	e8 8d c2 ff ff       	call   c0103580 <free_pages>
-c01072f3:	83 c4 10             	add    $0x10,%esp
+c01078db:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c01078de:	83 c0 40             	add    $0x40,%eax
+c01078e1:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
+c01078e8:	00 
+c01078e9:	89 04 24             	mov    %eax,(%esp)
+c01078ec:	e8 e7 ba ff ff       	call   c01033d8 <free_pages>
     assert(alloc_pages(4) == NULL);
-c01072f6:	83 ec 0c             	sub    $0xc,%esp
-c01072f9:	6a 04                	push   $0x4
-c01072fb:	e8 14 c2 ff ff       	call   c0103514 <alloc_pages>
-c0107300:	83 c4 10             	add    $0x10,%esp
-c0107303:	85 c0                	test   %eax,%eax
-c0107305:	74 19                	je     c0107320 <default_check+0x211>
-c0107307:	68 c8 9f 10 c0       	push   $0xc0109fc8
-c010730c:	68 82 9d 10 c0       	push   $0xc0109d82
-c0107311:	68 15 01 00 00       	push   $0x115
-c0107316:	68 97 9d 10 c0       	push   $0xc0109d97
-c010731b:	e8 c8 90 ff ff       	call   c01003e8 <__panic>
+c01078f1:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
+c01078f8:	e8 70 ba ff ff       	call   c010336d <alloc_pages>
+c01078fd:	85 c0                	test   %eax,%eax
+c01078ff:	74 24                	je     c0107925 <default_check+0x260>
+c0107901:	c7 44 24 0c f8 a6 10 	movl   $0xc010a6f8,0xc(%esp)
+c0107908:	c0 
+c0107909:	c7 44 24 08 b2 a4 10 	movl   $0xc010a4b2,0x8(%esp)
+c0107910:	c0 
+c0107911:	c7 44 24 04 14 01 00 	movl   $0x114,0x4(%esp)
+c0107918:	00 
+c0107919:	c7 04 24 c7 a4 10 c0 	movl   $0xc010a4c7,(%esp)
+c0107920:	e8 d3 8a ff ff       	call   c01003f8 <__panic>
     assert(PageProperty(p0 + 2) && p0[2].property == 3);
-c0107320:	8b 45 dc             	mov    -0x24(%ebp),%eax
-c0107323:	83 c0 40             	add    $0x40,%eax
-c0107326:	83 c0 04             	add    $0x4,%eax
-c0107329:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
-c0107330:	89 45 9c             	mov    %eax,-0x64(%ebp)
+c0107925:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0107928:	83 c0 40             	add    $0x40,%eax
+c010792b:	83 c0 04             	add    $0x4,%eax
+c010792e:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
+c0107935:	89 45 9c             	mov    %eax,-0x64(%ebp)
  * @addr:   the address to count from
  * */
 static inline bool
 test_bit(int nr, volatile void *addr) {
     int oldbit;
     asm volatile ("btl %2, %1; sbbl %0,%0" : "=r" (oldbit) : "m" (*(volatile long *)addr), "Ir" (nr));
-c0107333:	8b 45 9c             	mov    -0x64(%ebp),%eax
-c0107336:	8b 55 d4             	mov    -0x2c(%ebp),%edx
-c0107339:	0f a3 10             	bt     %edx,(%eax)
-c010733c:	19 c0                	sbb    %eax,%eax
-c010733e:	89 45 98             	mov    %eax,-0x68(%ebp)
+c0107938:	8b 45 9c             	mov    -0x64(%ebp),%eax
+c010793b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c010793e:	0f a3 10             	bt     %edx,(%eax)
+c0107941:	19 c0                	sbb    %eax,%eax
+c0107943:	89 45 98             	mov    %eax,-0x68(%ebp)
     return oldbit != 0;
-c0107341:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
-c0107345:	0f 95 c0             	setne  %al
-c0107348:	0f b6 c0             	movzbl %al,%eax
-c010734b:	85 c0                	test   %eax,%eax
-c010734d:	74 0e                	je     c010735d <default_check+0x24e>
-c010734f:	8b 45 dc             	mov    -0x24(%ebp),%eax
-c0107352:	83 c0 40             	add    $0x40,%eax
-c0107355:	8b 40 08             	mov    0x8(%eax),%eax
-c0107358:	83 f8 03             	cmp    $0x3,%eax
-c010735b:	74 19                	je     c0107376 <default_check+0x267>
-c010735d:	68 e0 9f 10 c0       	push   $0xc0109fe0
-c0107362:	68 82 9d 10 c0       	push   $0xc0109d82
-c0107367:	68 16 01 00 00       	push   $0x116
-c010736c:	68 97 9d 10 c0       	push   $0xc0109d97
-c0107371:	e8 72 90 ff ff       	call   c01003e8 <__panic>
+c0107946:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
+c010794a:	0f 95 c0             	setne  %al
+c010794d:	0f b6 c0             	movzbl %al,%eax
+c0107950:	85 c0                	test   %eax,%eax
+c0107952:	74 0e                	je     c0107962 <default_check+0x29d>
+c0107954:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0107957:	83 c0 40             	add    $0x40,%eax
+c010795a:	8b 40 08             	mov    0x8(%eax),%eax
+c010795d:	83 f8 03             	cmp    $0x3,%eax
+c0107960:	74 24                	je     c0107986 <default_check+0x2c1>
+c0107962:	c7 44 24 0c 10 a7 10 	movl   $0xc010a710,0xc(%esp)
+c0107969:	c0 
+c010796a:	c7 44 24 08 b2 a4 10 	movl   $0xc010a4b2,0x8(%esp)
+c0107971:	c0 
+c0107972:	c7 44 24 04 15 01 00 	movl   $0x115,0x4(%esp)
+c0107979:	00 
+c010797a:	c7 04 24 c7 a4 10 c0 	movl   $0xc010a4c7,(%esp)
+c0107981:	e8 72 8a ff ff       	call   c01003f8 <__panic>
     assert((p1 = alloc_pages(3)) != NULL);
-c0107376:	83 ec 0c             	sub    $0xc,%esp
-c0107379:	6a 03                	push   $0x3
-c010737b:	e8 94 c1 ff ff       	call   c0103514 <alloc_pages>
-c0107380:	83 c4 10             	add    $0x10,%esp
-c0107383:	89 45 c4             	mov    %eax,-0x3c(%ebp)
-c0107386:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
-c010738a:	75 19                	jne    c01073a5 <default_check+0x296>
-c010738c:	68 0c a0 10 c0       	push   $0xc010a00c
-c0107391:	68 82 9d 10 c0       	push   $0xc0109d82
-c0107396:	68 17 01 00 00       	push   $0x117
-c010739b:	68 97 9d 10 c0       	push   $0xc0109d97
-c01073a0:	e8 43 90 ff ff       	call   c01003e8 <__panic>
+c0107986:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
+c010798d:	e8 db b9 ff ff       	call   c010336d <alloc_pages>
+c0107992:	89 45 c4             	mov    %eax,-0x3c(%ebp)
+c0107995:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
+c0107999:	75 24                	jne    c01079bf <default_check+0x2fa>
+c010799b:	c7 44 24 0c 3c a7 10 	movl   $0xc010a73c,0xc(%esp)
+c01079a2:	c0 
+c01079a3:	c7 44 24 08 b2 a4 10 	movl   $0xc010a4b2,0x8(%esp)
+c01079aa:	c0 
+c01079ab:	c7 44 24 04 16 01 00 	movl   $0x116,0x4(%esp)
+c01079b2:	00 
+c01079b3:	c7 04 24 c7 a4 10 c0 	movl   $0xc010a4c7,(%esp)
+c01079ba:	e8 39 8a ff ff       	call   c01003f8 <__panic>
     assert(alloc_page() == NULL);
-c01073a5:	83 ec 0c             	sub    $0xc,%esp
-c01073a8:	6a 01                	push   $0x1
-c01073aa:	e8 65 c1 ff ff       	call   c0103514 <alloc_pages>
-c01073af:	83 c4 10             	add    $0x10,%esp
-c01073b2:	85 c0                	test   %eax,%eax
-c01073b4:	74 19                	je     c01073cf <default_check+0x2c0>
-c01073b6:	68 22 9f 10 c0       	push   $0xc0109f22
-c01073bb:	68 82 9d 10 c0       	push   $0xc0109d82
-c01073c0:	68 18 01 00 00       	push   $0x118
-c01073c5:	68 97 9d 10 c0       	push   $0xc0109d97
-c01073ca:	e8 19 90 ff ff       	call   c01003e8 <__panic>
+c01079bf:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c01079c6:	e8 a2 b9 ff ff       	call   c010336d <alloc_pages>
+c01079cb:	85 c0                	test   %eax,%eax
+c01079cd:	74 24                	je     c01079f3 <default_check+0x32e>
+c01079cf:	c7 44 24 0c 52 a6 10 	movl   $0xc010a652,0xc(%esp)
+c01079d6:	c0 
+c01079d7:	c7 44 24 08 b2 a4 10 	movl   $0xc010a4b2,0x8(%esp)
+c01079de:	c0 
+c01079df:	c7 44 24 04 17 01 00 	movl   $0x117,0x4(%esp)
+c01079e6:	00 
+c01079e7:	c7 04 24 c7 a4 10 c0 	movl   $0xc010a4c7,(%esp)
+c01079ee:	e8 05 8a ff ff       	call   c01003f8 <__panic>
     assert(p0 + 2 == p1);
-c01073cf:	8b 45 dc             	mov    -0x24(%ebp),%eax
-c01073d2:	83 c0 40             	add    $0x40,%eax
-c01073d5:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
-c01073d8:	74 19                	je     c01073f3 <default_check+0x2e4>
-c01073da:	68 2a a0 10 c0       	push   $0xc010a02a
-c01073df:	68 82 9d 10 c0       	push   $0xc0109d82
-c01073e4:	68 19 01 00 00       	push   $0x119
-c01073e9:	68 97 9d 10 c0       	push   $0xc0109d97
-c01073ee:	e8 f5 8f ff ff       	call   c01003e8 <__panic>
+c01079f3:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c01079f6:	83 c0 40             	add    $0x40,%eax
+c01079f9:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
+c01079fc:	74 24                	je     c0107a22 <default_check+0x35d>
+c01079fe:	c7 44 24 0c 5a a7 10 	movl   $0xc010a75a,0xc(%esp)
+c0107a05:	c0 
+c0107a06:	c7 44 24 08 b2 a4 10 	movl   $0xc010a4b2,0x8(%esp)
+c0107a0d:	c0 
+c0107a0e:	c7 44 24 04 18 01 00 	movl   $0x118,0x4(%esp)
+c0107a15:	00 
+c0107a16:	c7 04 24 c7 a4 10 c0 	movl   $0xc010a4c7,(%esp)
+c0107a1d:	e8 d6 89 ff ff       	call   c01003f8 <__panic>
 
     p2 = p0 + 1;
-c01073f3:	8b 45 dc             	mov    -0x24(%ebp),%eax
-c01073f6:	83 c0 20             	add    $0x20,%eax
-c01073f9:	89 45 c0             	mov    %eax,-0x40(%ebp)
+c0107a22:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0107a25:	83 c0 20             	add    $0x20,%eax
+c0107a28:	89 45 c0             	mov    %eax,-0x40(%ebp)
     free_page(p0);
-c01073fc:	83 ec 08             	sub    $0x8,%esp
-c01073ff:	6a 01                	push   $0x1
-c0107401:	ff 75 dc             	pushl  -0x24(%ebp)
-c0107404:	e8 77 c1 ff ff       	call   c0103580 <free_pages>
-c0107409:	83 c4 10             	add    $0x10,%esp
+c0107a2b:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+c0107a32:	00 
+c0107a33:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0107a36:	89 04 24             	mov    %eax,(%esp)
+c0107a39:	e8 9a b9 ff ff       	call   c01033d8 <free_pages>
     free_pages(p1, 3);
-c010740c:	83 ec 08             	sub    $0x8,%esp
-c010740f:	6a 03                	push   $0x3
-c0107411:	ff 75 c4             	pushl  -0x3c(%ebp)
-c0107414:	e8 67 c1 ff ff       	call   c0103580 <free_pages>
-c0107419:	83 c4 10             	add    $0x10,%esp
+c0107a3e:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
+c0107a45:	00 
+c0107a46:	8b 45 c4             	mov    -0x3c(%ebp),%eax
+c0107a49:	89 04 24             	mov    %eax,(%esp)
+c0107a4c:	e8 87 b9 ff ff       	call   c01033d8 <free_pages>
     assert(PageProperty(p0) && p0->property == 1);
-c010741c:	8b 45 dc             	mov    -0x24(%ebp),%eax
-c010741f:	83 c0 04             	add    $0x4,%eax
-c0107422:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
-c0107429:	89 45 94             	mov    %eax,-0x6c(%ebp)
+c0107a51:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0107a54:	83 c0 04             	add    $0x4,%eax
+c0107a57:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
+c0107a5e:	89 45 94             	mov    %eax,-0x6c(%ebp)
  * @addr:   the address to count from
  * */
 static inline bool
 test_bit(int nr, volatile void *addr) {
     int oldbit;
     asm volatile ("btl %2, %1; sbbl %0,%0" : "=r" (oldbit) : "m" (*(volatile long *)addr), "Ir" (nr));
-c010742c:	8b 45 94             	mov    -0x6c(%ebp),%eax
-c010742f:	8b 55 c8             	mov    -0x38(%ebp),%edx
-c0107432:	0f a3 10             	bt     %edx,(%eax)
-c0107435:	19 c0                	sbb    %eax,%eax
-c0107437:	89 45 90             	mov    %eax,-0x70(%ebp)
+c0107a61:	8b 45 94             	mov    -0x6c(%ebp),%eax
+c0107a64:	8b 55 c8             	mov    -0x38(%ebp),%edx
+c0107a67:	0f a3 10             	bt     %edx,(%eax)
+c0107a6a:	19 c0                	sbb    %eax,%eax
+c0107a6c:	89 45 90             	mov    %eax,-0x70(%ebp)
     return oldbit != 0;
-c010743a:	83 7d 90 00          	cmpl   $0x0,-0x70(%ebp)
-c010743e:	0f 95 c0             	setne  %al
-c0107441:	0f b6 c0             	movzbl %al,%eax
-c0107444:	85 c0                	test   %eax,%eax
-c0107446:	74 0b                	je     c0107453 <default_check+0x344>
-c0107448:	8b 45 dc             	mov    -0x24(%ebp),%eax
-c010744b:	8b 40 08             	mov    0x8(%eax),%eax
-c010744e:	83 f8 01             	cmp    $0x1,%eax
-c0107451:	74 19                	je     c010746c <default_check+0x35d>
-c0107453:	68 38 a0 10 c0       	push   $0xc010a038
-c0107458:	68 82 9d 10 c0       	push   $0xc0109d82
-c010745d:	68 1e 01 00 00       	push   $0x11e
-c0107462:	68 97 9d 10 c0       	push   $0xc0109d97
-c0107467:	e8 7c 8f ff ff       	call   c01003e8 <__panic>
+c0107a6f:	83 7d 90 00          	cmpl   $0x0,-0x70(%ebp)
+c0107a73:	0f 95 c0             	setne  %al
+c0107a76:	0f b6 c0             	movzbl %al,%eax
+c0107a79:	85 c0                	test   %eax,%eax
+c0107a7b:	74 0b                	je     c0107a88 <default_check+0x3c3>
+c0107a7d:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0107a80:	8b 40 08             	mov    0x8(%eax),%eax
+c0107a83:	83 f8 01             	cmp    $0x1,%eax
+c0107a86:	74 24                	je     c0107aac <default_check+0x3e7>
+c0107a88:	c7 44 24 0c 68 a7 10 	movl   $0xc010a768,0xc(%esp)
+c0107a8f:	c0 
+c0107a90:	c7 44 24 08 b2 a4 10 	movl   $0xc010a4b2,0x8(%esp)
+c0107a97:	c0 
+c0107a98:	c7 44 24 04 1d 01 00 	movl   $0x11d,0x4(%esp)
+c0107a9f:	00 
+c0107aa0:	c7 04 24 c7 a4 10 c0 	movl   $0xc010a4c7,(%esp)
+c0107aa7:	e8 4c 89 ff ff       	call   c01003f8 <__panic>
     assert(PageProperty(p1) && p1->property == 3);
-c010746c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
-c010746f:	83 c0 04             	add    $0x4,%eax
-c0107472:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
-c0107479:	89 45 8c             	mov    %eax,-0x74(%ebp)
+c0107aac:	8b 45 c4             	mov    -0x3c(%ebp),%eax
+c0107aaf:	83 c0 04             	add    $0x4,%eax
+c0107ab2:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
+c0107ab9:	89 45 8c             	mov    %eax,-0x74(%ebp)
  * @addr:   the address to count from
  * */
 static inline bool
 test_bit(int nr, volatile void *addr) {
     int oldbit;
     asm volatile ("btl %2, %1; sbbl %0,%0" : "=r" (oldbit) : "m" (*(volatile long *)addr), "Ir" (nr));
-c010747c:	8b 45 8c             	mov    -0x74(%ebp),%eax
-c010747f:	8b 55 bc             	mov    -0x44(%ebp),%edx
-c0107482:	0f a3 10             	bt     %edx,(%eax)
-c0107485:	19 c0                	sbb    %eax,%eax
-c0107487:	89 45 88             	mov    %eax,-0x78(%ebp)
+c0107abc:	8b 45 8c             	mov    -0x74(%ebp),%eax
+c0107abf:	8b 55 bc             	mov    -0x44(%ebp),%edx
+c0107ac2:	0f a3 10             	bt     %edx,(%eax)
+c0107ac5:	19 c0                	sbb    %eax,%eax
+c0107ac7:	89 45 88             	mov    %eax,-0x78(%ebp)
     return oldbit != 0;
-c010748a:	83 7d 88 00          	cmpl   $0x0,-0x78(%ebp)
-c010748e:	0f 95 c0             	setne  %al
-c0107491:	0f b6 c0             	movzbl %al,%eax
-c0107494:	85 c0                	test   %eax,%eax
-c0107496:	74 0b                	je     c01074a3 <default_check+0x394>
-c0107498:	8b 45 c4             	mov    -0x3c(%ebp),%eax
-c010749b:	8b 40 08             	mov    0x8(%eax),%eax
-c010749e:	83 f8 03             	cmp    $0x3,%eax
-c01074a1:	74 19                	je     c01074bc <default_check+0x3ad>
-c01074a3:	68 60 a0 10 c0       	push   $0xc010a060
-c01074a8:	68 82 9d 10 c0       	push   $0xc0109d82
-c01074ad:	68 1f 01 00 00       	push   $0x11f
-c01074b2:	68 97 9d 10 c0       	push   $0xc0109d97
-c01074b7:	e8 2c 8f ff ff       	call   c01003e8 <__panic>
+c0107aca:	83 7d 88 00          	cmpl   $0x0,-0x78(%ebp)
+c0107ace:	0f 95 c0             	setne  %al
+c0107ad1:	0f b6 c0             	movzbl %al,%eax
+c0107ad4:	85 c0                	test   %eax,%eax
+c0107ad6:	74 0b                	je     c0107ae3 <default_check+0x41e>
+c0107ad8:	8b 45 c4             	mov    -0x3c(%ebp),%eax
+c0107adb:	8b 40 08             	mov    0x8(%eax),%eax
+c0107ade:	83 f8 03             	cmp    $0x3,%eax
+c0107ae1:	74 24                	je     c0107b07 <default_check+0x442>
+c0107ae3:	c7 44 24 0c 90 a7 10 	movl   $0xc010a790,0xc(%esp)
+c0107aea:	c0 
+c0107aeb:	c7 44 24 08 b2 a4 10 	movl   $0xc010a4b2,0x8(%esp)
+c0107af2:	c0 
+c0107af3:	c7 44 24 04 1e 01 00 	movl   $0x11e,0x4(%esp)
+c0107afa:	00 
+c0107afb:	c7 04 24 c7 a4 10 c0 	movl   $0xc010a4c7,(%esp)
+c0107b02:	e8 f1 88 ff ff       	call   c01003f8 <__panic>
 
     assert((p0 = alloc_page()) == p2 - 1);
-c01074bc:	83 ec 0c             	sub    $0xc,%esp
-c01074bf:	6a 01                	push   $0x1
-c01074c1:	e8 4e c0 ff ff       	call   c0103514 <alloc_pages>
-c01074c6:	83 c4 10             	add    $0x10,%esp
-c01074c9:	89 45 dc             	mov    %eax,-0x24(%ebp)
-c01074cc:	8b 45 c0             	mov    -0x40(%ebp),%eax
-c01074cf:	83 e8 20             	sub    $0x20,%eax
-c01074d2:	39 45 dc             	cmp    %eax,-0x24(%ebp)
-c01074d5:	74 19                	je     c01074f0 <default_check+0x3e1>
-c01074d7:	68 86 a0 10 c0       	push   $0xc010a086
-c01074dc:	68 82 9d 10 c0       	push   $0xc0109d82
-c01074e1:	68 21 01 00 00       	push   $0x121
-c01074e6:	68 97 9d 10 c0       	push   $0xc0109d97
-c01074eb:	e8 f8 8e ff ff       	call   c01003e8 <__panic>
+c0107b07:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c0107b0e:	e8 5a b8 ff ff       	call   c010336d <alloc_pages>
+c0107b13:	89 45 dc             	mov    %eax,-0x24(%ebp)
+c0107b16:	8b 45 c0             	mov    -0x40(%ebp),%eax
+c0107b19:	83 e8 20             	sub    $0x20,%eax
+c0107b1c:	39 45 dc             	cmp    %eax,-0x24(%ebp)
+c0107b1f:	74 24                	je     c0107b45 <default_check+0x480>
+c0107b21:	c7 44 24 0c b6 a7 10 	movl   $0xc010a7b6,0xc(%esp)
+c0107b28:	c0 
+c0107b29:	c7 44 24 08 b2 a4 10 	movl   $0xc010a4b2,0x8(%esp)
+c0107b30:	c0 
+c0107b31:	c7 44 24 04 20 01 00 	movl   $0x120,0x4(%esp)
+c0107b38:	00 
+c0107b39:	c7 04 24 c7 a4 10 c0 	movl   $0xc010a4c7,(%esp)
+c0107b40:	e8 b3 88 ff ff       	call   c01003f8 <__panic>
     free_page(p0);
-c01074f0:	83 ec 08             	sub    $0x8,%esp
-c01074f3:	6a 01                	push   $0x1
-c01074f5:	ff 75 dc             	pushl  -0x24(%ebp)
-c01074f8:	e8 83 c0 ff ff       	call   c0103580 <free_pages>
-c01074fd:	83 c4 10             	add    $0x10,%esp
+c0107b45:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+c0107b4c:	00 
+c0107b4d:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0107b50:	89 04 24             	mov    %eax,(%esp)
+c0107b53:	e8 80 b8 ff ff       	call   c01033d8 <free_pages>
     assert((p0 = alloc_pages(2)) == p2 + 1);
-c0107500:	83 ec 0c             	sub    $0xc,%esp
-c0107503:	6a 02                	push   $0x2
-c0107505:	e8 0a c0 ff ff       	call   c0103514 <alloc_pages>
-c010750a:	83 c4 10             	add    $0x10,%esp
-c010750d:	89 45 dc             	mov    %eax,-0x24(%ebp)
-c0107510:	8b 45 c0             	mov    -0x40(%ebp),%eax
-c0107513:	83 c0 20             	add    $0x20,%eax
-c0107516:	39 45 dc             	cmp    %eax,-0x24(%ebp)
-c0107519:	74 19                	je     c0107534 <default_check+0x425>
-c010751b:	68 a4 a0 10 c0       	push   $0xc010a0a4
-c0107520:	68 82 9d 10 c0       	push   $0xc0109d82
-c0107525:	68 23 01 00 00       	push   $0x123
-c010752a:	68 97 9d 10 c0       	push   $0xc0109d97
-c010752f:	e8 b4 8e ff ff       	call   c01003e8 <__panic>
+c0107b58:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
+c0107b5f:	e8 09 b8 ff ff       	call   c010336d <alloc_pages>
+c0107b64:	89 45 dc             	mov    %eax,-0x24(%ebp)
+c0107b67:	8b 45 c0             	mov    -0x40(%ebp),%eax
+c0107b6a:	83 c0 20             	add    $0x20,%eax
+c0107b6d:	39 45 dc             	cmp    %eax,-0x24(%ebp)
+c0107b70:	74 24                	je     c0107b96 <default_check+0x4d1>
+c0107b72:	c7 44 24 0c d4 a7 10 	movl   $0xc010a7d4,0xc(%esp)
+c0107b79:	c0 
+c0107b7a:	c7 44 24 08 b2 a4 10 	movl   $0xc010a4b2,0x8(%esp)
+c0107b81:	c0 
+c0107b82:	c7 44 24 04 22 01 00 	movl   $0x122,0x4(%esp)
+c0107b89:	00 
+c0107b8a:	c7 04 24 c7 a4 10 c0 	movl   $0xc010a4c7,(%esp)
+c0107b91:	e8 62 88 ff ff       	call   c01003f8 <__panic>
 
     free_pages(p0, 2);
-c0107534:	83 ec 08             	sub    $0x8,%esp
-c0107537:	6a 02                	push   $0x2
-c0107539:	ff 75 dc             	pushl  -0x24(%ebp)
-c010753c:	e8 3f c0 ff ff       	call   c0103580 <free_pages>
-c0107541:	83 c4 10             	add    $0x10,%esp
+c0107b96:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
+c0107b9d:	00 
+c0107b9e:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0107ba1:	89 04 24             	mov    %eax,(%esp)
+c0107ba4:	e8 2f b8 ff ff       	call   c01033d8 <free_pages>
     free_page(p2);
-c0107544:	83 ec 08             	sub    $0x8,%esp
-c0107547:	6a 01                	push   $0x1
-c0107549:	ff 75 c0             	pushl  -0x40(%ebp)
-c010754c:	e8 2f c0 ff ff       	call   c0103580 <free_pages>
-c0107551:	83 c4 10             	add    $0x10,%esp
+c0107ba9:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
+c0107bb0:	00 
+c0107bb1:	8b 45 c0             	mov    -0x40(%ebp),%eax
+c0107bb4:	89 04 24             	mov    %eax,(%esp)
+c0107bb7:	e8 1c b8 ff ff       	call   c01033d8 <free_pages>
 
     assert((p0 = alloc_pages(5)) != NULL);
-c0107554:	83 ec 0c             	sub    $0xc,%esp
-c0107557:	6a 05                	push   $0x5
-c0107559:	e8 b6 bf ff ff       	call   c0103514 <alloc_pages>
-c010755e:	83 c4 10             	add    $0x10,%esp
-c0107561:	89 45 dc             	mov    %eax,-0x24(%ebp)
-c0107564:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
-c0107568:	75 19                	jne    c0107583 <default_check+0x474>
-c010756a:	68 c4 a0 10 c0       	push   $0xc010a0c4
-c010756f:	68 82 9d 10 c0       	push   $0xc0109d82
-c0107574:	68 28 01 00 00       	push   $0x128
-c0107579:	68 97 9d 10 c0       	push   $0xc0109d97
-c010757e:	e8 65 8e ff ff       	call   c01003e8 <__panic>
+c0107bbc:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
+c0107bc3:	e8 a5 b7 ff ff       	call   c010336d <alloc_pages>
+c0107bc8:	89 45 dc             	mov    %eax,-0x24(%ebp)
+c0107bcb:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+c0107bcf:	75 24                	jne    c0107bf5 <default_check+0x530>
+c0107bd1:	c7 44 24 0c f4 a7 10 	movl   $0xc010a7f4,0xc(%esp)
+c0107bd8:	c0 
+c0107bd9:	c7 44 24 08 b2 a4 10 	movl   $0xc010a4b2,0x8(%esp)
+c0107be0:	c0 
+c0107be1:	c7 44 24 04 27 01 00 	movl   $0x127,0x4(%esp)
+c0107be8:	00 
+c0107be9:	c7 04 24 c7 a4 10 c0 	movl   $0xc010a4c7,(%esp)
+c0107bf0:	e8 03 88 ff ff       	call   c01003f8 <__panic>
     assert(alloc_page() == NULL);
-c0107583:	83 ec 0c             	sub    $0xc,%esp
-c0107586:	6a 01                	push   $0x1
-c0107588:	e8 87 bf ff ff       	call   c0103514 <alloc_pages>
-c010758d:	83 c4 10             	add    $0x10,%esp
-c0107590:	85 c0                	test   %eax,%eax
-c0107592:	74 19                	je     c01075ad <default_check+0x49e>
-c0107594:	68 22 9f 10 c0       	push   $0xc0109f22
-c0107599:	68 82 9d 10 c0       	push   $0xc0109d82
-c010759e:	68 29 01 00 00       	push   $0x129
-c01075a3:	68 97 9d 10 c0       	push   $0xc0109d97
-c01075a8:	e8 3b 8e ff ff       	call   c01003e8 <__panic>
+c0107bf5:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c0107bfc:	e8 6c b7 ff ff       	call   c010336d <alloc_pages>
+c0107c01:	85 c0                	test   %eax,%eax
+c0107c03:	74 24                	je     c0107c29 <default_check+0x564>
+c0107c05:	c7 44 24 0c 52 a6 10 	movl   $0xc010a652,0xc(%esp)
+c0107c0c:	c0 
+c0107c0d:	c7 44 24 08 b2 a4 10 	movl   $0xc010a4b2,0x8(%esp)
+c0107c14:	c0 
+c0107c15:	c7 44 24 04 28 01 00 	movl   $0x128,0x4(%esp)
+c0107c1c:	00 
+c0107c1d:	c7 04 24 c7 a4 10 c0 	movl   $0xc010a4c7,(%esp)
+c0107c24:	e8 cf 87 ff ff       	call   c01003f8 <__panic>
 
     assert(nr_free == 0);
-c01075ad:	a1 14 31 12 c0       	mov    0xc0123114,%eax
-c01075b2:	85 c0                	test   %eax,%eax
-c01075b4:	74 19                	je     c01075cf <default_check+0x4c0>
-c01075b6:	68 75 9f 10 c0       	push   $0xc0109f75
-c01075bb:	68 82 9d 10 c0       	push   $0xc0109d82
-c01075c0:	68 2b 01 00 00       	push   $0x12b
-c01075c5:	68 97 9d 10 c0       	push   $0xc0109d97
-c01075ca:	e8 19 8e ff ff       	call   c01003e8 <__panic>
+c0107c29:	a1 14 41 12 c0       	mov    0xc0124114,%eax
+c0107c2e:	85 c0                	test   %eax,%eax
+c0107c30:	74 24                	je     c0107c56 <default_check+0x591>
+c0107c32:	c7 44 24 0c a5 a6 10 	movl   $0xc010a6a5,0xc(%esp)
+c0107c39:	c0 
+c0107c3a:	c7 44 24 08 b2 a4 10 	movl   $0xc010a4b2,0x8(%esp)
+c0107c41:	c0 
+c0107c42:	c7 44 24 04 2a 01 00 	movl   $0x12a,0x4(%esp)
+c0107c49:	00 
+c0107c4a:	c7 04 24 c7 a4 10 c0 	movl   $0xc010a4c7,(%esp)
+c0107c51:	e8 a2 87 ff ff       	call   c01003f8 <__panic>
     nr_free = nr_free_store;
-c01075cf:	8b 45 cc             	mov    -0x34(%ebp),%eax
-c01075d2:	a3 14 31 12 c0       	mov    %eax,0xc0123114
+c0107c56:	8b 45 cc             	mov    -0x34(%ebp),%eax
+c0107c59:	a3 14 41 12 c0       	mov    %eax,0xc0124114
 
     free_list = free_list_store;
-c01075d7:	8b 45 80             	mov    -0x80(%ebp),%eax
-c01075da:	8b 55 84             	mov    -0x7c(%ebp),%edx
-c01075dd:	a3 0c 31 12 c0       	mov    %eax,0xc012310c
-c01075e2:	89 15 10 31 12 c0    	mov    %edx,0xc0123110
+c0107c5e:	8b 45 80             	mov    -0x80(%ebp),%eax
+c0107c61:	8b 55 84             	mov    -0x7c(%ebp),%edx
+c0107c64:	a3 0c 41 12 c0       	mov    %eax,0xc012410c
+c0107c69:	89 15 10 41 12 c0    	mov    %edx,0xc0124110
     free_pages(p0, 5);
-c01075e8:	83 ec 08             	sub    $0x8,%esp
-c01075eb:	6a 05                	push   $0x5
-c01075ed:	ff 75 dc             	pushl  -0x24(%ebp)
-c01075f0:	e8 8b bf ff ff       	call   c0103580 <free_pages>
-c01075f5:	83 c4 10             	add    $0x10,%esp
+c0107c6f:	c7 44 24 04 05 00 00 	movl   $0x5,0x4(%esp)
+c0107c76:	00 
+c0107c77:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0107c7a:	89 04 24             	mov    %eax,(%esp)
+c0107c7d:	e8 56 b7 ff ff       	call   c01033d8 <free_pages>
 
     le = &free_list;
-c01075f8:	c7 45 ec 0c 31 12 c0 	movl   $0xc012310c,-0x14(%ebp)
+c0107c82:	c7 45 ec 0c 41 12 c0 	movl   $0xc012410c,-0x14(%ebp)
     while ((le = list_next(le)) != &free_list) {
-c01075ff:	eb 1d                	jmp    c010761e <default_check+0x50f>
+c0107c89:	eb 1c                	jmp    c0107ca7 <default_check+0x5e2>
         struct Page *p = le2page(le, page_link);
-c0107601:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c0107604:	83 e8 0c             	sub    $0xc,%eax
-c0107607:	89 45 b4             	mov    %eax,-0x4c(%ebp)
+c0107c8b:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0107c8e:	83 e8 0c             	sub    $0xc,%eax
+c0107c91:	89 45 b4             	mov    %eax,-0x4c(%ebp)
         count --, total -= p->property;
-c010760a:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
-c010760e:	8b 55 f0             	mov    -0x10(%ebp),%edx
-c0107611:	8b 45 b4             	mov    -0x4c(%ebp),%eax
-c0107614:	8b 40 08             	mov    0x8(%eax),%eax
-c0107617:	29 c2                	sub    %eax,%edx
-c0107619:	89 d0                	mov    %edx,%eax
-c010761b:	89 45 f0             	mov    %eax,-0x10(%ebp)
-c010761e:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c0107621:	89 45 b8             	mov    %eax,-0x48(%ebp)
+c0107c94:	ff 4d f4             	decl   -0xc(%ebp)
+c0107c97:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c0107c9a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
+c0107c9d:	8b 40 08             	mov    0x8(%eax),%eax
+c0107ca0:	29 c2                	sub    %eax,%edx
+c0107ca2:	89 d0                	mov    %edx,%eax
+c0107ca4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0107ca7:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0107caa:	89 45 b8             	mov    %eax,-0x48(%ebp)
  * list_next - get the next entry
  * @listelm:    the list head
  **/
 static inline list_entry_t *
 list_next(list_entry_t *listelm) {
     return listelm->next;
-c0107624:	8b 45 b8             	mov    -0x48(%ebp),%eax
-c0107627:	8b 40 04             	mov    0x4(%eax),%eax
+c0107cad:	8b 45 b8             	mov    -0x48(%ebp),%eax
+c0107cb0:	8b 40 04             	mov    0x4(%eax),%eax
 
     free_list = free_list_store;
     free_pages(p0, 5);
 
     le = &free_list;
     while ((le = list_next(le)) != &free_list) {
-c010762a:	89 45 ec             	mov    %eax,-0x14(%ebp)
-c010762d:	81 7d ec 0c 31 12 c0 	cmpl   $0xc012310c,-0x14(%ebp)
-c0107634:	75 cb                	jne    c0107601 <default_check+0x4f2>
+c0107cb3:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c0107cb6:	81 7d ec 0c 41 12 c0 	cmpl   $0xc012410c,-0x14(%ebp)
+c0107cbd:	75 cc                	jne    c0107c8b <default_check+0x5c6>
         struct Page *p = le2page(le, page_link);
         count --, total -= p->property;
     }
     assert(count == 0);
-c0107636:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
-c010763a:	74 19                	je     c0107655 <default_check+0x546>
-c010763c:	68 e2 a0 10 c0       	push   $0xc010a0e2
-c0107641:	68 82 9d 10 c0       	push   $0xc0109d82
-c0107646:	68 36 01 00 00       	push   $0x136
-c010764b:	68 97 9d 10 c0       	push   $0xc0109d97
-c0107650:	e8 93 8d ff ff       	call   c01003e8 <__panic>
+c0107cbf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0107cc3:	74 24                	je     c0107ce9 <default_check+0x624>
+c0107cc5:	c7 44 24 0c 12 a8 10 	movl   $0xc010a812,0xc(%esp)
+c0107ccc:	c0 
+c0107ccd:	c7 44 24 08 b2 a4 10 	movl   $0xc010a4b2,0x8(%esp)
+c0107cd4:	c0 
+c0107cd5:	c7 44 24 04 35 01 00 	movl   $0x135,0x4(%esp)
+c0107cdc:	00 
+c0107cdd:	c7 04 24 c7 a4 10 c0 	movl   $0xc010a4c7,(%esp)
+c0107ce4:	e8 0f 87 ff ff       	call   c01003f8 <__panic>
     assert(total == 0);
-c0107655:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
-c0107659:	74 19                	je     c0107674 <default_check+0x565>
-c010765b:	68 ed a0 10 c0       	push   $0xc010a0ed
-c0107660:	68 82 9d 10 c0       	push   $0xc0109d82
-c0107665:	68 37 01 00 00       	push   $0x137
-c010766a:	68 97 9d 10 c0       	push   $0xc0109d97
-c010766f:	e8 74 8d ff ff       	call   c01003e8 <__panic>
-}
-c0107674:	90                   	nop
-c0107675:	c9                   	leave  
-c0107676:	c3                   	ret    
+c0107ce9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c0107ced:	74 24                	je     c0107d13 <default_check+0x64e>
+c0107cef:	c7 44 24 0c 1d a8 10 	movl   $0xc010a81d,0xc(%esp)
+c0107cf6:	c0 
+c0107cf7:	c7 44 24 08 b2 a4 10 	movl   $0xc010a4b2,0x8(%esp)
+c0107cfe:	c0 
+c0107cff:	c7 44 24 04 36 01 00 	movl   $0x136,0x4(%esp)
+c0107d06:	00 
+c0107d07:	c7 04 24 c7 a4 10 c0 	movl   $0xc010a4c7,(%esp)
+c0107d0e:	e8 e5 86 ff ff       	call   c01003f8 <__panic>
+}
+c0107d13:	90                   	nop
+c0107d14:	c9                   	leave  
+c0107d15:	c3                   	ret    
 
-c0107677 <page2ppn>:
+c0107d16 <page2ppn>:
 
 extern struct Page *pages;
 extern size_t npage;
 
 static inline ppn_t
 page2ppn(struct Page *page) {
-c0107677:	55                   	push   %ebp
-c0107678:	89 e5                	mov    %esp,%ebp
+c0107d16:	55                   	push   %ebp
+c0107d17:	89 e5                	mov    %esp,%ebp
     return page - pages;
-c010767a:	8b 45 08             	mov    0x8(%ebp),%eax
-c010767d:	8b 15 28 30 12 c0    	mov    0xc0123028,%edx
-c0107683:	29 d0                	sub    %edx,%eax
-c0107685:	c1 f8 05             	sar    $0x5,%eax
+c0107d19:	8b 45 08             	mov    0x8(%ebp),%eax
+c0107d1c:	8b 15 28 40 12 c0    	mov    0xc0124028,%edx
+c0107d22:	29 d0                	sub    %edx,%eax
+c0107d24:	c1 f8 05             	sar    $0x5,%eax
 }
-c0107688:	5d                   	pop    %ebp
-c0107689:	c3                   	ret    
+c0107d27:	5d                   	pop    %ebp
+c0107d28:	c3                   	ret    
 
-c010768a <page2pa>:
+c0107d29 <page2pa>:
 
 static inline uintptr_t
 page2pa(struct Page *page) {
-c010768a:	55                   	push   %ebp
-c010768b:	89 e5                	mov    %esp,%ebp
+c0107d29:	55                   	push   %ebp
+c0107d2a:	89 e5                	mov    %esp,%ebp
+c0107d2c:	83 ec 04             	sub    $0x4,%esp
     return page2ppn(page) << PGSHIFT;
-c010768d:	ff 75 08             	pushl  0x8(%ebp)
-c0107690:	e8 e2 ff ff ff       	call   c0107677 <page2ppn>
-c0107695:	83 c4 04             	add    $0x4,%esp
-c0107698:	c1 e0 0c             	shl    $0xc,%eax
+c0107d2f:	8b 45 08             	mov    0x8(%ebp),%eax
+c0107d32:	89 04 24             	mov    %eax,(%esp)
+c0107d35:	e8 dc ff ff ff       	call   c0107d16 <page2ppn>
+c0107d3a:	c1 e0 0c             	shl    $0xc,%eax
 }
-c010769b:	c9                   	leave  
-c010769c:	c3                   	ret    
+c0107d3d:	c9                   	leave  
+c0107d3e:	c3                   	ret    
 
-c010769d <page2kva>:
+c0107d3f <page2kva>:
     }
     return &pages[PPN(pa)];
 }
 
 static inline void *
 page2kva(struct Page *page) {
-c010769d:	55                   	push   %ebp
-c010769e:	89 e5                	mov    %esp,%ebp
-c01076a0:	83 ec 18             	sub    $0x18,%esp
+c0107d3f:	55                   	push   %ebp
+c0107d40:	89 e5                	mov    %esp,%ebp
+c0107d42:	83 ec 28             	sub    $0x28,%esp
     return KADDR(page2pa(page));
-c01076a3:	ff 75 08             	pushl  0x8(%ebp)
-c01076a6:	e8 df ff ff ff       	call   c010768a <page2pa>
-c01076ab:	83 c4 04             	add    $0x4,%esp
-c01076ae:	89 45 f4             	mov    %eax,-0xc(%ebp)
-c01076b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c01076b4:	c1 e8 0c             	shr    $0xc,%eax
-c01076b7:	89 45 f0             	mov    %eax,-0x10(%ebp)
-c01076ba:	a1 80 2f 12 c0       	mov    0xc0122f80,%eax
-c01076bf:	39 45 f0             	cmp    %eax,-0x10(%ebp)
-c01076c2:	72 14                	jb     c01076d8 <page2kva+0x3b>
-c01076c4:	ff 75 f4             	pushl  -0xc(%ebp)
-c01076c7:	68 28 a1 10 c0       	push   $0xc010a128
-c01076cc:	6a 62                	push   $0x62
-c01076ce:	68 4b a1 10 c0       	push   $0xc010a14b
-c01076d3:	e8 10 8d ff ff       	call   c01003e8 <__panic>
-c01076d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c01076db:	2d 00 00 00 40       	sub    $0x40000000,%eax
+c0107d45:	8b 45 08             	mov    0x8(%ebp),%eax
+c0107d48:	89 04 24             	mov    %eax,(%esp)
+c0107d4b:	e8 d9 ff ff ff       	call   c0107d29 <page2pa>
+c0107d50:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0107d53:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0107d56:	c1 e8 0c             	shr    $0xc,%eax
+c0107d59:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0107d5c:	a1 80 3f 12 c0       	mov    0xc0123f80,%eax
+c0107d61:	39 45 f0             	cmp    %eax,-0x10(%ebp)
+c0107d64:	72 23                	jb     c0107d89 <page2kva+0x4a>
+c0107d66:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0107d69:	89 44 24 0c          	mov    %eax,0xc(%esp)
+c0107d6d:	c7 44 24 08 58 a8 10 	movl   $0xc010a858,0x8(%esp)
+c0107d74:	c0 
+c0107d75:	c7 44 24 04 62 00 00 	movl   $0x62,0x4(%esp)
+c0107d7c:	00 
+c0107d7d:	c7 04 24 7b a8 10 c0 	movl   $0xc010a87b,(%esp)
+c0107d84:	e8 6f 86 ff ff       	call   c01003f8 <__panic>
+c0107d89:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0107d8c:	2d 00 00 00 40       	sub    $0x40000000,%eax
 }
-c01076e0:	c9                   	leave  
-c01076e1:	c3                   	ret    
+c0107d91:	c9                   	leave  
+c0107d92:	c3                   	ret    
 
-c01076e2 <swapfs_init>:
+c0107d93 <swapfs_init>:
 #include <ide.h>
 #include <pmm.h>
 #include <assert.h>
 
 void
 swapfs_init(void) {
-c01076e2:	55                   	push   %ebp
-c01076e3:	89 e5                	mov    %esp,%ebp
-c01076e5:	83 ec 08             	sub    $0x8,%esp
+c0107d93:	55                   	push   %ebp
+c0107d94:	89 e5                	mov    %esp,%ebp
+c0107d96:	83 ec 18             	sub    $0x18,%esp
     static_assert((PGSIZE % SECTSIZE) == 0);
     if (!ide_device_valid(SWAP_DEV_NO)) {
-c01076e8:	83 ec 0c             	sub    $0xc,%esp
-c01076eb:	6a 01                	push   $0x1
-c01076ed:	e8 f4 99 ff ff       	call   c01010e6 <ide_device_valid>
-c01076f2:	83 c4 10             	add    $0x10,%esp
-c01076f5:	85 c0                	test   %eax,%eax
-c01076f7:	75 14                	jne    c010770d <swapfs_init+0x2b>
+c0107d99:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c0107da0:	e8 b5 92 ff ff       	call   c010105a <ide_device_valid>
+c0107da5:	85 c0                	test   %eax,%eax
+c0107da7:	75 1c                	jne    c0107dc5 <swapfs_init+0x32>
         panic("swap fs isn't available.\n");
-c01076f9:	83 ec 04             	sub    $0x4,%esp
-c01076fc:	68 59 a1 10 c0       	push   $0xc010a159
-c0107701:	6a 0d                	push   $0xd
-c0107703:	68 73 a1 10 c0       	push   $0xc010a173
-c0107708:	e8 db 8c ff ff       	call   c01003e8 <__panic>
+c0107da9:	c7 44 24 08 89 a8 10 	movl   $0xc010a889,0x8(%esp)
+c0107db0:	c0 
+c0107db1:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp)
+c0107db8:	00 
+c0107db9:	c7 04 24 a3 a8 10 c0 	movl   $0xc010a8a3,(%esp)
+c0107dc0:	e8 33 86 ff ff       	call   c01003f8 <__panic>
     }
     max_swap_offset = ide_device_size(SWAP_DEV_NO) / (PGSIZE / SECTSIZE);
-c010770d:	83 ec 0c             	sub    $0xc,%esp
-c0107710:	6a 01                	push   $0x1
-c0107712:	e8 0f 9a ff ff       	call   c0101126 <ide_device_size>
-c0107717:	83 c4 10             	add    $0x10,%esp
-c010771a:	c1 e8 03             	shr    $0x3,%eax
-c010771d:	a3 dc 30 12 c0       	mov    %eax,0xc01230dc
-}
-c0107722:	90                   	nop
-c0107723:	c9                   	leave  
-c0107724:	c3                   	ret    
+c0107dc5:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c0107dcc:	e8 cb 92 ff ff       	call   c010109c <ide_device_size>
+c0107dd1:	c1 e8 03             	shr    $0x3,%eax
+c0107dd4:	a3 dc 40 12 c0       	mov    %eax,0xc01240dc
+}
+c0107dd9:	90                   	nop
+c0107dda:	c9                   	leave  
+c0107ddb:	c3                   	ret    
 
-c0107725 <swapfs_read>:
+c0107ddc <swapfs_read>:
 
 int
 swapfs_read(swap_entry_t entry, struct Page *page) {
-c0107725:	55                   	push   %ebp
-c0107726:	89 e5                	mov    %esp,%ebp
-c0107728:	83 ec 18             	sub    $0x18,%esp
+c0107ddc:	55                   	push   %ebp
+c0107ddd:	89 e5                	mov    %esp,%ebp
+c0107ddf:	83 ec 28             	sub    $0x28,%esp
     return ide_read_secs(SWAP_DEV_NO, swap_offset(entry) * PAGE_NSECT, page2kva(page), PAGE_NSECT);
-c010772b:	83 ec 0c             	sub    $0xc,%esp
-c010772e:	ff 75 0c             	pushl  0xc(%ebp)
-c0107731:	e8 67 ff ff ff       	call   c010769d <page2kva>
-c0107736:	83 c4 10             	add    $0x10,%esp
-c0107739:	89 c2                	mov    %eax,%edx
-c010773b:	8b 45 08             	mov    0x8(%ebp),%eax
-c010773e:	c1 e8 08             	shr    $0x8,%eax
-c0107741:	89 45 f4             	mov    %eax,-0xc(%ebp)
-c0107744:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
-c0107748:	74 0a                	je     c0107754 <swapfs_read+0x2f>
-c010774a:	a1 dc 30 12 c0       	mov    0xc01230dc,%eax
-c010774f:	39 45 f4             	cmp    %eax,-0xc(%ebp)
-c0107752:	72 14                	jb     c0107768 <swapfs_read+0x43>
-c0107754:	ff 75 08             	pushl  0x8(%ebp)
-c0107757:	68 84 a1 10 c0       	push   $0xc010a184
-c010775c:	6a 14                	push   $0x14
-c010775e:	68 73 a1 10 c0       	push   $0xc010a173
-c0107763:	e8 80 8c ff ff       	call   c01003e8 <__panic>
-c0107768:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c010776b:	c1 e0 03             	shl    $0x3,%eax
-c010776e:	6a 08                	push   $0x8
-c0107770:	52                   	push   %edx
-c0107771:	50                   	push   %eax
-c0107772:	6a 01                	push   $0x1
-c0107774:	e8 ed 99 ff ff       	call   c0101166 <ide_read_secs>
-c0107779:	83 c4 10             	add    $0x10,%esp
+c0107de2:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0107de5:	89 04 24             	mov    %eax,(%esp)
+c0107de8:	e8 52 ff ff ff       	call   c0107d3f <page2kva>
+c0107ded:	8b 55 08             	mov    0x8(%ebp),%edx
+c0107df0:	c1 ea 08             	shr    $0x8,%edx
+c0107df3:	89 55 f4             	mov    %edx,-0xc(%ebp)
+c0107df6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0107dfa:	74 0b                	je     c0107e07 <swapfs_read+0x2b>
+c0107dfc:	8b 15 dc 40 12 c0    	mov    0xc01240dc,%edx
+c0107e02:	39 55 f4             	cmp    %edx,-0xc(%ebp)
+c0107e05:	72 23                	jb     c0107e2a <swapfs_read+0x4e>
+c0107e07:	8b 45 08             	mov    0x8(%ebp),%eax
+c0107e0a:	89 44 24 0c          	mov    %eax,0xc(%esp)
+c0107e0e:	c7 44 24 08 b4 a8 10 	movl   $0xc010a8b4,0x8(%esp)
+c0107e15:	c0 
+c0107e16:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
+c0107e1d:	00 
+c0107e1e:	c7 04 24 a3 a8 10 c0 	movl   $0xc010a8a3,(%esp)
+c0107e25:	e8 ce 85 ff ff       	call   c01003f8 <__panic>
+c0107e2a:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0107e2d:	c1 e2 03             	shl    $0x3,%edx
+c0107e30:	c7 44 24 0c 08 00 00 	movl   $0x8,0xc(%esp)
+c0107e37:	00 
+c0107e38:	89 44 24 08          	mov    %eax,0x8(%esp)
+c0107e3c:	89 54 24 04          	mov    %edx,0x4(%esp)
+c0107e40:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c0107e47:	e8 8f 92 ff ff       	call   c01010db <ide_read_secs>
 }
-c010777c:	c9                   	leave  
-c010777d:	c3                   	ret    
+c0107e4c:	c9                   	leave  
+c0107e4d:	c3                   	ret    
 
-c010777e <swapfs_write>:
+c0107e4e <swapfs_write>:
 
 int
 swapfs_write(swap_entry_t entry, struct Page *page) {
-c010777e:	55                   	push   %ebp
-c010777f:	89 e5                	mov    %esp,%ebp
-c0107781:	83 ec 18             	sub    $0x18,%esp
+c0107e4e:	55                   	push   %ebp
+c0107e4f:	89 e5                	mov    %esp,%ebp
+c0107e51:	83 ec 28             	sub    $0x28,%esp
     return ide_write_secs(SWAP_DEV_NO, swap_offset(entry) * PAGE_NSECT, page2kva(page), PAGE_NSECT);
-c0107784:	83 ec 0c             	sub    $0xc,%esp
-c0107787:	ff 75 0c             	pushl  0xc(%ebp)
-c010778a:	e8 0e ff ff ff       	call   c010769d <page2kva>
-c010778f:	83 c4 10             	add    $0x10,%esp
-c0107792:	89 c2                	mov    %eax,%edx
-c0107794:	8b 45 08             	mov    0x8(%ebp),%eax
-c0107797:	c1 e8 08             	shr    $0x8,%eax
-c010779a:	89 45 f4             	mov    %eax,-0xc(%ebp)
-c010779d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
-c01077a1:	74 0a                	je     c01077ad <swapfs_write+0x2f>
-c01077a3:	a1 dc 30 12 c0       	mov    0xc01230dc,%eax
-c01077a8:	39 45 f4             	cmp    %eax,-0xc(%ebp)
-c01077ab:	72 14                	jb     c01077c1 <swapfs_write+0x43>
-c01077ad:	ff 75 08             	pushl  0x8(%ebp)
-c01077b0:	68 84 a1 10 c0       	push   $0xc010a184
-c01077b5:	6a 19                	push   $0x19
-c01077b7:	68 73 a1 10 c0       	push   $0xc010a173
-c01077bc:	e8 27 8c ff ff       	call   c01003e8 <__panic>
-c01077c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c01077c4:	c1 e0 03             	shl    $0x3,%eax
-c01077c7:	6a 08                	push   $0x8
-c01077c9:	52                   	push   %edx
-c01077ca:	50                   	push   %eax
-c01077cb:	6a 01                	push   $0x1
-c01077cd:	e8 be 9b ff ff       	call   c0101390 <ide_write_secs>
-c01077d2:	83 c4 10             	add    $0x10,%esp
+c0107e54:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0107e57:	89 04 24             	mov    %eax,(%esp)
+c0107e5a:	e8 e0 fe ff ff       	call   c0107d3f <page2kva>
+c0107e5f:	8b 55 08             	mov    0x8(%ebp),%edx
+c0107e62:	c1 ea 08             	shr    $0x8,%edx
+c0107e65:	89 55 f4             	mov    %edx,-0xc(%ebp)
+c0107e68:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+c0107e6c:	74 0b                	je     c0107e79 <swapfs_write+0x2b>
+c0107e6e:	8b 15 dc 40 12 c0    	mov    0xc01240dc,%edx
+c0107e74:	39 55 f4             	cmp    %edx,-0xc(%ebp)
+c0107e77:	72 23                	jb     c0107e9c <swapfs_write+0x4e>
+c0107e79:	8b 45 08             	mov    0x8(%ebp),%eax
+c0107e7c:	89 44 24 0c          	mov    %eax,0xc(%esp)
+c0107e80:	c7 44 24 08 b4 a8 10 	movl   $0xc010a8b4,0x8(%esp)
+c0107e87:	c0 
+c0107e88:	c7 44 24 04 19 00 00 	movl   $0x19,0x4(%esp)
+c0107e8f:	00 
+c0107e90:	c7 04 24 a3 a8 10 c0 	movl   $0xc010a8a3,(%esp)
+c0107e97:	e8 5c 85 ff ff       	call   c01003f8 <__panic>
+c0107e9c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0107e9f:	c1 e2 03             	shl    $0x3,%edx
+c0107ea2:	c7 44 24 0c 08 00 00 	movl   $0x8,0xc(%esp)
+c0107ea9:	00 
+c0107eaa:	89 44 24 08          	mov    %eax,0x8(%esp)
+c0107eae:	89 54 24 04          	mov    %edx,0x4(%esp)
+c0107eb2:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+c0107eb9:	e8 57 94 ff ff       	call   c0101315 <ide_write_secs>
 }
-c01077d5:	c9                   	leave  
-c01077d6:	c3                   	ret    
+c0107ebe:	c9                   	leave  
+c0107ebf:	c3                   	ret    
 
-c01077d7 <strlen>:
+c0107ec0 <strlen>:
  * @s:      the input string
  *
  * The strlen() function returns the length of string @s.
  * */
 size_t
 strlen(const char *s) {
-c01077d7:	55                   	push   %ebp
-c01077d8:	89 e5                	mov    %esp,%ebp
-c01077da:	83 ec 10             	sub    $0x10,%esp
+c0107ec0:	55                   	push   %ebp
+c0107ec1:	89 e5                	mov    %esp,%ebp
+c0107ec3:	83 ec 10             	sub    $0x10,%esp
     size_t cnt = 0;
-c01077dd:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+c0107ec6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
     while (*s ++ != '\0') {
-c01077e4:	eb 04                	jmp    c01077ea <strlen+0x13>
+c0107ecd:	eb 03                	jmp    c0107ed2 <strlen+0x12>
         cnt ++;
-c01077e6:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+c0107ecf:	ff 45 fc             	incl   -0x4(%ebp)
  * The strlen() function returns the length of string @s.
  * */
 size_t
 strlen(const char *s) {
     size_t cnt = 0;
     while (*s ++ != '\0') {
-c01077ea:	8b 45 08             	mov    0x8(%ebp),%eax
-c01077ed:	8d 50 01             	lea    0x1(%eax),%edx
-c01077f0:	89 55 08             	mov    %edx,0x8(%ebp)
-c01077f3:	0f b6 00             	movzbl (%eax),%eax
-c01077f6:	84 c0                	test   %al,%al
-c01077f8:	75 ec                	jne    c01077e6 <strlen+0xf>
+c0107ed2:	8b 45 08             	mov    0x8(%ebp),%eax
+c0107ed5:	8d 50 01             	lea    0x1(%eax),%edx
+c0107ed8:	89 55 08             	mov    %edx,0x8(%ebp)
+c0107edb:	0f b6 00             	movzbl (%eax),%eax
+c0107ede:	84 c0                	test   %al,%al
+c0107ee0:	75 ed                	jne    c0107ecf <strlen+0xf>
         cnt ++;
     }
     return cnt;
-c01077fa:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0107ee2:	8b 45 fc             	mov    -0x4(%ebp),%eax
 }
-c01077fd:	c9                   	leave  
-c01077fe:	c3                   	ret    
+c0107ee5:	c9                   	leave  
+c0107ee6:	c3                   	ret    
 
-c01077ff <strnlen>:
+c0107ee7 <strnlen>:
  * The return value is strlen(s), if that is less than @len, or
  * @len if there is no '\0' character among the first @len characters
  * pointed by @s.
  * */
 size_t
 strnlen(const char *s, size_t len) {
-c01077ff:	55                   	push   %ebp
-c0107800:	89 e5                	mov    %esp,%ebp
-c0107802:	83 ec 10             	sub    $0x10,%esp
+c0107ee7:	55                   	push   %ebp
+c0107ee8:	89 e5                	mov    %esp,%ebp
+c0107eea:	83 ec 10             	sub    $0x10,%esp
     size_t cnt = 0;
-c0107805:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+c0107eed:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
     while (cnt < len && *s ++ != '\0') {
-c010780c:	eb 04                	jmp    c0107812 <strnlen+0x13>
+c0107ef4:	eb 03                	jmp    c0107ef9 <strnlen+0x12>
         cnt ++;
-c010780e:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+c0107ef6:	ff 45 fc             	incl   -0x4(%ebp)
  * pointed by @s.
  * */
 size_t
 strnlen(const char *s, size_t len) {
     size_t cnt = 0;
     while (cnt < len && *s ++ != '\0') {
-c0107812:	8b 45 fc             	mov    -0x4(%ebp),%eax
-c0107815:	3b 45 0c             	cmp    0xc(%ebp),%eax
-c0107818:	73 10                	jae    c010782a <strnlen+0x2b>
-c010781a:	8b 45 08             	mov    0x8(%ebp),%eax
-c010781d:	8d 50 01             	lea    0x1(%eax),%edx
-c0107820:	89 55 08             	mov    %edx,0x8(%ebp)
-c0107823:	0f b6 00             	movzbl (%eax),%eax
-c0107826:	84 c0                	test   %al,%al
-c0107828:	75 e4                	jne    c010780e <strnlen+0xf>
+c0107ef9:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0107efc:	3b 45 0c             	cmp    0xc(%ebp),%eax
+c0107eff:	73 10                	jae    c0107f11 <strnlen+0x2a>
+c0107f01:	8b 45 08             	mov    0x8(%ebp),%eax
+c0107f04:	8d 50 01             	lea    0x1(%eax),%edx
+c0107f07:	89 55 08             	mov    %edx,0x8(%ebp)
+c0107f0a:	0f b6 00             	movzbl (%eax),%eax
+c0107f0d:	84 c0                	test   %al,%al
+c0107f0f:	75 e5                	jne    c0107ef6 <strnlen+0xf>
         cnt ++;
     }
     return cnt;
-c010782a:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0107f11:	8b 45 fc             	mov    -0x4(%ebp),%eax
 }
-c010782d:	c9                   	leave  
-c010782e:	c3                   	ret    
+c0107f14:	c9                   	leave  
+c0107f15:	c3                   	ret    
 
-c010782f <strcpy>:
+c0107f16 <strcpy>:
  * To avoid overflows, the size of array pointed by @dst should be long enough to
  * contain the same string as @src (including the terminating null character), and
  * should not overlap in memory with @src.
  * */
 char *
 strcpy(char *dst, const char *src) {
-c010782f:	55                   	push   %ebp
-c0107830:	89 e5                	mov    %esp,%ebp
-c0107832:	57                   	push   %edi
-c0107833:	56                   	push   %esi
-c0107834:	83 ec 20             	sub    $0x20,%esp
-c0107837:	8b 45 08             	mov    0x8(%ebp),%eax
-c010783a:	89 45 f4             	mov    %eax,-0xc(%ebp)
-c010783d:	8b 45 0c             	mov    0xc(%ebp),%eax
-c0107840:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0107f16:	55                   	push   %ebp
+c0107f17:	89 e5                	mov    %esp,%ebp
+c0107f19:	57                   	push   %edi
+c0107f1a:	56                   	push   %esi
+c0107f1b:	83 ec 20             	sub    $0x20,%esp
+c0107f1e:	8b 45 08             	mov    0x8(%ebp),%eax
+c0107f21:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0107f24:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0107f27:	89 45 f0             	mov    %eax,-0x10(%ebp)
 #ifndef __HAVE_ARCH_STRCPY
 #define __HAVE_ARCH_STRCPY
 static inline char *
 __strcpy(char *dst, const char *src) {
     int d0, d1, d2;
     asm volatile (
-c0107843:	8b 55 f0             	mov    -0x10(%ebp),%edx
-c0107846:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0107849:	89 d1                	mov    %edx,%ecx
-c010784b:	89 c2                	mov    %eax,%edx
-c010784d:	89 ce                	mov    %ecx,%esi
-c010784f:	89 d7                	mov    %edx,%edi
-c0107851:	ac                   	lods   %ds:(%esi),%al
-c0107852:	aa                   	stos   %al,%es:(%edi)
-c0107853:	84 c0                	test   %al,%al
-c0107855:	75 fa                	jne    c0107851 <strcpy+0x22>
-c0107857:	89 fa                	mov    %edi,%edx
-c0107859:	89 f1                	mov    %esi,%ecx
-c010785b:	89 4d ec             	mov    %ecx,-0x14(%ebp)
-c010785e:	89 55 e8             	mov    %edx,-0x18(%ebp)
-c0107861:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+c0107f2a:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c0107f2d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0107f30:	89 d1                	mov    %edx,%ecx
+c0107f32:	89 c2                	mov    %eax,%edx
+c0107f34:	89 ce                	mov    %ecx,%esi
+c0107f36:	89 d7                	mov    %edx,%edi
+c0107f38:	ac                   	lods   %ds:(%esi),%al
+c0107f39:	aa                   	stos   %al,%es:(%edi)
+c0107f3a:	84 c0                	test   %al,%al
+c0107f3c:	75 fa                	jne    c0107f38 <strcpy+0x22>
+c0107f3e:	89 fa                	mov    %edi,%edx
+c0107f40:	89 f1                	mov    %esi,%ecx
+c0107f42:	89 4d ec             	mov    %ecx,-0x14(%ebp)
+c0107f45:	89 55 e8             	mov    %edx,-0x18(%ebp)
+c0107f48:	89 45 e4             	mov    %eax,-0x1c(%ebp)
         "stosb;"
         "testb %%al, %%al;"
         "jne 1b;"
         : "=&S" (d0), "=&D" (d1), "=&a" (d2)
         : "0" (src), "1" (dst) : "memory");
     return dst;
-c0107864:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0107f4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
 #ifdef __HAVE_ARCH_STRCPY
     return __strcpy(dst, src);
-c0107867:	90                   	nop
+c0107f4e:	90                   	nop
     char *p = dst;
     while ((*p ++ = *src ++) != '\0')
         /* nothing */;
     return dst;
 #endif /* __HAVE_ARCH_STRCPY */
 }
-c0107868:	83 c4 20             	add    $0x20,%esp
-c010786b:	5e                   	pop    %esi
-c010786c:	5f                   	pop    %edi
-c010786d:	5d                   	pop    %ebp
-c010786e:	c3                   	ret    
+c0107f4f:	83 c4 20             	add    $0x20,%esp
+c0107f52:	5e                   	pop    %esi
+c0107f53:	5f                   	pop    %edi
+c0107f54:	5d                   	pop    %ebp
+c0107f55:	c3                   	ret    
 
-c010786f <strncpy>:
+c0107f56 <strncpy>:
  * @len:    maximum number of characters to be copied from @src
  *
  * The return value is @dst
  * */
 char *
 strncpy(char *dst, const char *src, size_t len) {
-c010786f:	55                   	push   %ebp
-c0107870:	89 e5                	mov    %esp,%ebp
-c0107872:	83 ec 10             	sub    $0x10,%esp
+c0107f56:	55                   	push   %ebp
+c0107f57:	89 e5                	mov    %esp,%ebp
+c0107f59:	83 ec 10             	sub    $0x10,%esp
     char *p = dst;
-c0107875:	8b 45 08             	mov    0x8(%ebp),%eax
-c0107878:	89 45 fc             	mov    %eax,-0x4(%ebp)
+c0107f5c:	8b 45 08             	mov    0x8(%ebp),%eax
+c0107f5f:	89 45 fc             	mov    %eax,-0x4(%ebp)
     while (len > 0) {
-c010787b:	eb 21                	jmp    c010789e <strncpy+0x2f>
+c0107f62:	eb 1e                	jmp    c0107f82 <strncpy+0x2c>
         if ((*p = *src) != '\0') {
-c010787d:	8b 45 0c             	mov    0xc(%ebp),%eax
-c0107880:	0f b6 10             	movzbl (%eax),%edx
-c0107883:	8b 45 fc             	mov    -0x4(%ebp),%eax
-c0107886:	88 10                	mov    %dl,(%eax)
-c0107888:	8b 45 fc             	mov    -0x4(%ebp),%eax
-c010788b:	0f b6 00             	movzbl (%eax),%eax
-c010788e:	84 c0                	test   %al,%al
-c0107890:	74 04                	je     c0107896 <strncpy+0x27>
+c0107f64:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0107f67:	0f b6 10             	movzbl (%eax),%edx
+c0107f6a:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0107f6d:	88 10                	mov    %dl,(%eax)
+c0107f6f:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c0107f72:	0f b6 00             	movzbl (%eax),%eax
+c0107f75:	84 c0                	test   %al,%al
+c0107f77:	74 03                	je     c0107f7c <strncpy+0x26>
             src ++;
-c0107892:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+c0107f79:	ff 45 0c             	incl   0xc(%ebp)
         }
         p ++, len --;
-c0107896:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
-c010789a:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+c0107f7c:	ff 45 fc             	incl   -0x4(%ebp)
+c0107f7f:	ff 4d 10             	decl   0x10(%ebp)
  * The return value is @dst
  * */
 char *
 strncpy(char *dst, const char *src, size_t len) {
     char *p = dst;
     while (len > 0) {
-c010789e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
-c01078a2:	75 d9                	jne    c010787d <strncpy+0xe>
+c0107f82:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+c0107f86:	75 dc                	jne    c0107f64 <strncpy+0xe>
         if ((*p = *src) != '\0') {
             src ++;
         }
         p ++, len --;
     }
     return dst;
-c01078a4:	8b 45 08             	mov    0x8(%ebp),%eax
+c0107f88:	8b 45 08             	mov    0x8(%ebp),%eax
 }
-c01078a7:	c9                   	leave  
-c01078a8:	c3                   	ret    
+c0107f8b:	c9                   	leave  
+c0107f8c:	c3                   	ret    
 
-c01078a9 <strcmp>:
+c0107f8d <strcmp>:
  * - A value greater than zero indicates that the first character that does
  *   not match has a greater value in @s1 than in @s2;
  * - And a value less than zero indicates the opposite.
  * */
 int
 strcmp(const char *s1, const char *s2) {
-c01078a9:	55                   	push   %ebp
-c01078aa:	89 e5                	mov    %esp,%ebp
-c01078ac:	57                   	push   %edi
-c01078ad:	56                   	push   %esi
-c01078ae:	83 ec 20             	sub    $0x20,%esp
-c01078b1:	8b 45 08             	mov    0x8(%ebp),%eax
-c01078b4:	89 45 f4             	mov    %eax,-0xc(%ebp)
-c01078b7:	8b 45 0c             	mov    0xc(%ebp),%eax
-c01078ba:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0107f8d:	55                   	push   %ebp
+c0107f8e:	89 e5                	mov    %esp,%ebp
+c0107f90:	57                   	push   %edi
+c0107f91:	56                   	push   %esi
+c0107f92:	83 ec 20             	sub    $0x20,%esp
+c0107f95:	8b 45 08             	mov    0x8(%ebp),%eax
+c0107f98:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0107f9b:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0107f9e:	89 45 f0             	mov    %eax,-0x10(%ebp)
 #ifndef __HAVE_ARCH_STRCMP
 #define __HAVE_ARCH_STRCMP
 static inline int
 __strcmp(const char *s1, const char *s2) {
     int d0, d1, ret;
     asm volatile (
-c01078bd:	8b 55 f4             	mov    -0xc(%ebp),%edx
-c01078c0:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c01078c3:	89 d1                	mov    %edx,%ecx
-c01078c5:	89 c2                	mov    %eax,%edx
-c01078c7:	89 ce                	mov    %ecx,%esi
-c01078c9:	89 d7                	mov    %edx,%edi
-c01078cb:	ac                   	lods   %ds:(%esi),%al
-c01078cc:	ae                   	scas   %es:(%edi),%al
-c01078cd:	75 08                	jne    c01078d7 <strcmp+0x2e>
-c01078cf:	84 c0                	test   %al,%al
-c01078d1:	75 f8                	jne    c01078cb <strcmp+0x22>
-c01078d3:	31 c0                	xor    %eax,%eax
-c01078d5:	eb 04                	jmp    c01078db <strcmp+0x32>
-c01078d7:	19 c0                	sbb    %eax,%eax
-c01078d9:	0c 01                	or     $0x1,%al
-c01078db:	89 fa                	mov    %edi,%edx
-c01078dd:	89 f1                	mov    %esi,%ecx
-c01078df:	89 45 ec             	mov    %eax,-0x14(%ebp)
-c01078e2:	89 4d e8             	mov    %ecx,-0x18(%ebp)
-c01078e5:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+c0107fa1:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c0107fa4:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0107fa7:	89 d1                	mov    %edx,%ecx
+c0107fa9:	89 c2                	mov    %eax,%edx
+c0107fab:	89 ce                	mov    %ecx,%esi
+c0107fad:	89 d7                	mov    %edx,%edi
+c0107faf:	ac                   	lods   %ds:(%esi),%al
+c0107fb0:	ae                   	scas   %es:(%edi),%al
+c0107fb1:	75 08                	jne    c0107fbb <strcmp+0x2e>
+c0107fb3:	84 c0                	test   %al,%al
+c0107fb5:	75 f8                	jne    c0107faf <strcmp+0x22>
+c0107fb7:	31 c0                	xor    %eax,%eax
+c0107fb9:	eb 04                	jmp    c0107fbf <strcmp+0x32>
+c0107fbb:	19 c0                	sbb    %eax,%eax
+c0107fbd:	0c 01                	or     $0x1,%al
+c0107fbf:	89 fa                	mov    %edi,%edx
+c0107fc1:	89 f1                	mov    %esi,%ecx
+c0107fc3:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c0107fc6:	89 4d e8             	mov    %ecx,-0x18(%ebp)
+c0107fc9:	89 55 e4             	mov    %edx,-0x1c(%ebp)
         "orb $1, %%al;"
         "3:"
         : "=a" (ret), "=&S" (d0), "=&D" (d1)
         : "1" (s1), "2" (s2)
         : "memory");
     return ret;
-c01078e8:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0107fcc:	8b 45 ec             	mov    -0x14(%ebp),%eax
 #ifdef __HAVE_ARCH_STRCMP
     return __strcmp(s1, s2);
-c01078eb:	90                   	nop
+c0107fcf:	90                   	nop
     while (*s1 != '\0' && *s1 == *s2) {
         s1 ++, s2 ++;
     }
     return (int)((unsigned char)*s1 - (unsigned char)*s2);
 #endif /* __HAVE_ARCH_STRCMP */
 }
-c01078ec:	83 c4 20             	add    $0x20,%esp
-c01078ef:	5e                   	pop    %esi
-c01078f0:	5f                   	pop    %edi
-c01078f1:	5d                   	pop    %ebp
-c01078f2:	c3                   	ret    
+c0107fd0:	83 c4 20             	add    $0x20,%esp
+c0107fd3:	5e                   	pop    %esi
+c0107fd4:	5f                   	pop    %edi
+c0107fd5:	5d                   	pop    %ebp
+c0107fd6:	c3                   	ret    
 
-c01078f3 <strncmp>:
+c0107fd7 <strncmp>:
  * they are equal to each other, it continues with the following pairs until
  * the characters differ, until a terminating null-character is reached, or
  * until @n characters match in both strings, whichever happens first.
  * */
 int
 strncmp(const char *s1, const char *s2, size_t n) {
-c01078f3:	55                   	push   %ebp
-c01078f4:	89 e5                	mov    %esp,%ebp
+c0107fd7:	55                   	push   %ebp
+c0107fd8:	89 e5                	mov    %esp,%ebp
     while (n > 0 && *s1 != '\0' && *s1 == *s2) {
-c01078f6:	eb 0c                	jmp    c0107904 <strncmp+0x11>
+c0107fda:	eb 09                	jmp    c0107fe5 <strncmp+0xe>
         n --, s1 ++, s2 ++;
-c01078f8:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
-c01078fc:	83 45 08 01          	addl   $0x1,0x8(%ebp)
-c0107900:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+c0107fdc:	ff 4d 10             	decl   0x10(%ebp)
+c0107fdf:	ff 45 08             	incl   0x8(%ebp)
+c0107fe2:	ff 45 0c             	incl   0xc(%ebp)
  * the characters differ, until a terminating null-character is reached, or
  * until @n characters match in both strings, whichever happens first.
  * */
 int
 strncmp(const char *s1, const char *s2, size_t n) {
     while (n > 0 && *s1 != '\0' && *s1 == *s2) {
-c0107904:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
-c0107908:	74 1a                	je     c0107924 <strncmp+0x31>
-c010790a:	8b 45 08             	mov    0x8(%ebp),%eax
-c010790d:	0f b6 00             	movzbl (%eax),%eax
-c0107910:	84 c0                	test   %al,%al
-c0107912:	74 10                	je     c0107924 <strncmp+0x31>
-c0107914:	8b 45 08             	mov    0x8(%ebp),%eax
-c0107917:	0f b6 10             	movzbl (%eax),%edx
-c010791a:	8b 45 0c             	mov    0xc(%ebp),%eax
-c010791d:	0f b6 00             	movzbl (%eax),%eax
-c0107920:	38 c2                	cmp    %al,%dl
-c0107922:	74 d4                	je     c01078f8 <strncmp+0x5>
+c0107fe5:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+c0107fe9:	74 1a                	je     c0108005 <strncmp+0x2e>
+c0107feb:	8b 45 08             	mov    0x8(%ebp),%eax
+c0107fee:	0f b6 00             	movzbl (%eax),%eax
+c0107ff1:	84 c0                	test   %al,%al
+c0107ff3:	74 10                	je     c0108005 <strncmp+0x2e>
+c0107ff5:	8b 45 08             	mov    0x8(%ebp),%eax
+c0107ff8:	0f b6 10             	movzbl (%eax),%edx
+c0107ffb:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0107ffe:	0f b6 00             	movzbl (%eax),%eax
+c0108001:	38 c2                	cmp    %al,%dl
+c0108003:	74 d7                	je     c0107fdc <strncmp+0x5>
         n --, s1 ++, s2 ++;
     }
     return (n == 0) ? 0 : (int)((unsigned char)*s1 - (unsigned char)*s2);
-c0107924:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
-c0107928:	74 18                	je     c0107942 <strncmp+0x4f>
-c010792a:	8b 45 08             	mov    0x8(%ebp),%eax
-c010792d:	0f b6 00             	movzbl (%eax),%eax
-c0107930:	0f b6 d0             	movzbl %al,%edx
-c0107933:	8b 45 0c             	mov    0xc(%ebp),%eax
-c0107936:	0f b6 00             	movzbl (%eax),%eax
-c0107939:	0f b6 c0             	movzbl %al,%eax
-c010793c:	29 c2                	sub    %eax,%edx
-c010793e:	89 d0                	mov    %edx,%eax
-c0107940:	eb 05                	jmp    c0107947 <strncmp+0x54>
-c0107942:	b8 00 00 00 00       	mov    $0x0,%eax
+c0108005:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+c0108009:	74 18                	je     c0108023 <strncmp+0x4c>
+c010800b:	8b 45 08             	mov    0x8(%ebp),%eax
+c010800e:	0f b6 00             	movzbl (%eax),%eax
+c0108011:	0f b6 d0             	movzbl %al,%edx
+c0108014:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0108017:	0f b6 00             	movzbl (%eax),%eax
+c010801a:	0f b6 c0             	movzbl %al,%eax
+c010801d:	29 c2                	sub    %eax,%edx
+c010801f:	89 d0                	mov    %edx,%eax
+c0108021:	eb 05                	jmp    c0108028 <strncmp+0x51>
+c0108023:	b8 00 00 00 00       	mov    $0x0,%eax
 }
-c0107947:	5d                   	pop    %ebp
-c0107948:	c3                   	ret    
+c0108028:	5d                   	pop    %ebp
+c0108029:	c3                   	ret    
 
-c0107949 <strchr>:
+c010802a <strchr>:
  *
  * The strchr() function returns a pointer to the first occurrence of
  * character in @s. If the value is not found, the function returns 'NULL'.
  * */
 char *
 strchr(const char *s, char c) {
-c0107949:	55                   	push   %ebp
-c010794a:	89 e5                	mov    %esp,%ebp
-c010794c:	83 ec 04             	sub    $0x4,%esp
-c010794f:	8b 45 0c             	mov    0xc(%ebp),%eax
-c0107952:	88 45 fc             	mov    %al,-0x4(%ebp)
+c010802a:	55                   	push   %ebp
+c010802b:	89 e5                	mov    %esp,%ebp
+c010802d:	83 ec 04             	sub    $0x4,%esp
+c0108030:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0108033:	88 45 fc             	mov    %al,-0x4(%ebp)
     while (*s != '\0') {
-c0107955:	eb 14                	jmp    c010796b <strchr+0x22>
+c0108036:	eb 13                	jmp    c010804b <strchr+0x21>
         if (*s == c) {
-c0107957:	8b 45 08             	mov    0x8(%ebp),%eax
-c010795a:	0f b6 00             	movzbl (%eax),%eax
-c010795d:	3a 45 fc             	cmp    -0x4(%ebp),%al
-c0107960:	75 05                	jne    c0107967 <strchr+0x1e>
+c0108038:	8b 45 08             	mov    0x8(%ebp),%eax
+c010803b:	0f b6 00             	movzbl (%eax),%eax
+c010803e:	3a 45 fc             	cmp    -0x4(%ebp),%al
+c0108041:	75 05                	jne    c0108048 <strchr+0x1e>
             return (char *)s;
-c0107962:	8b 45 08             	mov    0x8(%ebp),%eax
-c0107965:	eb 13                	jmp    c010797a <strchr+0x31>
+c0108043:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108046:	eb 12                	jmp    c010805a <strchr+0x30>
         }
         s ++;
-c0107967:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+c0108048:	ff 45 08             	incl   0x8(%ebp)
  * The strchr() function returns a pointer to the first occurrence of
  * character in @s. If the value is not found, the function returns 'NULL'.
  * */
 char *
 strchr(const char *s, char c) {
     while (*s != '\0') {
-c010796b:	8b 45 08             	mov    0x8(%ebp),%eax
-c010796e:	0f b6 00             	movzbl (%eax),%eax
-c0107971:	84 c0                	test   %al,%al
-c0107973:	75 e2                	jne    c0107957 <strchr+0xe>
+c010804b:	8b 45 08             	mov    0x8(%ebp),%eax
+c010804e:	0f b6 00             	movzbl (%eax),%eax
+c0108051:	84 c0                	test   %al,%al
+c0108053:	75 e3                	jne    c0108038 <strchr+0xe>
         if (*s == c) {
             return (char *)s;
         }
         s ++;
     }
     return NULL;
-c0107975:	b8 00 00 00 00       	mov    $0x0,%eax
+c0108055:	b8 00 00 00 00       	mov    $0x0,%eax
 }
-c010797a:	c9                   	leave  
-c010797b:	c3                   	ret    
+c010805a:	c9                   	leave  
+c010805b:	c3                   	ret    
 
-c010797c <strfind>:
+c010805c <strfind>:
  * The strfind() function is like strchr() except that if @c is
  * not found in @s, then it returns a pointer to the null byte at the
  * end of @s, rather than 'NULL'.
  * */
 char *
 strfind(const char *s, char c) {
-c010797c:	55                   	push   %ebp
-c010797d:	89 e5                	mov    %esp,%ebp
-c010797f:	83 ec 04             	sub    $0x4,%esp
-c0107982:	8b 45 0c             	mov    0xc(%ebp),%eax
-c0107985:	88 45 fc             	mov    %al,-0x4(%ebp)
+c010805c:	55                   	push   %ebp
+c010805d:	89 e5                	mov    %esp,%ebp
+c010805f:	83 ec 04             	sub    $0x4,%esp
+c0108062:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0108065:	88 45 fc             	mov    %al,-0x4(%ebp)
     while (*s != '\0') {
-c0107988:	eb 0f                	jmp    c0107999 <strfind+0x1d>
+c0108068:	eb 0e                	jmp    c0108078 <strfind+0x1c>
         if (*s == c) {
-c010798a:	8b 45 08             	mov    0x8(%ebp),%eax
-c010798d:	0f b6 00             	movzbl (%eax),%eax
-c0107990:	3a 45 fc             	cmp    -0x4(%ebp),%al
-c0107993:	74 10                	je     c01079a5 <strfind+0x29>
+c010806a:	8b 45 08             	mov    0x8(%ebp),%eax
+c010806d:	0f b6 00             	movzbl (%eax),%eax
+c0108070:	3a 45 fc             	cmp    -0x4(%ebp),%al
+c0108073:	74 0f                	je     c0108084 <strfind+0x28>
             break;
         }
         s ++;
-c0107995:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+c0108075:	ff 45 08             	incl   0x8(%ebp)
  * not found in @s, then it returns a pointer to the null byte at the
  * end of @s, rather than 'NULL'.
  * */
 char *
 strfind(const char *s, char c) {
     while (*s != '\0') {
-c0107999:	8b 45 08             	mov    0x8(%ebp),%eax
-c010799c:	0f b6 00             	movzbl (%eax),%eax
-c010799f:	84 c0                	test   %al,%al
-c01079a1:	75 e7                	jne    c010798a <strfind+0xe>
-c01079a3:	eb 01                	jmp    c01079a6 <strfind+0x2a>
+c0108078:	8b 45 08             	mov    0x8(%ebp),%eax
+c010807b:	0f b6 00             	movzbl (%eax),%eax
+c010807e:	84 c0                	test   %al,%al
+c0108080:	75 e8                	jne    c010806a <strfind+0xe>
+c0108082:	eb 01                	jmp    c0108085 <strfind+0x29>
         if (*s == c) {
             break;
-c01079a5:	90                   	nop
+c0108084:	90                   	nop
         }
         s ++;
     }
     return (char *)s;
-c01079a6:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108085:	8b 45 08             	mov    0x8(%ebp),%eax
 }
-c01079a9:	c9                   	leave  
-c01079aa:	c3                   	ret    
+c0108088:	c9                   	leave  
+c0108089:	c3                   	ret    
 
-c01079ab <strtol>:
+c010808a <strtol>:
  * an optional "0x" or "0X" prefix.
  *
  * The strtol() function returns the converted integral number as a long int value.
  * */
 long
 strtol(const char *s, char **endptr, int base) {
-c01079ab:	55                   	push   %ebp
-c01079ac:	89 e5                	mov    %esp,%ebp
-c01079ae:	83 ec 10             	sub    $0x10,%esp
+c010808a:	55                   	push   %ebp
+c010808b:	89 e5                	mov    %esp,%ebp
+c010808d:	83 ec 10             	sub    $0x10,%esp
     int neg = 0;
-c01079b1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+c0108090:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
     long val = 0;
-c01079b8:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+c0108097:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
 
     // gobble initial whitespace
     while (*s == ' ' || *s == '\t') {
-c01079bf:	eb 04                	jmp    c01079c5 <strtol+0x1a>
+c010809e:	eb 03                	jmp    c01080a3 <strtol+0x19>
         s ++;
-c01079c1:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+c01080a0:	ff 45 08             	incl   0x8(%ebp)
 strtol(const char *s, char **endptr, int base) {
     int neg = 0;
     long val = 0;
 
     // gobble initial whitespace
     while (*s == ' ' || *s == '\t') {
-c01079c5:	8b 45 08             	mov    0x8(%ebp),%eax
-c01079c8:	0f b6 00             	movzbl (%eax),%eax
-c01079cb:	3c 20                	cmp    $0x20,%al
-c01079cd:	74 f2                	je     c01079c1 <strtol+0x16>
-c01079cf:	8b 45 08             	mov    0x8(%ebp),%eax
-c01079d2:	0f b6 00             	movzbl (%eax),%eax
-c01079d5:	3c 09                	cmp    $0x9,%al
-c01079d7:	74 e8                	je     c01079c1 <strtol+0x16>
+c01080a3:	8b 45 08             	mov    0x8(%ebp),%eax
+c01080a6:	0f b6 00             	movzbl (%eax),%eax
+c01080a9:	3c 20                	cmp    $0x20,%al
+c01080ab:	74 f3                	je     c01080a0 <strtol+0x16>
+c01080ad:	8b 45 08             	mov    0x8(%ebp),%eax
+c01080b0:	0f b6 00             	movzbl (%eax),%eax
+c01080b3:	3c 09                	cmp    $0x9,%al
+c01080b5:	74 e9                	je     c01080a0 <strtol+0x16>
         s ++;
     }
 
     // plus/minus sign
     if (*s == '+') {
-c01079d9:	8b 45 08             	mov    0x8(%ebp),%eax
-c01079dc:	0f b6 00             	movzbl (%eax),%eax
-c01079df:	3c 2b                	cmp    $0x2b,%al
-c01079e1:	75 06                	jne    c01079e9 <strtol+0x3e>
+c01080b7:	8b 45 08             	mov    0x8(%ebp),%eax
+c01080ba:	0f b6 00             	movzbl (%eax),%eax
+c01080bd:	3c 2b                	cmp    $0x2b,%al
+c01080bf:	75 05                	jne    c01080c6 <strtol+0x3c>
         s ++;
-c01079e3:	83 45 08 01          	addl   $0x1,0x8(%ebp)
-c01079e7:	eb 15                	jmp    c01079fe <strtol+0x53>
+c01080c1:	ff 45 08             	incl   0x8(%ebp)
+c01080c4:	eb 14                	jmp    c01080da <strtol+0x50>
     }
     else if (*s == '-') {
-c01079e9:	8b 45 08             	mov    0x8(%ebp),%eax
-c01079ec:	0f b6 00             	movzbl (%eax),%eax
-c01079ef:	3c 2d                	cmp    $0x2d,%al
-c01079f1:	75 0b                	jne    c01079fe <strtol+0x53>
+c01080c6:	8b 45 08             	mov    0x8(%ebp),%eax
+c01080c9:	0f b6 00             	movzbl (%eax),%eax
+c01080cc:	3c 2d                	cmp    $0x2d,%al
+c01080ce:	75 0a                	jne    c01080da <strtol+0x50>
         s ++, neg = 1;
-c01079f3:	83 45 08 01          	addl   $0x1,0x8(%ebp)
-c01079f7:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
+c01080d0:	ff 45 08             	incl   0x8(%ebp)
+c01080d3:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
     }
 
     // hex or octal base prefix
     if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x')) {
-c01079fe:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
-c0107a02:	74 06                	je     c0107a0a <strtol+0x5f>
-c0107a04:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
-c0107a08:	75 24                	jne    c0107a2e <strtol+0x83>
-c0107a0a:	8b 45 08             	mov    0x8(%ebp),%eax
-c0107a0d:	0f b6 00             	movzbl (%eax),%eax
-c0107a10:	3c 30                	cmp    $0x30,%al
-c0107a12:	75 1a                	jne    c0107a2e <strtol+0x83>
-c0107a14:	8b 45 08             	mov    0x8(%ebp),%eax
-c0107a17:	83 c0 01             	add    $0x1,%eax
-c0107a1a:	0f b6 00             	movzbl (%eax),%eax
-c0107a1d:	3c 78                	cmp    $0x78,%al
-c0107a1f:	75 0d                	jne    c0107a2e <strtol+0x83>
+c01080da:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+c01080de:	74 06                	je     c01080e6 <strtol+0x5c>
+c01080e0:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
+c01080e4:	75 22                	jne    c0108108 <strtol+0x7e>
+c01080e6:	8b 45 08             	mov    0x8(%ebp),%eax
+c01080e9:	0f b6 00             	movzbl (%eax),%eax
+c01080ec:	3c 30                	cmp    $0x30,%al
+c01080ee:	75 18                	jne    c0108108 <strtol+0x7e>
+c01080f0:	8b 45 08             	mov    0x8(%ebp),%eax
+c01080f3:	40                   	inc    %eax
+c01080f4:	0f b6 00             	movzbl (%eax),%eax
+c01080f7:	3c 78                	cmp    $0x78,%al
+c01080f9:	75 0d                	jne    c0108108 <strtol+0x7e>
         s += 2, base = 16;
-c0107a21:	83 45 08 02          	addl   $0x2,0x8(%ebp)
-c0107a25:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
-c0107a2c:	eb 2a                	jmp    c0107a58 <strtol+0xad>
+c01080fb:	83 45 08 02          	addl   $0x2,0x8(%ebp)
+c01080ff:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
+c0108106:	eb 29                	jmp    c0108131 <strtol+0xa7>
     }
     else if (base == 0 && s[0] == '0') {
-c0107a2e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
-c0107a32:	75 17                	jne    c0107a4b <strtol+0xa0>
-c0107a34:	8b 45 08             	mov    0x8(%ebp),%eax
-c0107a37:	0f b6 00             	movzbl (%eax),%eax
-c0107a3a:	3c 30                	cmp    $0x30,%al
-c0107a3c:	75 0d                	jne    c0107a4b <strtol+0xa0>
+c0108108:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+c010810c:	75 16                	jne    c0108124 <strtol+0x9a>
+c010810e:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108111:	0f b6 00             	movzbl (%eax),%eax
+c0108114:	3c 30                	cmp    $0x30,%al
+c0108116:	75 0c                	jne    c0108124 <strtol+0x9a>
         s ++, base = 8;
-c0107a3e:	83 45 08 01          	addl   $0x1,0x8(%ebp)
-c0107a42:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
-c0107a49:	eb 0d                	jmp    c0107a58 <strtol+0xad>
+c0108118:	ff 45 08             	incl   0x8(%ebp)
+c010811b:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
+c0108122:	eb 0d                	jmp    c0108131 <strtol+0xa7>
     }
     else if (base == 0) {
-c0107a4b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
-c0107a4f:	75 07                	jne    c0107a58 <strtol+0xad>
+c0108124:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+c0108128:	75 07                	jne    c0108131 <strtol+0xa7>
         base = 10;
-c0107a51:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)
+c010812a:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)
 
     // digits
     while (1) {
         int dig;
 
         if (*s >= '0' && *s <= '9') {
-c0107a58:	8b 45 08             	mov    0x8(%ebp),%eax
-c0107a5b:	0f b6 00             	movzbl (%eax),%eax
-c0107a5e:	3c 2f                	cmp    $0x2f,%al
-c0107a60:	7e 1b                	jle    c0107a7d <strtol+0xd2>
-c0107a62:	8b 45 08             	mov    0x8(%ebp),%eax
-c0107a65:	0f b6 00             	movzbl (%eax),%eax
-c0107a68:	3c 39                	cmp    $0x39,%al
-c0107a6a:	7f 11                	jg     c0107a7d <strtol+0xd2>
+c0108131:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108134:	0f b6 00             	movzbl (%eax),%eax
+c0108137:	3c 2f                	cmp    $0x2f,%al
+c0108139:	7e 1b                	jle    c0108156 <strtol+0xcc>
+c010813b:	8b 45 08             	mov    0x8(%ebp),%eax
+c010813e:	0f b6 00             	movzbl (%eax),%eax
+c0108141:	3c 39                	cmp    $0x39,%al
+c0108143:	7f 11                	jg     c0108156 <strtol+0xcc>
             dig = *s - '0';
-c0107a6c:	8b 45 08             	mov    0x8(%ebp),%eax
-c0107a6f:	0f b6 00             	movzbl (%eax),%eax
-c0107a72:	0f be c0             	movsbl %al,%eax
-c0107a75:	83 e8 30             	sub    $0x30,%eax
-c0107a78:	89 45 f4             	mov    %eax,-0xc(%ebp)
-c0107a7b:	eb 48                	jmp    c0107ac5 <strtol+0x11a>
+c0108145:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108148:	0f b6 00             	movzbl (%eax),%eax
+c010814b:	0f be c0             	movsbl %al,%eax
+c010814e:	83 e8 30             	sub    $0x30,%eax
+c0108151:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0108154:	eb 48                	jmp    c010819e <strtol+0x114>
         }
         else if (*s >= 'a' && *s <= 'z') {
-c0107a7d:	8b 45 08             	mov    0x8(%ebp),%eax
-c0107a80:	0f b6 00             	movzbl (%eax),%eax
-c0107a83:	3c 60                	cmp    $0x60,%al
-c0107a85:	7e 1b                	jle    c0107aa2 <strtol+0xf7>
-c0107a87:	8b 45 08             	mov    0x8(%ebp),%eax
-c0107a8a:	0f b6 00             	movzbl (%eax),%eax
-c0107a8d:	3c 7a                	cmp    $0x7a,%al
-c0107a8f:	7f 11                	jg     c0107aa2 <strtol+0xf7>
+c0108156:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108159:	0f b6 00             	movzbl (%eax),%eax
+c010815c:	3c 60                	cmp    $0x60,%al
+c010815e:	7e 1b                	jle    c010817b <strtol+0xf1>
+c0108160:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108163:	0f b6 00             	movzbl (%eax),%eax
+c0108166:	3c 7a                	cmp    $0x7a,%al
+c0108168:	7f 11                	jg     c010817b <strtol+0xf1>
             dig = *s - 'a' + 10;
-c0107a91:	8b 45 08             	mov    0x8(%ebp),%eax
-c0107a94:	0f b6 00             	movzbl (%eax),%eax
-c0107a97:	0f be c0             	movsbl %al,%eax
-c0107a9a:	83 e8 57             	sub    $0x57,%eax
-c0107a9d:	89 45 f4             	mov    %eax,-0xc(%ebp)
-c0107aa0:	eb 23                	jmp    c0107ac5 <strtol+0x11a>
+c010816a:	8b 45 08             	mov    0x8(%ebp),%eax
+c010816d:	0f b6 00             	movzbl (%eax),%eax
+c0108170:	0f be c0             	movsbl %al,%eax
+c0108173:	83 e8 57             	sub    $0x57,%eax
+c0108176:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c0108179:	eb 23                	jmp    c010819e <strtol+0x114>
         }
         else if (*s >= 'A' && *s <= 'Z') {
-c0107aa2:	8b 45 08             	mov    0x8(%ebp),%eax
-c0107aa5:	0f b6 00             	movzbl (%eax),%eax
-c0107aa8:	3c 40                	cmp    $0x40,%al
-c0107aaa:	7e 3c                	jle    c0107ae8 <strtol+0x13d>
-c0107aac:	8b 45 08             	mov    0x8(%ebp),%eax
-c0107aaf:	0f b6 00             	movzbl (%eax),%eax
-c0107ab2:	3c 5a                	cmp    $0x5a,%al
-c0107ab4:	7f 32                	jg     c0107ae8 <strtol+0x13d>
+c010817b:	8b 45 08             	mov    0x8(%ebp),%eax
+c010817e:	0f b6 00             	movzbl (%eax),%eax
+c0108181:	3c 40                	cmp    $0x40,%al
+c0108183:	7e 3b                	jle    c01081c0 <strtol+0x136>
+c0108185:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108188:	0f b6 00             	movzbl (%eax),%eax
+c010818b:	3c 5a                	cmp    $0x5a,%al
+c010818d:	7f 31                	jg     c01081c0 <strtol+0x136>
             dig = *s - 'A' + 10;
-c0107ab6:	8b 45 08             	mov    0x8(%ebp),%eax
-c0107ab9:	0f b6 00             	movzbl (%eax),%eax
-c0107abc:	0f be c0             	movsbl %al,%eax
-c0107abf:	83 e8 37             	sub    $0x37,%eax
-c0107ac2:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c010818f:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108192:	0f b6 00             	movzbl (%eax),%eax
+c0108195:	0f be c0             	movsbl %al,%eax
+c0108198:	83 e8 37             	sub    $0x37,%eax
+c010819b:	89 45 f4             	mov    %eax,-0xc(%ebp)
         }
         else {
             break;
         }
         if (dig >= base) {
-c0107ac5:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0107ac8:	3b 45 10             	cmp    0x10(%ebp),%eax
-c0107acb:	7d 1a                	jge    c0107ae7 <strtol+0x13c>
+c010819e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01081a1:	3b 45 10             	cmp    0x10(%ebp),%eax
+c01081a4:	7d 19                	jge    c01081bf <strtol+0x135>
             break;
         }
         s ++, val = (val * base) + dig;
-c0107acd:	83 45 08 01          	addl   $0x1,0x8(%ebp)
-c0107ad1:	8b 45 f8             	mov    -0x8(%ebp),%eax
-c0107ad4:	0f af 45 10          	imul   0x10(%ebp),%eax
-c0107ad8:	89 c2                	mov    %eax,%edx
-c0107ada:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0107add:	01 d0                	add    %edx,%eax
-c0107adf:	89 45 f8             	mov    %eax,-0x8(%ebp)
+c01081a6:	ff 45 08             	incl   0x8(%ebp)
+c01081a9:	8b 45 f8             	mov    -0x8(%ebp),%eax
+c01081ac:	0f af 45 10          	imul   0x10(%ebp),%eax
+c01081b0:	89 c2                	mov    %eax,%edx
+c01081b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01081b5:	01 d0                	add    %edx,%eax
+c01081b7:	89 45 f8             	mov    %eax,-0x8(%ebp)
         // we don't properly detect overflow!
     }
-c0107ae2:	e9 71 ff ff ff       	jmp    c0107a58 <strtol+0xad>
+c01081ba:	e9 72 ff ff ff       	jmp    c0108131 <strtol+0xa7>
         }
         else {
             break;
         }
         if (dig >= base) {
             break;
-c0107ae7:	90                   	nop
+c01081bf:	90                   	nop
         }
         s ++, val = (val * base) + dig;
         // we don't properly detect overflow!
     }
 
     if (endptr) {
-c0107ae8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
-c0107aec:	74 08                	je     c0107af6 <strtol+0x14b>
+c01081c0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+c01081c4:	74 08                	je     c01081ce <strtol+0x144>
         *endptr = (char *) s;
-c0107aee:	8b 45 0c             	mov    0xc(%ebp),%eax
-c0107af1:	8b 55 08             	mov    0x8(%ebp),%edx
-c0107af4:	89 10                	mov    %edx,(%eax)
+c01081c6:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01081c9:	8b 55 08             	mov    0x8(%ebp),%edx
+c01081cc:	89 10                	mov    %edx,(%eax)
     }
     return (neg ? -val : val);
-c0107af6:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
-c0107afa:	74 07                	je     c0107b03 <strtol+0x158>
-c0107afc:	8b 45 f8             	mov    -0x8(%ebp),%eax
-c0107aff:	f7 d8                	neg    %eax
-c0107b01:	eb 03                	jmp    c0107b06 <strtol+0x15b>
-c0107b03:	8b 45 f8             	mov    -0x8(%ebp),%eax
+c01081ce:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
+c01081d2:	74 07                	je     c01081db <strtol+0x151>
+c01081d4:	8b 45 f8             	mov    -0x8(%ebp),%eax
+c01081d7:	f7 d8                	neg    %eax
+c01081d9:	eb 03                	jmp    c01081de <strtol+0x154>
+c01081db:	8b 45 f8             	mov    -0x8(%ebp),%eax
 }
-c0107b06:	c9                   	leave  
-c0107b07:	c3                   	ret    
+c01081de:	c9                   	leave  
+c01081df:	c3                   	ret    
 
-c0107b08 <memset>:
+c01081e0 <memset>:
  * @n:      number of bytes to be set to the value
  *
  * The memset() function returns @s.
  * */
 void *
 memset(void *s, char c, size_t n) {
-c0107b08:	55                   	push   %ebp
-c0107b09:	89 e5                	mov    %esp,%ebp
-c0107b0b:	57                   	push   %edi
-c0107b0c:	83 ec 24             	sub    $0x24,%esp
-c0107b0f:	8b 45 0c             	mov    0xc(%ebp),%eax
-c0107b12:	88 45 d8             	mov    %al,-0x28(%ebp)
+c01081e0:	55                   	push   %ebp
+c01081e1:	89 e5                	mov    %esp,%ebp
+c01081e3:	57                   	push   %edi
+c01081e4:	83 ec 24             	sub    $0x24,%esp
+c01081e7:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01081ea:	88 45 d8             	mov    %al,-0x28(%ebp)
 #ifdef __HAVE_ARCH_MEMSET
     return __memset(s, c, n);
-c0107b15:	0f be 45 d8          	movsbl -0x28(%ebp),%eax
-c0107b19:	8b 55 08             	mov    0x8(%ebp),%edx
-c0107b1c:	89 55 f8             	mov    %edx,-0x8(%ebp)
-c0107b1f:	88 45 f7             	mov    %al,-0x9(%ebp)
-c0107b22:	8b 45 10             	mov    0x10(%ebp),%eax
-c0107b25:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c01081ed:	0f be 45 d8          	movsbl -0x28(%ebp),%eax
+c01081f1:	8b 55 08             	mov    0x8(%ebp),%edx
+c01081f4:	89 55 f8             	mov    %edx,-0x8(%ebp)
+c01081f7:	88 45 f7             	mov    %al,-0x9(%ebp)
+c01081fa:	8b 45 10             	mov    0x10(%ebp),%eax
+c01081fd:	89 45 f0             	mov    %eax,-0x10(%ebp)
 #ifndef __HAVE_ARCH_MEMSET
 #define __HAVE_ARCH_MEMSET
 static inline void *
 __memset(void *s, char c, size_t n) {
     int d0, d1;
     asm volatile (
-c0107b28:	8b 4d f0             	mov    -0x10(%ebp),%ecx
-c0107b2b:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
-c0107b2f:	8b 55 f8             	mov    -0x8(%ebp),%edx
-c0107b32:	89 d7                	mov    %edx,%edi
-c0107b34:	f3 aa                	rep stos %al,%es:(%edi)
-c0107b36:	89 fa                	mov    %edi,%edx
-c0107b38:	89 4d ec             	mov    %ecx,-0x14(%ebp)
-c0107b3b:	89 55 e8             	mov    %edx,-0x18(%ebp)
+c0108200:	8b 4d f0             	mov    -0x10(%ebp),%ecx
+c0108203:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
+c0108207:	8b 55 f8             	mov    -0x8(%ebp),%edx
+c010820a:	89 d7                	mov    %edx,%edi
+c010820c:	f3 aa                	rep stos %al,%es:(%edi)
+c010820e:	89 fa                	mov    %edi,%edx
+c0108210:	89 4d ec             	mov    %ecx,-0x14(%ebp)
+c0108213:	89 55 e8             	mov    %edx,-0x18(%ebp)
         "rep; stosb;"
         : "=&c" (d0), "=&D" (d1)
         : "0" (n), "a" (c), "1" (s)
         : "memory");
     return s;
-c0107b3e:	8b 45 f8             	mov    -0x8(%ebp),%eax
-c0107b41:	90                   	nop
+c0108216:	8b 45 f8             	mov    -0x8(%ebp),%eax
+c0108219:	90                   	nop
     while (n -- > 0) {
         *p ++ = c;
     }
     return s;
 #endif /* __HAVE_ARCH_MEMSET */
 }
-c0107b42:	83 c4 24             	add    $0x24,%esp
-c0107b45:	5f                   	pop    %edi
-c0107b46:	5d                   	pop    %ebp
-c0107b47:	c3                   	ret    
+c010821a:	83 c4 24             	add    $0x24,%esp
+c010821d:	5f                   	pop    %edi
+c010821e:	5d                   	pop    %ebp
+c010821f:	c3                   	ret    
 
-c0107b48 <memmove>:
+c0108220 <memmove>:
  * @n:      number of bytes to copy
  *
  * The memmove() function returns @dst.
  * */
 void *
 memmove(void *dst, const void *src, size_t n) {
-c0107b48:	55                   	push   %ebp
-c0107b49:	89 e5                	mov    %esp,%ebp
-c0107b4b:	57                   	push   %edi
-c0107b4c:	56                   	push   %esi
-c0107b4d:	53                   	push   %ebx
-c0107b4e:	83 ec 30             	sub    $0x30,%esp
-c0107b51:	8b 45 08             	mov    0x8(%ebp),%eax
-c0107b54:	89 45 f0             	mov    %eax,-0x10(%ebp)
-c0107b57:	8b 45 0c             	mov    0xc(%ebp),%eax
-c0107b5a:	89 45 ec             	mov    %eax,-0x14(%ebp)
-c0107b5d:	8b 45 10             	mov    0x10(%ebp),%eax
-c0107b60:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c0108220:	55                   	push   %ebp
+c0108221:	89 e5                	mov    %esp,%ebp
+c0108223:	57                   	push   %edi
+c0108224:	56                   	push   %esi
+c0108225:	53                   	push   %ebx
+c0108226:	83 ec 30             	sub    $0x30,%esp
+c0108229:	8b 45 08             	mov    0x8(%ebp),%eax
+c010822c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c010822f:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0108232:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c0108235:	8b 45 10             	mov    0x10(%ebp),%eax
+c0108238:	89 45 e8             	mov    %eax,-0x18(%ebp)
 
 #ifndef __HAVE_ARCH_MEMMOVE
 #define __HAVE_ARCH_MEMMOVE
 static inline void *
 __memmove(void *dst, const void *src, size_t n) {
     if (dst < src) {
-c0107b63:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0107b66:	3b 45 ec             	cmp    -0x14(%ebp),%eax
-c0107b69:	73 42                	jae    c0107bad <memmove+0x65>
-c0107b6b:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0107b6e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
-c0107b71:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c0107b74:	89 45 e0             	mov    %eax,-0x20(%ebp)
-c0107b77:	8b 45 e8             	mov    -0x18(%ebp),%eax
-c0107b7a:	89 45 dc             	mov    %eax,-0x24(%ebp)
+c010823b:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010823e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+c0108241:	73 42                	jae    c0108285 <memmove+0x65>
+c0108243:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0108246:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+c0108249:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c010824c:	89 45 e0             	mov    %eax,-0x20(%ebp)
+c010824f:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0108252:	89 45 dc             	mov    %eax,-0x24(%ebp)
         "andl $3, %%ecx;"
         "jz 1f;"
         "rep; movsb;"
         "1:"
         : "=&c" (d0), "=&D" (d1), "=&S" (d2)
         : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
-c0107b7d:	8b 45 dc             	mov    -0x24(%ebp),%eax
-c0107b80:	c1 e8 02             	shr    $0x2,%eax
-c0107b83:	89 c1                	mov    %eax,%ecx
+c0108255:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0108258:	c1 e8 02             	shr    $0x2,%eax
+c010825b:	89 c1                	mov    %eax,%ecx
 #ifndef __HAVE_ARCH_MEMCPY
 #define __HAVE_ARCH_MEMCPY
 static inline void *
 __memcpy(void *dst, const void *src, size_t n) {
     int d0, d1, d2;
     asm volatile (
-c0107b85:	8b 55 e4             	mov    -0x1c(%ebp),%edx
-c0107b88:	8b 45 e0             	mov    -0x20(%ebp),%eax
-c0107b8b:	89 d7                	mov    %edx,%edi
-c0107b8d:	89 c6                	mov    %eax,%esi
-c0107b8f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
-c0107b91:	8b 4d dc             	mov    -0x24(%ebp),%ecx
-c0107b94:	83 e1 03             	and    $0x3,%ecx
-c0107b97:	74 02                	je     c0107b9b <memmove+0x53>
-c0107b99:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
-c0107b9b:	89 f0                	mov    %esi,%eax
-c0107b9d:	89 fa                	mov    %edi,%edx
-c0107b9f:	89 4d d8             	mov    %ecx,-0x28(%ebp)
-c0107ba2:	89 55 d4             	mov    %edx,-0x2c(%ebp)
-c0107ba5:	89 45 d0             	mov    %eax,-0x30(%ebp)
+c010825d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c0108260:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0108263:	89 d7                	mov    %edx,%edi
+c0108265:	89 c6                	mov    %eax,%esi
+c0108267:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+c0108269:	8b 4d dc             	mov    -0x24(%ebp),%ecx
+c010826c:	83 e1 03             	and    $0x3,%ecx
+c010826f:	74 02                	je     c0108273 <memmove+0x53>
+c0108271:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+c0108273:	89 f0                	mov    %esi,%eax
+c0108275:	89 fa                	mov    %edi,%edx
+c0108277:	89 4d d8             	mov    %ecx,-0x28(%ebp)
+c010827a:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+c010827d:	89 45 d0             	mov    %eax,-0x30(%ebp)
         "rep; movsb;"
         "1:"
         : "=&c" (d0), "=&D" (d1), "=&S" (d2)
         : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
         : "memory");
     return dst;
-c0107ba8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0108280:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 #ifdef __HAVE_ARCH_MEMMOVE
     return __memmove(dst, src, n);
-c0107bab:	eb 36                	jmp    c0107be3 <memmove+0x9b>
+c0108283:	eb 36                	jmp    c01082bb <memmove+0x9b>
     asm volatile (
         "std;"
         "rep; movsb;"
         "cld;"
         : "=&c" (d0), "=&S" (d1), "=&D" (d2)
         : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
-c0107bad:	8b 45 e8             	mov    -0x18(%ebp),%eax
-c0107bb0:	8d 50 ff             	lea    -0x1(%eax),%edx
-c0107bb3:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c0107bb6:	01 c2                	add    %eax,%edx
-c0107bb8:	8b 45 e8             	mov    -0x18(%ebp),%eax
-c0107bbb:	8d 48 ff             	lea    -0x1(%eax),%ecx
-c0107bbe:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0107bc1:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
+c0108285:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0108288:	8d 50 ff             	lea    -0x1(%eax),%edx
+c010828b:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c010828e:	01 c2                	add    %eax,%edx
+c0108290:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0108293:	8d 48 ff             	lea    -0x1(%eax),%ecx
+c0108296:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0108299:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
 __memmove(void *dst, const void *src, size_t n) {
     if (dst < src) {
         return __memcpy(dst, src, n);
     }
     int d0, d1, d2;
     asm volatile (
-c0107bc4:	8b 45 e8             	mov    -0x18(%ebp),%eax
-c0107bc7:	89 c1                	mov    %eax,%ecx
-c0107bc9:	89 d8                	mov    %ebx,%eax
-c0107bcb:	89 d6                	mov    %edx,%esi
-c0107bcd:	89 c7                	mov    %eax,%edi
-c0107bcf:	fd                   	std    
-c0107bd0:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
-c0107bd2:	fc                   	cld    
-c0107bd3:	89 f8                	mov    %edi,%eax
-c0107bd5:	89 f2                	mov    %esi,%edx
-c0107bd7:	89 4d cc             	mov    %ecx,-0x34(%ebp)
-c0107bda:	89 55 c8             	mov    %edx,-0x38(%ebp)
-c0107bdd:	89 45 c4             	mov    %eax,-0x3c(%ebp)
+c010829c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c010829f:	89 c1                	mov    %eax,%ecx
+c01082a1:	89 d8                	mov    %ebx,%eax
+c01082a3:	89 d6                	mov    %edx,%esi
+c01082a5:	89 c7                	mov    %eax,%edi
+c01082a7:	fd                   	std    
+c01082a8:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+c01082aa:	fc                   	cld    
+c01082ab:	89 f8                	mov    %edi,%eax
+c01082ad:	89 f2                	mov    %esi,%edx
+c01082af:	89 4d cc             	mov    %ecx,-0x34(%ebp)
+c01082b2:	89 55 c8             	mov    %edx,-0x38(%ebp)
+c01082b5:	89 45 c4             	mov    %eax,-0x3c(%ebp)
         "rep; movsb;"
         "cld;"
         : "=&c" (d0), "=&S" (d1), "=&D" (d2)
         : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
         : "memory");
     return dst;
-c0107be0:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01082b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
             *d ++ = *s ++;
         }
     }
     return dst;
 #endif /* __HAVE_ARCH_MEMMOVE */
 }
-c0107be3:	83 c4 30             	add    $0x30,%esp
-c0107be6:	5b                   	pop    %ebx
-c0107be7:	5e                   	pop    %esi
-c0107be8:	5f                   	pop    %edi
-c0107be9:	5d                   	pop    %ebp
-c0107bea:	c3                   	ret    
+c01082bb:	83 c4 30             	add    $0x30,%esp
+c01082be:	5b                   	pop    %ebx
+c01082bf:	5e                   	pop    %esi
+c01082c0:	5f                   	pop    %edi
+c01082c1:	5d                   	pop    %ebp
+c01082c2:	c3                   	ret    
 
-c0107beb <memcpy>:
+c01082c3 <memcpy>:
  * it always copies exactly @n bytes. To avoid overflows, the size of arrays pointed
  * by both @src and @dst, should be at least @n bytes, and should not overlap
  * (for overlapping memory area, memmove is a safer approach).
  * */
 void *
 memcpy(void *dst, const void *src, size_t n) {
-c0107beb:	55                   	push   %ebp
-c0107bec:	89 e5                	mov    %esp,%ebp
-c0107bee:	57                   	push   %edi
-c0107bef:	56                   	push   %esi
-c0107bf0:	83 ec 20             	sub    $0x20,%esp
-c0107bf3:	8b 45 08             	mov    0x8(%ebp),%eax
-c0107bf6:	89 45 f4             	mov    %eax,-0xc(%ebp)
-c0107bf9:	8b 45 0c             	mov    0xc(%ebp),%eax
-c0107bfc:	89 45 f0             	mov    %eax,-0x10(%ebp)
-c0107bff:	8b 45 10             	mov    0x10(%ebp),%eax
-c0107c02:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c01082c3:	55                   	push   %ebp
+c01082c4:	89 e5                	mov    %esp,%ebp
+c01082c6:	57                   	push   %edi
+c01082c7:	56                   	push   %esi
+c01082c8:	83 ec 20             	sub    $0x20,%esp
+c01082cb:	8b 45 08             	mov    0x8(%ebp),%eax
+c01082ce:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c01082d1:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01082d4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c01082d7:	8b 45 10             	mov    0x10(%ebp),%eax
+c01082da:	89 45 ec             	mov    %eax,-0x14(%ebp)
         "andl $3, %%ecx;"
         "jz 1f;"
         "rep; movsb;"
         "1:"
         : "=&c" (d0), "=&D" (d1), "=&S" (d2)
         : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
-c0107c05:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c0107c08:	c1 e8 02             	shr    $0x2,%eax
-c0107c0b:	89 c1                	mov    %eax,%ecx
+c01082dd:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c01082e0:	c1 e8 02             	shr    $0x2,%eax
+c01082e3:	89 c1                	mov    %eax,%ecx
 #ifndef __HAVE_ARCH_MEMCPY
 #define __HAVE_ARCH_MEMCPY
 static inline void *
 __memcpy(void *dst, const void *src, size_t n) {
     int d0, d1, d2;
     asm volatile (
-c0107c0d:	8b 55 f4             	mov    -0xc(%ebp),%edx
-c0107c10:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0107c13:	89 d7                	mov    %edx,%edi
-c0107c15:	89 c6                	mov    %eax,%esi
-c0107c17:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
-c0107c19:	8b 4d ec             	mov    -0x14(%ebp),%ecx
-c0107c1c:	83 e1 03             	and    $0x3,%ecx
-c0107c1f:	74 02                	je     c0107c23 <memcpy+0x38>
-c0107c21:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
-c0107c23:	89 f0                	mov    %esi,%eax
-c0107c25:	89 fa                	mov    %edi,%edx
-c0107c27:	89 4d e8             	mov    %ecx,-0x18(%ebp)
-c0107c2a:	89 55 e4             	mov    %edx,-0x1c(%ebp)
-c0107c2d:	89 45 e0             	mov    %eax,-0x20(%ebp)
+c01082e5:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c01082e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01082eb:	89 d7                	mov    %edx,%edi
+c01082ed:	89 c6                	mov    %eax,%esi
+c01082ef:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+c01082f1:	8b 4d ec             	mov    -0x14(%ebp),%ecx
+c01082f4:	83 e1 03             	and    $0x3,%ecx
+c01082f7:	74 02                	je     c01082fb <memcpy+0x38>
+c01082f9:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+c01082fb:	89 f0                	mov    %esi,%eax
+c01082fd:	89 fa                	mov    %edi,%edx
+c01082ff:	89 4d e8             	mov    %ecx,-0x18(%ebp)
+c0108302:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+c0108305:	89 45 e0             	mov    %eax,-0x20(%ebp)
         "rep; movsb;"
         "1:"
         : "=&c" (d0), "=&D" (d1), "=&S" (d2)
         : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
         : "memory");
     return dst;
-c0107c30:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0108308:	8b 45 f4             	mov    -0xc(%ebp),%eax
 #ifdef __HAVE_ARCH_MEMCPY
     return __memcpy(dst, src, n);
-c0107c33:	90                   	nop
+c010830b:	90                   	nop
     while (n -- > 0) {
         *d ++ = *s ++;
     }
     return dst;
 #endif /* __HAVE_ARCH_MEMCPY */
 }
-c0107c34:	83 c4 20             	add    $0x20,%esp
-c0107c37:	5e                   	pop    %esi
-c0107c38:	5f                   	pop    %edi
-c0107c39:	5d                   	pop    %ebp
-c0107c3a:	c3                   	ret    
+c010830c:	83 c4 20             	add    $0x20,%esp
+c010830f:	5e                   	pop    %esi
+c0108310:	5f                   	pop    %edi
+c0108311:	5d                   	pop    %ebp
+c0108312:	c3                   	ret    
 
-c0107c3b <memcmp>:
+c0108313 <memcmp>:
  *   match in both memory blocks has a greater value in @v1 than in @v2
  *   as if evaluated as unsigned char values;
  * - And a value less than zero indicates the opposite.
  * */
 int
 memcmp(const void *v1, const void *v2, size_t n) {
-c0107c3b:	55                   	push   %ebp
-c0107c3c:	89 e5                	mov    %esp,%ebp
-c0107c3e:	83 ec 10             	sub    $0x10,%esp
+c0108313:	55                   	push   %ebp
+c0108314:	89 e5                	mov    %esp,%ebp
+c0108316:	83 ec 10             	sub    $0x10,%esp
     const char *s1 = (const char *)v1;
-c0107c41:	8b 45 08             	mov    0x8(%ebp),%eax
-c0107c44:	89 45 fc             	mov    %eax,-0x4(%ebp)
+c0108319:	8b 45 08             	mov    0x8(%ebp),%eax
+c010831c:	89 45 fc             	mov    %eax,-0x4(%ebp)
     const char *s2 = (const char *)v2;
-c0107c47:	8b 45 0c             	mov    0xc(%ebp),%eax
-c0107c4a:	89 45 f8             	mov    %eax,-0x8(%ebp)
+c010831f:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0108322:	89 45 f8             	mov    %eax,-0x8(%ebp)
     while (n -- > 0) {
-c0107c4d:	eb 30                	jmp    c0107c7f <memcmp+0x44>
+c0108325:	eb 2e                	jmp    c0108355 <memcmp+0x42>
         if (*s1 != *s2) {
-c0107c4f:	8b 45 fc             	mov    -0x4(%ebp),%eax
-c0107c52:	0f b6 10             	movzbl (%eax),%edx
-c0107c55:	8b 45 f8             	mov    -0x8(%ebp),%eax
-c0107c58:	0f b6 00             	movzbl (%eax),%eax
-c0107c5b:	38 c2                	cmp    %al,%dl
-c0107c5d:	74 18                	je     c0107c77 <memcmp+0x3c>
+c0108327:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c010832a:	0f b6 10             	movzbl (%eax),%edx
+c010832d:	8b 45 f8             	mov    -0x8(%ebp),%eax
+c0108330:	0f b6 00             	movzbl (%eax),%eax
+c0108333:	38 c2                	cmp    %al,%dl
+c0108335:	74 18                	je     c010834f <memcmp+0x3c>
             return (int)((unsigned char)*s1 - (unsigned char)*s2);
-c0107c5f:	8b 45 fc             	mov    -0x4(%ebp),%eax
-c0107c62:	0f b6 00             	movzbl (%eax),%eax
-c0107c65:	0f b6 d0             	movzbl %al,%edx
-c0107c68:	8b 45 f8             	mov    -0x8(%ebp),%eax
-c0107c6b:	0f b6 00             	movzbl (%eax),%eax
-c0107c6e:	0f b6 c0             	movzbl %al,%eax
-c0107c71:	29 c2                	sub    %eax,%edx
-c0107c73:	89 d0                	mov    %edx,%eax
-c0107c75:	eb 1a                	jmp    c0107c91 <memcmp+0x56>
+c0108337:	8b 45 fc             	mov    -0x4(%ebp),%eax
+c010833a:	0f b6 00             	movzbl (%eax),%eax
+c010833d:	0f b6 d0             	movzbl %al,%edx
+c0108340:	8b 45 f8             	mov    -0x8(%ebp),%eax
+c0108343:	0f b6 00             	movzbl (%eax),%eax
+c0108346:	0f b6 c0             	movzbl %al,%eax
+c0108349:	29 c2                	sub    %eax,%edx
+c010834b:	89 d0                	mov    %edx,%eax
+c010834d:	eb 18                	jmp    c0108367 <memcmp+0x54>
         }
         s1 ++, s2 ++;
-c0107c77:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
-c0107c7b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+c010834f:	ff 45 fc             	incl   -0x4(%ebp)
+c0108352:	ff 45 f8             	incl   -0x8(%ebp)
  * */
 int
 memcmp(const void *v1, const void *v2, size_t n) {
     const char *s1 = (const char *)v1;
     const char *s2 = (const char *)v2;
     while (n -- > 0) {
-c0107c7f:	8b 45 10             	mov    0x10(%ebp),%eax
-c0107c82:	8d 50 ff             	lea    -0x1(%eax),%edx
-c0107c85:	89 55 10             	mov    %edx,0x10(%ebp)
-c0107c88:	85 c0                	test   %eax,%eax
-c0107c8a:	75 c3                	jne    c0107c4f <memcmp+0x14>
+c0108355:	8b 45 10             	mov    0x10(%ebp),%eax
+c0108358:	8d 50 ff             	lea    -0x1(%eax),%edx
+c010835b:	89 55 10             	mov    %edx,0x10(%ebp)
+c010835e:	85 c0                	test   %eax,%eax
+c0108360:	75 c5                	jne    c0108327 <memcmp+0x14>
         if (*s1 != *s2) {
             return (int)((unsigned char)*s1 - (unsigned char)*s2);
         }
         s1 ++, s2 ++;
     }
     return 0;
-c0107c8c:	b8 00 00 00 00       	mov    $0x0,%eax
+c0108362:	b8 00 00 00 00       	mov    $0x0,%eax
 }
-c0107c91:	c9                   	leave  
-c0107c92:	c3                   	ret    
+c0108367:	c9                   	leave  
+c0108368:	c3                   	ret    
 
-c0107c93 <printnum>:
+c0108369 <printnum>:
  * @width:      maximum number of digits, if the actual width is less than @width, use @padc instead
  * @padc:       character that padded on the left if the actual width is less than @width
  * */
 static void
 printnum(void (*putch)(int, void*), void *putdat,
         unsigned long long num, unsigned base, int width, int padc) {
-c0107c93:	55                   	push   %ebp
-c0107c94:	89 e5                	mov    %esp,%ebp
-c0107c96:	83 ec 38             	sub    $0x38,%esp
-c0107c99:	8b 45 10             	mov    0x10(%ebp),%eax
-c0107c9c:	89 45 d0             	mov    %eax,-0x30(%ebp)
-c0107c9f:	8b 45 14             	mov    0x14(%ebp),%eax
-c0107ca2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+c0108369:	55                   	push   %ebp
+c010836a:	89 e5                	mov    %esp,%ebp
+c010836c:	83 ec 58             	sub    $0x58,%esp
+c010836f:	8b 45 10             	mov    0x10(%ebp),%eax
+c0108372:	89 45 d0             	mov    %eax,-0x30(%ebp)
+c0108375:	8b 45 14             	mov    0x14(%ebp),%eax
+c0108378:	89 45 d4             	mov    %eax,-0x2c(%ebp)
     unsigned long long result = num;
-c0107ca5:	8b 45 d0             	mov    -0x30(%ebp),%eax
-c0107ca8:	8b 55 d4             	mov    -0x2c(%ebp),%edx
-c0107cab:	89 45 e8             	mov    %eax,-0x18(%ebp)
-c0107cae:	89 55 ec             	mov    %edx,-0x14(%ebp)
+c010837b:	8b 45 d0             	mov    -0x30(%ebp),%eax
+c010837e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+c0108381:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c0108384:	89 55 ec             	mov    %edx,-0x14(%ebp)
     unsigned mod = do_div(result, base);
-c0107cb1:	8b 45 18             	mov    0x18(%ebp),%eax
-c0107cb4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
-c0107cb7:	8b 45 e8             	mov    -0x18(%ebp),%eax
-c0107cba:	8b 55 ec             	mov    -0x14(%ebp),%edx
-c0107cbd:	89 45 e0             	mov    %eax,-0x20(%ebp)
-c0107cc0:	89 55 f0             	mov    %edx,-0x10(%ebp)
-c0107cc3:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0107cc6:	89 45 f4             	mov    %eax,-0xc(%ebp)
-c0107cc9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
-c0107ccd:	74 1c                	je     c0107ceb <printnum+0x58>
-c0107ccf:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0107cd2:	ba 00 00 00 00       	mov    $0x0,%edx
-c0107cd7:	f7 75 e4             	divl   -0x1c(%ebp)
-c0107cda:	89 55 f4             	mov    %edx,-0xc(%ebp)
-c0107cdd:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0107ce0:	ba 00 00 00 00       	mov    $0x0,%edx
-c0107ce5:	f7 75 e4             	divl   -0x1c(%ebp)
-c0107ce8:	89 45 f0             	mov    %eax,-0x10(%ebp)
-c0107ceb:	8b 45 e0             	mov    -0x20(%ebp),%eax
-c0107cee:	8b 55 f4             	mov    -0xc(%ebp),%edx
-c0107cf1:	f7 75 e4             	divl   -0x1c(%ebp)
-c0107cf4:	89 45 e0             	mov    %eax,-0x20(%ebp)
-c0107cf7:	89 55 dc             	mov    %edx,-0x24(%ebp)
-c0107cfa:	8b 45 e0             	mov    -0x20(%ebp),%eax
-c0107cfd:	8b 55 f0             	mov    -0x10(%ebp),%edx
-c0107d00:	89 45 e8             	mov    %eax,-0x18(%ebp)
-c0107d03:	89 55 ec             	mov    %edx,-0x14(%ebp)
-c0107d06:	8b 45 dc             	mov    -0x24(%ebp),%eax
-c0107d09:	89 45 d8             	mov    %eax,-0x28(%ebp)
+c0108387:	8b 45 18             	mov    0x18(%ebp),%eax
+c010838a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+c010838d:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0108390:	8b 55 ec             	mov    -0x14(%ebp),%edx
+c0108393:	89 45 e0             	mov    %eax,-0x20(%ebp)
+c0108396:	89 55 f0             	mov    %edx,-0x10(%ebp)
+c0108399:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c010839c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c010839f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+c01083a3:	74 1c                	je     c01083c1 <printnum+0x58>
+c01083a5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01083a8:	ba 00 00 00 00       	mov    $0x0,%edx
+c01083ad:	f7 75 e4             	divl   -0x1c(%ebp)
+c01083b0:	89 55 f4             	mov    %edx,-0xc(%ebp)
+c01083b3:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01083b6:	ba 00 00 00 00       	mov    $0x0,%edx
+c01083bb:	f7 75 e4             	divl   -0x1c(%ebp)
+c01083be:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c01083c1:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c01083c4:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c01083c7:	f7 75 e4             	divl   -0x1c(%ebp)
+c01083ca:	89 45 e0             	mov    %eax,-0x20(%ebp)
+c01083cd:	89 55 dc             	mov    %edx,-0x24(%ebp)
+c01083d0:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c01083d3:	8b 55 f0             	mov    -0x10(%ebp),%edx
+c01083d6:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c01083d9:	89 55 ec             	mov    %edx,-0x14(%ebp)
+c01083dc:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c01083df:	89 45 d8             	mov    %eax,-0x28(%ebp)
 
     // first recursively print all preceding (more significant) digits
     if (num >= base) {
-c0107d0c:	8b 45 18             	mov    0x18(%ebp),%eax
-c0107d0f:	ba 00 00 00 00       	mov    $0x0,%edx
-c0107d14:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
-c0107d17:	77 41                	ja     c0107d5a <printnum+0xc7>
-c0107d19:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
-c0107d1c:	72 05                	jb     c0107d23 <printnum+0x90>
-c0107d1e:	3b 45 d0             	cmp    -0x30(%ebp),%eax
-c0107d21:	77 37                	ja     c0107d5a <printnum+0xc7>
+c01083e2:	8b 45 18             	mov    0x18(%ebp),%eax
+c01083e5:	ba 00 00 00 00       	mov    $0x0,%edx
+c01083ea:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+c01083ed:	77 56                	ja     c0108445 <printnum+0xdc>
+c01083ef:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+c01083f2:	72 05                	jb     c01083f9 <printnum+0x90>
+c01083f4:	3b 45 d0             	cmp    -0x30(%ebp),%eax
+c01083f7:	77 4c                	ja     c0108445 <printnum+0xdc>
         printnum(putch, putdat, result, base, width - 1, padc);
-c0107d23:	8b 45 1c             	mov    0x1c(%ebp),%eax
-c0107d26:	83 e8 01             	sub    $0x1,%eax
-c0107d29:	83 ec 04             	sub    $0x4,%esp
-c0107d2c:	ff 75 20             	pushl  0x20(%ebp)
-c0107d2f:	50                   	push   %eax
-c0107d30:	ff 75 18             	pushl  0x18(%ebp)
-c0107d33:	ff 75 ec             	pushl  -0x14(%ebp)
-c0107d36:	ff 75 e8             	pushl  -0x18(%ebp)
-c0107d39:	ff 75 0c             	pushl  0xc(%ebp)
-c0107d3c:	ff 75 08             	pushl  0x8(%ebp)
-c0107d3f:	e8 4f ff ff ff       	call   c0107c93 <printnum>
-c0107d44:	83 c4 20             	add    $0x20,%esp
-c0107d47:	eb 1b                	jmp    c0107d64 <printnum+0xd1>
+c01083f9:	8b 45 1c             	mov    0x1c(%ebp),%eax
+c01083fc:	8d 50 ff             	lea    -0x1(%eax),%edx
+c01083ff:	8b 45 20             	mov    0x20(%ebp),%eax
+c0108402:	89 44 24 18          	mov    %eax,0x18(%esp)
+c0108406:	89 54 24 14          	mov    %edx,0x14(%esp)
+c010840a:	8b 45 18             	mov    0x18(%ebp),%eax
+c010840d:	89 44 24 10          	mov    %eax,0x10(%esp)
+c0108411:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0108414:	8b 55 ec             	mov    -0x14(%ebp),%edx
+c0108417:	89 44 24 08          	mov    %eax,0x8(%esp)
+c010841b:	89 54 24 0c          	mov    %edx,0xc(%esp)
+c010841f:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0108422:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0108426:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108429:	89 04 24             	mov    %eax,(%esp)
+c010842c:	e8 38 ff ff ff       	call   c0108369 <printnum>
+c0108431:	eb 1b                	jmp    c010844e <printnum+0xe5>
     } else {
         // print any needed pad characters before first digit
         while (-- width > 0)
             putch(padc, putdat);
-c0107d49:	83 ec 08             	sub    $0x8,%esp
-c0107d4c:	ff 75 0c             	pushl  0xc(%ebp)
-c0107d4f:	ff 75 20             	pushl  0x20(%ebp)
-c0107d52:	8b 45 08             	mov    0x8(%ebp),%eax
-c0107d55:	ff d0                	call   *%eax
-c0107d57:	83 c4 10             	add    $0x10,%esp
+c0108433:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0108436:	89 44 24 04          	mov    %eax,0x4(%esp)
+c010843a:	8b 45 20             	mov    0x20(%ebp),%eax
+c010843d:	89 04 24             	mov    %eax,(%esp)
+c0108440:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108443:	ff d0                	call   *%eax
     // first recursively print all preceding (more significant) digits
     if (num >= base) {
         printnum(putch, putdat, result, base, width - 1, padc);
     } else {
         // print any needed pad characters before first digit
         while (-- width > 0)
-c0107d5a:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
-c0107d5e:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
-c0107d62:	7f e5                	jg     c0107d49 <printnum+0xb6>
+c0108445:	ff 4d 1c             	decl   0x1c(%ebp)
+c0108448:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
+c010844c:	7f e5                	jg     c0108433 <printnum+0xca>
             putch(padc, putdat);
     }
     // then print this (the least significant) digit
     putch("0123456789abcdef"[mod], putdat);
-c0107d64:	8b 45 d8             	mov    -0x28(%ebp),%eax
-c0107d67:	05 24 a2 10 c0       	add    $0xc010a224,%eax
-c0107d6c:	0f b6 00             	movzbl (%eax),%eax
-c0107d6f:	0f be c0             	movsbl %al,%eax
-c0107d72:	83 ec 08             	sub    $0x8,%esp
-c0107d75:	ff 75 0c             	pushl  0xc(%ebp)
-c0107d78:	50                   	push   %eax
-c0107d79:	8b 45 08             	mov    0x8(%ebp),%eax
-c0107d7c:	ff d0                	call   *%eax
-c0107d7e:	83 c4 10             	add    $0x10,%esp
-}
-c0107d81:	90                   	nop
-c0107d82:	c9                   	leave  
-c0107d83:	c3                   	ret    
+c010844e:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c0108451:	05 54 a9 10 c0       	add    $0xc010a954,%eax
+c0108456:	0f b6 00             	movzbl (%eax),%eax
+c0108459:	0f be c0             	movsbl %al,%eax
+c010845c:	8b 55 0c             	mov    0xc(%ebp),%edx
+c010845f:	89 54 24 04          	mov    %edx,0x4(%esp)
+c0108463:	89 04 24             	mov    %eax,(%esp)
+c0108466:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108469:	ff d0                	call   *%eax
+}
+c010846b:	90                   	nop
+c010846c:	c9                   	leave  
+c010846d:	c3                   	ret    
 
-c0107d84 <getuint>:
+c010846e <getuint>:
  * getuint - get an unsigned int of various possible sizes from a varargs list
  * @ap:         a varargs list pointer
  * @lflag:      determines the size of the vararg that @ap points to
  * */
 static unsigned long long
 getuint(va_list *ap, int lflag) {
-c0107d84:	55                   	push   %ebp
-c0107d85:	89 e5                	mov    %esp,%ebp
+c010846e:	55                   	push   %ebp
+c010846f:	89 e5                	mov    %esp,%ebp
     if (lflag >= 2) {
-c0107d87:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
-c0107d8b:	7e 14                	jle    c0107da1 <getuint+0x1d>
+c0108471:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+c0108475:	7e 14                	jle    c010848b <getuint+0x1d>
         return va_arg(*ap, unsigned long long);
-c0107d8d:	8b 45 08             	mov    0x8(%ebp),%eax
-c0107d90:	8b 00                	mov    (%eax),%eax
-c0107d92:	8d 48 08             	lea    0x8(%eax),%ecx
-c0107d95:	8b 55 08             	mov    0x8(%ebp),%edx
-c0107d98:	89 0a                	mov    %ecx,(%edx)
-c0107d9a:	8b 50 04             	mov    0x4(%eax),%edx
-c0107d9d:	8b 00                	mov    (%eax),%eax
-c0107d9f:	eb 30                	jmp    c0107dd1 <getuint+0x4d>
+c0108477:	8b 45 08             	mov    0x8(%ebp),%eax
+c010847a:	8b 00                	mov    (%eax),%eax
+c010847c:	8d 48 08             	lea    0x8(%eax),%ecx
+c010847f:	8b 55 08             	mov    0x8(%ebp),%edx
+c0108482:	89 0a                	mov    %ecx,(%edx)
+c0108484:	8b 50 04             	mov    0x4(%eax),%edx
+c0108487:	8b 00                	mov    (%eax),%eax
+c0108489:	eb 30                	jmp    c01084bb <getuint+0x4d>
     }
     else if (lflag) {
-c0107da1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
-c0107da5:	74 16                	je     c0107dbd <getuint+0x39>
+c010848b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+c010848f:	74 16                	je     c01084a7 <getuint+0x39>
         return va_arg(*ap, unsigned long);
-c0107da7:	8b 45 08             	mov    0x8(%ebp),%eax
-c0107daa:	8b 00                	mov    (%eax),%eax
-c0107dac:	8d 48 04             	lea    0x4(%eax),%ecx
-c0107daf:	8b 55 08             	mov    0x8(%ebp),%edx
-c0107db2:	89 0a                	mov    %ecx,(%edx)
-c0107db4:	8b 00                	mov    (%eax),%eax
-c0107db6:	ba 00 00 00 00       	mov    $0x0,%edx
-c0107dbb:	eb 14                	jmp    c0107dd1 <getuint+0x4d>
+c0108491:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108494:	8b 00                	mov    (%eax),%eax
+c0108496:	8d 48 04             	lea    0x4(%eax),%ecx
+c0108499:	8b 55 08             	mov    0x8(%ebp),%edx
+c010849c:	89 0a                	mov    %ecx,(%edx)
+c010849e:	8b 00                	mov    (%eax),%eax
+c01084a0:	ba 00 00 00 00       	mov    $0x0,%edx
+c01084a5:	eb 14                	jmp    c01084bb <getuint+0x4d>
     }
     else {
         return va_arg(*ap, unsigned int);
-c0107dbd:	8b 45 08             	mov    0x8(%ebp),%eax
-c0107dc0:	8b 00                	mov    (%eax),%eax
-c0107dc2:	8d 48 04             	lea    0x4(%eax),%ecx
-c0107dc5:	8b 55 08             	mov    0x8(%ebp),%edx
-c0107dc8:	89 0a                	mov    %ecx,(%edx)
-c0107dca:	8b 00                	mov    (%eax),%eax
-c0107dcc:	ba 00 00 00 00       	mov    $0x0,%edx
+c01084a7:	8b 45 08             	mov    0x8(%ebp),%eax
+c01084aa:	8b 00                	mov    (%eax),%eax
+c01084ac:	8d 48 04             	lea    0x4(%eax),%ecx
+c01084af:	8b 55 08             	mov    0x8(%ebp),%edx
+c01084b2:	89 0a                	mov    %ecx,(%edx)
+c01084b4:	8b 00                	mov    (%eax),%eax
+c01084b6:	ba 00 00 00 00       	mov    $0x0,%edx
     }
 }
-c0107dd1:	5d                   	pop    %ebp
-c0107dd2:	c3                   	ret    
+c01084bb:	5d                   	pop    %ebp
+c01084bc:	c3                   	ret    
 
-c0107dd3 <getint>:
+c01084bd <getint>:
  * getint - same as getuint but signed, we can't use getuint because of sign extension
  * @ap:         a varargs list pointer
  * @lflag:      determines the size of the vararg that @ap points to
  * */
 static long long
 getint(va_list *ap, int lflag) {
-c0107dd3:	55                   	push   %ebp
-c0107dd4:	89 e5                	mov    %esp,%ebp
+c01084bd:	55                   	push   %ebp
+c01084be:	89 e5                	mov    %esp,%ebp
     if (lflag >= 2) {
-c0107dd6:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
-c0107dda:	7e 14                	jle    c0107df0 <getint+0x1d>
+c01084c0:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+c01084c4:	7e 14                	jle    c01084da <getint+0x1d>
         return va_arg(*ap, long long);
-c0107ddc:	8b 45 08             	mov    0x8(%ebp),%eax
-c0107ddf:	8b 00                	mov    (%eax),%eax
-c0107de1:	8d 48 08             	lea    0x8(%eax),%ecx
-c0107de4:	8b 55 08             	mov    0x8(%ebp),%edx
-c0107de7:	89 0a                	mov    %ecx,(%edx)
-c0107de9:	8b 50 04             	mov    0x4(%eax),%edx
-c0107dec:	8b 00                	mov    (%eax),%eax
-c0107dee:	eb 28                	jmp    c0107e18 <getint+0x45>
+c01084c6:	8b 45 08             	mov    0x8(%ebp),%eax
+c01084c9:	8b 00                	mov    (%eax),%eax
+c01084cb:	8d 48 08             	lea    0x8(%eax),%ecx
+c01084ce:	8b 55 08             	mov    0x8(%ebp),%edx
+c01084d1:	89 0a                	mov    %ecx,(%edx)
+c01084d3:	8b 50 04             	mov    0x4(%eax),%edx
+c01084d6:	8b 00                	mov    (%eax),%eax
+c01084d8:	eb 28                	jmp    c0108502 <getint+0x45>
     }
     else if (lflag) {
-c0107df0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
-c0107df4:	74 12                	je     c0107e08 <getint+0x35>
+c01084da:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+c01084de:	74 12                	je     c01084f2 <getint+0x35>
         return va_arg(*ap, long);
-c0107df6:	8b 45 08             	mov    0x8(%ebp),%eax
-c0107df9:	8b 00                	mov    (%eax),%eax
-c0107dfb:	8d 48 04             	lea    0x4(%eax),%ecx
-c0107dfe:	8b 55 08             	mov    0x8(%ebp),%edx
-c0107e01:	89 0a                	mov    %ecx,(%edx)
-c0107e03:	8b 00                	mov    (%eax),%eax
-c0107e05:	99                   	cltd   
-c0107e06:	eb 10                	jmp    c0107e18 <getint+0x45>
+c01084e0:	8b 45 08             	mov    0x8(%ebp),%eax
+c01084e3:	8b 00                	mov    (%eax),%eax
+c01084e5:	8d 48 04             	lea    0x4(%eax),%ecx
+c01084e8:	8b 55 08             	mov    0x8(%ebp),%edx
+c01084eb:	89 0a                	mov    %ecx,(%edx)
+c01084ed:	8b 00                	mov    (%eax),%eax
+c01084ef:	99                   	cltd   
+c01084f0:	eb 10                	jmp    c0108502 <getint+0x45>
     }
     else {
         return va_arg(*ap, int);
-c0107e08:	8b 45 08             	mov    0x8(%ebp),%eax
-c0107e0b:	8b 00                	mov    (%eax),%eax
-c0107e0d:	8d 48 04             	lea    0x4(%eax),%ecx
-c0107e10:	8b 55 08             	mov    0x8(%ebp),%edx
-c0107e13:	89 0a                	mov    %ecx,(%edx)
-c0107e15:	8b 00                	mov    (%eax),%eax
-c0107e17:	99                   	cltd   
+c01084f2:	8b 45 08             	mov    0x8(%ebp),%eax
+c01084f5:	8b 00                	mov    (%eax),%eax
+c01084f7:	8d 48 04             	lea    0x4(%eax),%ecx
+c01084fa:	8b 55 08             	mov    0x8(%ebp),%edx
+c01084fd:	89 0a                	mov    %ecx,(%edx)
+c01084ff:	8b 00                	mov    (%eax),%eax
+c0108501:	99                   	cltd   
     }
 }
-c0107e18:	5d                   	pop    %ebp
-c0107e19:	c3                   	ret    
+c0108502:	5d                   	pop    %ebp
+c0108503:	c3                   	ret    
 
-c0107e1a <printfmt>:
+c0108504 <printfmt>:
  * @putch:      specified putch function, print a single character
  * @putdat:     used by @putch function
  * @fmt:        the format string to use
  * */
 void
 printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...) {
-c0107e1a:	55                   	push   %ebp
-c0107e1b:	89 e5                	mov    %esp,%ebp
-c0107e1d:	83 ec 18             	sub    $0x18,%esp
+c0108504:	55                   	push   %ebp
+c0108505:	89 e5                	mov    %esp,%ebp
+c0108507:	83 ec 28             	sub    $0x28,%esp
     va_list ap;
 
     va_start(ap, fmt);
-c0107e20:	8d 45 14             	lea    0x14(%ebp),%eax
-c0107e23:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c010850a:	8d 45 14             	lea    0x14(%ebp),%eax
+c010850d:	89 45 f4             	mov    %eax,-0xc(%ebp)
     vprintfmt(putch, putdat, fmt, ap);
-c0107e26:	8b 45 f4             	mov    -0xc(%ebp),%eax
-c0107e29:	50                   	push   %eax
-c0107e2a:	ff 75 10             	pushl  0x10(%ebp)
-c0107e2d:	ff 75 0c             	pushl  0xc(%ebp)
-c0107e30:	ff 75 08             	pushl  0x8(%ebp)
-c0107e33:	e8 06 00 00 00       	call   c0107e3e <vprintfmt>
-c0107e38:	83 c4 10             	add    $0x10,%esp
+c0108510:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0108513:	89 44 24 0c          	mov    %eax,0xc(%esp)
+c0108517:	8b 45 10             	mov    0x10(%ebp),%eax
+c010851a:	89 44 24 08          	mov    %eax,0x8(%esp)
+c010851e:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0108521:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0108525:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108528:	89 04 24             	mov    %eax,(%esp)
+c010852b:	e8 03 00 00 00       	call   c0108533 <vprintfmt>
     va_end(ap);
 }
-c0107e3b:	90                   	nop
-c0107e3c:	c9                   	leave  
-c0107e3d:	c3                   	ret    
+c0108530:	90                   	nop
+c0108531:	c9                   	leave  
+c0108532:	c3                   	ret    
 
-c0107e3e <vprintfmt>:
+c0108533 <vprintfmt>:
  *
  * Call this function if you are already dealing with a va_list.
  * Or you probably want printfmt() instead.
  * */
 void
 vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap) {
-c0107e3e:	55                   	push   %ebp
-c0107e3f:	89 e5                	mov    %esp,%ebp
-c0107e41:	56                   	push   %esi
-c0107e42:	53                   	push   %ebx
-c0107e43:	83 ec 20             	sub    $0x20,%esp
+c0108533:	55                   	push   %ebp
+c0108534:	89 e5                	mov    %esp,%ebp
+c0108536:	56                   	push   %esi
+c0108537:	53                   	push   %ebx
+c0108538:	83 ec 40             	sub    $0x40,%esp
     register int ch, err;
     unsigned long long num;
     int base, width, precision, lflag, altflag;
 
     while (1) {
         while ((ch = *(unsigned char *)fmt ++) != '%') {
-c0107e46:	eb 17                	jmp    c0107e5f <vprintfmt+0x21>
+c010853b:	eb 17                	jmp    c0108554 <vprintfmt+0x21>
             if (ch == '\0') {
-c0107e48:	85 db                	test   %ebx,%ebx
-c0107e4a:	0f 84 8e 03 00 00    	je     c01081de <vprintfmt+0x3a0>
+c010853d:	85 db                	test   %ebx,%ebx
+c010853f:	0f 84 bf 03 00 00    	je     c0108904 <vprintfmt+0x3d1>
                 return;
             }
             putch(ch, putdat);
-c0107e50:	83 ec 08             	sub    $0x8,%esp
-c0107e53:	ff 75 0c             	pushl  0xc(%ebp)
-c0107e56:	53                   	push   %ebx
-c0107e57:	8b 45 08             	mov    0x8(%ebp),%eax
-c0107e5a:	ff d0                	call   *%eax
-c0107e5c:	83 c4 10             	add    $0x10,%esp
+c0108545:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0108548:	89 44 24 04          	mov    %eax,0x4(%esp)
+c010854c:	89 1c 24             	mov    %ebx,(%esp)
+c010854f:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108552:	ff d0                	call   *%eax
     register int ch, err;
     unsigned long long num;
     int base, width, precision, lflag, altflag;
 
     while (1) {
         while ((ch = *(unsigned char *)fmt ++) != '%') {
-c0107e5f:	8b 45 10             	mov    0x10(%ebp),%eax
-c0107e62:	8d 50 01             	lea    0x1(%eax),%edx
-c0107e65:	89 55 10             	mov    %edx,0x10(%ebp)
-c0107e68:	0f b6 00             	movzbl (%eax),%eax
-c0107e6b:	0f b6 d8             	movzbl %al,%ebx
-c0107e6e:	83 fb 25             	cmp    $0x25,%ebx
-c0107e71:	75 d5                	jne    c0107e48 <vprintfmt+0xa>
+c0108554:	8b 45 10             	mov    0x10(%ebp),%eax
+c0108557:	8d 50 01             	lea    0x1(%eax),%edx
+c010855a:	89 55 10             	mov    %edx,0x10(%ebp)
+c010855d:	0f b6 00             	movzbl (%eax),%eax
+c0108560:	0f b6 d8             	movzbl %al,%ebx
+c0108563:	83 fb 25             	cmp    $0x25,%ebx
+c0108566:	75 d5                	jne    c010853d <vprintfmt+0xa>
             }
             putch(ch, putdat);
         }
 
         // Process a %-escape sequence
         char padc = ' ';
-c0107e73:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
+c0108568:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
         width = precision = -1;
-c0107e77:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
-c0107e7e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-c0107e81:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c010856c:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+c0108573:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0108576:	89 45 e8             	mov    %eax,-0x18(%ebp)
         lflag = altflag = 0;
-c0107e84:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
-c0107e8b:	8b 45 dc             	mov    -0x24(%ebp),%eax
-c0107e8e:	89 45 e0             	mov    %eax,-0x20(%ebp)
+c0108579:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+c0108580:	8b 45 dc             	mov    -0x24(%ebp),%eax
+c0108583:	89 45 e0             	mov    %eax,-0x20(%ebp)
 
     reswitch:
         switch (ch = *(unsigned char *)fmt ++) {
-c0107e91:	8b 45 10             	mov    0x10(%ebp),%eax
-c0107e94:	8d 50 01             	lea    0x1(%eax),%edx
-c0107e97:	89 55 10             	mov    %edx,0x10(%ebp)
-c0107e9a:	0f b6 00             	movzbl (%eax),%eax
-c0107e9d:	0f b6 d8             	movzbl %al,%ebx
-c0107ea0:	8d 43 dd             	lea    -0x23(%ebx),%eax
-c0107ea3:	83 f8 55             	cmp    $0x55,%eax
-c0107ea6:	0f 87 05 03 00 00    	ja     c01081b1 <vprintfmt+0x373>
-c0107eac:	8b 04 85 48 a2 10 c0 	mov    -0x3fef5db8(,%eax,4),%eax
-c0107eb3:	ff e0                	jmp    *%eax
+c0108586:	8b 45 10             	mov    0x10(%ebp),%eax
+c0108589:	8d 50 01             	lea    0x1(%eax),%edx
+c010858c:	89 55 10             	mov    %edx,0x10(%ebp)
+c010858f:	0f b6 00             	movzbl (%eax),%eax
+c0108592:	0f b6 d8             	movzbl %al,%ebx
+c0108595:	8d 43 dd             	lea    -0x23(%ebx),%eax
+c0108598:	83 f8 55             	cmp    $0x55,%eax
+c010859b:	0f 87 37 03 00 00    	ja     c01088d8 <vprintfmt+0x3a5>
+c01085a1:	8b 04 85 78 a9 10 c0 	mov    -0x3fef5688(,%eax,4),%eax
+c01085a8:	ff e0                	jmp    *%eax
 
         // flag to pad on the right
         case '-':
             padc = '-';
-c0107eb5:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
+c01085aa:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
             goto reswitch;
-c0107eb9:	eb d6                	jmp    c0107e91 <vprintfmt+0x53>
+c01085ae:	eb d6                	jmp    c0108586 <vprintfmt+0x53>
 
         // flag to pad with 0's instead of spaces
         case '0':
             padc = '0';
-c0107ebb:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
+c01085b0:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
             goto reswitch;
-c0107ebf:	eb d0                	jmp    c0107e91 <vprintfmt+0x53>
+c01085b4:	eb d0                	jmp    c0108586 <vprintfmt+0x53>
 
         // width field
         case '1' ... '9':
             for (precision = 0; ; ++ fmt) {
-c0107ec1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+c01085b6:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
                 precision = precision * 10 + ch - '0';
-c0107ec8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
-c0107ecb:	89 d0                	mov    %edx,%eax
-c0107ecd:	c1 e0 02             	shl    $0x2,%eax
-c0107ed0:	01 d0                	add    %edx,%eax
-c0107ed2:	01 c0                	add    %eax,%eax
-c0107ed4:	01 d8                	add    %ebx,%eax
-c0107ed6:	83 e8 30             	sub    $0x30,%eax
-c0107ed9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+c01085bd:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c01085c0:	89 d0                	mov    %edx,%eax
+c01085c2:	c1 e0 02             	shl    $0x2,%eax
+c01085c5:	01 d0                	add    %edx,%eax
+c01085c7:	01 c0                	add    %eax,%eax
+c01085c9:	01 d8                	add    %ebx,%eax
+c01085cb:	83 e8 30             	sub    $0x30,%eax
+c01085ce:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                 ch = *fmt;
-c0107edc:	8b 45 10             	mov    0x10(%ebp),%eax
-c0107edf:	0f b6 00             	movzbl (%eax),%eax
-c0107ee2:	0f be d8             	movsbl %al,%ebx
+c01085d1:	8b 45 10             	mov    0x10(%ebp),%eax
+c01085d4:	0f b6 00             	movzbl (%eax),%eax
+c01085d7:	0f be d8             	movsbl %al,%ebx
                 if (ch < '0' || ch > '9') {
-c0107ee5:	83 fb 2f             	cmp    $0x2f,%ebx
-c0107ee8:	7e 39                	jle    c0107f23 <vprintfmt+0xe5>
-c0107eea:	83 fb 39             	cmp    $0x39,%ebx
-c0107eed:	7f 34                	jg     c0107f23 <vprintfmt+0xe5>
+c01085da:	83 fb 2f             	cmp    $0x2f,%ebx
+c01085dd:	7e 38                	jle    c0108617 <vprintfmt+0xe4>
+c01085df:	83 fb 39             	cmp    $0x39,%ebx
+c01085e2:	7f 33                	jg     c0108617 <vprintfmt+0xe4>
             padc = '0';
             goto reswitch;
 
         // width field
         case '1' ... '9':
             for (precision = 0; ; ++ fmt) {
-c0107eef:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+c01085e4:	ff 45 10             	incl   0x10(%ebp)
                 precision = precision * 10 + ch - '0';
                 ch = *fmt;
                 if (ch < '0' || ch > '9') {
                     break;
                 }
             }
-c0107ef3:	eb d3                	jmp    c0107ec8 <vprintfmt+0x8a>
+c01085e7:	eb d4                	jmp    c01085bd <vprintfmt+0x8a>
             goto process_precision;
 
         case '*':
             precision = va_arg(ap, int);
-c0107ef5:	8b 45 14             	mov    0x14(%ebp),%eax
-c0107ef8:	8d 50 04             	lea    0x4(%eax),%edx
-c0107efb:	89 55 14             	mov    %edx,0x14(%ebp)
-c0107efe:	8b 00                	mov    (%eax),%eax
-c0107f00:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+c01085e9:	8b 45 14             	mov    0x14(%ebp),%eax
+c01085ec:	8d 50 04             	lea    0x4(%eax),%edx
+c01085ef:	89 55 14             	mov    %edx,0x14(%ebp)
+c01085f2:	8b 00                	mov    (%eax),%eax
+c01085f4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
             goto process_precision;
-c0107f03:	eb 1f                	jmp    c0107f24 <vprintfmt+0xe6>
+c01085f7:	eb 1f                	jmp    c0108618 <vprintfmt+0xe5>
 
         case '.':
             if (width < 0)
-c0107f05:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
-c0107f09:	79 86                	jns    c0107e91 <vprintfmt+0x53>
+c01085f9:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+c01085fd:	79 87                	jns    c0108586 <vprintfmt+0x53>
                 width = 0;
-c0107f0b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+c01085ff:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
             goto reswitch;
-c0107f12:	e9 7a ff ff ff       	jmp    c0107e91 <vprintfmt+0x53>
+c0108606:	e9 7b ff ff ff       	jmp    c0108586 <vprintfmt+0x53>
 
         case '#':
             altflag = 1;
-c0107f17:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
+c010860b:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
             goto reswitch;
-c0107f1e:	e9 6e ff ff ff       	jmp    c0107e91 <vprintfmt+0x53>
+c0108612:	e9 6f ff ff ff       	jmp    c0108586 <vprintfmt+0x53>
                 ch = *fmt;
                 if (ch < '0' || ch > '9') {
                     break;
                 }
             }
             goto process_precision;
-c0107f23:	90                   	nop
+c0108617:	90                   	nop
         case '#':
             altflag = 1;
             goto reswitch;
 
         process_precision:
             if (width < 0)
-c0107f24:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
-c0107f28:	0f 89 63 ff ff ff    	jns    c0107e91 <vprintfmt+0x53>
+c0108618:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+c010861c:	0f 89 64 ff ff ff    	jns    c0108586 <vprintfmt+0x53>
                 width = precision, precision = -1;
-c0107f2e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-c0107f31:	89 45 e8             	mov    %eax,-0x18(%ebp)
-c0107f34:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+c0108622:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c0108625:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c0108628:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
             goto reswitch;
-c0107f3b:	e9 51 ff ff ff       	jmp    c0107e91 <vprintfmt+0x53>
+c010862f:	e9 52 ff ff ff       	jmp    c0108586 <vprintfmt+0x53>
 
         // long flag (doubled for long long)
         case 'l':
             lflag ++;
-c0107f40:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
+c0108634:	ff 45 e0             	incl   -0x20(%ebp)
             goto reswitch;
-c0107f44:	e9 48 ff ff ff       	jmp    c0107e91 <vprintfmt+0x53>
+c0108637:	e9 4a ff ff ff       	jmp    c0108586 <vprintfmt+0x53>
 
         // character
         case 'c':
             putch(va_arg(ap, int), putdat);
-c0107f49:	8b 45 14             	mov    0x14(%ebp),%eax
-c0107f4c:	8d 50 04             	lea    0x4(%eax),%edx
-c0107f4f:	89 55 14             	mov    %edx,0x14(%ebp)
-c0107f52:	8b 00                	mov    (%eax),%eax
-c0107f54:	83 ec 08             	sub    $0x8,%esp
-c0107f57:	ff 75 0c             	pushl  0xc(%ebp)
-c0107f5a:	50                   	push   %eax
-c0107f5b:	8b 45 08             	mov    0x8(%ebp),%eax
-c0107f5e:	ff d0                	call   *%eax
-c0107f60:	83 c4 10             	add    $0x10,%esp
+c010863c:	8b 45 14             	mov    0x14(%ebp),%eax
+c010863f:	8d 50 04             	lea    0x4(%eax),%edx
+c0108642:	89 55 14             	mov    %edx,0x14(%ebp)
+c0108645:	8b 00                	mov    (%eax),%eax
+c0108647:	8b 55 0c             	mov    0xc(%ebp),%edx
+c010864a:	89 54 24 04          	mov    %edx,0x4(%esp)
+c010864e:	89 04 24             	mov    %eax,(%esp)
+c0108651:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108654:	ff d0                	call   *%eax
             break;
-c0107f63:	e9 71 02 00 00       	jmp    c01081d9 <vprintfmt+0x39b>
+c0108656:	e9 a4 02 00 00       	jmp    c01088ff <vprintfmt+0x3cc>
 
         // error message
         case 'e':
             err = va_arg(ap, int);
-c0107f68:	8b 45 14             	mov    0x14(%ebp),%eax
-c0107f6b:	8d 50 04             	lea    0x4(%eax),%edx
-c0107f6e:	89 55 14             	mov    %edx,0x14(%ebp)
-c0107f71:	8b 18                	mov    (%eax),%ebx
+c010865b:	8b 45 14             	mov    0x14(%ebp),%eax
+c010865e:	8d 50 04             	lea    0x4(%eax),%edx
+c0108661:	89 55 14             	mov    %edx,0x14(%ebp)
+c0108664:	8b 18                	mov    (%eax),%ebx
             if (err < 0) {
-c0107f73:	85 db                	test   %ebx,%ebx
-c0107f75:	79 02                	jns    c0107f79 <vprintfmt+0x13b>
+c0108666:	85 db                	test   %ebx,%ebx
+c0108668:	79 02                	jns    c010866c <vprintfmt+0x139>
                 err = -err;
-c0107f77:	f7 db                	neg    %ebx
+c010866a:	f7 db                	neg    %ebx
             }
             if (err > MAXERROR || (p = error_string[err]) == NULL) {
-c0107f79:	83 fb 06             	cmp    $0x6,%ebx
-c0107f7c:	7f 0b                	jg     c0107f89 <vprintfmt+0x14b>
-c0107f7e:	8b 34 9d 08 a2 10 c0 	mov    -0x3fef5df8(,%ebx,4),%esi
-c0107f85:	85 f6                	test   %esi,%esi
-c0107f87:	75 19                	jne    c0107fa2 <vprintfmt+0x164>
+c010866c:	83 fb 06             	cmp    $0x6,%ebx
+c010866f:	7f 0b                	jg     c010867c <vprintfmt+0x149>
+c0108671:	8b 34 9d 38 a9 10 c0 	mov    -0x3fef56c8(,%ebx,4),%esi
+c0108678:	85 f6                	test   %esi,%esi
+c010867a:	75 23                	jne    c010869f <vprintfmt+0x16c>
                 printfmt(putch, putdat, "error %d", err);
-c0107f89:	53                   	push   %ebx
-c0107f8a:	68 35 a2 10 c0       	push   $0xc010a235
-c0107f8f:	ff 75 0c             	pushl  0xc(%ebp)
-c0107f92:	ff 75 08             	pushl  0x8(%ebp)
-c0107f95:	e8 80 fe ff ff       	call   c0107e1a <printfmt>
-c0107f9a:	83 c4 10             	add    $0x10,%esp
+c010867c:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+c0108680:	c7 44 24 08 65 a9 10 	movl   $0xc010a965,0x8(%esp)
+c0108687:	c0 
+c0108688:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010868b:	89 44 24 04          	mov    %eax,0x4(%esp)
+c010868f:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108692:	89 04 24             	mov    %eax,(%esp)
+c0108695:	e8 6a fe ff ff       	call   c0108504 <printfmt>
             }
             else {
                 printfmt(putch, putdat, "%s", p);
             }
             break;
-c0107f9d:	e9 37 02 00 00       	jmp    c01081d9 <vprintfmt+0x39b>
+c010869a:	e9 60 02 00 00       	jmp    c01088ff <vprintfmt+0x3cc>
             }
             if (err > MAXERROR || (p = error_string[err]) == NULL) {
                 printfmt(putch, putdat, "error %d", err);
             }
             else {
                 printfmt(putch, putdat, "%s", p);
-c0107fa2:	56                   	push   %esi
-c0107fa3:	68 3e a2 10 c0       	push   $0xc010a23e
-c0107fa8:	ff 75 0c             	pushl  0xc(%ebp)
-c0107fab:	ff 75 08             	pushl  0x8(%ebp)
-c0107fae:	e8 67 fe ff ff       	call   c0107e1a <printfmt>
-c0107fb3:	83 c4 10             	add    $0x10,%esp
+c010869f:	89 74 24 0c          	mov    %esi,0xc(%esp)
+c01086a3:	c7 44 24 08 6e a9 10 	movl   $0xc010a96e,0x8(%esp)
+c01086aa:	c0 
+c01086ab:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01086ae:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01086b2:	8b 45 08             	mov    0x8(%ebp),%eax
+c01086b5:	89 04 24             	mov    %eax,(%esp)
+c01086b8:	e8 47 fe ff ff       	call   c0108504 <printfmt>
             }
             break;
-c0107fb6:	e9 1e 02 00 00       	jmp    c01081d9 <vprintfmt+0x39b>
+c01086bd:	e9 3d 02 00 00       	jmp    c01088ff <vprintfmt+0x3cc>
 
         // string
         case 's':
             if ((p = va_arg(ap, char *)) == NULL) {
-c0107fbb:	8b 45 14             	mov    0x14(%ebp),%eax
-c0107fbe:	8d 50 04             	lea    0x4(%eax),%edx
-c0107fc1:	89 55 14             	mov    %edx,0x14(%ebp)
-c0107fc4:	8b 30                	mov    (%eax),%esi
-c0107fc6:	85 f6                	test   %esi,%esi
-c0107fc8:	75 05                	jne    c0107fcf <vprintfmt+0x191>
+c01086c2:	8b 45 14             	mov    0x14(%ebp),%eax
+c01086c5:	8d 50 04             	lea    0x4(%eax),%edx
+c01086c8:	89 55 14             	mov    %edx,0x14(%ebp)
+c01086cb:	8b 30                	mov    (%eax),%esi
+c01086cd:	85 f6                	test   %esi,%esi
+c01086cf:	75 05                	jne    c01086d6 <vprintfmt+0x1a3>
                 p = "(null)";
-c0107fca:	be 41 a2 10 c0       	mov    $0xc010a241,%esi
+c01086d1:	be 71 a9 10 c0       	mov    $0xc010a971,%esi
             }
             if (width > 0 && padc != '-') {
-c0107fcf:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
-c0107fd3:	7e 76                	jle    c010804b <vprintfmt+0x20d>
-c0107fd5:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
-c0107fd9:	74 70                	je     c010804b <vprintfmt+0x20d>
+c01086d6:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+c01086da:	7e 76                	jle    c0108752 <vprintfmt+0x21f>
+c01086dc:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
+c01086e0:	74 70                	je     c0108752 <vprintfmt+0x21f>
                 for (width -= strnlen(p, precision); width > 0; width --) {
-c0107fdb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
-c0107fde:	83 ec 08             	sub    $0x8,%esp
-c0107fe1:	50                   	push   %eax
-c0107fe2:	56                   	push   %esi
-c0107fe3:	e8 17 f8 ff ff       	call   c01077ff <strnlen>
-c0107fe8:	83 c4 10             	add    $0x10,%esp
-c0107feb:	89 c2                	mov    %eax,%edx
-c0107fed:	8b 45 e8             	mov    -0x18(%ebp),%eax
-c0107ff0:	29 d0                	sub    %edx,%eax
-c0107ff2:	89 45 e8             	mov    %eax,-0x18(%ebp)
-c0107ff5:	eb 17                	jmp    c010800e <vprintfmt+0x1d0>
+c01086e2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+c01086e5:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01086e9:	89 34 24             	mov    %esi,(%esp)
+c01086ec:	e8 f6 f7 ff ff       	call   c0107ee7 <strnlen>
+c01086f1:	8b 55 e8             	mov    -0x18(%ebp),%edx
+c01086f4:	29 c2                	sub    %eax,%edx
+c01086f6:	89 d0                	mov    %edx,%eax
+c01086f8:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c01086fb:	eb 16                	jmp    c0108713 <vprintfmt+0x1e0>
                     putch(padc, putdat);
-c0107ff7:	0f be 45 db          	movsbl -0x25(%ebp),%eax
-c0107ffb:	83 ec 08             	sub    $0x8,%esp
-c0107ffe:	ff 75 0c             	pushl  0xc(%ebp)
-c0108001:	50                   	push   %eax
-c0108002:	8b 45 08             	mov    0x8(%ebp),%eax
-c0108005:	ff d0                	call   *%eax
-c0108007:	83 c4 10             	add    $0x10,%esp
+c01086fd:	0f be 45 db          	movsbl -0x25(%ebp),%eax
+c0108701:	8b 55 0c             	mov    0xc(%ebp),%edx
+c0108704:	89 54 24 04          	mov    %edx,0x4(%esp)
+c0108708:	89 04 24             	mov    %eax,(%esp)
+c010870b:	8b 45 08             	mov    0x8(%ebp),%eax
+c010870e:	ff d0                	call   *%eax
         case 's':
             if ((p = va_arg(ap, char *)) == NULL) {
                 p = "(null)";
             }
             if (width > 0 && padc != '-') {
                 for (width -= strnlen(p, precision); width > 0; width --) {
-c010800a:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
-c010800e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
-c0108012:	7f e3                	jg     c0107ff7 <vprintfmt+0x1b9>
+c0108710:	ff 4d e8             	decl   -0x18(%ebp)
+c0108713:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+c0108717:	7f e4                	jg     c01086fd <vprintfmt+0x1ca>
                     putch(padc, putdat);
                 }
             }
             for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
-c0108014:	eb 35                	jmp    c010804b <vprintfmt+0x20d>
+c0108719:	eb 37                	jmp    c0108752 <vprintfmt+0x21f>
                 if (altflag && (ch < ' ' || ch > '~')) {
-c0108016:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
-c010801a:	74 1c                	je     c0108038 <vprintfmt+0x1fa>
-c010801c:	83 fb 1f             	cmp    $0x1f,%ebx
-c010801f:	7e 05                	jle    c0108026 <vprintfmt+0x1e8>
-c0108021:	83 fb 7e             	cmp    $0x7e,%ebx
-c0108024:	7e 12                	jle    c0108038 <vprintfmt+0x1fa>
+c010871b:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+c010871f:	74 1f                	je     c0108740 <vprintfmt+0x20d>
+c0108721:	83 fb 1f             	cmp    $0x1f,%ebx
+c0108724:	7e 05                	jle    c010872b <vprintfmt+0x1f8>
+c0108726:	83 fb 7e             	cmp    $0x7e,%ebx
+c0108729:	7e 15                	jle    c0108740 <vprintfmt+0x20d>
                     putch('?', putdat);
-c0108026:	83 ec 08             	sub    $0x8,%esp
-c0108029:	ff 75 0c             	pushl  0xc(%ebp)
-c010802c:	6a 3f                	push   $0x3f
-c010802e:	8b 45 08             	mov    0x8(%ebp),%eax
-c0108031:	ff d0                	call   *%eax
-c0108033:	83 c4 10             	add    $0x10,%esp
-c0108036:	eb 0f                	jmp    c0108047 <vprintfmt+0x209>
+c010872b:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010872e:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0108732:	c7 04 24 3f 00 00 00 	movl   $0x3f,(%esp)
+c0108739:	8b 45 08             	mov    0x8(%ebp),%eax
+c010873c:	ff d0                	call   *%eax
+c010873e:	eb 0f                	jmp    c010874f <vprintfmt+0x21c>
                 }
                 else {
                     putch(ch, putdat);
-c0108038:	83 ec 08             	sub    $0x8,%esp
-c010803b:	ff 75 0c             	pushl  0xc(%ebp)
-c010803e:	53                   	push   %ebx
-c010803f:	8b 45 08             	mov    0x8(%ebp),%eax
-c0108042:	ff d0                	call   *%eax
-c0108044:	83 c4 10             	add    $0x10,%esp
+c0108740:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0108743:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0108747:	89 1c 24             	mov    %ebx,(%esp)
+c010874a:	8b 45 08             	mov    0x8(%ebp),%eax
+c010874d:	ff d0                	call   *%eax
             if (width > 0 && padc != '-') {
                 for (width -= strnlen(p, precision); width > 0; width --) {
                     putch(padc, putdat);
                 }
             }
             for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
-c0108047:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
-c010804b:	89 f0                	mov    %esi,%eax
-c010804d:	8d 70 01             	lea    0x1(%eax),%esi
-c0108050:	0f b6 00             	movzbl (%eax),%eax
-c0108053:	0f be d8             	movsbl %al,%ebx
-c0108056:	85 db                	test   %ebx,%ebx
-c0108058:	74 26                	je     c0108080 <vprintfmt+0x242>
-c010805a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
-c010805e:	78 b6                	js     c0108016 <vprintfmt+0x1d8>
-c0108060:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
-c0108064:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
-c0108068:	79 ac                	jns    c0108016 <vprintfmt+0x1d8>
+c010874f:	ff 4d e8             	decl   -0x18(%ebp)
+c0108752:	89 f0                	mov    %esi,%eax
+c0108754:	8d 70 01             	lea    0x1(%eax),%esi
+c0108757:	0f b6 00             	movzbl (%eax),%eax
+c010875a:	0f be d8             	movsbl %al,%ebx
+c010875d:	85 db                	test   %ebx,%ebx
+c010875f:	74 27                	je     c0108788 <vprintfmt+0x255>
+c0108761:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+c0108765:	78 b4                	js     c010871b <vprintfmt+0x1e8>
+c0108767:	ff 4d e4             	decl   -0x1c(%ebp)
+c010876a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+c010876e:	79 ab                	jns    c010871b <vprintfmt+0x1e8>
                 }
                 else {
                     putch(ch, putdat);
                 }
             }
             for (; width > 0; width --) {
-c010806a:	eb 14                	jmp    c0108080 <vprintfmt+0x242>
+c0108770:	eb 16                	jmp    c0108788 <vprintfmt+0x255>
                 putch(' ', putdat);
-c010806c:	83 ec 08             	sub    $0x8,%esp
-c010806f:	ff 75 0c             	pushl  0xc(%ebp)
-c0108072:	6a 20                	push   $0x20
-c0108074:	8b 45 08             	mov    0x8(%ebp),%eax
-c0108077:	ff d0                	call   *%eax
-c0108079:	83 c4 10             	add    $0x10,%esp
+c0108772:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0108775:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0108779:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
+c0108780:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108783:	ff d0                	call   *%eax
                 }
                 else {
                     putch(ch, putdat);
                 }
             }
             for (; width > 0; width --) {
-c010807c:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
-c0108080:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
-c0108084:	7f e6                	jg     c010806c <vprintfmt+0x22e>
+c0108785:	ff 4d e8             	decl   -0x18(%ebp)
+c0108788:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+c010878c:	7f e4                	jg     c0108772 <vprintfmt+0x23f>
                 putch(' ', putdat);
             }
             break;
-c0108086:	e9 4e 01 00 00       	jmp    c01081d9 <vprintfmt+0x39b>
+c010878e:	e9 6c 01 00 00       	jmp    c01088ff <vprintfmt+0x3cc>
 
         // (signed) decimal
         case 'd':
             num = getint(&ap, lflag);
-c010808b:	83 ec 08             	sub    $0x8,%esp
-c010808e:	ff 75 e0             	pushl  -0x20(%ebp)
-c0108091:	8d 45 14             	lea    0x14(%ebp),%eax
-c0108094:	50                   	push   %eax
-c0108095:	e8 39 fd ff ff       	call   c0107dd3 <getint>
-c010809a:	83 c4 10             	add    $0x10,%esp
-c010809d:	89 45 f0             	mov    %eax,-0x10(%ebp)
-c01080a0:	89 55 f4             	mov    %edx,-0xc(%ebp)
+c0108793:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0108796:	89 44 24 04          	mov    %eax,0x4(%esp)
+c010879a:	8d 45 14             	lea    0x14(%ebp),%eax
+c010879d:	89 04 24             	mov    %eax,(%esp)
+c01087a0:	e8 18 fd ff ff       	call   c01084bd <getint>
+c01087a5:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c01087a8:	89 55 f4             	mov    %edx,-0xc(%ebp)
             if ((long long)num < 0) {
-c01080a3:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c01080a6:	8b 55 f4             	mov    -0xc(%ebp),%edx
-c01080a9:	85 d2                	test   %edx,%edx
-c01080ab:	79 23                	jns    c01080d0 <vprintfmt+0x292>
+c01087ab:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01087ae:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c01087b1:	85 d2                	test   %edx,%edx
+c01087b3:	79 26                	jns    c01087db <vprintfmt+0x2a8>
                 putch('-', putdat);
-c01080ad:	83 ec 08             	sub    $0x8,%esp
-c01080b0:	ff 75 0c             	pushl  0xc(%ebp)
-c01080b3:	6a 2d                	push   $0x2d
-c01080b5:	8b 45 08             	mov    0x8(%ebp),%eax
-c01080b8:	ff d0                	call   *%eax
-c01080ba:	83 c4 10             	add    $0x10,%esp
+c01087b5:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01087b8:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01087bc:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
+c01087c3:	8b 45 08             	mov    0x8(%ebp),%eax
+c01087c6:	ff d0                	call   *%eax
                 num = -(long long)num;
-c01080bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c01080c0:	8b 55 f4             	mov    -0xc(%ebp),%edx
-c01080c3:	f7 d8                	neg    %eax
-c01080c5:	83 d2 00             	adc    $0x0,%edx
-c01080c8:	f7 da                	neg    %edx
-c01080ca:	89 45 f0             	mov    %eax,-0x10(%ebp)
-c01080cd:	89 55 f4             	mov    %edx,-0xc(%ebp)
+c01087c8:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01087cb:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c01087ce:	f7 d8                	neg    %eax
+c01087d0:	83 d2 00             	adc    $0x0,%edx
+c01087d3:	f7 da                	neg    %edx
+c01087d5:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c01087d8:	89 55 f4             	mov    %edx,-0xc(%ebp)
             }
             base = 10;
-c01080d0:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+c01087db:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
             goto number;
-c01080d7:	e9 9f 00 00 00       	jmp    c010817b <vprintfmt+0x33d>
+c01087e2:	e9 a8 00 00 00       	jmp    c010888f <vprintfmt+0x35c>
 
         // unsigned decimal
         case 'u':
             num = getuint(&ap, lflag);
-c01080dc:	83 ec 08             	sub    $0x8,%esp
-c01080df:	ff 75 e0             	pushl  -0x20(%ebp)
-c01080e2:	8d 45 14             	lea    0x14(%ebp),%eax
-c01080e5:	50                   	push   %eax
-c01080e6:	e8 99 fc ff ff       	call   c0107d84 <getuint>
-c01080eb:	83 c4 10             	add    $0x10,%esp
-c01080ee:	89 45 f0             	mov    %eax,-0x10(%ebp)
-c01080f1:	89 55 f4             	mov    %edx,-0xc(%ebp)
+c01087e7:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c01087ea:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01087ee:	8d 45 14             	lea    0x14(%ebp),%eax
+c01087f1:	89 04 24             	mov    %eax,(%esp)
+c01087f4:	e8 75 fc ff ff       	call   c010846e <getuint>
+c01087f9:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c01087fc:	89 55 f4             	mov    %edx,-0xc(%ebp)
             base = 10;
-c01080f4:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+c01087ff:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
             goto number;
-c01080fb:	eb 7e                	jmp    c010817b <vprintfmt+0x33d>
+c0108806:	e9 84 00 00 00       	jmp    c010888f <vprintfmt+0x35c>
 
         // (unsigned) octal
         case 'o':
             num = getuint(&ap, lflag);
-c01080fd:	83 ec 08             	sub    $0x8,%esp
-c0108100:	ff 75 e0             	pushl  -0x20(%ebp)
-c0108103:	8d 45 14             	lea    0x14(%ebp),%eax
-c0108106:	50                   	push   %eax
-c0108107:	e8 78 fc ff ff       	call   c0107d84 <getuint>
-c010810c:	83 c4 10             	add    $0x10,%esp
-c010810f:	89 45 f0             	mov    %eax,-0x10(%ebp)
-c0108112:	89 55 f4             	mov    %edx,-0xc(%ebp)
+c010880b:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c010880e:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0108812:	8d 45 14             	lea    0x14(%ebp),%eax
+c0108815:	89 04 24             	mov    %eax,(%esp)
+c0108818:	e8 51 fc ff ff       	call   c010846e <getuint>
+c010881d:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0108820:	89 55 f4             	mov    %edx,-0xc(%ebp)
             base = 8;
-c0108115:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
+c0108823:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
             goto number;
-c010811c:	eb 5d                	jmp    c010817b <vprintfmt+0x33d>
+c010882a:	eb 63                	jmp    c010888f <vprintfmt+0x35c>
 
         // pointer
         case 'p':
             putch('0', putdat);
-c010811e:	83 ec 08             	sub    $0x8,%esp
-c0108121:	ff 75 0c             	pushl  0xc(%ebp)
-c0108124:	6a 30                	push   $0x30
-c0108126:	8b 45 08             	mov    0x8(%ebp),%eax
-c0108129:	ff d0                	call   *%eax
-c010812b:	83 c4 10             	add    $0x10,%esp
+c010882c:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010882f:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0108833:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
+c010883a:	8b 45 08             	mov    0x8(%ebp),%eax
+c010883d:	ff d0                	call   *%eax
             putch('x', putdat);
-c010812e:	83 ec 08             	sub    $0x8,%esp
-c0108131:	ff 75 0c             	pushl  0xc(%ebp)
-c0108134:	6a 78                	push   $0x78
-c0108136:	8b 45 08             	mov    0x8(%ebp),%eax
-c0108139:	ff d0                	call   *%eax
-c010813b:	83 c4 10             	add    $0x10,%esp
+c010883f:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0108842:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0108846:	c7 04 24 78 00 00 00 	movl   $0x78,(%esp)
+c010884d:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108850:	ff d0                	call   *%eax
             num = (unsigned long long)(uintptr_t)va_arg(ap, void *);
-c010813e:	8b 45 14             	mov    0x14(%ebp),%eax
-c0108141:	8d 50 04             	lea    0x4(%eax),%edx
-c0108144:	89 55 14             	mov    %edx,0x14(%ebp)
-c0108147:	8b 00                	mov    (%eax),%eax
-c0108149:	89 45 f0             	mov    %eax,-0x10(%ebp)
-c010814c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+c0108852:	8b 45 14             	mov    0x14(%ebp),%eax
+c0108855:	8d 50 04             	lea    0x4(%eax),%edx
+c0108858:	89 55 14             	mov    %edx,0x14(%ebp)
+c010885b:	8b 00                	mov    (%eax),%eax
+c010885d:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0108860:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
             base = 16;
-c0108153:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+c0108867:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
             goto number;
-c010815a:	eb 1f                	jmp    c010817b <vprintfmt+0x33d>
+c010886e:	eb 1f                	jmp    c010888f <vprintfmt+0x35c>
 
         // (unsigned) hexadecimal
         case 'x':
             num = getuint(&ap, lflag);
-c010815c:	83 ec 08             	sub    $0x8,%esp
-c010815f:	ff 75 e0             	pushl  -0x20(%ebp)
-c0108162:	8d 45 14             	lea    0x14(%ebp),%eax
-c0108165:	50                   	push   %eax
-c0108166:	e8 19 fc ff ff       	call   c0107d84 <getuint>
-c010816b:	83 c4 10             	add    $0x10,%esp
-c010816e:	89 45 f0             	mov    %eax,-0x10(%ebp)
-c0108171:	89 55 f4             	mov    %edx,-0xc(%ebp)
+c0108870:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0108873:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0108877:	8d 45 14             	lea    0x14(%ebp),%eax
+c010887a:	89 04 24             	mov    %eax,(%esp)
+c010887d:	e8 ec fb ff ff       	call   c010846e <getuint>
+c0108882:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0108885:	89 55 f4             	mov    %edx,-0xc(%ebp)
             base = 16;
-c0108174:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+c0108888:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
         number:
             printnum(putch, putdat, num, base, width, padc);
-c010817b:	0f be 55 db          	movsbl -0x25(%ebp),%edx
-c010817f:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c0108182:	83 ec 04             	sub    $0x4,%esp
-c0108185:	52                   	push   %edx
-c0108186:	ff 75 e8             	pushl  -0x18(%ebp)
-c0108189:	50                   	push   %eax
-c010818a:	ff 75 f4             	pushl  -0xc(%ebp)
-c010818d:	ff 75 f0             	pushl  -0x10(%ebp)
-c0108190:	ff 75 0c             	pushl  0xc(%ebp)
-c0108193:	ff 75 08             	pushl  0x8(%ebp)
-c0108196:	e8 f8 fa ff ff       	call   c0107c93 <printnum>
-c010819b:	83 c4 20             	add    $0x20,%esp
+c010888f:	0f be 55 db          	movsbl -0x25(%ebp),%edx
+c0108893:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c0108896:	89 54 24 18          	mov    %edx,0x18(%esp)
+c010889a:	8b 55 e8             	mov    -0x18(%ebp),%edx
+c010889d:	89 54 24 14          	mov    %edx,0x14(%esp)
+c01088a1:	89 44 24 10          	mov    %eax,0x10(%esp)
+c01088a5:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01088a8:	8b 55 f4             	mov    -0xc(%ebp),%edx
+c01088ab:	89 44 24 08          	mov    %eax,0x8(%esp)
+c01088af:	89 54 24 0c          	mov    %edx,0xc(%esp)
+c01088b3:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01088b6:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01088ba:	8b 45 08             	mov    0x8(%ebp),%eax
+c01088bd:	89 04 24             	mov    %eax,(%esp)
+c01088c0:	e8 a4 fa ff ff       	call   c0108369 <printnum>
             break;
-c010819e:	eb 39                	jmp    c01081d9 <vprintfmt+0x39b>
+c01088c5:	eb 38                	jmp    c01088ff <vprintfmt+0x3cc>
 
         // escaped '%' character
         case '%':
             putch(ch, putdat);
-c01081a0:	83 ec 08             	sub    $0x8,%esp
-c01081a3:	ff 75 0c             	pushl  0xc(%ebp)
-c01081a6:	53                   	push   %ebx
-c01081a7:	8b 45 08             	mov    0x8(%ebp),%eax
-c01081aa:	ff d0                	call   *%eax
-c01081ac:	83 c4 10             	add    $0x10,%esp
+c01088c7:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01088ca:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01088ce:	89 1c 24             	mov    %ebx,(%esp)
+c01088d1:	8b 45 08             	mov    0x8(%ebp),%eax
+c01088d4:	ff d0                	call   *%eax
             break;
-c01081af:	eb 28                	jmp    c01081d9 <vprintfmt+0x39b>
+c01088d6:	eb 27                	jmp    c01088ff <vprintfmt+0x3cc>
 
         // unrecognized escape sequence - just print it literally
         default:
             putch('%', putdat);
-c01081b1:	83 ec 08             	sub    $0x8,%esp
-c01081b4:	ff 75 0c             	pushl  0xc(%ebp)
-c01081b7:	6a 25                	push   $0x25
-c01081b9:	8b 45 08             	mov    0x8(%ebp),%eax
-c01081bc:	ff d0                	call   *%eax
-c01081be:	83 c4 10             	add    $0x10,%esp
+c01088d8:	8b 45 0c             	mov    0xc(%ebp),%eax
+c01088db:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01088df:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
+c01088e6:	8b 45 08             	mov    0x8(%ebp),%eax
+c01088e9:	ff d0                	call   *%eax
             for (fmt --; fmt[-1] != '%'; fmt --)
-c01081c1:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
-c01081c5:	eb 04                	jmp    c01081cb <vprintfmt+0x38d>
-c01081c7:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
-c01081cb:	8b 45 10             	mov    0x10(%ebp),%eax
-c01081ce:	83 e8 01             	sub    $0x1,%eax
-c01081d1:	0f b6 00             	movzbl (%eax),%eax
-c01081d4:	3c 25                	cmp    $0x25,%al
-c01081d6:	75 ef                	jne    c01081c7 <vprintfmt+0x389>
+c01088eb:	ff 4d 10             	decl   0x10(%ebp)
+c01088ee:	eb 03                	jmp    c01088f3 <vprintfmt+0x3c0>
+c01088f0:	ff 4d 10             	decl   0x10(%ebp)
+c01088f3:	8b 45 10             	mov    0x10(%ebp),%eax
+c01088f6:	48                   	dec    %eax
+c01088f7:	0f b6 00             	movzbl (%eax),%eax
+c01088fa:	3c 25                	cmp    $0x25,%al
+c01088fc:	75 f2                	jne    c01088f0 <vprintfmt+0x3bd>
                 /* do nothing */;
             break;
-c01081d8:	90                   	nop
+c01088fe:	90                   	nop
         }
     }
-c01081d9:	e9 68 fc ff ff       	jmp    c0107e46 <vprintfmt+0x8>
+c01088ff:	e9 37 fc ff ff       	jmp    c010853b <vprintfmt+0x8>
     int base, width, precision, lflag, altflag;
 
     while (1) {
         while ((ch = *(unsigned char *)fmt ++) != '%') {
             if (ch == '\0') {
                 return;
-c01081de:	90                   	nop
+c0108904:	90                   	nop
             for (fmt --; fmt[-1] != '%'; fmt --)
                 /* do nothing */;
             break;
         }
     }
 }
-c01081df:	8d 65 f8             	lea    -0x8(%ebp),%esp
-c01081e2:	5b                   	pop    %ebx
-c01081e3:	5e                   	pop    %esi
-c01081e4:	5d                   	pop    %ebp
-c01081e5:	c3                   	ret    
+c0108905:	83 c4 40             	add    $0x40,%esp
+c0108908:	5b                   	pop    %ebx
+c0108909:	5e                   	pop    %esi
+c010890a:	5d                   	pop    %ebp
+c010890b:	c3                   	ret    
 
-c01081e6 <sprintputch>:
+c010890c <sprintputch>:
  * sprintputch - 'print' a single character in a buffer
  * @ch:         the character will be printed
  * @b:          the buffer to place the character @ch
  * */
 static void
 sprintputch(int ch, struct sprintbuf *b) {
-c01081e6:	55                   	push   %ebp
-c01081e7:	89 e5                	mov    %esp,%ebp
+c010890c:	55                   	push   %ebp
+c010890d:	89 e5                	mov    %esp,%ebp
     b->cnt ++;
-c01081e9:	8b 45 0c             	mov    0xc(%ebp),%eax
-c01081ec:	8b 40 08             	mov    0x8(%eax),%eax
-c01081ef:	8d 50 01             	lea    0x1(%eax),%edx
-c01081f2:	8b 45 0c             	mov    0xc(%ebp),%eax
-c01081f5:	89 50 08             	mov    %edx,0x8(%eax)
+c010890f:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0108912:	8b 40 08             	mov    0x8(%eax),%eax
+c0108915:	8d 50 01             	lea    0x1(%eax),%edx
+c0108918:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010891b:	89 50 08             	mov    %edx,0x8(%eax)
     if (b->buf < b->ebuf) {
-c01081f8:	8b 45 0c             	mov    0xc(%ebp),%eax
-c01081fb:	8b 10                	mov    (%eax),%edx
-c01081fd:	8b 45 0c             	mov    0xc(%ebp),%eax
-c0108200:	8b 40 04             	mov    0x4(%eax),%eax
-c0108203:	39 c2                	cmp    %eax,%edx
-c0108205:	73 12                	jae    c0108219 <sprintputch+0x33>
+c010891e:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0108921:	8b 10                	mov    (%eax),%edx
+c0108923:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0108926:	8b 40 04             	mov    0x4(%eax),%eax
+c0108929:	39 c2                	cmp    %eax,%edx
+c010892b:	73 12                	jae    c010893f <sprintputch+0x33>
         *b->buf ++ = ch;
-c0108207:	8b 45 0c             	mov    0xc(%ebp),%eax
-c010820a:	8b 00                	mov    (%eax),%eax
-c010820c:	8d 48 01             	lea    0x1(%eax),%ecx
-c010820f:	8b 55 0c             	mov    0xc(%ebp),%edx
-c0108212:	89 0a                	mov    %ecx,(%edx)
-c0108214:	8b 55 08             	mov    0x8(%ebp),%edx
-c0108217:	88 10                	mov    %dl,(%eax)
+c010892d:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0108930:	8b 00                	mov    (%eax),%eax
+c0108932:	8d 48 01             	lea    0x1(%eax),%ecx
+c0108935:	8b 55 0c             	mov    0xc(%ebp),%edx
+c0108938:	89 0a                	mov    %ecx,(%edx)
+c010893a:	8b 55 08             	mov    0x8(%ebp),%edx
+c010893d:	88 10                	mov    %dl,(%eax)
     }
 }
-c0108219:	90                   	nop
-c010821a:	5d                   	pop    %ebp
-c010821b:	c3                   	ret    
+c010893f:	90                   	nop
+c0108940:	5d                   	pop    %ebp
+c0108941:	c3                   	ret    
 
-c010821c <snprintf>:
+c0108942 <snprintf>:
  * @str:        the buffer to place the result into
  * @size:       the size of buffer, including the trailing null space
  * @fmt:        the format string to use
  * */
 int
 snprintf(char *str, size_t size, const char *fmt, ...) {
-c010821c:	55                   	push   %ebp
-c010821d:	89 e5                	mov    %esp,%ebp
-c010821f:	83 ec 18             	sub    $0x18,%esp
+c0108942:	55                   	push   %ebp
+c0108943:	89 e5                	mov    %esp,%ebp
+c0108945:	83 ec 28             	sub    $0x28,%esp
     va_list ap;
     int cnt;
     va_start(ap, fmt);
-c0108222:	8d 45 14             	lea    0x14(%ebp),%eax
-c0108225:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0108948:	8d 45 14             	lea    0x14(%ebp),%eax
+c010894b:	89 45 f0             	mov    %eax,-0x10(%ebp)
     cnt = vsnprintf(str, size, fmt, ap);
-c0108228:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c010822b:	50                   	push   %eax
-c010822c:	ff 75 10             	pushl  0x10(%ebp)
-c010822f:	ff 75 0c             	pushl  0xc(%ebp)
-c0108232:	ff 75 08             	pushl  0x8(%ebp)
-c0108235:	e8 0b 00 00 00       	call   c0108245 <vsnprintf>
-c010823a:	83 c4 10             	add    $0x10,%esp
-c010823d:	89 45 f4             	mov    %eax,-0xc(%ebp)
+c010894e:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c0108951:	89 44 24 0c          	mov    %eax,0xc(%esp)
+c0108955:	8b 45 10             	mov    0x10(%ebp),%eax
+c0108958:	89 44 24 08          	mov    %eax,0x8(%esp)
+c010895c:	8b 45 0c             	mov    0xc(%ebp),%eax
+c010895f:	89 44 24 04          	mov    %eax,0x4(%esp)
+c0108963:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108966:	89 04 24             	mov    %eax,(%esp)
+c0108969:	e8 08 00 00 00       	call   c0108976 <vsnprintf>
+c010896e:	89 45 f4             	mov    %eax,-0xc(%ebp)
     va_end(ap);
     return cnt;
-c0108240:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c0108971:	8b 45 f4             	mov    -0xc(%ebp),%eax
 }
-c0108243:	c9                   	leave  
-c0108244:	c3                   	ret    
+c0108974:	c9                   	leave  
+c0108975:	c3                   	ret    
 
-c0108245 <vsnprintf>:
+c0108976 <vsnprintf>:
  *
  * Call this function if you are already dealing with a va_list.
  * Or you probably want snprintf() instead.
  * */
 int
 vsnprintf(char *str, size_t size, const char *fmt, va_list ap) {
-c0108245:	55                   	push   %ebp
-c0108246:	89 e5                	mov    %esp,%ebp
-c0108248:	83 ec 18             	sub    $0x18,%esp
+c0108976:	55                   	push   %ebp
+c0108977:	89 e5                	mov    %esp,%ebp
+c0108979:	83 ec 28             	sub    $0x28,%esp
     struct sprintbuf b = {str, str + size - 1, 0};
-c010824b:	8b 45 08             	mov    0x8(%ebp),%eax
-c010824e:	89 45 ec             	mov    %eax,-0x14(%ebp)
-c0108251:	8b 45 0c             	mov    0xc(%ebp),%eax
-c0108254:	8d 50 ff             	lea    -0x1(%eax),%edx
-c0108257:	8b 45 08             	mov    0x8(%ebp),%eax
-c010825a:	01 d0                	add    %edx,%eax
-c010825c:	89 45 f0             	mov    %eax,-0x10(%ebp)
-c010825f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+c010897c:	8b 45 08             	mov    0x8(%ebp),%eax
+c010897f:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c0108982:	8b 45 0c             	mov    0xc(%ebp),%eax
+c0108985:	8d 50 ff             	lea    -0x1(%eax),%edx
+c0108988:	8b 45 08             	mov    0x8(%ebp),%eax
+c010898b:	01 d0                	add    %edx,%eax
+c010898d:	89 45 f0             	mov    %eax,-0x10(%ebp)
+c0108990:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     if (str == NULL || b.buf > b.ebuf) {
-c0108266:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
-c010826a:	74 0a                	je     c0108276 <vsnprintf+0x31>
-c010826c:	8b 55 ec             	mov    -0x14(%ebp),%edx
-c010826f:	8b 45 f0             	mov    -0x10(%ebp),%eax
-c0108272:	39 c2                	cmp    %eax,%edx
-c0108274:	76 07                	jbe    c010827d <vsnprintf+0x38>
+c0108997:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+c010899b:	74 0a                	je     c01089a7 <vsnprintf+0x31>
+c010899d:	8b 55 ec             	mov    -0x14(%ebp),%edx
+c01089a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
+c01089a3:	39 c2                	cmp    %eax,%edx
+c01089a5:	76 07                	jbe    c01089ae <vsnprintf+0x38>
         return -E_INVAL;
-c0108276:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
-c010827b:	eb 20                	jmp    c010829d <vsnprintf+0x58>
+c01089a7:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
+c01089ac:	eb 2a                	jmp    c01089d8 <vsnprintf+0x62>
     }
     // print the string to the buffer
     vprintfmt((void*)sprintputch, &b, fmt, ap);
-c010827d:	ff 75 14             	pushl  0x14(%ebp)
-c0108280:	ff 75 10             	pushl  0x10(%ebp)
-c0108283:	8d 45 ec             	lea    -0x14(%ebp),%eax
-c0108286:	50                   	push   %eax
-c0108287:	68 e6 81 10 c0       	push   $0xc01081e6
-c010828c:	e8 ad fb ff ff       	call   c0107e3e <vprintfmt>
-c0108291:	83 c4 10             	add    $0x10,%esp
+c01089ae:	8b 45 14             	mov    0x14(%ebp),%eax
+c01089b1:	89 44 24 0c          	mov    %eax,0xc(%esp)
+c01089b5:	8b 45 10             	mov    0x10(%ebp),%eax
+c01089b8:	89 44 24 08          	mov    %eax,0x8(%esp)
+c01089bc:	8d 45 ec             	lea    -0x14(%ebp),%eax
+c01089bf:	89 44 24 04          	mov    %eax,0x4(%esp)
+c01089c3:	c7 04 24 0c 89 10 c0 	movl   $0xc010890c,(%esp)
+c01089ca:	e8 64 fb ff ff       	call   c0108533 <vprintfmt>
     // null terminate the buffer
     *b.buf = '\0';
-c0108294:	8b 45 ec             	mov    -0x14(%ebp),%eax
-c0108297:	c6 00 00             	movb   $0x0,(%eax)
+c01089cf:	8b 45 ec             	mov    -0x14(%ebp),%eax
+c01089d2:	c6 00 00             	movb   $0x0,(%eax)
     return b.cnt;
-c010829a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+c01089d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
 }
-c010829d:	c9                   	leave  
-c010829e:	c3                   	ret    
+c01089d8:	c9                   	leave  
+c01089d9:	c3                   	ret    
 
-c010829f <rand>:
+c01089da <rand>:
  * rand - returns a pseudo-random integer
  *
  * The rand() function return a value in the range [0, RAND_MAX].
  * */
 int
 rand(void) {
-c010829f:	55                   	push   %ebp
-c01082a0:	89 e5                	mov    %esp,%ebp
-c01082a2:	57                   	push   %edi
-c01082a3:	56                   	push   %esi
-c01082a4:	53                   	push   %ebx
-c01082a5:	83 ec 24             	sub    $0x24,%esp
+c01089da:	55                   	push   %ebp
+c01089db:	89 e5                	mov    %esp,%ebp
+c01089dd:	57                   	push   %edi
+c01089de:	56                   	push   %esi
+c01089df:	53                   	push   %ebx
+c01089e0:	83 ec 24             	sub    $0x24,%esp
     next = (next * 0x5DEECE66DLL + 0xBLL) & ((1LL << 48) - 1);
-c01082a8:	a1 60 fa 11 c0       	mov    0xc011fa60,%eax
-c01082ad:	8b 15 64 fa 11 c0    	mov    0xc011fa64,%edx
-c01082b3:	69 fa 6d e6 ec de    	imul   $0xdeece66d,%edx,%edi
-c01082b9:	6b f0 05             	imul   $0x5,%eax,%esi
-c01082bc:	01 fe                	add    %edi,%esi
-c01082be:	bf 6d e6 ec de       	mov    $0xdeece66d,%edi
-c01082c3:	f7 e7                	mul    %edi
-c01082c5:	01 d6                	add    %edx,%esi
-c01082c7:	89 f2                	mov    %esi,%edx
-c01082c9:	83 c0 0b             	add    $0xb,%eax
-c01082cc:	83 d2 00             	adc    $0x0,%edx
-c01082cf:	89 c7                	mov    %eax,%edi
-c01082d1:	83 e7 ff             	and    $0xffffffff,%edi
-c01082d4:	89 f9                	mov    %edi,%ecx
-c01082d6:	0f b7 da             	movzwl %dx,%ebx
-c01082d9:	89 0d 60 fa 11 c0    	mov    %ecx,0xc011fa60
-c01082df:	89 1d 64 fa 11 c0    	mov    %ebx,0xc011fa64
+c01089e3:	a1 60 0a 12 c0       	mov    0xc0120a60,%eax
+c01089e8:	8b 15 64 0a 12 c0    	mov    0xc0120a64,%edx
+c01089ee:	69 fa 6d e6 ec de    	imul   $0xdeece66d,%edx,%edi
+c01089f4:	6b f0 05             	imul   $0x5,%eax,%esi
+c01089f7:	01 fe                	add    %edi,%esi
+c01089f9:	bf 6d e6 ec de       	mov    $0xdeece66d,%edi
+c01089fe:	f7 e7                	mul    %edi
+c0108a00:	01 d6                	add    %edx,%esi
+c0108a02:	89 f2                	mov    %esi,%edx
+c0108a04:	83 c0 0b             	add    $0xb,%eax
+c0108a07:	83 d2 00             	adc    $0x0,%edx
+c0108a0a:	89 c7                	mov    %eax,%edi
+c0108a0c:	83 e7 ff             	and    $0xffffffff,%edi
+c0108a0f:	89 f9                	mov    %edi,%ecx
+c0108a11:	0f b7 da             	movzwl %dx,%ebx
+c0108a14:	89 0d 60 0a 12 c0    	mov    %ecx,0xc0120a60
+c0108a1a:	89 1d 64 0a 12 c0    	mov    %ebx,0xc0120a64
     unsigned long long result = (next >> 12);
-c01082e5:	a1 60 fa 11 c0       	mov    0xc011fa60,%eax
-c01082ea:	8b 15 64 fa 11 c0    	mov    0xc011fa64,%edx
-c01082f0:	0f ac d0 0c          	shrd   $0xc,%edx,%eax
-c01082f4:	c1 ea 0c             	shr    $0xc,%edx
-c01082f7:	89 45 e0             	mov    %eax,-0x20(%ebp)
-c01082fa:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+c0108a20:	a1 60 0a 12 c0       	mov    0xc0120a60,%eax
+c0108a25:	8b 15 64 0a 12 c0    	mov    0xc0120a64,%edx
+c0108a2b:	0f ac d0 0c          	shrd   $0xc,%edx,%eax
+c0108a2f:	c1 ea 0c             	shr    $0xc,%edx
+c0108a32:	89 45 e0             	mov    %eax,-0x20(%ebp)
+c0108a35:	89 55 e4             	mov    %edx,-0x1c(%ebp)
     return (int)do_div(result, RAND_MAX + 1);
-c01082fd:	c7 45 dc 00 00 00 80 	movl   $0x80000000,-0x24(%ebp)
-c0108304:	8b 45 e0             	mov    -0x20(%ebp),%eax
-c0108307:	8b 55 e4             	mov    -0x1c(%ebp),%edx
-c010830a:	89 45 d8             	mov    %eax,-0x28(%ebp)
-c010830d:	89 55 e8             	mov    %edx,-0x18(%ebp)
-c0108310:	8b 45 e8             	mov    -0x18(%ebp),%eax
-c0108313:	89 45 ec             	mov    %eax,-0x14(%ebp)
-c0108316:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
-c010831a:	74 1c                	je     c0108338 <rand+0x99>
-c010831c:	8b 45 e8             	mov    -0x18(%ebp),%eax
-c010831f:	ba 00 00 00 00       	mov    $0x0,%edx
-c0108324:	f7 75 dc             	divl   -0x24(%ebp)
-c0108327:	89 55 ec             	mov    %edx,-0x14(%ebp)
-c010832a:	8b 45 e8             	mov    -0x18(%ebp),%eax
-c010832d:	ba 00 00 00 00       	mov    $0x0,%edx
-c0108332:	f7 75 dc             	divl   -0x24(%ebp)
-c0108335:	89 45 e8             	mov    %eax,-0x18(%ebp)
-c0108338:	8b 45 d8             	mov    -0x28(%ebp),%eax
-c010833b:	8b 55 ec             	mov    -0x14(%ebp),%edx
-c010833e:	f7 75 dc             	divl   -0x24(%ebp)
-c0108341:	89 45 d8             	mov    %eax,-0x28(%ebp)
-c0108344:	89 55 d4             	mov    %edx,-0x2c(%ebp)
-c0108347:	8b 45 d8             	mov    -0x28(%ebp),%eax
-c010834a:	8b 55 e8             	mov    -0x18(%ebp),%edx
-c010834d:	89 45 e0             	mov    %eax,-0x20(%ebp)
-c0108350:	89 55 e4             	mov    %edx,-0x1c(%ebp)
-c0108353:	8b 45 d4             	mov    -0x2c(%ebp),%eax
-}
-c0108356:	83 c4 24             	add    $0x24,%esp
-c0108359:	5b                   	pop    %ebx
-c010835a:	5e                   	pop    %esi
-c010835b:	5f                   	pop    %edi
-c010835c:	5d                   	pop    %ebp
-c010835d:	c3                   	ret    
+c0108a38:	c7 45 dc 00 00 00 80 	movl   $0x80000000,-0x24(%ebp)
+c0108a3f:	8b 45 e0             	mov    -0x20(%ebp),%eax
+c0108a42:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+c0108a45:	89 45 d8             	mov    %eax,-0x28(%ebp)
+c0108a48:	89 55 e8             	mov    %edx,-0x18(%ebp)
+c0108a4b:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0108a4e:	89 45 ec             	mov    %eax,-0x14(%ebp)
+c0108a51:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+c0108a55:	74 1c                	je     c0108a73 <rand+0x99>
+c0108a57:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0108a5a:	ba 00 00 00 00       	mov    $0x0,%edx
+c0108a5f:	f7 75 dc             	divl   -0x24(%ebp)
+c0108a62:	89 55 ec             	mov    %edx,-0x14(%ebp)
+c0108a65:	8b 45 e8             	mov    -0x18(%ebp),%eax
+c0108a68:	ba 00 00 00 00       	mov    $0x0,%edx
+c0108a6d:	f7 75 dc             	divl   -0x24(%ebp)
+c0108a70:	89 45 e8             	mov    %eax,-0x18(%ebp)
+c0108a73:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c0108a76:	8b 55 ec             	mov    -0x14(%ebp),%edx
+c0108a79:	f7 75 dc             	divl   -0x24(%ebp)
+c0108a7c:	89 45 d8             	mov    %eax,-0x28(%ebp)
+c0108a7f:	89 55 d4             	mov    %edx,-0x2c(%ebp)
+c0108a82:	8b 45 d8             	mov    -0x28(%ebp),%eax
+c0108a85:	8b 55 e8             	mov    -0x18(%ebp),%edx
+c0108a88:	89 45 e0             	mov    %eax,-0x20(%ebp)
+c0108a8b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
+c0108a8e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+}
+c0108a91:	83 c4 24             	add    $0x24,%esp
+c0108a94:	5b                   	pop    %ebx
+c0108a95:	5e                   	pop    %esi
+c0108a96:	5f                   	pop    %edi
+c0108a97:	5d                   	pop    %ebp
+c0108a98:	c3                   	ret    
 
-c010835e <srand>:
+c0108a99 <srand>:
 /* *
  * srand - seed the random number generator with the given number
  * @seed:   the required seed number
  * */
 void
 srand(unsigned int seed) {
-c010835e:	55                   	push   %ebp
-c010835f:	89 e5                	mov    %esp,%ebp
+c0108a99:	55                   	push   %ebp
+c0108a9a:	89 e5                	mov    %esp,%ebp
     next = seed;
-c0108361:	8b 45 08             	mov    0x8(%ebp),%eax
-c0108364:	ba 00 00 00 00       	mov    $0x0,%edx
-c0108369:	a3 60 fa 11 c0       	mov    %eax,0xc011fa60
-c010836e:	89 15 64 fa 11 c0    	mov    %edx,0xc011fa64
-}
-c0108374:	90                   	nop
-c0108375:	5d                   	pop    %ebp
-c0108376:	c3                   	ret    
+c0108a9c:	8b 45 08             	mov    0x8(%ebp),%eax
+c0108a9f:	ba 00 00 00 00       	mov    $0x0,%edx
+c0108aa4:	a3 60 0a 12 c0       	mov    %eax,0xc0120a60
+c0108aa9:	89 15 64 0a 12 c0    	mov    %edx,0xc0120a64
+}
+c0108aaf:	90                   	nop
+c0108ab0:	5d                   	pop    %ebp
+c0108ab1:	c3                   	ret    
diff -r -uN labcodes_answer/lab3_result/obj/kernel.sym labcodes/lab3/obj/kernel.sym
--- labcodes_answer/lab3_result/obj/kernel.sym	2020-05-30 10:42:06.589373725 +0800
+++ labcodes/lab3/obj/kernel.sym	2020-05-30 16:42:21.726841019 +0800
@@ -1,543 +1,543 @@
 c0100000 .text
-c0108380 .rodata
-c010a3a0 .stab
-c0119521 .stabstr
-c011d000 .data
-c0120000 .data.pgdir
-c0122000 .bss
+c0108ac0 .rodata
+c010aad0 .stab
+c0119a65 .stabstr
+c011e000 .data
+c0121000 .data.pgdir
+c0123000 .bss
 00000000 .comment
 00000000 obj/kern/init/entry.o
 c010001e next
 c0100034 spin
-c0121000 __boot_pt1
+c0122000 __boot_pt1
 00000400 i
 00000000 init.c
-c010012a lab1_print_cur_status
-c0122000 round.1797
-c01001e7 lab1_switch_to_user
-c01001ed lab1_switch_to_kernel
-c01001f3 lab1_switch_test
+c0100149 lab1_print_cur_status
+c0123000 round.1833
+c0100207 lab1_switch_to_user
+c010020d lab1_switch_to_kernel
+c0100213 lab1_switch_test
 00000000 stdio.c
-c0100235 cputch
+c010024d cputch
 00000000 readline.c
-c0122020 buf
+c0123020 buf
 00000000 panic.c
-c0122420 is_panic
+c0123420 is_panic
 00000000 kdebug.c
-c01004bc stab_binsearch
-c0100a5a read_eip
+c01004c7 stab_binsearch
+c0100a81 read_eip
 00000000 kmonitor.c
-c011f000 commands
-c0100b30 parse
-c0100bec runcmd
+c0120000 commands
+c0100a98 parse
+c0100b53 runcmd
 00000000 ide.c
-c0108694 channels
-c0122440 ide_devices
-c0100d88 ide_wait_ready
+c0108dac channels
+c0123440 ide_devices
+c0100ce7 ide_wait_ready
 00000000 clock.c
 00000000 console.c
-c0101623 __intr_save
-c010164d __intr_restore
-c0101661 delay
-c0122520 crt_buf
-c0122524 crt_pos
-c0122526 addr_6845
-c01016aa cga_init
-c0122528 serial_exists
-c0101791 serial_init
-c0101876 lpt_putc_sub
-c01018f0 lpt_putc
-c0101927 cga_putc
-c0101afc serial_putc_sub
-c0101b56 serial_putc
-c0122540 cons
-c0101b8d cons_intr
-c0101bd9 serial_proc_data
-c011f040 shiftcode
-c011f140 togglecode
-c011f240 normalmap
-c011f340 shiftmap
-c011f440 ctlmap
-c011f540 charcode
-c0101c52 kbd_proc_data
-c0122748 shift.1612
-c0101ddf kbd_intr
-c0101df8 kbd_init
+c01015b2 __intr_save
+c01015dc __intr_restore
+c01015f0 delay
+c0123520 crt_buf
+c0123524 crt_pos
+c0123526 addr_6845
+c0101637 cga_init
+c0123528 serial_exists
+c0101719 serial_init
+c01017f8 lpt_putc_sub
+c010186f lpt_putc
+c01018af cga_putc
+c0101a90 serial_putc_sub
+c0101ae8 serial_putc
+c0123540 cons
+c0101b28 cons_intr
+c0101b74 serial_proc_data
+c0120040 shiftcode
+c0120140 togglecode
+c0120240 normalmap
+c0120340 shiftmap
+c0120440 ctlmap
+c0120540 charcode
+c0101be8 kbd_proc_data
+c0123748 shift.1612
+c0101d6d kbd_intr
+c0101d82 kbd_init
 00000000 picirq.c
-c011f550 irq_mask
-c012274c did_init
-c0101eff pic_setmask
+c0120550 irq_mask
+c012374c did_init
+c0101e75 pic_setmask
 00000000 intr.c
 00000000 trap.c
-c01020d0 print_ticks
-c0122760 idt
-c011f560 idt_pd
-c01021ff trapname
-c0108be0 excnames.1710
-c011f580 IA32flags
-c01024e3 print_pgfault
-c0102558 pgfault_handler
-c0122f60 in_swap_tick_event
-c01025b2 trap_dispatch
+c0102041 print_ticks
+c0123760 idt
+c0120560 idt_pd
+c0102089 trapname
+c0109300 excnames.1704
+c0120580 IA32flags
+c010233c print_pgfault
+c01023ba pgfault_handler
+c0123f60 in_swap_tick_event
+c0102418 trap_dispatch
 00000000 pmm.c
-c01031c9 page2ppn
-c01031dc page2pa
-c01031ef pa2page
-c010322c page2kva
-c0103271 kva2page
-c01032b0 pte2page
-c01032ea pde2page
-c0103306 page_ref
-c0103310 set_page_ref
-c010331e page_ref_inc
-c0103335 page_ref_dec
-c010334c __intr_save
-c0103376 __intr_restore
-c0122fa0 ts
-c011fa00 gdt
-c011fa30 gdt_pd
-c010338a lgdt
-c01033ce gdt_init
-c01034c0 init_pmm_manager
-c01034f5 init_memmap
-c01035e3 page_init
-c010398f boot_map_segment
-c0103a78 boot_alloc_page
-c0103f3d check_alloc_page
-c0103f60 check_pgdir
-c01044c6 check_boot_pgdir
-c0103cee page_remove_pte
-c01047bf perm2str
-c0123008 str.1892
-c010480d get_pgtable_items
+c0103006 page2ppn
+c0103019 page2pa
+c010302f pa2page
+c0103074 page2kva
+c01030c8 kva2page
+c0103112 pte2page
+c0103150 pde2page
+c0103168 page_ref
+c0103172 set_page_ref
+c0103180 page_ref_inc
+c0103197 page_ref_dec
+c01031ae __intr_save
+c01031d8 __intr_restore
+c0123fa0 ts
+c0120a00 gdt
+c0120a30 gdt_pd
+c01031ec lgdt
+c0103230 gdt_init
+c0103319 init_pmm_manager
+c010334d init_memmap
+c0103436 page_init
+c010380d boot_map_segment
+c0103910 boot_alloc_page
+c0103e77 check_alloc_page
+c0103e96 check_pgdir
+c0104532 check_boot_pgdir
+c0103bcc page_remove_pte
+c01048bc perm2str
+c0124008 str.1892
+c01048fe get_pgtable_items
 00000000 vmm.c
-c0104b2e pa2page
-c0104b6b pde2page
-c0104cf0 check_vma_overlap
-c0104f18 check_vmm
-c0104f66 check_vma_struct
-c0105386 check_pgfault
+c0104c5a pa2page
+c0104c9f pde2page
+c0104e1b check_vma_overlap
+c0105080 check_vmm
+c01050d5 check_vma_struct
+c0105595 check_pgfault
 00000000 swap.c
-c010578e pa2page
-c01057cb pte2page
-c0123018 sm
-c0105c7a check_swap
-c0105b01 check_content_set
-c0105c62 check_content_access
+c01059ee pa2page
+c0105a33 pte2page
+c0124018 sm
+c0105f9a check_swap
+c0105dc9 check_content_set
+c0105f82 check_content_access
 00000000 swap_fifo.c
-c010622d _fifo_init_mm
-c010625f _fifo_map_swappable
-c01062f1 _fifo_swap_out_victim
-c01063ba _fifo_check_swap
-c0106689 _fifo_init
-c0106693 _fifo_set_unswappable
-c010669d _fifo_tick_event
+c01065f9 _fifo_init_mm
+c010662b _fifo_map_swappable
+c01066cb _fifo_swap_out_victim
+c01067cc _fifo_check_swap
+c0106b21 _fifo_init
+c0106b2b _fifo_set_unswappable
+c0106b35 _fifo_tick_event
 00000000 default_pmm.c
-c01066a7 page2ppn
-c01066ba page2pa
-c01066cd page_ref
-c01066d7 set_page_ref
-c01066e5 default_init
-c0106713 default_init_memmap
-c0106838 default_alloc_pages
-c01069a6 default_free_pages
-c0106c8f default_nr_free_pages
-c0106c99 basic_check
-c010710f default_check
+c0106b3f page2ppn
+c0106b52 page2pa
+c0106b68 page_ref
+c0106b72 set_page_ref
+c0106b80 default_init
+c0106bae default_init_memmap
+c0106cf6 default_alloc_pages
+c0106e71 default_free_pages
+c010717e default_nr_free_pages
+c0107188 basic_check
+c01076c5 default_check
 00000000 swapfs.c
-c0107677 page2ppn
-c010768a page2pa
-c010769d page2kva
+c0107d16 page2ppn
+c0107d29 page2pa
+c0107d3f page2kva
 00000000 string.c
 00000000 printfmt.c
-c010a208 error_string
-c0107c93 printnum
-c0107d84 getuint
-c0107dd3 getint
-c01081e6 sprintputch
+c010a938 error_string
+c0108369 printnum
+c010846e getuint
+c01084bd getint
+c010890c sprintputch
 00000000 rand.c
-c011fa60 next
-c01030ff vector242
-c0102b56 vector119
-c0100921 print_kerninfo
-c0102a36 vector87
-c0102a2d vector86
-c010316b vector251
-c010782f strcpy
-c01010e6 ide_device_valid
-c0102a5a vector91
-c0102850 vector33
-c0102d3f vector162
-c0102fa3 vector213
-c0102af3 vector108
-c01028aa vector43
+c0120a60 next
+c0102f3c vector242
+c0102993 vector119
+c0100947 print_kerninfo
+c0102873 vector87
+c010286a vector86
+c0102fa8 vector251
+c0107f16 strcpy
+c010105a ide_device_valid
+c0102897 vector91
+c010268d vector33
+c0102b7c vector162
+c0102de0 vector213
+c0102930 vector108
+c01026e7 vector43
 c0100000 kern_entry
-c0100d76 mon_backtrace
-c0102d63 vector165
-c0102e53 vector185
-c0102b32 vector115
-c0102b71 vector122
-c0103d8c page_insert
-c0102cf7 vector156
-c0103123 vector245
-c0102e83 vector189
-c0102776 vector7
-c010294c vector61
-c01027ff vector24
-c0102b0e vector111
-c0102f07 vector200
-c0102982 vector67
-c0103e95 pgdir_alloc_page
-c0102c1f vector138
-c01029c1 vector74
-c0107b48 memmove
-c0102928 vector57
-c0104b87 mm_create
-c010821c snprintf
-c0102246 print_trapframe
-c0102faf vector214
-c0107e3e vprintfmt
-c0102aa2 vector99
-c0103c98 get_page
-c01031a7 __alltraps
-c0101e8d cons_getc
-c0102c43 vector141
-c01004b2 is_kernel_panic
-c0102db7 vector172
-c0100a6b print_stackframe
-c01030f3 vector241
-c0123104 pra_list_head
-c0103183 vector253
-c0102752 vector3
-c0102749 vector2
-c010304b vector227
-c0102f7f vector210
-c0103027 vector224
-c0102898 vector41
-c011fa40 swap_manager_fifo
-c0100282 cprintf
-c01027e4 vector21
-c0102df3 vector177
-c0102b4d vector118
-c010299d vector70
-c0102994 vector69
-c01030c3 vector237
-c0102967 vector64
-c010281a vector27
-c0104f0a vmm_init
-c0102bd7 vector132
-c0102e5f vector186
-c0102fd3 vector217
-c0104e8f mm_destroy
-c0107beb memcpy
-c0102740 vector1
-c0102dff vector178
-c010287d vector38
-c0104aa6 kfree
-c01030cf vector238
-c0100326 readline
-c0102be3 vector133
-c01029b8 vector73
-c0102c67 vector144
-c0108cd0 vpd
+c0100cd5 mon_backtrace
+c0102ba0 vector165
+c0102c90 vector185
+c010296f vector115
+c01029ae vector122
+c0103c97 page_insert
+c0102b34 vector156
+c0102f60 vector245
+c0102cc0 vector189
+c01025b1 vector7
+c0102789 vector61
+c010263c vector24
+c010294b vector111
+c0102d44 vector200
+c01027bf vector67
+c0103dac pgdir_alloc_page
+c0102a5c vector138
+c01027fe vector74
+c0108220 memmove
+c0102765 vector57
+c0104cb7 mm_create
+c0108942 snprintf
+c01020cf print_trapframe
+c0102dec vector214
+c0108533 vprintfmt
+c01028df vector99
+c0103b73 get_page
+c0102fe4 __alltraps
+c0101e06 cons_getc
+c0102a80 vector141
+c01004bd is_kernel_panic
+c0102bf4 vector172
+c0100a92 print_stackframe
+c0102f30 vector241
+c0124104 pra_list_head
+c0102fc0 vector253
+c010258d vector3
+c0102584 vector2
+c0102e88 vector227
+c0102dbc vector210
+c0102e64 vector224
+c01026d5 vector41
+c0120a40 swap_manager_fifo
+c01002a1 cprintf
+c0102621 vector21
+c0102c30 vector177
+c010298a vector118
+c01027da vector70
+c01027d1 vector69
+c0102f00 vector237
+c01027a4 vector64
+c0102657 vector27
+c0105072 vmm_init
+c0102a14 vector132
+c0102c9c vector186
+c0102e10 vector217
+c0104ff2 mm_destroy
+c01082c3 memcpy
+c010257b vector1
+c0102c3c vector178
+c01026ba vector38
+c0104bbf kfree
+c0102f0c vector238
+c0100343 readline
+c0102a20 vector133
+c01027f5 vector73
+c0102aa4 vector144
+c01093f0 vpd
 c0100036 kern_init
-c010318f vector254
-c0102ab4 vector101
-c0102f8b vector211
-c0102dcf vector174
-c010310b vector243
-c0102ba7 vector128
-c0102a00 vector81
-c0103580 free_pages
-c01027a2 vector13
-c0108245 vsnprintf
-c01028f2 vector51
-c01027b9 vector16
-c0122000 edata
-c0101e13 cons_init
-c0105a4e swap_in
-c0101390 ide_write_secs
-c0123020 pmm_manager
-c01030e7 vector240
-c010290d vector54
-c01027d2 vector19
-c0119520 __STAB_END__
-c0102a63 vector92
-c0103117 vector244
-c0123010 swap_init_ok
-c01033c0 load_esp0
-c0102c37 vector140
-c01028bc vector45
-c01029ee vector79
-c0103063 vector229
-c0105805 swap_init
-c0102d0f vector158
-c0101f58 pic_enable
-c01076e2 swapfs_init
-c0123040 check_rp
-c0102886 vector39
-c0102d87 vector168
-c0102862 vector35
-c0102b20 vector113
-c0119521 __STABSTR_BEGIN__
-c0102b8c vector125
-c01003e8 __panic
-c0102fc7 vector216
-c010295e vector63
-c0102811 vector26
-c0101c30 serial_intr
-c0102eb3 vector193
-c0102ed7 vector196
-c01000ef grade_backtrace0
-c0102f73 vector209
-c010275b vector4
-c0102d9f vector170
-c0102c07 vector136
-c010278d vector10
-c0102f4f vector206
-c010319b vector255
-c0102e23 vector181
-c010293a vector59
-c0100109 grade_backtrace
-c0102a24 vector85
-c0102a1b vector84
-c0102e3b vector183
-c0102d1b vector159
-c0102f97 vector212
-c01028ce vector47
-c01079ab strtol
-c0103057 vector228
-c01028a1 vector42
-c0102b29 vector114
-c01077ff strnlen
-c0102ddb vector175
-c0102c5b vector143
-c0102bbf vector130
-c010a10c default_pmm_manager
-c010312f vector246
-c0102786 vector9
-c0102c4f vector142
-c0102aab vector100
-c0102f13 vector201
-c010210c idt_init
-c01009be print_debuginfo
-c0104c3f find_vma
-c0123060 swap_in_seq_no
-c0102943 vector60
-c01027f6 vector23
-c01030b7 vector236
-c0122f80 npage
-c010558b do_pgfault
-c010307b vector231
-c0102979 vector66
-c010282c vector29
-c01048c1 print_pgdir
-c0102bfb vector135
-c0100c9c kmonitor
-c01029dc vector77
-c0102e17 vector180
-c01015ba clock_init
-c0102f67 vector208
-c0102a99 vector98
-c0102a90 vector97
-c01035b5 nr_free_pages
-c0102de7 vector176
-c0102ebf vector194
-c0102847 vector32
-c0123024 boot_cr3
-c0123118 end
-c0102efb vector199
-c0102bcb vector131
-c0103177 vector252
-c0102737 vector0
-c010797c strfind
-c0101e44 cons_putc
-c01230a0 swap_out_seq_no
-c0108377 etext
-c0102c73 vector145
-c0102aea vector107
-c011f9e0 boot_pgdir
-c010288f vector40
-c01020c2 intr_enable
-c0102abd vector102
-c010291f vector56
-c010298b vector68
-c010276d vector6
-c010829f rand
-c0102bb3 vector129
-c0102ee3 vector197
-c0102cc7 vector152
-c011f5e0 __vectors
-c010306f vector230
-c01078f3 strncmp
-c0103b7b get_pte
-c0101126 ide_device_size
-c0102874 vector37
-c01230c8 check_swap_addr
-c0102f43 vector205
-c0102d33 vector161
-c010786f strncpy
-c01029a6 vector71
-c0102d27 vector160
-c0102fbb vector215
-c0102d03 vector157
-c01020c9 intr_disable
-c0102423 print_regs
-c0102b17 vector112
-c01000b0 grade_backtrace2
-c0102e2f vector182
-c010279b vector12
-c0107c3b memcmp
-c0102afc vector109
-c01027db vector20
-c0102904 vector53
-c01027c9 vector18
-c0102a7e vector95
-c010303f vector226
-c01028e0 vector49
-c01028b3 vector44
-c01029e5 vector78
-c0102dc3 vector173
-c0107725 swapfs_read
-c0102b44 vector117
-c0102230 trap_in_kernel
-c01058df swap_set_unswappable
-c0102a09 vector82
-c010300f vector222
-c010277f vector8
-c0102ca3 vector149
-c01002a8 cputchar
-c0107b08 memset
-c0103087 vector232
-c0101166 ide_read_secs
-c0102ae1 vector106
-c0102ff7 vector220
-c0102a51 vector90
-c0102d4b vector163
-c010835e srand
-c010309f vector234
-c01058be swap_map_swappable
-c0102955 vector62
-c0102808 vector25
-c0102eef vector198
-c0102b5f vector120
-c010030d getchar
-c0103d53 page_remove
-c01028e9 vector50
-c01027b0 vector15
-c0123014 swap_out_num
-c0107e1a printfmt
-c0102cbb vector151
-c0102a12 vector83
-c0102a48 vector89
-c0102a3f vector88
-c0102720 trap
-c0102e0b vector179
-c0102859 vector34
-c011ce06 __STABSTR_END__
-c01028c5 vector46
-c01078a9 strcmp
-c0102bef vector134
-c010301b vector223
-c0102fdf vector218
-c0100613 debuginfo_eip
-c01230dc max_swap_offset
-c0104d6b insert_vma_struct
-c0101f85 pic_init
-c0103033 vector225
-c0102e6b vector187
-c0103abb pmm_init
-c0102835 vector30
-c0102b9e vector127
-c012301c ticks
-c0102ea7 vector192
-c0102d6f vector166
-c01029d3 vector76
-c01029ca vector75
-c0102ecb vector195
-c0102caf vector150
-c0102931 vector58
-c0103147 vector248
-c0102b7a vector123
-c0102a87 vector96
-c010283e vector31
-c0102f2b vector203
-c0103514 alloc_pages
-c0102c2b vector139
-c0102cd3 vector153
-c0102d57 vector164
-c0102b68 vector121
-c0102764 vector5
-c0102d7b vector167
-c0102ceb vector155
-c0103153 vector249
-c0108ccc vpt
-c010315f vector250
-c0102b83 vector124
-c0102b05 vector110
-c0102f37 vector204
-c01230e0 swap_page
-c01031be __trapret
-c0100259 vcprintf
-c0102c13 vector137
-c010046b __warn
-c010313b vector247
-c01027ed vector22
-c0102f1f vector202
-c01029af vector72
-c0102916 vector55
-c01002bf cputs
-c011f000 bootstacktop
-c0102b95 vector126
-c0102970 vector65
-c0102823 vector28
-c0102d93 vector169
-c01058a3 swap_tick_event
-c0103093 vector233
-c01058fd swap_out
-c0104a15 kmalloc
-c0104c03 vma_create
-c0102c8b vector147
-c011d000 bootstack
-c0120000 __boot_pgdir
-c0102acf vector104
-c012310c free_area
-c0102b3b vector116
-c010777e swapfs_write
-c010a3a0 __STAB_BEGIN__
-c01230f4 check_ptep
-c01028fb vector52
-c01027c2 vector17
-c0102e47 vector184
-c01077d7 strlen
-c012300c pgfault_num
-c0102f5b vector207
-c0102e8f vector190
-c0100de2 ide_init
-c01030db vector239
-c0102a75 vector94
-c0102a6c vector93
-c0102e77 vector188
-c0107949 strchr
-c01028d7 vector48
-c012302c check_mm_struct
-c0105888 swap_init_mm
-c01000ca grade_backtrace1
-c0102feb vector219
-c0102c97 vector148
-c0103003 vector221
-c01029f7 vector80
-c0102dab vector171
-c0102cdf vector154
-c010286b vector36
-c01030ab vector235
-c0102ad8 vector105
-c0100d64 mon_kerninfo
-c0123028 pages
-c0102c7f vector146
-c0102e9b vector191
-c0102ac6 vector103
-c0100d0a mon_help
-c0102794 vector11
-c0103e45 tlb_invalidate
-c01027a9 vector14
+c0102fcc vector254
+c01028f1 vector101
+c0102dc8 vector211
+c0102c0c vector174
+c0102f48 vector243
+c01029e4 vector128
+c010283d vector81
+c01033d8 free_pages
+c01025df vector13
+c0108976 vsnprintf
+c010272f vector51
+c01025f6 vector16
+c0123000 edata
+c0101d9c cons_init
+c0105cf3 swap_in
+c0101315 ide_write_secs
+c0124020 pmm_manager
+c0102f24 vector240
+c010274a vector54
+c010260f vector19
+c0119a64 __STAB_END__
+c01028a0 vector92
+c0102f54 vector244
+c0124010 swap_init_ok
+c0103222 load_esp0
+c0102a74 vector140
+c01026f9 vector45
+c010282b vector79
+c0102ea0 vector229
+c0105a71 swap_init
+c0102b4c vector158
+c0101ecd pic_enable
+c0107d93 swapfs_init
+c0124040 check_rp
+c01026c3 vector39
+c0102bc4 vector168
+c010269f vector35
+c010295d vector113
+c0119a65 __STABSTR_BEGIN__
+c01029c9 vector125
+c01003f8 __panic
+c0102e04 vector216
+c010279b vector63
+c010264e vector26
+c0101bca serial_intr
+c0102cf0 vector193
+c0102d14 vector196
+c0100108 grade_backtrace0
+c0102db0 vector209
+c0102596 vector4
+c0102bdc vector170
+c0102a44 vector136
+c01025ca vector10
+c0102d8c vector206
+c0102fd8 vector255
+c0102c60 vector181
+c0102777 vector59
+c0100123 grade_backtrace
+c0102861 vector85
+c0102858 vector84
+c0102c78 vector183
+c0102b58 vector159
+c0102dd4 vector212
+c010270b vector47
+c010808a strtol
+c0102e94 vector228
+c01026de vector42
+c0102966 vector114
+c0107ee7 strnlen
+c0102c18 vector175
+c0102a98 vector143
+c01029fc vector130
+c010a83c default_pmm_manager
+c0102f6c vector246
+c01025c1 vector9
+c0102a8c vector142
+c01028e8 vector100
+c0102d50 vector201
+c0102083 idt_init
+c01009de print_debuginfo
+c0104d6a find_vma
+c0124060 swap_in_seq_no
+c0102780 vector60
+c0102633 vector23
+c0102ef4 vector236
+c0123f80 npage
+c01057d9 do_pgfault
+c0102eb8 vector231
+c01027b6 vector66
+c0102669 vector29
+c01049b0 print_pgdir
+c0102a38 vector135
+c0100c08 kmonitor
+c0102819 vector77
+c0102c54 vector180
+c010154f clock_init
+c0102da4 vector208
+c01028d6 vector98
+c01028cd vector97
+c010340b nr_free_pages
+c0102c24 vector176
+c0102cfc vector194
+c0102684 vector32
+c0124024 boot_cr3
+c0124118 end
+c0102d38 vector199
+c0102a08 vector131
+c0102fb4 vector252
+c0102572 vector0
+c010805c strfind
+c0101dc9 cons_putc
+c01240a0 swap_out_seq_no
+c0108ab2 etext
+c0102ab0 vector145
+c0102927 vector107
+c01209e0 boot_pgdir
+c01026cc vector40
+c0102033 intr_enable
+c01028fa vector102
+c010275c vector56
+c01027c8 vector68
+c01025a8 vector6
+c01089da rand
+c01029f0 vector129
+c0102d20 vector197
+c0102b04 vector152
+c01205e0 __vectors
+c0102eac vector230
+c0107fd7 strncmp
+c0103a3a get_pte
+c010109c ide_device_size
+c01026b1 vector37
+c01240c8 check_swap_addr
+c0102d80 vector205
+c0102b70 vector161
+c0107f56 strncpy
+c01027e3 vector71
+c0102b64 vector160
+c0102df8 vector215
+c0102b40 vector157
+c010203a intr_disable
+c0102284 print_regs
+c0102954 vector112
+c01000b5 grade_backtrace2
+c0102c6c vector182
+c01025d8 vector12
+c0108313 memcmp
+c0102939 vector109
+c0102618 vector20
+c0102741 vector53
+c0102606 vector18
+c01028bb vector95
+c0102e7c vector226
+c010271d vector49
+c01026f0 vector44
+c0102822 vector78
+c0102c00 vector173
+c0107ddc swapfs_read
+c0102981 vector117
+c01020ba trap_in_kernel
+c0105b5e swap_set_unswappable
+c0102846 vector82
+c0102e4c vector222
+c01025ba vector8
+c0102ae0 vector149
+c01002c7 cputchar
+c01081e0 memset
+c0102ec4 vector232
+c01010db ide_read_secs
+c010291e vector106
+c0102e34 vector220
+c010288e vector90
+c0102b88 vector163
+c0108a99 srand
+c0102edc vector234
+c0105b31 swap_map_swappable
+c0102792 vector62
+c0102645 vector25
+c0102d2c vector198
+c010299c vector120
+c010032a getchar
+c0103c52 page_remove
+c0102726 vector50
+c01025ed vector15
+c0124014 swap_out_num
+c0108504 printfmt
+c0102af8 vector151
+c010284f vector83
+c0102885 vector89
+c010287c vector88
+c010255e trap
+c0102c48 vector179
+c0102696 vector34
+c011d32d __STABSTR_END__
+c0102702 vector46
+c0107f8d strcmp
+c0102a2c vector134
+c0102e58 vector223
+c0102e1c vector218
+c0100615 debuginfo_eip
+c01240dc max_swap_offset
+c0104ec0 insert_vma_struct
+c0101f00 pic_init
+c0102e70 vector225
+c0102ca8 vector187
+c0103954 pmm_init
+c0102672 vector30
+c01029db vector127
+c012401c ticks
+c0102ce4 vector192
+c0102bac vector166
+c0102810 vector76
+c0102807 vector75
+c0102d08 vector195
+c0102aec vector150
+c010276e vector58
+c0102f84 vector248
+c01029b7 vector123
+c01028c4 vector96
+c010267b vector31
+c0102d68 vector203
+c010336d alloc_pages
+c0102a68 vector139
+c0102b10 vector153
+c0102b94 vector164
+c01029a5 vector121
+c010259f vector5
+c0102bb8 vector167
+c0102b28 vector155
+c0102f90 vector249
+c01093ec vpt
+c0102f9c vector250
+c01029c0 vector124
+c0102942 vector110
+c0102d74 vector204
+c01240e0 swap_page
+c0102ffb __trapret
+c010026e vcprintf
+c0102a50 vector137
+c0100476 __warn
+c0102f78 vector247
+c010262a vector22
+c0102d5c vector202
+c01027ec vector72
+c0102753 vector55
+c01002db cputs
+c0120000 bootstacktop
+c01029d2 vector126
+c01027ad vector65
+c0102660 vector28
+c0102bd0 vector169
+c0105b19 swap_tick_event
+c0102ed0 vector233
+c0105b7d swap_out
+c0104b1f kmalloc
+c0104d2f vma_create
+c0102ac8 vector147
+c011e000 bootstack
+c0121000 __boot_pgdir
+c010290c vector104
+c012410c free_area
+c0102978 vector116
+c0107e4e swapfs_write
+c010aad0 __STAB_BEGIN__
+c01240f4 check_ptep
+c0102738 vector52
+c01025ff vector17
+c0102c84 vector184
+c0107ec0 strlen
+c012400c pgfault_num
+c0102d98 vector207
+c0102ccc vector190
+c0100d40 ide_init
+c0102f18 vector239
+c01028b2 vector94
+c01028a9 vector93
+c0102cb4 vector188
+c010802a strchr
+c0102714 vector48
+c012402c check_mm_struct
+c0105b01 swap_init_mm
+c01000da grade_backtrace1
+c0102e28 vector219
+c0102ad4 vector148
+c0102e40 vector221
+c0102834 vector80
+c0102be8 vector171
+c0102b1c vector154
+c01026a8 vector36
+c0102ee8 vector235
+c0102915 vector105
+c0100cc3 mon_kerninfo
+c0124028 pages
+c0102abc vector146
+c0102cd8 vector191
+c0102903 vector103
+c0100c68 mon_help
+c01025d1 vector11
+c0103d50 tlb_invalidate
+c01025e6 vector14
Binary files labcodes_answer/lab3_result/obj/libs/printfmt.o and labcodes/lab3/obj/libs/printfmt.o differ
Binary files labcodes_answer/lab3_result/obj/libs/string.o and labcodes/lab3/obj/libs/string.o differ
Binary files labcodes_answer/lab3_result/obj/sign/tools/sign.o and labcodes/lab3/obj/sign/tools/sign.o differ
diff -r -uN labcodes_answer/lab3_result/.qemu.out labcodes/lab3/.qemu.out
--- labcodes_answer/lab3_result/.qemu.out	2020-05-30 10:42:09.117376215 +0800
+++ labcodes/lab3/.qemu.out	2020-05-30 16:42:23.206845510 +0800
@@ -2,24 +2,10 @@
 
 Special kernel symbols:
   entry  0xc0100036 (phys)
-  etext  0xc0108377 (phys)
-  edata  0xc0122000 (phys)
-  end    0xc0123118 (phys)
-Kernel executable memory footprint: 141KB
-ebp:0xc011ef48 eip:0xc0100a81 args:0x00010094 0x00010094 0xc011ef78 0xc01000c4 
-    kern/debug/kdebug.c:308: print_stackframe+21
-ebp:0xc011ef58 eip:0xc0100d81 args:0x00000000 0x00000000 0x00000000 0xc011efc8 
-    kern/debug/kmonitor.c:129: mon_backtrace+10
-ebp:0xc011ef78 eip:0xc01000c4 args:0x00000000 0xc011efa0 0xffff0000 0xc011efa4 
-    kern/init/init.c:56: grade_backtrace2+19
-ebp:0xc011ef98 eip:0xc01000e6 args:0x00000000 0xffff0000 0xc011efc4 0x0000002a 
-    kern/init/init.c:61: grade_backtrace1+27
-ebp:0xc011efb8 eip:0xc0100103 args:0x00000000 0xc0100036 0xffff0000 0xc0100079 
-    kern/init/init.c:66: grade_backtrace0+19
-ebp:0xc011efd8 eip:0xc0100124 args:0x00000000 0x00000000 0x00000000 0xc0108380 
-    kern/init/init.c:71: grade_backtrace+26
-ebp:0xc011eff8 eip:0xc0100086 args:0xc010857c 0xc0108584 0xc0100d0a 0xc01085a3 
-    kern/init/init.c:31: kern_init+79
+  etext  0xc0108ab2 (phys)
+  edata  0xc0123000 (phys)
+  end    0xc0124118 (phys)
+Kernel executable memory footprint: 145KB
 memory management: default_pmm_manager
 e820map:
   memory: 0009fc00, [00000000, 0009fbff], type = 1.
@@ -39,73 +25,3 @@
   |-- PTE(00001) fafeb000-fafec000 00001000 -rw
 --------------------- END ---------------------
 check_vma_struct() succeeded!
-page fault at 0x00000100: K/W [no page found].
-check_pgfault() succeeded!
-check_vmm() succeeded.
-ide 0:      10000(sectors), 'QEMU HARDDISK'.
-ide 1:     262144(sectors), 'QEMU HARDDISK'.
-SWAP: manager = fifo swap manager
-BEGIN check_swap: count 1, total 31965
-setup Page Table for vaddr 0X1000, so alloc a page
-setup Page Table vaddr 0~4MB OVER!
-set up init env for check_swap begin!
-page fault at 0x00001000: K/W [no page found].
-page fault at 0x00002000: K/W [no page found].
-page fault at 0x00003000: K/W [no page found].
-page fault at 0x00004000: K/W [no page found].
-set up init env for check_swap over!
-write Virt Page c in fifo_check_swap
-write Virt Page a in fifo_check_swap
-write Virt Page d in fifo_check_swap
-write Virt Page b in fifo_check_swap
-write Virt Page e in fifo_check_swap
-page fault at 0x00005000: K/W [no page found].
-swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
-write Virt Page b in fifo_check_swap
-write Virt Page a in fifo_check_swap
-page fault at 0x00001000: K/W [no page found].
-swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
-swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
-write Virt Page b in fifo_check_swap
-page fault at 0x00002000: K/W [no page found].
-swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
-swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
-write Virt Page c in fifo_check_swap
-page fault at 0x00003000: K/W [no page found].
-swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
-swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
-write Virt Page d in fifo_check_swap
-page fault at 0x00004000: K/W [no page found].
-swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
-swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
-write Virt Page e in fifo_check_swap
-page fault at 0x00005000: K/W [no page found].
-swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
-swap_in: load disk swap entry 6 with swap_page in vadr 0x5000
-write Virt Page a in fifo_check_swap
-page fault at 0x00001000: K/R [no page found].
-swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
-swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
-count is 0, total is 7
-check_swap() succeeded!
-++ setup timer interrupts
-100 ticks
-End of Test.
-kernel panic at kern/trap/trap.c:20:
-    EOT: kernel seems ok.
-stack trackback:
-ebp:0xc011ef10 eip:0xc0100a81 args:0xc0303000 0xc0303000 0xc011ef3c 0xc011ef44 
-    kern/debug/kdebug.c:308: print_stackframe+21
-ebp:0xc011ef30 eip:0xc0100454 args:0xc010880e 0x00000014 0xc01087f8 0x00010094 
-    kern/debug/panic.c:27: __panic+107
-ebp:0xc011ef50 eip:0xc010210c args:0xc01087a1 0xc011efb4 0xffffffff 0xc012a064 
-    kern/trap/trap.c:20: print_ticks+59
-ebp:0xc011ef70 eip:0xc010267c args:0xc011ef9c 0xc010029d 0xc0108786 0xc011efb4 
-    kern/trap/trap.c:197: trap_dispatch+201
-ebp:0xc011ef90 eip:0xc0102731 args:0xc011ef9c 0x0000807c 0x00010094 0xc011eff8 
-    kern/trap/trap.c:234: trap+16
-ebp:0xc011eff8 eip:0xc01031bd args:0xc010857c 0xc0108584 0xc0100d0a 0xc01085a3 
-    kern/trap/trapentry.S:24: <unknown>+0
-Welcome to the kernel debug monitor!!
-Type 'help' for a list of commands.
-K> 
\ No newline at end of file
diff -r -uN labcodes_answer/lab3_result/.qemu.out.orig labcodes/lab3/.qemu.out.orig
--- labcodes_answer/lab3_result/.qemu.out.orig	1970-01-01 08:00:00.000000000 +0800
+++ labcodes/lab3/.qemu.out.orig	2020-05-30 16:38:42.162383041 +0800
@@ -0,0 +1,27 @@
+(THU.CST) os is loading ...
+
+Special kernel symbols:
+  entry  0xc0100036 (phys)
+  etext  0xc0108ab2 (phys)
+  edata  0xc0123000 (phys)
+  end    0xc0124118 (phys)
+Kernel executable memory footprint: 145KB
+memory management: default_pmm_manager
+e820map:
+  memory: 0009fc00, [00000000, 0009fbff], type = 1.
+  memory: 00000400, [0009fc00, 0009ffff], type = 2.
+  memory: 00010000, [000f0000, 000fffff], type = 2.
+  memory: 07ee0000, [00100000, 07fdffff], type = 1.
+  memory: 00020000, [07fe0000, 07ffffff], type = 2.
+  memory: 00040000, [fffc0000, ffffffff], type = 2.
+check_alloc_page() succeeded!
+check_pgdir() succeeded!
+check_boot_pgdir() succeeded!
+-------------------- BEGIN --------------------
+PDE(0e0) c0000000-f8000000 38000000 urw
+  |-- PTE(38000) c0000000-f8000000 38000000 -rw
+PDE(001) fac00000-fb000000 00400000 -rw
+  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw
+  |-- PTE(00001) fafeb000-fafec000 00001000 -rw
+--------------------- END ---------------------
+check_vma_struct() succeeded!
diff -r -uN labcodes_answer/lab3_result/tools/grade.sh labcodes/lab3/tools/grade.sh
--- labcodes_answer/lab3_result/tools/grade.sh	2020-05-30 07:45:13.671200547 +0800
+++ labcodes/lab3/tools/grade.sh	2020-05-30 07:45:13.631200508 +0800
@@ -105,7 +105,7 @@
     echo $1
     shift
     if [ $# -gt 0 ]; then
-        echo "$@" | awk '{printf "   %s\n", $0}'
+        echo -e "$@" | awk '{printf "   %s\n", $0}'
         echo
     fi
 }
@@ -146,9 +146,13 @@
     if [ -n "$brkfun" ]; then
         # find the address of the kernel $brkfun function
         brkaddr=`$grep " $brkfun\$" $sym_table | $sed -e's/ .*$//g'`
+        brkaddr_phys=`echo $brkaddr | sed "s/^c0/00/g"`
         (
             echo "target remote localhost:$gdbport"
             echo "break *0x$brkaddr"
+            if [ "$brkaddr" != "$brkaddr_phys" ]; then
+                echo "break *0x$brkaddr_phys"
+            fi
             echo "continue"
         ) > $gdb_in
 
@@ -179,6 +183,8 @@
     run_qemu
 
     show_time
+
+    cp $qemu_out .`echo $tag | tr '[:upper:]' '[:lower:]' | sed 's/ /_/g'`.log
 }
 
 check_result() {
@@ -361,4 +367,3 @@
 
 ## print final-score
 show_final
-
diff -r -uN labcodes_answer/lab3_result/tools/vector.c labcodes/lab3/tools/vector.c
--- labcodes_answer/lab3_result/tools/vector.c	2020-05-30 07:45:13.671200547 +0800
+++ labcodes/lab3/tools/vector.c	2020-05-30 07:45:13.631200508 +0800
@@ -10,7 +10,7 @@
     for (i = 0; i < 256; i ++) {
         printf(".globl vector%d\n", i);
         printf("vector%d:\n", i);
-        if ((i < 8 || i > 14) && i != 17) {
+        if (i != 8 && (i < 10 || i > 14) && i != 17) {
             printf("  pushl $0\n");
         }
         printf("  pushl $%d\n", i);
